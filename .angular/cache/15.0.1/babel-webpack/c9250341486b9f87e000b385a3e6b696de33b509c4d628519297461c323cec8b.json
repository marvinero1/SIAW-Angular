{"ast":null,"code":"import moment from 'moment';\n\n// Formats which are correctly parsed to time (supported by momentjs)\nconst STRICT_FORMATS = ['YYYY-MM-DDTHH:mm:ss.SSSZ', 'X',\n// Unix timestamp\n'x' // Unix ms timestamp\n];\n\nexport const VALIDATOR_TYPE = 'time';\n\n/**\n * The Time cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\nexport function timeValidator(value, callback) {\n  const timeFormat = this.timeFormat || 'h:mm:ss a';\n  let valid = true;\n  let valueToValidate = value;\n  if (valueToValidate === null) {\n    valueToValidate = '';\n  }\n  valueToValidate = /^\\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;\n  const twoDigitValue = /^\\d{1,2}$/.test(valueToValidate);\n  if (twoDigitValue) {\n    valueToValidate += ':00';\n  }\n  const date = moment(valueToValidate, STRICT_FORMATS, true).isValid() ? moment(valueToValidate) : moment(valueToValidate, timeFormat);\n  let isValidTime = date.isValid();\n\n  // is it in the specified format\n  let isValidFormat = moment(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidTime = true;\n    isValidFormat = true;\n  }\n  if (!isValidTime) {\n    valid = false;\n  }\n  if (!isValidTime && isValidFormat) {\n    valid = true;\n  }\n  if (isValidTime && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      const correctedValue = date.format(timeFormat);\n      const row = this.instance.toVisualRow(this.row);\n      const column = this.instance.toVisualColumn(this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'timeValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n  callback(valid);\n}\ntimeValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;","map":{"version":3,"names":["moment","STRICT_FORMATS","VALIDATOR_TYPE","timeValidator","value","callback","timeFormat","valid","valueToValidate","test","parseInt","twoDigitValue","date","isValid","isValidTime","isValidFormat","allowEmpty","correctFormat","correctedValue","format","row","instance","toVisualRow","column","toVisualColumn","col","setDataAtCell"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/validators/timeValidator/timeValidator.mjs"],"sourcesContent":["import moment from 'moment';\n\n// Formats which are correctly parsed to time (supported by momentjs)\nconst STRICT_FORMATS = ['YYYY-MM-DDTHH:mm:ss.SSSZ', 'X',\n// Unix timestamp\n'x' // Unix ms timestamp\n];\nexport const VALIDATOR_TYPE = 'time';\n\n/**\n * The Time cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\nexport function timeValidator(value, callback) {\n  const timeFormat = this.timeFormat || 'h:mm:ss a';\n  let valid = true;\n  let valueToValidate = value;\n  if (valueToValidate === null) {\n    valueToValidate = '';\n  }\n  valueToValidate = /^\\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;\n  const twoDigitValue = /^\\d{1,2}$/.test(valueToValidate);\n  if (twoDigitValue) {\n    valueToValidate += ':00';\n  }\n  const date = moment(valueToValidate, STRICT_FORMATS, true).isValid() ? moment(valueToValidate) : moment(valueToValidate, timeFormat);\n  let isValidTime = date.isValid();\n\n  // is it in the specified format\n  let isValidFormat = moment(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidTime = true;\n    isValidFormat = true;\n  }\n  if (!isValidTime) {\n    valid = false;\n  }\n  if (!isValidTime && isValidFormat) {\n    valid = true;\n  }\n  if (isValidTime && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      const correctedValue = date.format(timeFormat);\n      const row = this.instance.toVisualRow(this.row);\n      const column = this.instance.toVisualColumn(this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'timeValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n  callback(valid);\n}\ntimeValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;"],"mappings":"AAAA,OAAOA,MAAM,MAAM,QAAQ;;AAE3B;AACA,MAAMC,cAAc,GAAG,CAAC,0BAA0B,EAAE,GAAG;AACvD;AACA,GAAG,CAAC;AAAA,CACH;;AACD,OAAO,MAAMC,cAAc,GAAG,MAAM;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAa,CAACC,KAAK,EAAEC,QAAQ,EAAE;EAC7C,MAAMC,UAAU,GAAG,IAAI,CAACA,UAAU,IAAI,WAAW;EACjD,IAAIC,KAAK,GAAG,IAAI;EAChB,IAAIC,eAAe,GAAGJ,KAAK;EAC3B,IAAII,eAAe,KAAK,IAAI,EAAE;IAC5BA,eAAe,GAAG,EAAE;EACtB;EACAA,eAAe,GAAG,UAAU,CAACC,IAAI,CAACD,eAAe,CAAC,GAAGE,QAAQ,CAACF,eAAe,EAAE,EAAE,CAAC,GAAGA,eAAe;EACpG,MAAMG,aAAa,GAAG,WAAW,CAACF,IAAI,CAACD,eAAe,CAAC;EACvD,IAAIG,aAAa,EAAE;IACjBH,eAAe,IAAI,KAAK;EAC1B;EACA,MAAMI,IAAI,GAAGZ,MAAM,CAACQ,eAAe,EAAEP,cAAc,EAAE,IAAI,CAAC,CAACY,OAAO,EAAE,GAAGb,MAAM,CAACQ,eAAe,CAAC,GAAGR,MAAM,CAACQ,eAAe,EAAEF,UAAU,CAAC;EACpI,IAAIQ,WAAW,GAAGF,IAAI,CAACC,OAAO,EAAE;;EAEhC;EACA,IAAIE,aAAa,GAAGf,MAAM,CAACQ,eAAe,EAAEF,UAAU,EAAE,IAAI,CAAC,CAACO,OAAO,EAAE,IAAI,CAACF,aAAa;EACzF,IAAI,IAAI,CAACK,UAAU,IAAIR,eAAe,KAAK,EAAE,EAAE;IAC7CM,WAAW,GAAG,IAAI;IAClBC,aAAa,GAAG,IAAI;EACtB;EACA,IAAI,CAACD,WAAW,EAAE;IAChBP,KAAK,GAAG,KAAK;EACf;EACA,IAAI,CAACO,WAAW,IAAIC,aAAa,EAAE;IACjCR,KAAK,GAAG,IAAI;EACd;EACA,IAAIO,WAAW,IAAI,CAACC,aAAa,EAAE;IACjC,IAAI,IAAI,CAACE,aAAa,KAAK,IAAI,EAAE;MAC/B;MACA,MAAMC,cAAc,GAAGN,IAAI,CAACO,MAAM,CAACb,UAAU,CAAC;MAC9C,MAAMc,GAAG,GAAG,IAAI,CAACC,QAAQ,CAACC,WAAW,CAAC,IAAI,CAACF,GAAG,CAAC;MAC/C,MAAMG,MAAM,GAAG,IAAI,CAACF,QAAQ,CAACG,cAAc,CAAC,IAAI,CAACC,GAAG,CAAC;MACrD,IAAI,CAACJ,QAAQ,CAACK,aAAa,CAACN,GAAG,EAAEG,MAAM,EAAEL,cAAc,EAAE,eAAe,CAAC;MACzEX,KAAK,GAAG,IAAI;IACd,CAAC,MAAM;MACLA,KAAK,GAAG,KAAK;IACf;EACF;EACAF,QAAQ,CAACE,KAAK,CAAC;AACjB;AACAJ,aAAa,CAACD,cAAc,GAAGA,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}