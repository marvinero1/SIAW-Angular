{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * The `MergedCellCoords` class represents a single merged cell.\n *\n * @private\n * @class MergedCellCoords\n */\nclass MergedCellCoords {\n  constructor(row, column, rowspan, colspan, cellCoordsFactory, cellRangeFactory) {\n    /**\n     * The index of the topmost merged cell row.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"row\", void 0);\n    /**\n     * The index of the leftmost column.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"col\", void 0);\n    /**\n     * The `rowspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"rowspan\", void 0);\n    /**\n     * The `colspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"colspan\", void 0);\n    /**\n     * `true` only if the merged cell is bound to be removed.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"removed\", false);\n    /**\n     * The CellCoords function factory.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"cellCoordsFactory\", void 0);\n    /**\n     * The CellRange function factory.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"cellRangeFactory\", void 0);\n    this.row = row;\n    this.col = column;\n    this.rowspan = rowspan;\n    this.colspan = colspan;\n    this.cellCoordsFactory = cellCoordsFactory;\n    this.cellRangeFactory = cellRangeFactory;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains negative values.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static NEGATIVE_VALUES_WARNING(newMergedCell) {\n    return toSingleLine`The merged cell declared with {row: ${newMergedCell.row}, col: ${newMergedCell.col},\\x20\n      rowspan: ${newMergedCell.rowspan}, colspan: ${newMergedCell.colspan}} contains negative values, which is\\x20\n      not supported. It will not be added to the collection.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {\n    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] is positioned\\x20\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data represents a single cell.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_SINGLE_CELL(newMergedCell) {\n    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] has both \"rowspan\"\\x20\n      and \"colspan\" declared as \"1\", which makes it a single cell. It cannot be added to the collection.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static ZERO_SPAN_WARNING(newMergedCell) {\n    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] has \"rowspan\"\\x20\n      or \"colspan\" declared as \"0\", which is not supported. It cannot be added to the collection.`;\n  }\n\n  /**\n   * Check whether the values provided for a merged cell contain any negative values.\n   *\n   * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  static containsNegativeValues(mergedCellInfo) {\n    return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;\n  }\n\n  /**\n   * Check whether the provided merged cell information object represents a single cell.\n   *\n   * @private\n   * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  static isSingleCell(mergedCellInfo) {\n    return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;\n  }\n\n  /**\n   * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\n   *\n   * @private\n   * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  static containsZeroSpan(mergedCellInfo) {\n    return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;\n  }\n\n  /**\n   * Check whether the provided merged cell object is to be declared out of bounds of the table.\n   *\n   * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n   * @param {number} rowCount Number of rows in the table.\n   * @param {number} columnCount Number of rows in the table.\n   * @returns {boolean}\n   */\n  static isOutOfBounds(mergeCell, rowCount, columnCount) {\n    return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\n  }\n\n  /**\n   * Sanitize (prevent from going outside the boundaries) the merged cell.\n   *\n   * @param {Core} hotInstance The Handsontable instance.\n   */\n  normalize(hotInstance) {\n    const totalRows = hotInstance.countRows();\n    const totalColumns = hotInstance.countCols();\n    if (this.row < 0) {\n      this.row = 0;\n    } else if (this.row > totalRows - 1) {\n      this.row = totalRows - 1;\n    }\n    if (this.col < 0) {\n      this.col = 0;\n    } else if (this.col > totalColumns - 1) {\n      this.col = totalColumns - 1;\n    }\n    if (this.row + this.rowspan > totalRows - 1) {\n      this.rowspan = totalRows - this.row;\n    }\n    if (this.col + this.colspan > totalColumns - 1) {\n      this.colspan = totalColumns - this.col;\n    }\n  }\n\n  /**\n   * Returns `true` if the provided coordinates are inside the merged cell.\n   *\n   * @param {number} row The row index.\n   * @param {number} column The column index.\n   * @returns {boolean}\n   */\n  includes(row, column) {\n    return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\n  }\n\n  /**\n   * Returns `true` if the provided `column` property is within the column span of the merged cell.\n   *\n   * @param {number} column The column index.\n   * @returns {boolean}\n   */\n  includesHorizontally(column) {\n    return this.col <= column && this.col + this.colspan - 1 >= column;\n  }\n\n  /**\n   * Returns `true` if the provided `row` property is within the row span of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @returns {boolean}\n   */\n  includesVertically(row) {\n    return this.row <= row && this.row + this.rowspan - 1 >= row;\n  }\n\n  /**\n   * Shift (and possibly resize, if needed) the merged cell.\n   *\n   * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\n   * @param {number} indexOfChange Index of the preceding change.\n   * @returns {boolean} Returns `false` if the whole merged cell was removed.\n   */\n  shift(shiftVector, indexOfChange) {\n    const shiftValue = shiftVector[0] || shiftVector[1];\n    const shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n    const span = shiftVector[0] ? 'colspan' : 'rowspan';\n    const index = shiftVector[0] ? 'col' : 'row';\n    const changeStart = Math.min(indexOfChange, shiftedIndex);\n    const changeEnd = Math.max(indexOfChange, shiftedIndex);\n    const mergeStart = this[index];\n    const mergeEnd = this[index] + this[span] - 1;\n    if (mergeStart >= indexOfChange) {\n      this[index] += shiftValue;\n    }\n\n    // adding rows/columns\n    if (shiftValue > 0) {\n      if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\n        this[span] += shiftValue;\n      }\n\n      // removing rows/columns\n    } else if (shiftValue < 0) {\n      // removing the whole merge\n      if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\n        this.removed = true;\n        return false;\n\n        // removing the merge partially, including the beginning\n      } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n        const removedOffset = changeEnd - mergeStart + 1;\n        const preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n        this[index] -= preRemovedOffset + shiftValue;\n        this[span] -= removedOffset;\n\n        // removing the middle part of the merge\n      } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\n        this[span] += shiftValue;\n\n        // removing the end part of the merge\n      } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n        const removedPart = mergeEnd - changeStart + 1;\n        this[span] -= removedPart;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Check if the second provided merged cell is \"farther\" in the provided direction.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to check.\n   * @param {string} direction Drag direction.\n   * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\n   */\n  isFarther(mergedCell, direction) {\n    if (!mergedCell) {\n      return true;\n    }\n    if (direction === 'down') {\n      return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n    } else if (direction === 'up') {\n      return mergedCell.row > this.row;\n    } else if (direction === 'right') {\n      return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\n    } else if (direction === 'left') {\n      return mergedCell.col > this.col;\n    }\n    return null;\n  }\n\n  /**\n   * Get the bottom row index of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastRow() {\n    return this.row + this.rowspan - 1;\n  }\n\n  /**\n   * Get the rightmost column index of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastColumn() {\n    return this.col + this.colspan - 1;\n  }\n\n  /**\n   * Get the range coordinates of the merged cell.\n   *\n   * @returns {CellRange}\n   */\n  getRange() {\n    return this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.getLastRow(), this.getLastColumn()));\n  }\n}\nexport default MergedCellCoords;","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","toSingleLine","MergedCellCoords","constructor","row","column","rowspan","colspan","cellCoordsFactory","cellRangeFactory","col","NEGATIVE_VALUES_WARNING","newMergedCell","IS_OUT_OF_BOUNDS_WARNING","IS_SINGLE_CELL","ZERO_SPAN_WARNING","containsNegativeValues","mergedCellInfo","isSingleCell","containsZeroSpan","isOutOfBounds","mergeCell","rowCount","columnCount","normalize","hotInstance","totalRows","countRows","totalColumns","countCols","includes","includesHorizontally","includesVertically","shift","shiftVector","indexOfChange","shiftValue","shiftedIndex","Math","abs","span","index","changeStart","min","changeEnd","max","mergeStart","mergeEnd","removed","removedOffset","preRemovedOffset","removedPart","isFarther","mergedCell","direction","getLastRow","getLastColumn","getRange"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/mergeCells/cellCoords.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * The `MergedCellCoords` class represents a single merged cell.\n *\n * @private\n * @class MergedCellCoords\n */\nclass MergedCellCoords {\n  constructor(row, column, rowspan, colspan, cellCoordsFactory, cellRangeFactory) {\n    /**\n     * The index of the topmost merged cell row.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"row\", void 0);\n    /**\n     * The index of the leftmost column.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"col\", void 0);\n    /**\n     * The `rowspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"rowspan\", void 0);\n    /**\n     * The `colspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"colspan\", void 0);\n    /**\n     * `true` only if the merged cell is bound to be removed.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"removed\", false);\n    /**\n     * The CellCoords function factory.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"cellCoordsFactory\", void 0);\n    /**\n     * The CellRange function factory.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"cellRangeFactory\", void 0);\n    this.row = row;\n    this.col = column;\n    this.rowspan = rowspan;\n    this.colspan = colspan;\n    this.cellCoordsFactory = cellCoordsFactory;\n    this.cellRangeFactory = cellRangeFactory;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains negative values.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static NEGATIVE_VALUES_WARNING(newMergedCell) {\n    return toSingleLine`The merged cell declared with {row: ${newMergedCell.row}, col: ${newMergedCell.col},\\x20\n      rowspan: ${newMergedCell.rowspan}, colspan: ${newMergedCell.colspan}} contains negative values, which is\\x20\n      not supported. It will not be added to the collection.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {\n    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] is positioned\\x20\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data represents a single cell.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_SINGLE_CELL(newMergedCell) {\n    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] has both \"rowspan\"\\x20\n      and \"colspan\" declared as \"1\", which makes it a single cell. It cannot be added to the collection.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static ZERO_SPAN_WARNING(newMergedCell) {\n    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] has \"rowspan\"\\x20\n      or \"colspan\" declared as \"0\", which is not supported. It cannot be added to the collection.`;\n  }\n\n  /**\n   * Check whether the values provided for a merged cell contain any negative values.\n   *\n   * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  static containsNegativeValues(mergedCellInfo) {\n    return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;\n  }\n\n  /**\n   * Check whether the provided merged cell information object represents a single cell.\n   *\n   * @private\n   * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  static isSingleCell(mergedCellInfo) {\n    return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;\n  }\n\n  /**\n   * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\n   *\n   * @private\n   * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  static containsZeroSpan(mergedCellInfo) {\n    return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;\n  }\n\n  /**\n   * Check whether the provided merged cell object is to be declared out of bounds of the table.\n   *\n   * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n   * @param {number} rowCount Number of rows in the table.\n   * @param {number} columnCount Number of rows in the table.\n   * @returns {boolean}\n   */\n  static isOutOfBounds(mergeCell, rowCount, columnCount) {\n    return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\n  }\n\n  /**\n   * Sanitize (prevent from going outside the boundaries) the merged cell.\n   *\n   * @param {Core} hotInstance The Handsontable instance.\n   */\n  normalize(hotInstance) {\n    const totalRows = hotInstance.countRows();\n    const totalColumns = hotInstance.countCols();\n    if (this.row < 0) {\n      this.row = 0;\n    } else if (this.row > totalRows - 1) {\n      this.row = totalRows - 1;\n    }\n    if (this.col < 0) {\n      this.col = 0;\n    } else if (this.col > totalColumns - 1) {\n      this.col = totalColumns - 1;\n    }\n    if (this.row + this.rowspan > totalRows - 1) {\n      this.rowspan = totalRows - this.row;\n    }\n    if (this.col + this.colspan > totalColumns - 1) {\n      this.colspan = totalColumns - this.col;\n    }\n  }\n\n  /**\n   * Returns `true` if the provided coordinates are inside the merged cell.\n   *\n   * @param {number} row The row index.\n   * @param {number} column The column index.\n   * @returns {boolean}\n   */\n  includes(row, column) {\n    return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\n  }\n\n  /**\n   * Returns `true` if the provided `column` property is within the column span of the merged cell.\n   *\n   * @param {number} column The column index.\n   * @returns {boolean}\n   */\n  includesHorizontally(column) {\n    return this.col <= column && this.col + this.colspan - 1 >= column;\n  }\n\n  /**\n   * Returns `true` if the provided `row` property is within the row span of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @returns {boolean}\n   */\n  includesVertically(row) {\n    return this.row <= row && this.row + this.rowspan - 1 >= row;\n  }\n\n  /**\n   * Shift (and possibly resize, if needed) the merged cell.\n   *\n   * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\n   * @param {number} indexOfChange Index of the preceding change.\n   * @returns {boolean} Returns `false` if the whole merged cell was removed.\n   */\n  shift(shiftVector, indexOfChange) {\n    const shiftValue = shiftVector[0] || shiftVector[1];\n    const shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n    const span = shiftVector[0] ? 'colspan' : 'rowspan';\n    const index = shiftVector[0] ? 'col' : 'row';\n    const changeStart = Math.min(indexOfChange, shiftedIndex);\n    const changeEnd = Math.max(indexOfChange, shiftedIndex);\n    const mergeStart = this[index];\n    const mergeEnd = this[index] + this[span] - 1;\n    if (mergeStart >= indexOfChange) {\n      this[index] += shiftValue;\n    }\n\n    // adding rows/columns\n    if (shiftValue > 0) {\n      if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\n        this[span] += shiftValue;\n      }\n\n      // removing rows/columns\n    } else if (shiftValue < 0) {\n      // removing the whole merge\n      if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\n        this.removed = true;\n        return false;\n\n        // removing the merge partially, including the beginning\n      } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n        const removedOffset = changeEnd - mergeStart + 1;\n        const preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n        this[index] -= preRemovedOffset + shiftValue;\n        this[span] -= removedOffset;\n\n        // removing the middle part of the merge\n      } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\n        this[span] += shiftValue;\n\n        // removing the end part of the merge\n      } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n        const removedPart = mergeEnd - changeStart + 1;\n        this[span] -= removedPart;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Check if the second provided merged cell is \"farther\" in the provided direction.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to check.\n   * @param {string} direction Drag direction.\n   * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\n   */\n  isFarther(mergedCell, direction) {\n    if (!mergedCell) {\n      return true;\n    }\n    if (direction === 'down') {\n      return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n    } else if (direction === 'up') {\n      return mergedCell.row > this.row;\n    } else if (direction === 'right') {\n      return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\n    } else if (direction === 'left') {\n      return mergedCell.col > this.col;\n    }\n    return null;\n  }\n\n  /**\n   * Get the bottom row index of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastRow() {\n    return this.row + this.rowspan - 1;\n  }\n\n  /**\n   * Get the rightmost column index of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastColumn() {\n    return this.col + this.colspan - 1;\n  }\n\n  /**\n   * Get the range coordinates of the merged cell.\n   *\n   * @returns {CellRange}\n   */\n  getRange() {\n    return this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.getLastRow(), this.getLastColumn()));\n  }\n}\nexport default MergedCellCoords;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}