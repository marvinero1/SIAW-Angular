{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport TreeNode from \"../../../utils/dataStructures/tree.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @private\n * @class HeadersTree\n *\n * The header tree class keeps nested header settings in the tree\n * structure for easier node manipulation (e.q collapse or expand column).\n * That trees represent the current state of the nested headers. From the\n * trees, the matrix is generated for nested header renderers.\n *\n * The second role of the module is validation. While building the tree,\n * there is check whether the configuration contains overlapping\n * headers. If true, then the exception is thrown.\n *\n * The tree is static; it means that its column indexing never changes\n * even when a collapsing header is performed. The structure is based\n * on visual column indexes.\n *\n * For example, for that header configuration:\n *   +----+----+----+----+----+\n *   │ A1                │ A2 │\n *   +----+----+----+----+----+\n *   │ B1           │ B2 │ B3 │\n *   +----+----+----+----+----+\n *   │ C1      │ C2 │ C3 │ C4 │\n *   +----+----+----+----+----+\n *\n * The tree structures look like:\n *                (0)                      (4)           // a visual column index\n *                 │                        │\n *        .------(A1)------.              (A2)--.\n *   .--(B1)--.           (B2)--.              (B3)--.\n *  (C1)     (C2)              (C3)                 (C4)\n *\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _rootNodes = /*#__PURE__*/new WeakMap();\nvar _rootsIndex = /*#__PURE__*/new WeakMap();\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\nexport default class HeadersTree {\n  constructor(sourceSettings) {\n    /**\n     * The collection of nested headers settings structured into trees. The root trees are stored\n     * under the visual column index.\n     *\n     * @private\n     * @type {Map<number, TreeNode>}\n     */\n    _classPrivateFieldInitSpec(this, _rootNodes, {\n      writable: true,\n      value: new Map()\n    });\n    /**\n     * A map that translates the visual column indexes that intersect the range\n     * defined by the header colspan width to the root index.\n     *\n     * @private\n     * @type {Map<number, number>}\n     */\n    _classPrivateFieldInitSpec(this, _rootsIndex, {\n      writable: true,\n      value: new Map()\n    });\n    /**\n     * The instance of the SourceSettings class.\n     *\n     * @private\n     * @type {SourceSettings}\n     */\n    _classPrivateFieldInitSpec(this, _sourceSettings, {\n      writable: true,\n      value: null\n    });\n    _classPrivateFieldSet(this, _sourceSettings, sourceSettings);\n  }\n\n  /**\n   * Gets an array of the all root nodes.\n   *\n   * @returns {TreeNode[]}\n   */\n  getRoots() {\n    return Array.from(_classPrivateFieldGet(this, _rootNodes).values());\n  }\n\n  /**\n   * Gets a root node by specified visual column index.\n   *\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|undefined}\n   */\n  getRootByColumn(columnIndex) {\n    let node;\n    if (_classPrivateFieldGet(this, _rootsIndex).has(columnIndex)) {\n      node = _classPrivateFieldGet(this, _rootNodes).get(_classPrivateFieldGet(this, _rootsIndex).get(columnIndex));\n    }\n    return node;\n  }\n\n  /**\n   * Gets a tree node by its position in the grid settings.\n   *\n   * @param {number} headerLevel Header level index (there is support only for positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|undefined}\n   */\n  getNode(headerLevel, columnIndex) {\n    const rootNode = this.getRootByColumn(columnIndex);\n    if (!rootNode) {\n      return;\n    }\n\n    // Normalize the visual column index to a 0-based system for a specific \"box\" defined\n    // by root node colspan width.\n    const normColumnIndex = columnIndex - _classPrivateFieldGet(this, _rootsIndex).get(columnIndex);\n    let columnCursor = 0;\n    let treeNode;\n\n    // Collect all parent nodes that depend on the collapsed node.\n    rootNode.walkDown(node => {\n      const {\n        data: {\n          origColspan,\n          headerLevel: nodeHeaderLevel\n        }\n      } = node;\n      if (headerLevel === nodeHeaderLevel) {\n        if (normColumnIndex >= columnCursor && normColumnIndex <= columnCursor + origColspan - 1) {\n          treeNode = node;\n          treeNode.data.isRoot = columnIndex === treeNode.data.columnIndex;\n          return false; // Cancel tree traversing.\n        }\n\n        columnCursor += origColspan;\n      }\n    });\n    return treeNode;\n  }\n\n  /**\n   * Builds (or rebuilds if called again) root nodes indexes.\n   */\n  rebuildTreeIndex() {\n    let columnIndex = 0;\n    _classPrivateFieldGet(this, _rootsIndex).clear();\n    arrayEach(_classPrivateFieldGet(this, _rootNodes), _ref => {\n      let [, {\n        data: {\n          colspan\n        }\n      }] = _ref;\n      // Map tree range (colspan range/width) into visual column index of the root node.\n      for (let i = columnIndex; i < columnIndex + colspan; i++) {\n        _classPrivateFieldGet(this, _rootsIndex).set(i, columnIndex);\n      }\n      columnIndex += colspan;\n    });\n  }\n\n  /**\n   * Builds trees based on SourceSettings class. Calling a method causes clearing the tree state built\n   * from the previous call.\n   */\n  buildTree() {\n    this.clear();\n    const columnsCount = _classPrivateFieldGet(this, _sourceSettings).getColumnsCount();\n    let columnIndex = 0;\n    while (columnIndex < columnsCount) {\n      const columnSettings = _classPrivateFieldGet(this, _sourceSettings).getHeaderSettings(0, columnIndex);\n      const rootNode = new TreeNode();\n      _classPrivateFieldGet(this, _rootNodes).set(columnIndex, rootNode);\n      this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);\n      columnIndex += columnSettings.origColspan;\n    }\n    this.rebuildTreeIndex();\n  }\n\n  /**\n   * Builds leaves for specified tree node.\n   *\n   * @param {TreeNode} parentNode A node to which the leaves applies.\n   * @param {number} columnIndex A visual column index.\n   * @param {number} headerLevel Currently processed header level.\n   * @param {number} [extractionLength=1] Determines column extraction length for node children.\n   */\n  buildLeaves(parentNode, columnIndex, headerLevel) {\n    let extractionLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    const columnsSettings = _classPrivateFieldGet(this, _sourceSettings).getHeadersSettings(headerLevel, columnIndex, extractionLength);\n    headerLevel += 1;\n    arrayEach(columnsSettings, columnSettings => {\n      const nodeData = {\n        ...columnSettings,\n        /**\n         * The header level (tree node depth level).\n         *\n         * @type {number}\n         */\n        headerLevel: headerLevel - 1,\n        /**\n         * A visual column index.\n         *\n         * @type {number}\n         */\n        columnIndex\n      };\n      let node;\n      if (headerLevel === 1) {\n        // fill the root node\n        parentNode.data = nodeData;\n        node = parentNode;\n      } else {\n        node = new TreeNode(nodeData);\n        parentNode.addChild(node);\n      }\n      if (headerLevel < _classPrivateFieldGet(this, _sourceSettings).getLayersCount()) {\n        this.buildLeaves(node, columnIndex, headerLevel, columnSettings.origColspan);\n      }\n      columnIndex += columnSettings.origColspan;\n    });\n  }\n\n  /**\n   * Clears the tree to the initial state.\n   */\n  clear() {\n    _classPrivateFieldGet(this, _rootNodes).clear();\n    _classPrivateFieldGet(this, _rootsIndex).clear();\n  }\n}","map":{"version":3,"names":["_classPrivateFieldInitSpec","obj","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","TypeError","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","call","_classPrivateFieldSet","_classApplyDescriptorSet","action","writable","arrayEach","TreeNode","_rootNodes","WeakMap","_rootsIndex","_sourceSettings","HeadersTree","constructor","sourceSettings","Map","getRoots","Array","from","values","getRootByColumn","columnIndex","node","getNode","headerLevel","rootNode","normColumnIndex","columnCursor","treeNode","walkDown","data","origColspan","nodeHeaderLevel","isRoot","rebuildTreeIndex","clear","_ref","colspan","i","buildTree","columnsCount","getColumnsCount","columnSettings","getHeaderSettings","buildLeaves","parentNode","extractionLength","arguments","length","undefined","columnsSettings","getHeadersSettings","nodeData","addChild","getLayersCount"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/nestedHeaders/stateManager/headersTree.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport TreeNode from \"../../../utils/dataStructures/tree.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @private\n * @class HeadersTree\n *\n * The header tree class keeps nested header settings in the tree\n * structure for easier node manipulation (e.q collapse or expand column).\n * That trees represent the current state of the nested headers. From the\n * trees, the matrix is generated for nested header renderers.\n *\n * The second role of the module is validation. While building the tree,\n * there is check whether the configuration contains overlapping\n * headers. If true, then the exception is thrown.\n *\n * The tree is static; it means that its column indexing never changes\n * even when a collapsing header is performed. The structure is based\n * on visual column indexes.\n *\n * For example, for that header configuration:\n *   +----+----+----+----+----+\n *   │ A1                │ A2 │\n *   +----+----+----+----+----+\n *   │ B1           │ B2 │ B3 │\n *   +----+----+----+----+----+\n *   │ C1      │ C2 │ C3 │ C4 │\n *   +----+----+----+----+----+\n *\n * The tree structures look like:\n *                (0)                      (4)           // a visual column index\n *                 │                        │\n *        .------(A1)------.              (A2)--.\n *   .--(B1)--.           (B2)--.              (B3)--.\n *  (C1)     (C2)              (C3)                 (C4)\n *\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _rootNodes = /*#__PURE__*/new WeakMap();\nvar _rootsIndex = /*#__PURE__*/new WeakMap();\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\nexport default class HeadersTree {\n  constructor(sourceSettings) {\n    /**\n     * The collection of nested headers settings structured into trees. The root trees are stored\n     * under the visual column index.\n     *\n     * @private\n     * @type {Map<number, TreeNode>}\n     */\n    _classPrivateFieldInitSpec(this, _rootNodes, {\n      writable: true,\n      value: new Map()\n    });\n    /**\n     * A map that translates the visual column indexes that intersect the range\n     * defined by the header colspan width to the root index.\n     *\n     * @private\n     * @type {Map<number, number>}\n     */\n    _classPrivateFieldInitSpec(this, _rootsIndex, {\n      writable: true,\n      value: new Map()\n    });\n    /**\n     * The instance of the SourceSettings class.\n     *\n     * @private\n     * @type {SourceSettings}\n     */\n    _classPrivateFieldInitSpec(this, _sourceSettings, {\n      writable: true,\n      value: null\n    });\n    _classPrivateFieldSet(this, _sourceSettings, sourceSettings);\n  }\n\n  /**\n   * Gets an array of the all root nodes.\n   *\n   * @returns {TreeNode[]}\n   */\n  getRoots() {\n    return Array.from(_classPrivateFieldGet(this, _rootNodes).values());\n  }\n\n  /**\n   * Gets a root node by specified visual column index.\n   *\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|undefined}\n   */\n  getRootByColumn(columnIndex) {\n    let node;\n    if (_classPrivateFieldGet(this, _rootsIndex).has(columnIndex)) {\n      node = _classPrivateFieldGet(this, _rootNodes).get(_classPrivateFieldGet(this, _rootsIndex).get(columnIndex));\n    }\n    return node;\n  }\n\n  /**\n   * Gets a tree node by its position in the grid settings.\n   *\n   * @param {number} headerLevel Header level index (there is support only for positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|undefined}\n   */\n  getNode(headerLevel, columnIndex) {\n    const rootNode = this.getRootByColumn(columnIndex);\n    if (!rootNode) {\n      return;\n    }\n\n    // Normalize the visual column index to a 0-based system for a specific \"box\" defined\n    // by root node colspan width.\n    const normColumnIndex = columnIndex - _classPrivateFieldGet(this, _rootsIndex).get(columnIndex);\n    let columnCursor = 0;\n    let treeNode;\n\n    // Collect all parent nodes that depend on the collapsed node.\n    rootNode.walkDown(node => {\n      const {\n        data: {\n          origColspan,\n          headerLevel: nodeHeaderLevel\n        }\n      } = node;\n      if (headerLevel === nodeHeaderLevel) {\n        if (normColumnIndex >= columnCursor && normColumnIndex <= columnCursor + origColspan - 1) {\n          treeNode = node;\n          treeNode.data.isRoot = columnIndex === treeNode.data.columnIndex;\n          return false; // Cancel tree traversing.\n        }\n        columnCursor += origColspan;\n      }\n    });\n    return treeNode;\n  }\n\n  /**\n   * Builds (or rebuilds if called again) root nodes indexes.\n   */\n  rebuildTreeIndex() {\n    let columnIndex = 0;\n    _classPrivateFieldGet(this, _rootsIndex).clear();\n    arrayEach(_classPrivateFieldGet(this, _rootNodes), _ref => {\n      let [, {\n        data: {\n          colspan\n        }\n      }] = _ref;\n      // Map tree range (colspan range/width) into visual column index of the root node.\n      for (let i = columnIndex; i < columnIndex + colspan; i++) {\n        _classPrivateFieldGet(this, _rootsIndex).set(i, columnIndex);\n      }\n      columnIndex += colspan;\n    });\n  }\n\n  /**\n   * Builds trees based on SourceSettings class. Calling a method causes clearing the tree state built\n   * from the previous call.\n   */\n  buildTree() {\n    this.clear();\n    const columnsCount = _classPrivateFieldGet(this, _sourceSettings).getColumnsCount();\n    let columnIndex = 0;\n    while (columnIndex < columnsCount) {\n      const columnSettings = _classPrivateFieldGet(this, _sourceSettings).getHeaderSettings(0, columnIndex);\n      const rootNode = new TreeNode();\n      _classPrivateFieldGet(this, _rootNodes).set(columnIndex, rootNode);\n      this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);\n      columnIndex += columnSettings.origColspan;\n    }\n    this.rebuildTreeIndex();\n  }\n\n  /**\n   * Builds leaves for specified tree node.\n   *\n   * @param {TreeNode} parentNode A node to which the leaves applies.\n   * @param {number} columnIndex A visual column index.\n   * @param {number} headerLevel Currently processed header level.\n   * @param {number} [extractionLength=1] Determines column extraction length for node children.\n   */\n  buildLeaves(parentNode, columnIndex, headerLevel) {\n    let extractionLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    const columnsSettings = _classPrivateFieldGet(this, _sourceSettings).getHeadersSettings(headerLevel, columnIndex, extractionLength);\n    headerLevel += 1;\n    arrayEach(columnsSettings, columnSettings => {\n      const nodeData = {\n        ...columnSettings,\n        /**\n         * The header level (tree node depth level).\n         *\n         * @type {number}\n         */\n        headerLevel: headerLevel - 1,\n        /**\n         * A visual column index.\n         *\n         * @type {number}\n         */\n        columnIndex\n      };\n      let node;\n      if (headerLevel === 1) {\n        // fill the root node\n        parentNode.data = nodeData;\n        node = parentNode;\n      } else {\n        node = new TreeNode(nodeData);\n        parentNode.addChild(node);\n      }\n      if (headerLevel < _classPrivateFieldGet(this, _sourceSettings).getLayersCount()) {\n        this.buildLeaves(node, columnIndex, headerLevel, columnSettings.origColspan);\n      }\n      columnIndex += columnSettings.origColspan;\n    });\n  }\n\n  /**\n   * Clears the tree to the initial state.\n   */\n  clear() {\n    _classPrivateFieldGet(this, _rootNodes).clear();\n    _classPrivateFieldGet(this, _rootsIndex).clear();\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}