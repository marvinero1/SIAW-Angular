{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\n/**\n * Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)).\n *\n * @type {string}\n */\nexport const TRAVERSAL_DF_PRE = 'DF-pre-order';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n * @returns {boolean}\n */\nexport function depthFirstPreOrder(callback, context) {\n  let continueTraverse = callback.call(context, this);\n  for (let i = 0; i < this.childs.length; i++) {\n    if (continueTraverse === false) {\n      return false;\n    }\n    continueTraverse = depthFirstPreOrder.call(this.childs[i], callback, context);\n  }\n  return continueTraverse;\n}\n\n/**\n * Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR)).\n *\n * @type {string}\n */\nexport const TRAVERSAL_DF_POST = 'DF-post-order';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n * @returns {boolean}\n */\nfunction depthFirstPostOrder(callback, context) {\n  for (let i = 0; i < this.childs.length; i++) {\n    const continueTraverse = depthFirstPostOrder.call(this.childs[i], callback, context);\n    if (continueTraverse === false) {\n      return false;\n    }\n  }\n  return callback.call(context, this);\n}\n\n/**\n * Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).\n *\n * @type {string}\n */\nexport const TRAVERSAL_BF = 'BF';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n */\nfunction breadthFirst(callback, context) {\n  const queue = [this];\n\n  /**\n   * Internal processor.\n   */\n  function process() {\n    if (queue.length === 0) {\n      return;\n    }\n    const node = queue.shift();\n    queue.push(...node.childs);\n    if (callback.call(context, node) !== false) {\n      process();\n    }\n  }\n  process();\n}\n\n/**\n * Default strategy for tree traversal.\n *\n * @type {string}\n */\nconst DEFAULT_TRAVERSAL_STRATEGY = TRAVERSAL_BF;\n/**\n * Collection of all available tree traversal strategies.\n *\n * @type {Map<string, Function>}\n */\nconst TRAVERSAL_STRATEGIES = new Map([[TRAVERSAL_DF_PRE, depthFirstPreOrder], [TRAVERSAL_DF_POST, depthFirstPostOrder], [TRAVERSAL_BF, breadthFirst]]);\n\n/**\n *\n */\nexport default class TreeNode {\n  constructor(data) {\n    /**\n     * A tree data.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"data\", {});\n    /**\n     * A parent node.\n     *\n     * @type {TreeNode}\n     */\n    _defineProperty(this, \"parent\", null);\n    /**\n     * A tree leaves.\n     *\n     * @type {TreeNode[]}\n     */\n    _defineProperty(this, \"childs\", []);\n    this.data = data;\n  }\n\n  /**\n   * Adds a node to tree leaves. Added node is linked with the parent node through \"parent\" property.\n   *\n   * @param {TreeNode} node A TreeNode to add.\n   */\n  addChild(node) {\n    node.parent = this;\n    this.childs.push(node);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof TreeNode#\n   * @function cloneTree\n   *\n   * Clones a tree structure deeply.\n   *\n   * For example, for giving a tree structure:\n   *      .--(B1)--.\n   *   .-(C1)   .-(C2)-.----.\n   *  (D1)     (D2)   (D3) (D4)\n   *\n   * Cloning a tree starting from C2 node creates a mirrored tree structure.\n   *     .-(C2')-.-----.\n   *    (D2')   (D3') (D4')\n   *\n   * The cloned tree can be safely modified without affecting the original structure.\n   * After modification, the clone can be merged with a tree using the \"replaceTreeWith\" method.\n   *\n   * @param {TreeNode} [nodeTree=this] A TreeNode to clone.\n   * @returns {TreeNode}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  cloneTree() {\n    let nodeTree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n    const clonedNode = new TreeNode({\n      ...nodeTree.data\n    });\n    for (let i = 0; i < nodeTree.childs.length; i++) {\n      clonedNode.addChild(this.cloneTree(nodeTree.childs[i]));\n    }\n    return clonedNode;\n  }\n\n  /**\n   * Replaces the current node with a passed tree structure.\n   *\n   * @param {TreeNode} nodeTree A TreeNode to replace with.\n   */\n  replaceTreeWith(nodeTree) {\n    this.data = {\n      ...nodeTree.data\n    };\n    this.childs = [];\n    for (let i = 0; i < nodeTree.childs.length; i++) {\n      this.addChild(nodeTree.childs[i]);\n    }\n  }\n\n  /**\n   * Traverses the tree structure through node childs. The walk down traversing supports\n   * a three different strategies.\n   *  - Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR));\n   *  - Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR));\n   *  - Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).\n   *\n   * @param {Function} callback The callback function which will be called for each node.\n   * @param {string} [traversalStrategy=DEFAULT_TRAVERSAL_STRATEGY] Traversing strategy.\n   */\n  walkDown(callback) {\n    let traversalStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_TRAVERSAL_STRATEGY;\n    if (!TRAVERSAL_STRATEGIES.has(traversalStrategy)) {\n      throw new Error(`Traversal strategy \"${traversalStrategy}\" does not exist`);\n    }\n    TRAVERSAL_STRATEGIES.get(traversalStrategy).call(this, callback, this);\n  }\n\n  /**\n   * Traverses the tree structure through node parents.\n   *\n   * @param {Function} callback The callback function which will be called for each node.\n   */\n  walkUp(callback) {\n    const context = this;\n    const process = node => {\n      const continueTraverse = callback.call(context, node);\n      if (continueTraverse !== false && node.parent !== null) {\n        process(node.parent);\n      }\n    };\n    process(this);\n  }\n}","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","TRAVERSAL_DF_PRE","depthFirstPreOrder","callback","context","continueTraverse","childs","length","TRAVERSAL_DF_POST","depthFirstPostOrder","TRAVERSAL_BF","breadthFirst","queue","process","node","shift","push","DEFAULT_TRAVERSAL_STRATEGY","TRAVERSAL_STRATEGIES","Map","TreeNode","constructor","data","addChild","parent","cloneTree","nodeTree","arguments","undefined","clonedNode","replaceTreeWith","walkDown","traversalStrategy","has","Error","get","walkUp"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/utils/dataStructures/tree.mjs"],"sourcesContent":["function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\n/**\n * Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)).\n *\n * @type {string}\n */\nexport const TRAVERSAL_DF_PRE = 'DF-pre-order';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n * @returns {boolean}\n */\nexport function depthFirstPreOrder(callback, context) {\n  let continueTraverse = callback.call(context, this);\n  for (let i = 0; i < this.childs.length; i++) {\n    if (continueTraverse === false) {\n      return false;\n    }\n    continueTraverse = depthFirstPreOrder.call(this.childs[i], callback, context);\n  }\n  return continueTraverse;\n}\n\n/**\n * Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR)).\n *\n * @type {string}\n */\nexport const TRAVERSAL_DF_POST = 'DF-post-order';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n * @returns {boolean}\n */\nfunction depthFirstPostOrder(callback, context) {\n  for (let i = 0; i < this.childs.length; i++) {\n    const continueTraverse = depthFirstPostOrder.call(this.childs[i], callback, context);\n    if (continueTraverse === false) {\n      return false;\n    }\n  }\n  return callback.call(context, this);\n}\n\n/**\n * Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).\n *\n * @type {string}\n */\nexport const TRAVERSAL_BF = 'BF';\n/**\n * @param {Function} callback A callback which will be called on each visited node.\n * @param {*} context A context to pass through.\n */\nfunction breadthFirst(callback, context) {\n  const queue = [this];\n\n  /**\n   * Internal processor.\n   */\n  function process() {\n    if (queue.length === 0) {\n      return;\n    }\n    const node = queue.shift();\n    queue.push(...node.childs);\n    if (callback.call(context, node) !== false) {\n      process();\n    }\n  }\n  process();\n}\n\n/**\n * Default strategy for tree traversal.\n *\n * @type {string}\n */\nconst DEFAULT_TRAVERSAL_STRATEGY = TRAVERSAL_BF;\n/**\n * Collection of all available tree traversal strategies.\n *\n * @type {Map<string, Function>}\n */\nconst TRAVERSAL_STRATEGIES = new Map([[TRAVERSAL_DF_PRE, depthFirstPreOrder], [TRAVERSAL_DF_POST, depthFirstPostOrder], [TRAVERSAL_BF, breadthFirst]]);\n\n/**\n *\n */\nexport default class TreeNode {\n  constructor(data) {\n    /**\n     * A tree data.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"data\", {});\n    /**\n     * A parent node.\n     *\n     * @type {TreeNode}\n     */\n    _defineProperty(this, \"parent\", null);\n    /**\n     * A tree leaves.\n     *\n     * @type {TreeNode[]}\n     */\n    _defineProperty(this, \"childs\", []);\n    this.data = data;\n  }\n\n  /**\n   * Adds a node to tree leaves. Added node is linked with the parent node through \"parent\" property.\n   *\n   * @param {TreeNode} node A TreeNode to add.\n   */\n  addChild(node) {\n    node.parent = this;\n    this.childs.push(node);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof TreeNode#\n   * @function cloneTree\n   *\n   * Clones a tree structure deeply.\n   *\n   * For example, for giving a tree structure:\n   *      .--(B1)--.\n   *   .-(C1)   .-(C2)-.----.\n   *  (D1)     (D2)   (D3) (D4)\n   *\n   * Cloning a tree starting from C2 node creates a mirrored tree structure.\n   *     .-(C2')-.-----.\n   *    (D2')   (D3') (D4')\n   *\n   * The cloned tree can be safely modified without affecting the original structure.\n   * After modification, the clone can be merged with a tree using the \"replaceTreeWith\" method.\n   *\n   * @param {TreeNode} [nodeTree=this] A TreeNode to clone.\n   * @returns {TreeNode}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  cloneTree() {\n    let nodeTree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n    const clonedNode = new TreeNode({\n      ...nodeTree.data\n    });\n    for (let i = 0; i < nodeTree.childs.length; i++) {\n      clonedNode.addChild(this.cloneTree(nodeTree.childs[i]));\n    }\n    return clonedNode;\n  }\n\n  /**\n   * Replaces the current node with a passed tree structure.\n   *\n   * @param {TreeNode} nodeTree A TreeNode to replace with.\n   */\n  replaceTreeWith(nodeTree) {\n    this.data = {\n      ...nodeTree.data\n    };\n    this.childs = [];\n    for (let i = 0; i < nodeTree.childs.length; i++) {\n      this.addChild(nodeTree.childs[i]);\n    }\n  }\n\n  /**\n   * Traverses the tree structure through node childs. The walk down traversing supports\n   * a three different strategies.\n   *  - Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR));\n   *  - Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR));\n   *  - Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).\n   *\n   * @param {Function} callback The callback function which will be called for each node.\n   * @param {string} [traversalStrategy=DEFAULT_TRAVERSAL_STRATEGY] Traversing strategy.\n   */\n  walkDown(callback) {\n    let traversalStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_TRAVERSAL_STRATEGY;\n    if (!TRAVERSAL_STRATEGIES.has(traversalStrategy)) {\n      throw new Error(`Traversal strategy \"${traversalStrategy}\" does not exist`);\n    }\n    TRAVERSAL_STRATEGIES.get(traversalStrategy).call(this, callback, this);\n  }\n\n  /**\n   * Traverses the tree structure through node parents.\n   *\n   * @param {Function} callback The callback function which will be called for each node.\n   */\n  walkUp(callback) {\n    const context = this;\n    const process = node => {\n      const continueTraverse = callback.call(context, node);\n      if (continueTraverse !== false && node.parent !== null) {\n        process(node.parent);\n      }\n    };\n    process(this);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}