{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nimport Highlight, { AREA_TYPE, HEADER_TYPE, FOCUS_TYPE } from \"./highlight/highlight.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { clamp } from \"./../helpers/number.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\nimport { A11Y_SELECTED } from \"../helpers/a11y.mjs\";\n/**\n * @class Selection\n * @util\n */\nvar _disableHeadersHighlight = /*#__PURE__*/new WeakMap();\nclass Selection {\n  constructor(settings, tableProps) {\n    var _this = this;\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"tableProps\", void 0);\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n    _defineProperty(this, \"selectedRange\", new SelectionRange((highlight, from, to) => {\n      return this.tableProps.createCellRange(highlight, from, to);\n    }));\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n    _defineProperty(this, \"highlight\", void 0);\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n    _defineProperty(this, \"transformation\", void 0);\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByRowHeader\", new Set());\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByColumnHeader\", new Set());\n    /**\n     * When sets disable highlighting the headers even when the logical coordinates points on them.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _disableHeadersHighlight, {\n      writable: true,\n      value: false\n    });\n    this.settings = settings;\n    this.tableProps = tableProps;\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      cellAttributes: [A11Y_SELECTED()],\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      disabledCellSelection: (row, column) => this.tableProps.isDisabledCellSelection(row, column),\n      cellCornerVisible: function () {\n        return _this.isCellCornerVisible(...arguments);\n      },\n      areaCornerVisible: function () {\n        return _this.isAreaCornerVisible(...arguments);\n      },\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      createCellRange: (highlight, from, to) => this.tableProps.createCellRange(highlight, from, to)\n    });\n    this.transformation = new Transformation(this.selectedRange, {\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      countRenderableRows: () => this.tableProps.countRenderableRows(),\n      countRenderableColumns: () => this.tableProps.countRenderableColumns(),\n      countRowHeaders: () => this.tableProps.countRowHeaders(),\n      countColHeaders: () => this.tableProps.countColHeaders(),\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      navigableHeaders: () => settings.navigableHeaders,\n      fixedRowsBottom: () => settings.fixedRowsBottom,\n      minSpareRows: () => settings.minSpareRows,\n      minSpareCols: () => settings.minSpareCols,\n      autoWrapRow: () => settings.autoWrapRow,\n      autoWrapCol: () => settings.autoWrapCol\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.runLocalHooks('beforeModifyTransformStart', ...args);\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.runLocalHooks('afterModifyTransformStart', ...args);\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.runLocalHooks('beforeModifyTransformEnd', ...args);\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.runLocalHooks('afterModifyTransformEnd', ...args);\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.runLocalHooks('insertRowRequire', ...args);\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.runLocalHooks('insertColRequire', ...args);\n    });\n    this.transformation.addLocalHook('beforeRowWrap', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _this.runLocalHooks('beforeRowWrap', ...args);\n    });\n    this.transformation.addLocalHook('beforeColumnWrap', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _this.runLocalHooks('beforeColumnWrap', ...args);\n    });\n  }\n\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n  getSelectedRange() {\n    return this.selectedRange;\n  }\n\n  /**\n   * Indicate that selection process began. It sets internally `.inProgress` property to `true`.\n   */\n  begin() {\n    this.inProgress = true;\n  }\n\n  /**\n   * Indicate that selection process finished. It sets internally `.inProgress` property to `false`.\n   */\n  finish() {\n    this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n    this.inProgress = false;\n  }\n\n  /**\n   * Check if the process of selecting the cell/cells is in progress.\n   *\n   * @returns {boolean}\n   */\n  isInProgress() {\n    return this.inProgress;\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n   *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStart(coords, multipleSelection) {\n    let fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let highlightCoords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : coords;\n    const isMultipleMode = this.settings.selectionMode === 'multiple';\n    const isMultipleSelection = isUndefined(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;\n    // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n    // should be handled by next methods.\n    const coordsClone = coords.clone();\n    this.runLocalHooks(`beforeSetRangeStart${fragment ? 'Only' : ''}`, coordsClone);\n    if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n      this.selectedRange.clear();\n    }\n    this.selectedRange.add(coordsClone).current().setHighlight(highlightCoords.clone());\n    if (this.getLayerLevel() === 0) {\n      this.selectedByRowHeader.clear();\n      this.selectedByColumnHeader.clear();\n    }\n    if (!fragment) {\n      this.setRangeEnd(coords);\n    }\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStartOnly(coords, multipleSelection) {\n    let highlightCoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : coords;\n    this.setRangeStart(coords, multipleSelection, true, highlightCoords);\n  }\n\n  /**\n   * Ends selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   */\n  setRangeEnd(coords) {\n    if (this.selectedRange.isEmpty()) {\n      return;\n    }\n    const coordsClone = coords.clone();\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const isSingle = this.selectedRange.current().clone().setTo(coords).isSingleHeader();\n\n    // Ignore processing the end range when the header selection starts overlapping the corner and\n    // the selection is not a single header highlight.\n    if ((countRows > 0 || countCols > 0) && (countRows === 0 && coordsClone.col < 0 && !isSingle || countCols === 0 && coordsClone.row < 0 && !isSingle)) {\n      return;\n    }\n    this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n    this.begin();\n    const cellRange = this.selectedRange.current();\n    if (!this.settings.navigableHeaders) {\n      cellRange.highlight.normalize();\n    }\n    if (this.settings.selectionMode === 'single') {\n      cellRange.setFrom(cellRange.highlight);\n      cellRange.setTo(cellRange.highlight);\n    } else {\n      cellRange.setTo(coordsClone);\n    }\n\n    // Prevent creating \"area\" selection that overlaps headers.\n    if (countRows > 0 && countCols > 0) {\n      if (!this.settings.navigableHeaders || this.settings.navigableHeaders && !cellRange.isSingleHeader()) {\n        cellRange.to.normalize();\n      }\n    }\n    this.runLocalHooks('beforeHighlightSet');\n    const focusHighlight = this.highlight.getFocus();\n    focusHighlight.clear();\n    if (this.highlight.isEnabledFor(FOCUS_TYPE, cellRange.highlight)) {\n      focusHighlight.add(this.selectedRange.current().highlight).commit().syncWith(cellRange);\n    }\n    const layerLevel = this.getLayerLevel();\n\n    // If the next layer level is lower than previous then clear all area and header highlights. This is the\n    // indication that the new selection is performing.\n    if (layerLevel < this.highlight.layerLevel) {\n      arrayEach(this.highlight.getAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getLayeredAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveCornerHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHighlights(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHighlights(), highlight => void highlight.clear());\n    }\n    this.highlight.useLayerLevel(layerLevel);\n    const areaHighlight = this.highlight.createArea();\n    const layeredAreaHighlight = this.highlight.createLayeredArea();\n    const rowHeaderHighlight = this.highlight.createRowHeader();\n    const columnHeaderHighlight = this.highlight.createColumnHeader();\n    const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n    const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n    const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n    const rowHighlight = this.highlight.createRowHighlight();\n    const columnHighlight = this.highlight.createColumnHighlight();\n    areaHighlight.clear();\n    layeredAreaHighlight.clear();\n    rowHeaderHighlight.clear();\n    columnHeaderHighlight.clear();\n    activeRowHeaderHighlight.clear();\n    activeColumnHeaderHighlight.clear();\n    activeCornerHeaderHighlight.clear();\n    rowHighlight.clear();\n    columnHighlight.clear();\n    if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n      areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      layeredAreaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      if (layerLevel === 1) {\n        // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n        // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n        // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n        const previousRange = this.selectedRange.previous();\n        this.highlight.useLayerLevel(layerLevel - 1);\n        this.highlight.createArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.createLayeredArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.useLayerLevel(layerLevel);\n      }\n    }\n    if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n      if (!cellRange.isSingleHeader()) {\n        const rowCoordsFrom = this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), -1);\n        const rowCoordsTo = this.tableProps.createCellCoords(cellRange.to.row, -1);\n        const columnCoordsFrom = this.tableProps.createCellCoords(-1, Math.max(cellRange.from.col, 0));\n        const columnCoordsTo = this.tableProps.createCellCoords(-1, cellRange.to.col);\n        if (this.settings.selectionMode === 'single') {\n          rowHeaderHighlight.add(rowCoordsFrom).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).commit();\n          rowHighlight.add(rowCoordsFrom).commit();\n          columnHighlight.add(columnCoordsFrom).commit();\n        } else {\n          rowHeaderHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n          rowHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n        }\n      }\n      const highlightRowHeaders = !_classPrivateFieldGet(this, _disableHeadersHighlight) && this.isEntireRowSelected() && (countCols > 0 && countCols === cellRange.getWidth() || countCols === 0 && this.isSelectedByRowHeader());\n      const highlightColumnHeaders = !_classPrivateFieldGet(this, _disableHeadersHighlight) && this.isEntireColumnSelected() && (countRows > 0 && countRows === cellRange.getHeight() || countRows === 0 && this.isSelectedByColumnHeader());\n      if (highlightRowHeaders) {\n        activeRowHeaderHighlight.add(this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), Math.min(-this.tableProps.countRowHeaders(), -1))).add(this.tableProps.createCellCoords(Math.max(cellRange.to.row, 0), -1)).commit();\n      }\n      if (highlightColumnHeaders) {\n        activeColumnHeaderHighlight.add(this.tableProps.createCellCoords(Math.min(-this.tableProps.countColHeaders(), -1), Math.max(cellRange.from.col, 0))).add(this.tableProps.createCellCoords(-1, Math.max(cellRange.to.col, 0))).commit();\n      }\n      if (highlightRowHeaders && highlightColumnHeaders) {\n        activeCornerHeaderHighlight.add(this.tableProps.createCellCoords(-this.tableProps.countColHeaders(), -this.tableProps.countRowHeaders())).add(this.tableProps.createCellCoords(-1, -1)).commit();\n      }\n    }\n    this.runLocalHooks('afterSetRangeEnd', coords);\n  }\n\n  /**\n   * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n   * the selection.\n   *\n   * @returns {boolean}\n   */\n  isMultiple() {\n    const isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n    this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n    return isMultipleListener.value;\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary.\n   * Otherwise, row/column will be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, createMissingRecords));\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   */\n  transformEnd(rowDelta, colDelta) {\n    this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n  }\n\n  /**\n   * Returns currently used layer level.\n   *\n   * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n   */\n  getLayerLevel() {\n    return this.selectedRange.size() - 1;\n  }\n\n  /**\n   * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n   *\n   * @returns {boolean}\n   */\n  isSelected() {\n    return !this.selectedRange.isEmpty();\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByRowHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner(layerLevel) && (layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireRowSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        col\n      } = range.getOuterTopStartCorner();\n      const rowHeaders = this.tableProps.countRowHeaders();\n      const countCols = this.tableProps.countCols();\n      return (rowHeaders > 0 && col < 0 || rowHeaders === 0) && range.getWidth() === countCols;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByColumnHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner() && (layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireColumnSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        row\n      } = range.getOuterTopStartCorner();\n      const colHeaders = this.tableProps.countColHeaders();\n      const countRows = this.tableProps.countRows();\n      return (colHeaders > 0 && row < 0 || colHeaders === 0) && range.getHeight() === countRows;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByAnyHeader() {\n    return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByCorner() {\n    return this.selectedByColumnHeader.has(this.getLayerLevel()) && this.selectedByRowHeader.has(this.getLayerLevel());\n  }\n\n  /**\n   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n   * the coords object is within selection range.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {boolean}\n   */\n  inInSelection(coords) {\n    return this.selectedRange.includes(coords);\n  }\n\n  /**\n   * Returns `true` if the cell corner should be visible.\n   *\n   * @private\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isCellCornerVisible() {\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n  }\n\n  /**\n   * Returns `true` if the cell coordinates are visible (renderable).\n   *\n   * @private\n   * @param {CellCoords} coords The cell coordinates to check.\n   * @returns {boolean}\n   */\n  isCellVisible(coords) {\n    const renderableCoords = this.tableProps.visualToRenderableCoords(coords);\n    return renderableCoords.row !== null && renderableCoords.col !== null;\n  }\n\n  /**\n   * Returns `true` if the area corner should be visible.\n   *\n   * @param {number} layerLevel The layer level.\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isAreaCornerVisible(layerLevel) {\n    if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n      return false;\n    }\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n  }\n\n  /**\n   * Clear the selection by resetting the collected ranges and highlights.\n   */\n  clear() {\n    // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n    this.selectedRange.clear();\n    this.highlight.clear();\n  }\n\n  /**\n   * Deselects all selected cells.\n   */\n  deselect() {\n    if (!this.isSelected()) {\n      return;\n    }\n    this.inProgress = false;\n    this.clear();\n    this.runLocalHooks('afterDeselect');\n  }\n\n  /**\n   * Selects all cells and headers.\n   *\n   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers,\n   * `false` otherwise.\n   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column\n   * headers, `false` otherwise.\n   * @param {object} [options] Additional object with options.\n   * @param {{row: number, col: number} | boolean} [options.focusPosition] The argument allows changing the cell/header\n   * focus position. The value takes an object with a `row` and `col` properties from -N to N, where\n   * negative values point to the headers and positive values point to the cell range. If `false`, the focus\n   * position won't be changed.\n   * @param {boolean} [options.disableHeadersHighlight] If `true`, disables highlighting the headers even when\n   * the logical coordinates points on them.\n   */\n  selectAll() {\n    var _this$getSelectedRang;\n    let includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      focusPosition: false,\n      disableHeadersHighlight: false\n    };\n    const nrOfRows = this.tableProps.countRows();\n    const nrOfColumns = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const rowFrom = includeColumnHeaders ? -countColHeaders : 0;\n    const columnFrom = includeRowHeaders ? -countRowHeaders : 0;\n\n    // We can't select cells when there is no data.\n    if (rowFrom === 0 && columnFrom === 0 && (nrOfRows === 0 || nrOfColumns === 0)) {\n      return;\n    }\n    let highlight = (_this$getSelectedRang = this.getSelectedRange().current()) === null || _this$getSelectedRang === void 0 ? void 0 : _this$getSelectedRang.highlight;\n    const {\n      focusPosition,\n      disableHeadersHighlight\n    } = options;\n    _classPrivateFieldSet(this, _disableHeadersHighlight, disableHeadersHighlight);\n    if (focusPosition && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n      highlight = this.tableProps.createCellCoords(clamp(focusPosition.row, rowFrom, nrOfRows - 1), clamp(focusPosition.col, columnFrom, nrOfColumns - 1));\n    }\n    const startCoords = this.tableProps.createCellCoords(rowFrom, columnFrom);\n    const endCoords = this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);\n    this.clear();\n    this.setRangeStartOnly(startCoords, undefined, highlight);\n    if (columnFrom < 0) {\n      this.selectedByRowHeader.add(this.getLayerLevel());\n    }\n    if (rowFrom < 0) {\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n    }\n    this.setRangeEnd(endCoords);\n    this.finish();\n    _classPrivateFieldSet(this, _disableHeadersHighlight, false);\n  }\n\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n   * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n   * If the passed ranges have another format the exception will be thrown.\n   *\n   * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectCells(selectionRanges) {\n    var _this2 = this;\n    const selectionType = detectSelectionType(selectionRanges);\n    if (selectionType === SELECTION_TYPE_EMPTY) {\n      return false;\n    } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n      throw new Error(toSingleLine`Unsupported format of the selection ranges was passed. To select cells pass\\x20\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\x20\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.`);\n    }\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: function () {\n        return _this2.tableProps.createCellCoords(...arguments);\n      },\n      createCellRange: function () {\n        return _this2.tableProps.createCellRange(...arguments);\n      },\n      propToCol: prop => this.tableProps.propToCol(prop),\n      keepDirection: true\n    });\n    const navigableHeaders = this.settings.navigableHeaders;\n    const tableParams = {\n      countRows: this.tableProps.countRows(),\n      countCols: this.tableProps.countCols(),\n      countRowHeaders: navigableHeaders ? this.tableProps.countRowHeaders() : 0,\n      countColHeaders: navigableHeaders ? this.tableProps.countColHeaders() : 0\n    };\n\n    // Check if every layer of the coordinates are valid.\n    const isValid = !selectionRanges.some(selection => {\n      const cellRange = selectionSchemaNormalizer(selection);\n      const rangeValidity = cellRange.isValid(tableParams);\n      return !(rangeValidity && !cellRange.containsHeaders() || rangeValidity && cellRange.containsHeaders() && cellRange.isSingleHeader());\n    });\n    if (isValid) {\n      this.clear();\n      arrayEach(selectionRanges, selection => {\n        const {\n          from,\n          to\n        } = selectionSchemaNormalizer(selection);\n        this.setRangeStartOnly(from.clone(), false);\n        this.setRangeEnd(to.clone());\n        this.finish();\n      });\n    }\n    return isValid;\n  }\n\n  /**\n   * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n   * `endColumn`.\n   *\n   * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n   * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n   * @param {number} [focusPosition=0] The argument allows changing the cell/header focus position.\n   *                                   The value can take visual row index from -N to N, where negative values\n   *                                   point to the headers and positive values point to the cell range.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectColumns(startColumn) {\n    let endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n    const end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const columnHeaderLastIndex = countColHeaders === 0 ? 0 : -countColHeaders;\n    const fromCoords = this.tableProps.createCellCoords(columnHeaderLastIndex, start);\n    const toCoords = this.tableProps.createCellCoords(countRows - 1, end);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders: 0,\n      countColHeaders\n    });\n    if (isValid) {\n      const fromRow = countColHeaders === 0 ? 0 : clamp(focusPosition, columnHeaderLastIndex, -1);\n      const toRow = countRows - 1;\n      const from = this.tableProps.createCellCoords(fromRow, start);\n      const to = this.tableProps.createCellCoords(toRow, end);\n      const highlight = this.tableProps.createCellCoords(clamp(focusPosition, columnHeaderLastIndex, countRows - 1), start);\n      this.runLocalHooks('beforeSelectColumns', from, to, highlight);\n\n      // disallow modifying row axis for that hooks\n      from.row = fromRow;\n      to.row = toRow;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectColumns', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @param {number} startRow Visual row index from which the selection starts.\n   * @param {number} [endRow] Visual row index from to the selection finishes.\n   * @param {number} [focusPosition=0] The argument allows changing the cell/header focus position.\n   *                                   The value can take visual column index from -N to N, where negative values\n   *                                   point to the headers and positive values point to the cell range.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectRows(startRow) {\n    let endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const rowHeaderLastIndex = countRowHeaders === 0 ? 0 : -countRowHeaders;\n    const fromCoords = this.tableProps.createCellCoords(startRow, rowHeaderLastIndex);\n    const toCoords = this.tableProps.createCellCoords(endRow, countCols - 1);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders,\n      countColHeaders: 0\n    });\n    if (isValid) {\n      const fromColumn = countRowHeaders === 0 ? 0 : clamp(focusPosition, rowHeaderLastIndex, -1);\n      const toColumn = countCols - 1;\n      const from = this.tableProps.createCellCoords(startRow, fromColumn);\n      const to = this.tableProps.createCellCoords(endRow, toColumn);\n      const highlight = this.tableProps.createCellCoords(startRow, clamp(focusPosition, rowHeaderLastIndex, countCols - 1));\n      this.runLocalHooks('beforeSelectRows', from, to, highlight);\n\n      // disallow modifying column axis for that hooks\n      from.col = fromColumn;\n      to.col = toColumn;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectRows', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\n   */\n  refresh() {\n    const customSelections = this.highlight.getCustomSelections();\n    customSelections.forEach(customSelection => {\n      customSelection.commit();\n    });\n    if (!this.isSelected()) {\n      return;\n    }\n    const focusHighlight = this.highlight.getFocus();\n    const currentLayer = this.getLayerLevel();\n    focusHighlight.commit().syncWith(this.selectedRange.current());\n\n    // Rewriting rendered ranges going through all layers.\n    for (let layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n      this.highlight.useLayerLevel(layerLevel);\n      const areaHighlight = this.highlight.createArea();\n      const areaLayeredHighlight = this.highlight.createLayeredArea();\n      const rowHeaderHighlight = this.highlight.createRowHeader();\n      const columnHeaderHighlight = this.highlight.createColumnHeader();\n      const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n      const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n      const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n      const rowHighlight = this.highlight.createRowHighlight();\n      const columnHighlight = this.highlight.createColumnHighlight();\n      areaHighlight.commit();\n      areaLayeredHighlight.commit();\n      rowHeaderHighlight.commit();\n      columnHeaderHighlight.commit();\n      activeRowHeaderHighlight.commit();\n      activeColumnHeaderHighlight.commit();\n      activeCornerHeaderHighlight.commit();\n      rowHighlight.commit();\n      columnHighlight.commit();\n    }\n\n    // Reverting starting layer for the Highlight.\n    this.highlight.useLayerLevel(currentLayer);\n  }\n}\nmixin(Selection, localHooks);\nexport default Selection;","map":{"version":3,"names":["_classPrivateFieldInitSpec","obj","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","TypeError","_defineProperty","key","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateFieldSet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorSet","_classPrivateFieldGet","_classApplyDescriptorGet","action","get","Highlight","AREA_TYPE","HEADER_TYPE","FOCUS_TYPE","SelectionRange","createObjectPropListener","mixin","isUndefined","clamp","arrayEach","localHooks","Transformation","detectSelectionType","normalizeSelectionFactory","SELECTION_TYPE_EMPTY","SELECTION_TYPE_UNRECOGNIZED","toSingleLine","A11Y_SELECTED","_disableHeadersHighlight","WeakMap","Selection","constructor","settings","tableProps","_this","highlight","from","to","createCellRange","Set","headerClassName","currentHeaderClassName","activeHeaderClassName","rowClassName","currentRowClassName","columnClassName","currentColClassName","cellAttributes","rowIndexMapper","columnIndexMapper","disabledCellSelection","row","column","isDisabledCellSelection","cellCornerVisible","isCellCornerVisible","arguments","areaCornerVisible","isAreaCornerVisible","visualToRenderableCoords","coords","renderableToVisualCoords","createCellCoords","transformation","selectedRange","countRenderableRows","countRenderableColumns","countRowHeaders","countColHeaders","navigableHeaders","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","addLocalHook","_len","length","args","Array","_key","runLocalHooks","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","_len7","_key7","_len8","_key8","getSelectedRange","begin","inProgress","finish","isInProgress","setRangeStart","multipleSelection","fragment","undefined","highlightCoords","isMultipleMode","selectionMode","isMultipleSelection","getShortcutManager","isCtrlPressed","coordsClone","clone","clear","add","current","setHighlight","getLayerLevel","selectedByRowHeader","selectedByColumnHeader","setRangeEnd","setRangeStartOnly","isEmpty","countRows","countCols","isSingle","setTo","isSingleHeader","col","cellRange","normalize","setFrom","focusHighlight","getFocus","isEnabledFor","commit","syncWith","layerLevel","getAreas","getLayeredAreas","getRowHeaders","getColumnHeaders","getActiveRowHeaders","getActiveColumnHeaders","getActiveCornerHeaders","getRowHighlights","getColumnHighlights","useLayerLevel","areaHighlight","createArea","layeredAreaHighlight","createLayeredArea","rowHeaderHighlight","createRowHeader","columnHeaderHighlight","createColumnHeader","activeRowHeaderHighlight","createActiveRowHeader","activeColumnHeaderHighlight","createActiveColumnHeader","activeCornerHeaderHighlight","createActiveCornerHeader","rowHighlight","createRowHighlight","columnHighlight","createColumnHighlight","isMultiple","previousRange","previous","rowCoordsFrom","Math","max","rowCoordsTo","columnCoordsFrom","columnCoordsTo","highlightRowHeaders","isEntireRowSelected","getWidth","isSelectedByRowHeader","highlightColumnHeaders","isEntireColumnSelected","getHeight","isSelectedByColumnHeader","min","isMultipleListener","transformStart","rowDelta","colDelta","createMissingRecords","transformEnd","size","isSelected","isSelectedByCorner","tester","range","getOuterTopStartCorner","rowHeaders","some","peekByIndex","colHeaders","isSelectedByAnyHeader","inInSelection","includes","fillHandle","isEditorOpened","isCellVisible","renderableCoords","isInteger","deselect","selectAll","_this$getSelectedRang","includeRowHeaders","includeColumnHeaders","options","focusPosition","disableHeadersHighlight","nrOfRows","nrOfColumns","rowFrom","columnFrom","startCoords","endCoords","selectCells","selectionRanges","_this2","selectionType","Error","selectionSchemaNormalizer","propToCol","prop","keepDirection","tableParams","isValid","selection","rangeValidity","containsHeaders","selectColumns","startColumn","endColumn","start","end","columnHeaderLastIndex","fromCoords","toCoords","fromRow","toRow","selectRows","startRow","endRow","rowHeaderLastIndex","fromColumn","toColumn","refresh","customSelections","getCustomSelections","forEach","customSelection","currentLayer","areaLayeredHighlight"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/selection/selection.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nimport Highlight, { AREA_TYPE, HEADER_TYPE, FOCUS_TYPE } from \"./highlight/highlight.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { clamp } from \"./../helpers/number.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\nimport { A11Y_SELECTED } from \"../helpers/a11y.mjs\";\n/**\n * @class Selection\n * @util\n */\nvar _disableHeadersHighlight = /*#__PURE__*/new WeakMap();\nclass Selection {\n  constructor(settings, tableProps) {\n    var _this = this;\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"tableProps\", void 0);\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n    _defineProperty(this, \"selectedRange\", new SelectionRange((highlight, from, to) => {\n      return this.tableProps.createCellRange(highlight, from, to);\n    }));\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n    _defineProperty(this, \"highlight\", void 0);\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n    _defineProperty(this, \"transformation\", void 0);\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByRowHeader\", new Set());\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByColumnHeader\", new Set());\n    /**\n     * When sets disable highlighting the headers even when the logical coordinates points on them.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _disableHeadersHighlight, {\n      writable: true,\n      value: false\n    });\n    this.settings = settings;\n    this.tableProps = tableProps;\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      cellAttributes: [A11Y_SELECTED()],\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      disabledCellSelection: (row, column) => this.tableProps.isDisabledCellSelection(row, column),\n      cellCornerVisible: function () {\n        return _this.isCellCornerVisible(...arguments);\n      },\n      areaCornerVisible: function () {\n        return _this.isAreaCornerVisible(...arguments);\n      },\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      createCellRange: (highlight, from, to) => this.tableProps.createCellRange(highlight, from, to)\n    });\n    this.transformation = new Transformation(this.selectedRange, {\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      countRenderableRows: () => this.tableProps.countRenderableRows(),\n      countRenderableColumns: () => this.tableProps.countRenderableColumns(),\n      countRowHeaders: () => this.tableProps.countRowHeaders(),\n      countColHeaders: () => this.tableProps.countColHeaders(),\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      navigableHeaders: () => settings.navigableHeaders,\n      fixedRowsBottom: () => settings.fixedRowsBottom,\n      minSpareRows: () => settings.minSpareRows,\n      minSpareCols: () => settings.minSpareCols,\n      autoWrapRow: () => settings.autoWrapRow,\n      autoWrapCol: () => settings.autoWrapCol\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.runLocalHooks('beforeModifyTransformStart', ...args);\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.runLocalHooks('afterModifyTransformStart', ...args);\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.runLocalHooks('beforeModifyTransformEnd', ...args);\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.runLocalHooks('afterModifyTransformEnd', ...args);\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.runLocalHooks('insertRowRequire', ...args);\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.runLocalHooks('insertColRequire', ...args);\n    });\n    this.transformation.addLocalHook('beforeRowWrap', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _this.runLocalHooks('beforeRowWrap', ...args);\n    });\n    this.transformation.addLocalHook('beforeColumnWrap', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _this.runLocalHooks('beforeColumnWrap', ...args);\n    });\n  }\n\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n  getSelectedRange() {\n    return this.selectedRange;\n  }\n\n  /**\n   * Indicate that selection process began. It sets internally `.inProgress` property to `true`.\n   */\n  begin() {\n    this.inProgress = true;\n  }\n\n  /**\n   * Indicate that selection process finished. It sets internally `.inProgress` property to `false`.\n   */\n  finish() {\n    this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n    this.inProgress = false;\n  }\n\n  /**\n   * Check if the process of selecting the cell/cells is in progress.\n   *\n   * @returns {boolean}\n   */\n  isInProgress() {\n    return this.inProgress;\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n   *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStart(coords, multipleSelection) {\n    let fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let highlightCoords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : coords;\n    const isMultipleMode = this.settings.selectionMode === 'multiple';\n    const isMultipleSelection = isUndefined(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;\n    // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n    // should be handled by next methods.\n    const coordsClone = coords.clone();\n    this.runLocalHooks(`beforeSetRangeStart${fragment ? 'Only' : ''}`, coordsClone);\n    if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n      this.selectedRange.clear();\n    }\n    this.selectedRange.add(coordsClone).current().setHighlight(highlightCoords.clone());\n    if (this.getLayerLevel() === 0) {\n      this.selectedByRowHeader.clear();\n      this.selectedByColumnHeader.clear();\n    }\n    if (!fragment) {\n      this.setRangeEnd(coords);\n    }\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStartOnly(coords, multipleSelection) {\n    let highlightCoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : coords;\n    this.setRangeStart(coords, multipleSelection, true, highlightCoords);\n  }\n\n  /**\n   * Ends selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   */\n  setRangeEnd(coords) {\n    if (this.selectedRange.isEmpty()) {\n      return;\n    }\n    const coordsClone = coords.clone();\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const isSingle = this.selectedRange.current().clone().setTo(coords).isSingleHeader();\n\n    // Ignore processing the end range when the header selection starts overlapping the corner and\n    // the selection is not a single header highlight.\n    if ((countRows > 0 || countCols > 0) && (countRows === 0 && coordsClone.col < 0 && !isSingle || countCols === 0 && coordsClone.row < 0 && !isSingle)) {\n      return;\n    }\n    this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n    this.begin();\n    const cellRange = this.selectedRange.current();\n    if (!this.settings.navigableHeaders) {\n      cellRange.highlight.normalize();\n    }\n    if (this.settings.selectionMode === 'single') {\n      cellRange.setFrom(cellRange.highlight);\n      cellRange.setTo(cellRange.highlight);\n    } else {\n      cellRange.setTo(coordsClone);\n    }\n\n    // Prevent creating \"area\" selection that overlaps headers.\n    if (countRows > 0 && countCols > 0) {\n      if (!this.settings.navigableHeaders || this.settings.navigableHeaders && !cellRange.isSingleHeader()) {\n        cellRange.to.normalize();\n      }\n    }\n    this.runLocalHooks('beforeHighlightSet');\n    const focusHighlight = this.highlight.getFocus();\n    focusHighlight.clear();\n    if (this.highlight.isEnabledFor(FOCUS_TYPE, cellRange.highlight)) {\n      focusHighlight.add(this.selectedRange.current().highlight).commit().syncWith(cellRange);\n    }\n    const layerLevel = this.getLayerLevel();\n\n    // If the next layer level is lower than previous then clear all area and header highlights. This is the\n    // indication that the new selection is performing.\n    if (layerLevel < this.highlight.layerLevel) {\n      arrayEach(this.highlight.getAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getLayeredAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveCornerHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHighlights(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHighlights(), highlight => void highlight.clear());\n    }\n    this.highlight.useLayerLevel(layerLevel);\n    const areaHighlight = this.highlight.createArea();\n    const layeredAreaHighlight = this.highlight.createLayeredArea();\n    const rowHeaderHighlight = this.highlight.createRowHeader();\n    const columnHeaderHighlight = this.highlight.createColumnHeader();\n    const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n    const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n    const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n    const rowHighlight = this.highlight.createRowHighlight();\n    const columnHighlight = this.highlight.createColumnHighlight();\n    areaHighlight.clear();\n    layeredAreaHighlight.clear();\n    rowHeaderHighlight.clear();\n    columnHeaderHighlight.clear();\n    activeRowHeaderHighlight.clear();\n    activeColumnHeaderHighlight.clear();\n    activeCornerHeaderHighlight.clear();\n    rowHighlight.clear();\n    columnHighlight.clear();\n    if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n      areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      layeredAreaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      if (layerLevel === 1) {\n        // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n        // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n        // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n        const previousRange = this.selectedRange.previous();\n        this.highlight.useLayerLevel(layerLevel - 1);\n        this.highlight.createArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.createLayeredArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.useLayerLevel(layerLevel);\n      }\n    }\n    if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n      if (!cellRange.isSingleHeader()) {\n        const rowCoordsFrom = this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), -1);\n        const rowCoordsTo = this.tableProps.createCellCoords(cellRange.to.row, -1);\n        const columnCoordsFrom = this.tableProps.createCellCoords(-1, Math.max(cellRange.from.col, 0));\n        const columnCoordsTo = this.tableProps.createCellCoords(-1, cellRange.to.col);\n        if (this.settings.selectionMode === 'single') {\n          rowHeaderHighlight.add(rowCoordsFrom).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).commit();\n          rowHighlight.add(rowCoordsFrom).commit();\n          columnHighlight.add(columnCoordsFrom).commit();\n        } else {\n          rowHeaderHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n          rowHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n        }\n      }\n      const highlightRowHeaders = !_classPrivateFieldGet(this, _disableHeadersHighlight) && this.isEntireRowSelected() && (countCols > 0 && countCols === cellRange.getWidth() || countCols === 0 && this.isSelectedByRowHeader());\n      const highlightColumnHeaders = !_classPrivateFieldGet(this, _disableHeadersHighlight) && this.isEntireColumnSelected() && (countRows > 0 && countRows === cellRange.getHeight() || countRows === 0 && this.isSelectedByColumnHeader());\n      if (highlightRowHeaders) {\n        activeRowHeaderHighlight.add(this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), Math.min(-this.tableProps.countRowHeaders(), -1))).add(this.tableProps.createCellCoords(Math.max(cellRange.to.row, 0), -1)).commit();\n      }\n      if (highlightColumnHeaders) {\n        activeColumnHeaderHighlight.add(this.tableProps.createCellCoords(Math.min(-this.tableProps.countColHeaders(), -1), Math.max(cellRange.from.col, 0))).add(this.tableProps.createCellCoords(-1, Math.max(cellRange.to.col, 0))).commit();\n      }\n      if (highlightRowHeaders && highlightColumnHeaders) {\n        activeCornerHeaderHighlight.add(this.tableProps.createCellCoords(-this.tableProps.countColHeaders(), -this.tableProps.countRowHeaders())).add(this.tableProps.createCellCoords(-1, -1)).commit();\n      }\n    }\n    this.runLocalHooks('afterSetRangeEnd', coords);\n  }\n\n  /**\n   * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n   * the selection.\n   *\n   * @returns {boolean}\n   */\n  isMultiple() {\n    const isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n    this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n    return isMultipleListener.value;\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary.\n   * Otherwise, row/column will be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, createMissingRecords));\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   */\n  transformEnd(rowDelta, colDelta) {\n    this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n  }\n\n  /**\n   * Returns currently used layer level.\n   *\n   * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n   */\n  getLayerLevel() {\n    return this.selectedRange.size() - 1;\n  }\n\n  /**\n   * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n   *\n   * @returns {boolean}\n   */\n  isSelected() {\n    return !this.selectedRange.isEmpty();\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByRowHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner(layerLevel) && (layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireRowSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        col\n      } = range.getOuterTopStartCorner();\n      const rowHeaders = this.tableProps.countRowHeaders();\n      const countCols = this.tableProps.countCols();\n      return (rowHeaders > 0 && col < 0 || rowHeaders === 0) && range.getWidth() === countCols;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByColumnHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner() && (layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireColumnSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        row\n      } = range.getOuterTopStartCorner();\n      const colHeaders = this.tableProps.countColHeaders();\n      const countRows = this.tableProps.countRows();\n      return (colHeaders > 0 && row < 0 || colHeaders === 0) && range.getHeight() === countRows;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByAnyHeader() {\n    return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByCorner() {\n    return this.selectedByColumnHeader.has(this.getLayerLevel()) && this.selectedByRowHeader.has(this.getLayerLevel());\n  }\n\n  /**\n   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n   * the coords object is within selection range.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {boolean}\n   */\n  inInSelection(coords) {\n    return this.selectedRange.includes(coords);\n  }\n\n  /**\n   * Returns `true` if the cell corner should be visible.\n   *\n   * @private\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isCellCornerVisible() {\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n  }\n\n  /**\n   * Returns `true` if the cell coordinates are visible (renderable).\n   *\n   * @private\n   * @param {CellCoords} coords The cell coordinates to check.\n   * @returns {boolean}\n   */\n  isCellVisible(coords) {\n    const renderableCoords = this.tableProps.visualToRenderableCoords(coords);\n    return renderableCoords.row !== null && renderableCoords.col !== null;\n  }\n\n  /**\n   * Returns `true` if the area corner should be visible.\n   *\n   * @param {number} layerLevel The layer level.\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isAreaCornerVisible(layerLevel) {\n    if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n      return false;\n    }\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n  }\n\n  /**\n   * Clear the selection by resetting the collected ranges and highlights.\n   */\n  clear() {\n    // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n    this.selectedRange.clear();\n    this.highlight.clear();\n  }\n\n  /**\n   * Deselects all selected cells.\n   */\n  deselect() {\n    if (!this.isSelected()) {\n      return;\n    }\n    this.inProgress = false;\n    this.clear();\n    this.runLocalHooks('afterDeselect');\n  }\n\n  /**\n   * Selects all cells and headers.\n   *\n   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers,\n   * `false` otherwise.\n   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column\n   * headers, `false` otherwise.\n   * @param {object} [options] Additional object with options.\n   * @param {{row: number, col: number} | boolean} [options.focusPosition] The argument allows changing the cell/header\n   * focus position. The value takes an object with a `row` and `col` properties from -N to N, where\n   * negative values point to the headers and positive values point to the cell range. If `false`, the focus\n   * position won't be changed.\n   * @param {boolean} [options.disableHeadersHighlight] If `true`, disables highlighting the headers even when\n   * the logical coordinates points on them.\n   */\n  selectAll() {\n    var _this$getSelectedRang;\n    let includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      focusPosition: false,\n      disableHeadersHighlight: false\n    };\n    const nrOfRows = this.tableProps.countRows();\n    const nrOfColumns = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const rowFrom = includeColumnHeaders ? -countColHeaders : 0;\n    const columnFrom = includeRowHeaders ? -countRowHeaders : 0;\n\n    // We can't select cells when there is no data.\n    if (rowFrom === 0 && columnFrom === 0 && (nrOfRows === 0 || nrOfColumns === 0)) {\n      return;\n    }\n    let highlight = (_this$getSelectedRang = this.getSelectedRange().current()) === null || _this$getSelectedRang === void 0 ? void 0 : _this$getSelectedRang.highlight;\n    const {\n      focusPosition,\n      disableHeadersHighlight\n    } = options;\n    _classPrivateFieldSet(this, _disableHeadersHighlight, disableHeadersHighlight);\n    if (focusPosition && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n      highlight = this.tableProps.createCellCoords(clamp(focusPosition.row, rowFrom, nrOfRows - 1), clamp(focusPosition.col, columnFrom, nrOfColumns - 1));\n    }\n    const startCoords = this.tableProps.createCellCoords(rowFrom, columnFrom);\n    const endCoords = this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);\n    this.clear();\n    this.setRangeStartOnly(startCoords, undefined, highlight);\n    if (columnFrom < 0) {\n      this.selectedByRowHeader.add(this.getLayerLevel());\n    }\n    if (rowFrom < 0) {\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n    }\n    this.setRangeEnd(endCoords);\n    this.finish();\n    _classPrivateFieldSet(this, _disableHeadersHighlight, false);\n  }\n\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n   * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n   * If the passed ranges have another format the exception will be thrown.\n   *\n   * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectCells(selectionRanges) {\n    var _this2 = this;\n    const selectionType = detectSelectionType(selectionRanges);\n    if (selectionType === SELECTION_TYPE_EMPTY) {\n      return false;\n    } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n      throw new Error(toSingleLine`Unsupported format of the selection ranges was passed. To select cells pass\\x20\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\x20\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.`);\n    }\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: function () {\n        return _this2.tableProps.createCellCoords(...arguments);\n      },\n      createCellRange: function () {\n        return _this2.tableProps.createCellRange(...arguments);\n      },\n      propToCol: prop => this.tableProps.propToCol(prop),\n      keepDirection: true\n    });\n    const navigableHeaders = this.settings.navigableHeaders;\n    const tableParams = {\n      countRows: this.tableProps.countRows(),\n      countCols: this.tableProps.countCols(),\n      countRowHeaders: navigableHeaders ? this.tableProps.countRowHeaders() : 0,\n      countColHeaders: navigableHeaders ? this.tableProps.countColHeaders() : 0\n    };\n\n    // Check if every layer of the coordinates are valid.\n    const isValid = !selectionRanges.some(selection => {\n      const cellRange = selectionSchemaNormalizer(selection);\n      const rangeValidity = cellRange.isValid(tableParams);\n      return !(rangeValidity && !cellRange.containsHeaders() || rangeValidity && cellRange.containsHeaders() && cellRange.isSingleHeader());\n    });\n    if (isValid) {\n      this.clear();\n      arrayEach(selectionRanges, selection => {\n        const {\n          from,\n          to\n        } = selectionSchemaNormalizer(selection);\n        this.setRangeStartOnly(from.clone(), false);\n        this.setRangeEnd(to.clone());\n        this.finish();\n      });\n    }\n    return isValid;\n  }\n\n  /**\n   * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n   * `endColumn`.\n   *\n   * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n   * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n   * @param {number} [focusPosition=0] The argument allows changing the cell/header focus position.\n   *                                   The value can take visual row index from -N to N, where negative values\n   *                                   point to the headers and positive values point to the cell range.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectColumns(startColumn) {\n    let endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n    const end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const columnHeaderLastIndex = countColHeaders === 0 ? 0 : -countColHeaders;\n    const fromCoords = this.tableProps.createCellCoords(columnHeaderLastIndex, start);\n    const toCoords = this.tableProps.createCellCoords(countRows - 1, end);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders: 0,\n      countColHeaders\n    });\n    if (isValid) {\n      const fromRow = countColHeaders === 0 ? 0 : clamp(focusPosition, columnHeaderLastIndex, -1);\n      const toRow = countRows - 1;\n      const from = this.tableProps.createCellCoords(fromRow, start);\n      const to = this.tableProps.createCellCoords(toRow, end);\n      const highlight = this.tableProps.createCellCoords(clamp(focusPosition, columnHeaderLastIndex, countRows - 1), start);\n      this.runLocalHooks('beforeSelectColumns', from, to, highlight);\n\n      // disallow modifying row axis for that hooks\n      from.row = fromRow;\n      to.row = toRow;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectColumns', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @param {number} startRow Visual row index from which the selection starts.\n   * @param {number} [endRow] Visual row index from to the selection finishes.\n   * @param {number} [focusPosition=0] The argument allows changing the cell/header focus position.\n   *                                   The value can take visual column index from -N to N, where negative values\n   *                                   point to the headers and positive values point to the cell range.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectRows(startRow) {\n    let endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const rowHeaderLastIndex = countRowHeaders === 0 ? 0 : -countRowHeaders;\n    const fromCoords = this.tableProps.createCellCoords(startRow, rowHeaderLastIndex);\n    const toCoords = this.tableProps.createCellCoords(endRow, countCols - 1);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders,\n      countColHeaders: 0\n    });\n    if (isValid) {\n      const fromColumn = countRowHeaders === 0 ? 0 : clamp(focusPosition, rowHeaderLastIndex, -1);\n      const toColumn = countCols - 1;\n      const from = this.tableProps.createCellCoords(startRow, fromColumn);\n      const to = this.tableProps.createCellCoords(endRow, toColumn);\n      const highlight = this.tableProps.createCellCoords(startRow, clamp(focusPosition, rowHeaderLastIndex, countCols - 1));\n      this.runLocalHooks('beforeSelectRows', from, to, highlight);\n\n      // disallow modifying column axis for that hooks\n      from.col = fromColumn;\n      to.col = toColumn;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectRows', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\n   */\n  refresh() {\n    const customSelections = this.highlight.getCustomSelections();\n    customSelections.forEach(customSelection => {\n      customSelection.commit();\n    });\n    if (!this.isSelected()) {\n      return;\n    }\n    const focusHighlight = this.highlight.getFocus();\n    const currentLayer = this.getLayerLevel();\n    focusHighlight.commit().syncWith(this.selectedRange.current());\n\n    // Rewriting rendered ranges going through all layers.\n    for (let layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n      this.highlight.useLayerLevel(layerLevel);\n      const areaHighlight = this.highlight.createArea();\n      const areaLayeredHighlight = this.highlight.createLayeredArea();\n      const rowHeaderHighlight = this.highlight.createRowHeader();\n      const columnHeaderHighlight = this.highlight.createColumnHeader();\n      const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n      const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n      const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n      const rowHighlight = this.highlight.createRowHighlight();\n      const columnHighlight = this.highlight.createColumnHighlight();\n      areaHighlight.commit();\n      areaLayeredHighlight.commit();\n      rowHeaderHighlight.commit();\n      columnHeaderHighlight.commit();\n      activeRowHeaderHighlight.commit();\n      activeColumnHeaderHighlight.commit();\n      activeCornerHeaderHighlight.commit();\n      rowHighlight.commit();\n      columnHighlight.commit();\n    }\n\n    // Reverting starting layer for the Highlight.\n    this.highlight.useLayerLevel(currentLayer);\n  }\n}\nmixin(Selection, localHooks);\nexport default Selection;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}