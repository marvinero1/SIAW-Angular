{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport { extend, isObject } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { normalizeSettings } from \"./settingsNormalizer.mjs\";\n/**\n * List of properties which are configurable. That properties can be changed using public API.\n *\n * @type {string[]}\n */\nexport const HEADER_CONFIGURABLE_PROPS = ['label', 'collapsible'];\n\n/**\n * The class manages and normalizes settings passed by the developer\n * into the nested headers plugin. The SourceSettings class is a\n * source of truth for tree builder (HeaderTree) module.\n *\n * @private\n * @class SourceSettings\n */\nvar _data = /*#__PURE__*/new WeakMap();\nvar _dataLength = /*#__PURE__*/new WeakMap();\nvar _columnsLimit = /*#__PURE__*/new WeakMap();\nexport default class SourceSettings {\n  constructor() {\n    /**\n     * The normalized source data (normalized user-defined settings for nested headers).\n     *\n     * @private\n     * @type {Array[]}\n     */\n    _classPrivateFieldInitSpec(this, _data, {\n      writable: true,\n      value: []\n    });\n    /**\n     * The total length of the nested header layers.\n     *\n     * @private\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _dataLength, {\n      writable: true,\n      value: 0\n    });\n    /**\n     * Columns count limit value trims source settings to that value. If columns\n     * count limit intersects nested header, the header's colspan value is reduced\n     * to keep the whole structure stable (trimmed precisely where the limit is set).\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _columnsLimit, {\n      writable: true,\n      value: Infinity\n    });\n  }\n  /**\n   * Sets columns limit to the source settings will be trimmed. All headers which\n   * overlap the column limit will be reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount The number of columns to limit to.\n   */\n  setColumnsLimit(columnsCount) {\n    _classPrivateFieldSet(this, _columnsLimit, columnsCount);\n  }\n\n  /**\n   * Sets a new nested header configuration.\n   *\n   * @param {Array[]} [nestedHeadersSettings=[]] The user-defined nested headers settings.\n   */\n  setData() {\n    let nestedHeadersSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classPrivateFieldSet(this, _data, normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet(this, _columnsLimit)));\n    _classPrivateFieldSet(this, _dataLength, _classPrivateFieldGet(this, _data).length);\n  }\n\n  /**\n   * Gets normalized source settings.\n   *\n   * @returns {Array[]}\n   */\n  getData() {\n    return _classPrivateFieldGet(this, _data);\n  }\n\n  /**\n   * Merges settings with current source settings.\n   *\n   * @param {object[]} additionalSettings An array of objects with `row`, `col` and additional\n   *                                      properties to merge with current source settings.\n   */\n  mergeWith(additionalSettings) {\n    arrayEach(additionalSettings, _ref => {\n      let {\n        row,\n        col,\n        ...rest\n      } = _ref;\n      const headerSettings = this.getHeaderSettings(row, col);\n      if (headerSettings !== null) {\n        extend(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);\n      }\n    });\n  }\n\n  /**\n   * Maps the current state with a callback. For each source settings the callback function\n   * is called. If the function returns value that value is merged with the source settings.\n   *\n   * @param {Function} callback A function that is called for every header settings.\n   *                            Each time the callback is called, the returned value extends\n   *                            header settings.\n   */\n  map(callback) {\n    arrayEach(_classPrivateFieldGet(this, _data), header => {\n      arrayEach(header, headerSettings => {\n        const propsToExtend = callback({\n          ...headerSettings\n        });\n        if (isObject(propsToExtend)) {\n          extend(headerSettings, propsToExtend, HEADER_CONFIGURABLE_PROPS);\n        }\n      });\n    });\n  }\n\n  /**\n   * Gets source column header settings for a specified header. The returned\n   * object contains information about the header label, its colspan length,\n   * or if it is hidden in the header renderers.\n   *\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    var _headersSettings$colu;\n    if (headerLevel >= _classPrivateFieldGet(this, _dataLength) || headerLevel < 0) {\n      return null;\n    }\n    const headersSettings = _classPrivateFieldGet(this, _data)[headerLevel];\n    if (Array.isArray(headersSettings) === false || columnIndex >= headersSettings.length) {\n      return null;\n    }\n    return (_headersSettings$colu = headersSettings[columnIndex]) !== null && _headersSettings$colu !== void 0 ? _headersSettings$colu : null;\n  }\n\n  /**\n   * Gets source of column headers settings for specified headers. If the retrieved column\n   * settings overlap the range \"box\" determined by \"columnIndex\" and \"columnsLength\"\n   * the exception will be thrown.\n   *\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index from which the settings will be extracted.\n   * @param {number} [columnsLength=1] The number of columns involved in the extraction of settings.\n   * @returns {object}\n   */\n  getHeadersSettings(headerLevel, columnIndex) {\n    let columnsLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const headersSettingsChunks = [];\n    if (headerLevel >= _classPrivateFieldGet(this, _dataLength) || headerLevel < 0) {\n      return headersSettingsChunks;\n    }\n    const headersSettings = _classPrivateFieldGet(this, _data)[headerLevel];\n    let currentLength = 0;\n    for (let i = columnIndex; i < headersSettings.length; i++) {\n      const headerSettings = headersSettings[i];\n      if (headerSettings.isPlaceholder) {\n        throw new Error('The first column settings cannot overlap the other header layers');\n      }\n      currentLength += headerSettings.colspan;\n      headersSettingsChunks.push(headerSettings);\n      if (headerSettings.colspan > 1) {\n        i += headerSettings.colspan - 1;\n      }\n\n      // We met the current sum of the child colspans\n      if (currentLength === columnsLength) {\n        break;\n      }\n      // We exceeds the current sum of the child colspans, the last columns colspan overlaps the \"columnsLength\" length.\n      if (currentLength > columnsLength) {\n        throw new Error('The last column settings cannot overlap the other header layers');\n      }\n    }\n    return headersSettingsChunks;\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(this, _dataLength);\n  }\n\n  /**\n   * Gets a total number of columns count.\n   *\n   * @returns {number}\n   */\n  getColumnsCount() {\n    return _classPrivateFieldGet(this, _dataLength) > 0 ? _classPrivateFieldGet(this, _data)[0].length : 0;\n  }\n\n  /**\n   * Clears the data.\n   */\n  clear() {\n    _classPrivateFieldSet(this, _data, []);\n    _classPrivateFieldSet(this, _dataLength, 0);\n  }\n}","map":{"version":3,"names":["_classPrivateFieldInitSpec","obj","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","TypeError","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","call","_classPrivateFieldSet","_classApplyDescriptorSet","action","writable","extend","isObject","arrayEach","normalizeSettings","HEADER_CONFIGURABLE_PROPS","_data","WeakMap","_dataLength","_columnsLimit","SourceSettings","constructor","Infinity","setColumnsLimit","columnsCount","setData","nestedHeadersSettings","arguments","length","undefined","getData","mergeWith","additionalSettings","_ref","row","col","rest","headerSettings","getHeaderSettings","map","callback","header","propsToExtend","headerLevel","columnIndex","_headersSettings$colu","headersSettings","Array","isArray","getHeadersSettings","columnsLength","headersSettingsChunks","currentLength","i","isPlaceholder","Error","colspan","push","getLayersCount","getColumnsCount","clear"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/nestedHeaders/stateManager/sourceSettings.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { extend, isObject } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { normalizeSettings } from \"./settingsNormalizer.mjs\";\n/**\n * List of properties which are configurable. That properties can be changed using public API.\n *\n * @type {string[]}\n */\nexport const HEADER_CONFIGURABLE_PROPS = ['label', 'collapsible'];\n\n/**\n * The class manages and normalizes settings passed by the developer\n * into the nested headers plugin. The SourceSettings class is a\n * source of truth for tree builder (HeaderTree) module.\n *\n * @private\n * @class SourceSettings\n */\nvar _data = /*#__PURE__*/new WeakMap();\nvar _dataLength = /*#__PURE__*/new WeakMap();\nvar _columnsLimit = /*#__PURE__*/new WeakMap();\nexport default class SourceSettings {\n  constructor() {\n    /**\n     * The normalized source data (normalized user-defined settings for nested headers).\n     *\n     * @private\n     * @type {Array[]}\n     */\n    _classPrivateFieldInitSpec(this, _data, {\n      writable: true,\n      value: []\n    });\n    /**\n     * The total length of the nested header layers.\n     *\n     * @private\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _dataLength, {\n      writable: true,\n      value: 0\n    });\n    /**\n     * Columns count limit value trims source settings to that value. If columns\n     * count limit intersects nested header, the header's colspan value is reduced\n     * to keep the whole structure stable (trimmed precisely where the limit is set).\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _columnsLimit, {\n      writable: true,\n      value: Infinity\n    });\n  }\n  /**\n   * Sets columns limit to the source settings will be trimmed. All headers which\n   * overlap the column limit will be reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount The number of columns to limit to.\n   */\n  setColumnsLimit(columnsCount) {\n    _classPrivateFieldSet(this, _columnsLimit, columnsCount);\n  }\n\n  /**\n   * Sets a new nested header configuration.\n   *\n   * @param {Array[]} [nestedHeadersSettings=[]] The user-defined nested headers settings.\n   */\n  setData() {\n    let nestedHeadersSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classPrivateFieldSet(this, _data, normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet(this, _columnsLimit)));\n    _classPrivateFieldSet(this, _dataLength, _classPrivateFieldGet(this, _data).length);\n  }\n\n  /**\n   * Gets normalized source settings.\n   *\n   * @returns {Array[]}\n   */\n  getData() {\n    return _classPrivateFieldGet(this, _data);\n  }\n\n  /**\n   * Merges settings with current source settings.\n   *\n   * @param {object[]} additionalSettings An array of objects with `row`, `col` and additional\n   *                                      properties to merge with current source settings.\n   */\n  mergeWith(additionalSettings) {\n    arrayEach(additionalSettings, _ref => {\n      let {\n        row,\n        col,\n        ...rest\n      } = _ref;\n      const headerSettings = this.getHeaderSettings(row, col);\n      if (headerSettings !== null) {\n        extend(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);\n      }\n    });\n  }\n\n  /**\n   * Maps the current state with a callback. For each source settings the callback function\n   * is called. If the function returns value that value is merged with the source settings.\n   *\n   * @param {Function} callback A function that is called for every header settings.\n   *                            Each time the callback is called, the returned value extends\n   *                            header settings.\n   */\n  map(callback) {\n    arrayEach(_classPrivateFieldGet(this, _data), header => {\n      arrayEach(header, headerSettings => {\n        const propsToExtend = callback({\n          ...headerSettings\n        });\n        if (isObject(propsToExtend)) {\n          extend(headerSettings, propsToExtend, HEADER_CONFIGURABLE_PROPS);\n        }\n      });\n    });\n  }\n\n  /**\n   * Gets source column header settings for a specified header. The returned\n   * object contains information about the header label, its colspan length,\n   * or if it is hidden in the header renderers.\n   *\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    var _headersSettings$colu;\n    if (headerLevel >= _classPrivateFieldGet(this, _dataLength) || headerLevel < 0) {\n      return null;\n    }\n    const headersSettings = _classPrivateFieldGet(this, _data)[headerLevel];\n    if (Array.isArray(headersSettings) === false || columnIndex >= headersSettings.length) {\n      return null;\n    }\n    return (_headersSettings$colu = headersSettings[columnIndex]) !== null && _headersSettings$colu !== void 0 ? _headersSettings$colu : null;\n  }\n\n  /**\n   * Gets source of column headers settings for specified headers. If the retrieved column\n   * settings overlap the range \"box\" determined by \"columnIndex\" and \"columnsLength\"\n   * the exception will be thrown.\n   *\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index from which the settings will be extracted.\n   * @param {number} [columnsLength=1] The number of columns involved in the extraction of settings.\n   * @returns {object}\n   */\n  getHeadersSettings(headerLevel, columnIndex) {\n    let columnsLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const headersSettingsChunks = [];\n    if (headerLevel >= _classPrivateFieldGet(this, _dataLength) || headerLevel < 0) {\n      return headersSettingsChunks;\n    }\n    const headersSettings = _classPrivateFieldGet(this, _data)[headerLevel];\n    let currentLength = 0;\n    for (let i = columnIndex; i < headersSettings.length; i++) {\n      const headerSettings = headersSettings[i];\n      if (headerSettings.isPlaceholder) {\n        throw new Error('The first column settings cannot overlap the other header layers');\n      }\n      currentLength += headerSettings.colspan;\n      headersSettingsChunks.push(headerSettings);\n      if (headerSettings.colspan > 1) {\n        i += headerSettings.colspan - 1;\n      }\n\n      // We met the current sum of the child colspans\n      if (currentLength === columnsLength) {\n        break;\n      }\n      // We exceeds the current sum of the child colspans, the last columns colspan overlaps the \"columnsLength\" length.\n      if (currentLength > columnsLength) {\n        throw new Error('The last column settings cannot overlap the other header layers');\n      }\n    }\n    return headersSettingsChunks;\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(this, _dataLength);\n  }\n\n  /**\n   * Gets a total number of columns count.\n   *\n   * @returns {number}\n   */\n  getColumnsCount() {\n    return _classPrivateFieldGet(this, _dataLength) > 0 ? _classPrivateFieldGet(this, _data)[0].length : 0;\n  }\n\n  /**\n   * Clears the data.\n   */\n  clear() {\n    _classPrivateFieldSet(this, _data, []);\n    _classPrivateFieldSet(this, _dataLength, 0);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}