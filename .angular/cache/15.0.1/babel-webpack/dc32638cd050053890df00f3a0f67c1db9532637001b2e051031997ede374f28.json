{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.from-entries.js\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { arrayMap, arrayEach } from \"../../helpers/array.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { inherit, deepClone } from \"../../helpers/object.mjs\";\nimport { align } from \"../contextMenu/utils.mjs\";\nconst SHORTCUTS_GROUP = 'undoRedo';\nexport const PLUGIN_KEY = 'undoRedo';\n\n/**\n * @description\n * Handsontable UndoRedo plugin allows to undo and redo certain actions done in the table.\n *\n * __Note__, that not all actions are currently undo-able. The UndoRedo plugin is enabled by default.\n * @example\n * ```js\n * undo: true\n * ```\n * @class UndoRedo\n * @plugin UndoRedo\n * @param {Core} instance The Handsontable instance.\n */\nfunction UndoRedo(instance) {\n  const plugin = this;\n  this.instance = instance;\n  this.doneActions = [];\n  this.undoneActions = [];\n  this.ignoreNewActions = false;\n  this.enabled = false;\n  instance.addHook('afterChange', function (changes, source) {\n    const changesLen = changes && changes.length;\n    if (!changesLen) {\n      return;\n    }\n    const hasDifferences = changes.find(change => {\n      const [,, oldValue, newValue] = change;\n      return oldValue !== newValue;\n    });\n    if (!hasDifferences) {\n      return;\n    }\n    const wrappedAction = () => {\n      const clonedChanges = changes.reduce((arr, change) => {\n        arr.push([...change]);\n        return arr;\n      }, []);\n      arrayEach(clonedChanges, change => {\n        change[1] = instance.propToCol(change[1]);\n      });\n      const selected = changesLen > 1 ? this.getSelected() : [[clonedChanges[0][0], clonedChanges[0][1]]];\n      return new UndoRedo.ChangeAction(clonedChanges, selected);\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('afterCreateRow', (index, amount, source) => {\n    plugin.done(() => new UndoRedo.CreateRowAction(index, amount), source);\n  });\n  const getCellMetas = (fromRow, toRow, fromColumn, toColumn) => {\n    const genericKeys = ['visualRow', 'visualCol', 'row', 'col', 'prop'];\n    const genericKeysLength = genericKeys.length;\n    const cellMetas = [];\n    rangeEach(fromColumn, toColumn, columnIndex => {\n      rangeEach(fromRow, toRow, rowIndex => {\n        const cellMeta = instance.getCellMeta(rowIndex, columnIndex);\n        if (Object.keys(cellMeta).length !== genericKeysLength) {\n          const uniqueMeta = Object.fromEntries(Object.entries(cellMeta).filter(_ref => {\n            let [key] = _ref;\n            return genericKeys.includes(key) === false;\n          }));\n          cellMetas.push([cellMeta.visualRow, cellMeta.visualCol, uniqueMeta]);\n        }\n      });\n    });\n    return cellMetas;\n  };\n  instance.addHook('beforeRemoveRow', (index, amount, logicRows, source) => {\n    const wrappedAction = () => {\n      const physicalRowIndex = instance.toPhysicalRow(index);\n      const lastRowIndex = physicalRowIndex + amount - 1;\n      const removedData = deepClone(plugin.instance.getSourceData(physicalRowIndex, 0, physicalRowIndex + amount - 1, plugin.instance.countSourceCols() - 1));\n      return new UndoRedo.RemoveRowAction(physicalRowIndex, removedData, instance.getSettings().fixedRowsBottom, instance.getSettings().fixedRowsTop, instance.rowIndexMapper.getIndexesSequence(), getCellMetas(physicalRowIndex, lastRowIndex, 0, instance.countCols() - 1));\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('afterCreateCol', (index, amount, source) => {\n    plugin.done(() => new UndoRedo.CreateColumnAction(index, amount), source);\n  });\n  instance.addHook('beforeRemoveCol', (index, amount, logicColumns, source) => {\n    const wrappedAction = () => {\n      const originalData = plugin.instance.getSourceDataArray();\n      const columnIndex = (plugin.instance.countCols() + index) % plugin.instance.countCols();\n      const lastColumnIndex = columnIndex + amount - 1;\n      const removedData = [];\n      const headers = [];\n      const indexes = [];\n      rangeEach(originalData.length - 1, i => {\n        const column = [];\n        const origRow = originalData[i];\n        rangeEach(columnIndex, lastColumnIndex, j => {\n          column.push(origRow[instance.toPhysicalColumn(j)]);\n        });\n        removedData.push(column);\n      });\n      rangeEach(amount - 1, i => {\n        indexes.push(instance.toPhysicalColumn(columnIndex + i));\n      });\n      if (Array.isArray(instance.getSettings().colHeaders)) {\n        rangeEach(amount - 1, i => {\n          headers.push(instance.getSettings().colHeaders[instance.toPhysicalColumn(columnIndex + i)] || null);\n        });\n      }\n      const columnsMap = instance.columnIndexMapper.getIndexesSequence();\n      const rowsMap = instance.rowIndexMapper.getIndexesSequence();\n      return new UndoRedo.RemoveColumnAction(columnIndex, indexes, removedData, headers, columnsMap, rowsMap, instance.getSettings().fixedColumnsStart, getCellMetas(0, instance.countRows(), columnIndex, lastColumnIndex));\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('beforeCellAlignment', (stateBefore, range, type, alignment) => {\n    plugin.done(() => new UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment));\n  });\n  instance.addHook('beforeFilter', conditionsStack => {\n    plugin.done(() => new UndoRedo.FiltersAction(conditionsStack));\n  });\n  instance.addHook('beforeRowMove', (rows, finalIndex) => {\n    if (rows === false) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.RowMoveAction(rows, finalIndex));\n  });\n  instance.addHook('beforeMergeCells', (cellRange, auto) => {\n    if (auto) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.MergeCellsAction(instance, cellRange));\n  });\n  instance.addHook('afterUnmergeCells', (cellRange, auto) => {\n    if (auto) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.UnmergeCellsAction(instance, cellRange));\n  });\n\n  // TODO: Why this callback is needed? One test doesn't pass after calling method right after plugin creation (outside the callback).\n  instance.addHook('afterInit', () => {\n    plugin.init();\n  });\n}\n\n/**\n * Stash information about performed actions.\n *\n * @function done\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @param {Function} wrappedAction The action descriptor wrapped in a closure.\n * @param {string} [source] Source of the action. It is defined just for more general actions (not related to plugins).\n */\nUndoRedo.prototype.done = function (wrappedAction, source) {\n  if (this.ignoreNewActions) {\n    return;\n  }\n  const isBlockedByDefault = source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n  if (isBlockedByDefault) {\n    return;\n  }\n  const doneActionsCopy = this.doneActions.slice();\n  const continueAction = this.instance.runHooks('beforeUndoStackChange', doneActionsCopy, source);\n  if (continueAction === false) {\n    return;\n  }\n  const newAction = wrappedAction();\n  const undoneActionsCopy = this.undoneActions.slice();\n  this.doneActions.push(newAction);\n  this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n  this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n  this.undoneActions.length = 0;\n  this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n};\n\n/**\n * Undo the last action performed to the table.\n *\n * @function undo\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @fires Hooks#beforeUndo\n * @fires Hooks#afterUndo\n */\nUndoRedo.prototype.undo = function () {\n  if (this.isUndoAvailable()) {\n    const doneActionsCopy = this.doneActions.slice();\n    this.instance.runHooks('beforeUndoStackChange', doneActionsCopy);\n    const action = this.doneActions.pop();\n    this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n    const actionClone = deepClone(action);\n    const continueAction = this.instance.runHooks('beforeUndo', actionClone);\n    if (continueAction === false) {\n      return;\n    }\n    this.ignoreNewActions = true;\n    const that = this;\n    const undoneActionsCopy = this.undoneActions.slice();\n    this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n    action.undo(this.instance, () => {\n      that.ignoreNewActions = false;\n      that.undoneActions.push(action);\n    });\n    this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n    this.instance.runHooks('afterUndo', actionClone);\n  }\n};\n\n/**\n * Redo the previous action performed to the table (used to reverse an undo).\n *\n * @function redo\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @fires Hooks#beforeRedo\n * @fires Hooks#afterRedo\n */\nUndoRedo.prototype.redo = function () {\n  if (this.isRedoAvailable()) {\n    const undoneActionsCopy = this.undoneActions.slice();\n    this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n    const action = this.undoneActions.pop();\n    this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n    const actionClone = deepClone(action);\n    const continueAction = this.instance.runHooks('beforeRedo', actionClone);\n    if (continueAction === false) {\n      return;\n    }\n    this.ignoreNewActions = true;\n    const that = this;\n    const doneActionsCopy = this.doneActions.slice();\n    this.instance.runHooks('beforeUndoStackChange', doneActionsCopy);\n    action.redo(this.instance, () => {\n      that.ignoreNewActions = false;\n      that.doneActions.push(action);\n    });\n    this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n    this.instance.runHooks('afterRedo', actionClone);\n  }\n};\n\n/**\n * Checks if undo action is available.\n *\n * @function isUndoAvailable\n * @memberof UndoRedo#\n * @returns {boolean} Return `true` if undo can be performed, `false` otherwise.\n */\nUndoRedo.prototype.isUndoAvailable = function () {\n  return this.doneActions.length > 0;\n};\n\n/**\n * Checks if redo action is available.\n *\n * @function isRedoAvailable\n * @memberof UndoRedo#\n * @returns {boolean} Return `true` if redo can be performed, `false` otherwise.\n */\nUndoRedo.prototype.isRedoAvailable = function () {\n  return this.undoneActions.length > 0;\n};\n\n/**\n * Clears undo history.\n *\n * @function clear\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.clear = function () {\n  this.doneActions.length = 0;\n  this.undoneActions.length = 0;\n};\n\n/**\n * Checks if the plugin is enabled.\n *\n * @function isEnabled\n * @memberof UndoRedo#\n * @returns {boolean}\n */\nUndoRedo.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\n * Enables the plugin.\n *\n * @function enable\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.enable = function () {\n  if (this.isEnabled()) {\n    return;\n  }\n  const hot = this.instance;\n  this.enabled = true;\n  exposeUndoRedoMethods(hot);\n  this.registerShortcuts();\n  hot.addHook('afterChange', onAfterChange);\n};\n\n/**\n * Disables the plugin.\n *\n * @function disable\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.disable = function () {\n  if (!this.isEnabled()) {\n    return;\n  }\n  const hot = this.instance;\n  this.enabled = false;\n  removeExposedUndoRedoMethods(hot);\n  this.unregisterShortcuts();\n  hot.removeHook('afterChange', onAfterChange);\n};\n\n/**\n * Destroys the instance.\n *\n * @function destroy\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.destroy = function () {\n  this.clear();\n  this.instance = null;\n  this.doneActions = null;\n  this.undoneActions = null;\n};\nUndoRedo.Action = function () {};\nUndoRedo.Action.prototype.undo = function () {};\nUndoRedo.Action.prototype.redo = function () {};\n\n/**\n * Change action.\n *\n * @private\n * @param {Array} changes 2D array containing information about each of the edited cells.\n * @param {number[]} selected The cell selection.\n */\nUndoRedo.ChangeAction = function (changes, selected) {\n  this.changes = changes;\n  this.selected = selected;\n  this.actionType = 'change';\n};\ninherit(UndoRedo.ChangeAction, UndoRedo.Action);\nUndoRedo.ChangeAction.prototype.undo = function (instance, undoneCallback) {\n  const data = deepClone(this.changes);\n  const emptyRowsAtTheEnd = instance.countEmptyRows(true);\n  const emptyColsAtTheEnd = instance.countEmptyCols(true);\n  for (let i = 0, len = data.length; i < len; i++) {\n    data[i].splice(3, 1);\n  }\n  instance.addHookOnce('afterChange', undoneCallback);\n  instance.setDataAtCell(data, null, null, 'UndoRedo.undo');\n  for (let i = 0, len = data.length; i < len; i++) {\n    const [row, column] = data[i];\n    if (instance.getSettings().minSpareRows && row + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd === instance.getSettings().minSpareRows) {\n      instance.alter('remove_row', parseInt(row + 1, 10), instance.getSettings().minSpareRows);\n      instance.undoRedo.doneActions.pop();\n    }\n    if (instance.getSettings().minSpareCols && column + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd === instance.getSettings().minSpareCols) {\n      instance.alter('remove_col', parseInt(column + 1, 10), instance.getSettings().minSpareCols);\n      instance.undoRedo.doneActions.pop();\n    }\n  }\n  const selectedLast = instance.getSelectedLast();\n  if (selectedLast !== undefined) {\n    const [changedRow, changedColumn] = data[0];\n    const [selectedRow, selectedColumn] = selectedLast;\n    const firstFullyVisibleRow = instance.view.getFirstFullyVisibleRow();\n    const firstFullyVisibleColumn = instance.view.getFirstFullyVisibleColumn();\n    const isInVerticalViewPort = changedRow >= firstFullyVisibleRow;\n    const isInHorizontalViewPort = changedColumn >= firstFullyVisibleColumn;\n    const isInViewport = isInVerticalViewPort && isInHorizontalViewPort;\n    const isChangedSelection = selectedRow !== changedRow || selectedColumn !== changedColumn;\n\n    // Performing scroll only when selection has been changed right after editing a cell.\n    if (isInViewport === false && isChangedSelection === true) {\n      const scrollConfig = {\n        row: changedRow,\n        col: changedColumn\n      };\n      if (isInVerticalViewPort === false) {\n        scrollConfig.verticalSnap = 'top';\n      }\n      if (isInHorizontalViewPort === false) {\n        scrollConfig.horizontalSnap = 'start';\n      }\n      instance.scrollViewportTo(scrollConfig);\n    }\n  }\n  instance.selectCells(this.selected, false, false);\n};\nUndoRedo.ChangeAction.prototype.redo = function (instance, onFinishCallback) {\n  const data = deepClone(this.changes);\n  for (let i = 0, len = data.length; i < len; i++) {\n    data[i].splice(2, 1);\n  }\n  instance.addHookOnce('afterChange', onFinishCallback);\n  instance.setDataAtCell(data, null, null, 'UndoRedo.redo');\n  if (this.selected) {\n    instance.selectCells(this.selected, false, false);\n  }\n};\n\n/**\n * Create row action.\n *\n * @private\n * @param {number} index The visual row index.\n * @param {number} amount The number of created rows.\n */\nUndoRedo.CreateRowAction = function (index, amount) {\n  this.index = index;\n  this.amount = amount;\n  this.actionType = 'insert_row';\n};\ninherit(UndoRedo.CreateRowAction, UndoRedo.Action);\nUndoRedo.CreateRowAction.prototype.undo = function (instance, undoneCallback) {\n  const rowCount = instance.countRows();\n  const minSpareRows = instance.getSettings().minSpareRows;\n  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {\n    this.index -= minSpareRows; // work around the situation where the needed row was removed due to an 'undo' of a made change\n  }\n\n  instance.addHookOnce('afterRemoveRow', undoneCallback);\n  instance.alter('remove_row', this.index, this.amount, 'UndoRedo.undo');\n};\nUndoRedo.CreateRowAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterCreateRow', redoneCallback);\n  instance.alter('insert_row_above', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Remove row action.\n *\n * @private\n * @param {number} index The visual row index.\n * @param {Array} data The removed data.\n * @param {number} fixedRowsBottom Number of fixed rows on the bottom. Remove row action change it sometimes.\n * @param {number} fixedRowsTop Number of fixed rows on the top. Remove row action change it sometimes.\n * @param {Array} rowIndexesSequence Row index sequence taken from the row index mapper.\n * @param {Array} removedCellMetas List of removed cell metas.\n */\nUndoRedo.RemoveRowAction = function (index, data, fixedRowsBottom, fixedRowsTop, rowIndexesSequence, removedCellMetas) {\n  this.index = index;\n  this.data = data;\n  this.actionType = 'remove_row';\n  this.fixedRowsBottom = fixedRowsBottom;\n  this.fixedRowsTop = fixedRowsTop;\n  this.rowIndexesSequence = rowIndexesSequence;\n  this.removedCellMetas = removedCellMetas;\n};\ninherit(UndoRedo.RemoveRowAction, UndoRedo.Action);\nUndoRedo.RemoveRowAction.prototype.undo = function (instance, undoneCallback) {\n  const settings = instance.getSettings();\n  const changes = [];\n\n  // Changing by the reference as `updateSettings` doesn't work the best.\n  settings.fixedRowsBottom = this.fixedRowsBottom;\n  settings.fixedRowsTop = this.fixedRowsTop;\n\n  // Prepare the change list to fill the source data.\n  this.data.forEach((dataRow, rowIndexDelta) => {\n    Object.keys(dataRow).forEach(columnProp => {\n      const columnIndex = parseInt(columnProp, 10);\n      changes.push([this.index + rowIndexDelta, isNaN(columnIndex) ? columnProp : columnIndex, dataRow[columnProp]]);\n    });\n  });\n  instance.alter('insert_row_above', this.index, this.data.length, 'UndoRedo.undo');\n  this.removedCellMetas.forEach(_ref2 => {\n    let [rowIndex, columnIndex, cellMeta] = _ref2;\n    instance.setCellMetaObject(rowIndex, columnIndex, cellMeta);\n  });\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.setSourceDataAtCell(changes, null, null, 'UndoRedo.undo');\n  instance.rowIndexMapper.setIndexesSequence(this.rowIndexesSequence);\n};\nUndoRedo.RemoveRowAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterRemoveRow', redoneCallback);\n  instance.alter('remove_row', this.index, this.data.length, 'UndoRedo.redo');\n};\n\n/**\n * Create column action.\n *\n * @private\n * @param {number} index The visual column index.\n * @param {number} amount The number of created columns.\n */\nUndoRedo.CreateColumnAction = function (index, amount) {\n  this.index = index;\n  this.amount = amount;\n  this.actionType = 'insert_col';\n};\ninherit(UndoRedo.CreateColumnAction, UndoRedo.Action);\nUndoRedo.CreateColumnAction.prototype.undo = function (instance, undoneCallback) {\n  instance.addHookOnce('afterRemoveCol', undoneCallback);\n  instance.alter('remove_col', this.index, this.amount, 'UndoRedo.undo');\n};\nUndoRedo.CreateColumnAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterCreateCol', redoneCallback);\n  instance.alter('insert_col_start', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Remove column action.\n *\n * @private\n * @param {number} index The visual column index.\n * @param {number[]} indexes The visual column indexes.\n * @param {Array} data The removed data.\n * @param {Array} headers The header values.\n * @param {number[]} columnPositions The column position.\n * @param {number[]} rowPositions The row position.\n * @param {number} fixedColumnsStart Number of fixed columns on the left. Remove column action change it sometimes.\n * @param {Array} removedCellMetas List of removed cell metas.\n */\nUndoRedo.RemoveColumnAction = function (index, indexes, data, headers, columnPositions, rowPositions, fixedColumnsStart, removedCellMetas) {\n  // eslint-disable-line max-len\n  this.index = index;\n  this.indexes = indexes;\n  this.data = data;\n  this.amount = this.data[0].length;\n  this.headers = headers;\n  this.columnPositions = columnPositions.slice(0);\n  this.rowPositions = rowPositions.slice(0);\n  this.actionType = 'remove_col';\n  this.fixedColumnsStart = fixedColumnsStart;\n  this.removedCellMetas = removedCellMetas;\n};\ninherit(UndoRedo.RemoveColumnAction, UndoRedo.Action);\nUndoRedo.RemoveColumnAction.prototype.undo = function (instance, undoneCallback) {\n  const settings = instance.getSettings();\n\n  // Changing by the reference as `updateSettings` doesn't work the best.\n  settings.fixedColumnsStart = this.fixedColumnsStart;\n  const ascendingIndexes = this.indexes.slice(0).sort();\n  const sortByIndexes = (elem, j, arr) => arr[this.indexes.indexOf(ascendingIndexes[j])];\n  const removedDataLength = this.data.length;\n  const sortedData = [];\n  for (let rowIndex = 0; rowIndex < removedDataLength; rowIndex++) {\n    sortedData.push(arrayMap(this.data[rowIndex], sortByIndexes));\n  }\n  const sortedHeaders = arrayMap(this.headers, sortByIndexes);\n  const changes = [];\n  instance.alter('insert_col_start', this.indexes[0], this.indexes.length, 'UndoRedo.undo');\n  arrayEach(instance.getSourceDataArray(), (rowData, rowIndex) => {\n    arrayEach(ascendingIndexes, (changedIndex, contiquesIndex) => {\n      rowData[changedIndex] = sortedData[rowIndex][contiquesIndex];\n      changes.push([rowIndex, changedIndex, rowData[changedIndex]]);\n    });\n  });\n  instance.setSourceDataAtCell(changes, undefined, undefined, 'UndoRedo.undo');\n  if (typeof this.headers !== 'undefined') {\n    arrayEach(sortedHeaders, (headerData, columnIndex) => {\n      instance.getSettings().colHeaders[ascendingIndexes[columnIndex]] = headerData;\n    });\n  }\n  this.removedCellMetas.forEach(_ref3 => {\n    let [rowIndex, columnIndex, cellMeta] = _ref3;\n    instance.setCellMetaObject(rowIndex, columnIndex, cellMeta);\n  });\n  instance.batchExecution(() => {\n    // Restore row sequence in a case when all columns are removed. the original\n    // row sequence is lost in that case.\n    instance.rowIndexMapper.setIndexesSequence(this.rowPositions);\n    instance.columnIndexMapper.setIndexesSequence(this.columnPositions);\n  }, true);\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\nUndoRedo.RemoveColumnAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterRemoveCol', redoneCallback);\n  instance.alter('remove_col', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Cell alignment action.\n *\n * @private\n * @param {Array} stateBefore The previous state.\n * @param {object} range The cell range.\n * @param {string} type The type of the alignment (\"top\", \"left\", \"bottom\" or \"right\").\n * @param {string} alignment The alignment CSS class.\n */\nUndoRedo.CellAlignmentAction = function (stateBefore, range, type, alignment) {\n  this.stateBefore = stateBefore;\n  this.range = range;\n  this.type = type;\n  this.alignment = alignment;\n};\nUndoRedo.CellAlignmentAction.prototype.undo = function (instance, undoneCallback) {\n  arrayEach(this.range, range => {\n    range.forAll((row, col) => {\n      // Alignment classes should only collected within cell ranges. We skip header coordinates.\n      if (row >= 0 && col >= 0) {\n        instance.setCellMeta(row, col, 'className', this.stateBefore[row][col] || ' htLeft');\n      }\n    });\n  });\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\nUndoRedo.CellAlignmentAction.prototype.redo = function (instance, undoneCallback) {\n  align(this.range, this.type, this.alignment, (row, col) => instance.getCellMeta(row, col), (row, col, key, value) => instance.setCellMeta(row, col, key, value));\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\n\n/**\n * Filters action.\n *\n * @private\n * @param {Array} conditionsStack An array of the filter condition.\n */\nUndoRedo.FiltersAction = function (conditionsStack) {\n  this.conditionsStack = conditionsStack;\n  this.actionType = 'filter';\n};\ninherit(UndoRedo.FiltersAction, UndoRedo.Action);\nUndoRedo.FiltersAction.prototype.undo = function (instance, undoneCallback) {\n  const filters = instance.getPlugin('filters');\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  filters.conditionCollection.importAllConditions(this.conditionsStack.slice(0, this.conditionsStack.length - 1));\n  filters.filter();\n};\nUndoRedo.FiltersAction.prototype.redo = function (instance, redoneCallback) {\n  const filters = instance.getPlugin('filters');\n  instance.addHookOnce('afterViewRender', redoneCallback);\n  filters.conditionCollection.importAllConditions(this.conditionsStack);\n  filters.filter();\n};\n\n/**\n * Merge Cells action.\n *\n * @util\n */\nclass MergeCellsAction extends UndoRedo.Action {\n  constructor(instance, cellRange) {\n    super();\n    this.cellRange = cellRange;\n    const topStartCorner = this.cellRange.getTopStartCorner();\n    const bottomEndCorner = this.cellRange.getBottomEndCorner();\n    this.rangeData = instance.getData(topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col);\n  }\n  undo(instance, undoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', undoneCallback);\n    mergeCellsPlugin.unmergeRange(this.cellRange, true);\n    const topStartCorner = this.cellRange.getTopStartCorner();\n    instance.populateFromArray(topStartCorner.row, topStartCorner.col, this.rangeData, undefined, undefined, 'MergeCells');\n  }\n  redo(instance, redoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', redoneCallback);\n    mergeCellsPlugin.mergeRange(this.cellRange);\n  }\n}\nUndoRedo.MergeCellsAction = MergeCellsAction;\n\n/**\n * Unmerge Cells action.\n *\n * @util\n */\nclass UnmergeCellsAction extends UndoRedo.Action {\n  constructor(instance, cellRange) {\n    super();\n    this.cellRange = cellRange;\n  }\n  undo(instance, undoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', undoneCallback);\n    mergeCellsPlugin.mergeRange(this.cellRange, true);\n  }\n  redo(instance, redoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', redoneCallback);\n    mergeCellsPlugin.unmergeRange(this.cellRange, true);\n    instance.render();\n  }\n}\nUndoRedo.UnmergeCellsAction = UnmergeCellsAction;\n\n/**\n * ManualRowMove action.\n *\n * @TODO removeRow undo should works on logical index\n * @private\n * @param {number[]} rows An array with moved rows.\n * @param {number} finalIndex The destination index.\n */\nUndoRedo.RowMoveAction = function (rows, finalIndex) {\n  this.rows = rows.slice();\n  this.finalIndex = finalIndex;\n  this.actionType = 'row_move';\n};\ninherit(UndoRedo.RowMoveAction, UndoRedo.Action);\nUndoRedo.RowMoveAction.prototype.undo = function (instance, undoneCallback) {\n  const manualRowMove = instance.getPlugin('manualRowMove');\n  const copyOfRows = [].concat(this.rows);\n  const rowsMovedUp = copyOfRows.filter(a => a > this.finalIndex);\n  const rowsMovedDown = copyOfRows.filter(a => a <= this.finalIndex);\n  const allMovedRows = rowsMovedUp.sort((a, b) => b - a).concat(rowsMovedDown.sort((a, b) => a - b));\n  instance.addHookOnce('afterViewRender', undoneCallback);\n\n  // Moving rows from those with higher indexes to those with lower indexes when action was performed from bottom to top\n  // Moving rows from those with lower indexes to those with higher indexes when action was performed from top to bottom\n  for (let i = 0; i < allMovedRows.length; i += 1) {\n    const newPhysicalRow = instance.toVisualRow(allMovedRows[i]);\n    manualRowMove.moveRow(newPhysicalRow, allMovedRows[i]);\n  }\n  instance.render();\n  instance.deselectCell();\n  instance.selectRows(this.rows[0], this.rows[0] + this.rows.length - 1);\n};\nUndoRedo.RowMoveAction.prototype.redo = function (instance, redoneCallback) {\n  const manualRowMove = instance.getPlugin('manualRowMove');\n  instance.addHookOnce('afterViewRender', redoneCallback);\n  manualRowMove.moveRows(this.rows.slice(), this.finalIndex);\n  instance.render();\n  instance.deselectCell();\n  instance.selectRows(this.finalIndex, this.finalIndex + this.rows.length - 1);\n};\n\n/**\n * Enabling and disabling plugin and attaching its to an instance.\n *\n * @private\n */\nUndoRedo.prototype.init = function () {\n  const settings = this.instance.getSettings().undo;\n  const pluginEnabled = typeof settings === 'undefined' || settings;\n  if (!this.instance.undoRedo) {\n    this.instance.undoRedo = this;\n  }\n  if (pluginEnabled) {\n    this.instance.undoRedo.enable();\n  } else {\n    this.instance.undoRedo.disable();\n  }\n};\n\n/**\n * Registers shortcuts responsible for performing undo/redo.\n *\n * @private\n */\nUndoRedo.prototype.registerShortcuts = function () {\n  const shortcutManager = this.instance.getShortcutManager();\n  const gridContext = shortcutManager.getContext('grid');\n  const runOnlyIf = event => {\n    return !event.altKey; // right ALT in some systems triggers ALT+CTR\n  };\n\n  const config = {\n    runOnlyIf,\n    group: SHORTCUTS_GROUP\n  };\n  gridContext.addShortcuts([{\n    keys: [['Control/Meta', 'z']],\n    callback: () => {\n      this.undo();\n    }\n  }, {\n    keys: [['Control/Meta', 'y'], ['Control/Meta', 'Shift', 'z']],\n    callback: () => {\n      this.redo();\n    }\n  }], config);\n};\n\n/**\n * Unregister shortcuts responsible for performing undo/redo.\n *\n * @private\n */\nUndoRedo.prototype.unregisterShortcuts = function () {\n  const shortcutManager = this.instance.getShortcutManager();\n  const gridContext = shortcutManager.getContext('grid');\n  gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n};\n\n/**\n * @param {Array} changes 2D array containing information about each of the edited cells.\n * @param {string} source String that identifies source of hook call.\n * @returns {boolean}\n */\nfunction onAfterChange(changes, source) {\n  const instance = this;\n  if (source === 'loadData') {\n    return instance.undoRedo.clear();\n  }\n}\n\n/**\n * @param {Core} instance The Handsontable instance.\n */\nfunction exposeUndoRedoMethods(instance) {\n  /**\n   * {@link UndoRedo#undo}.\n   *\n   * @alias undo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.undo = function () {\n    return instance.undoRedo.undo();\n  };\n\n  /**\n   * {@link UndoRedo#redo}.\n   *\n   * @alias redo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.redo = function () {\n    return instance.undoRedo.redo();\n  };\n\n  /**\n   * {@link UndoRedo#isUndoAvailable}.\n   *\n   * @alias isUndoAvailable\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.isUndoAvailable = function () {\n    return instance.undoRedo.isUndoAvailable();\n  };\n\n  /**\n   * {@link UndoRedo#isRedoAvailable}.\n   *\n   * @alias isRedoAvailable\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.isRedoAvailable = function () {\n    return instance.undoRedo.isRedoAvailable();\n  };\n\n  /**\n   * {@link UndoRedo#clear}.\n   *\n   * @alias clearUndo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.clearUndo = function () {\n    return instance.undoRedo.clear();\n  };\n}\n\n/**\n * @param {Core} instance The Handsontable instance.\n */\nfunction removeExposedUndoRedoMethods(instance) {\n  delete instance.undo;\n  delete instance.redo;\n  delete instance.isUndoAvailable;\n  delete instance.isRedoAvailable;\n  delete instance.clearUndo;\n}\nconst hook = Hooks.getSingleton();\nhook.add('afterUpdateSettings', function () {\n  var _this$getPlugin;\n  (_this$getPlugin = this.getPlugin('undoRedo')) === null || _this$getPlugin === void 0 || _this$getPlugin.init();\n});\nhook.register('beforeUndo');\nhook.register('afterUndo');\nhook.register('beforeRedo');\nhook.register('afterRedo');\nUndoRedo.PLUGIN_KEY = PLUGIN_KEY;\nUndoRedo.SETTING_KEYS = true;\nexport default UndoRedo;","map":{"version":3,"names":["Hooks","arrayMap","arrayEach","rangeEach","inherit","deepClone","align","SHORTCUTS_GROUP","PLUGIN_KEY","UndoRedo","instance","plugin","doneActions","undoneActions","ignoreNewActions","enabled","addHook","changes","source","changesLen","length","hasDifferences","find","change","oldValue","newValue","wrappedAction","clonedChanges","reduce","arr","push","propToCol","selected","getSelected","ChangeAction","done","index","amount","CreateRowAction","getCellMetas","fromRow","toRow","fromColumn","toColumn","genericKeys","genericKeysLength","cellMetas","columnIndex","rowIndex","cellMeta","getCellMeta","Object","keys","uniqueMeta","fromEntries","entries","filter","_ref","key","includes","visualRow","visualCol","logicRows","physicalRowIndex","toPhysicalRow","lastRowIndex","removedData","getSourceData","countSourceCols","RemoveRowAction","getSettings","fixedRowsBottom","fixedRowsTop","rowIndexMapper","getIndexesSequence","countCols","CreateColumnAction","logicColumns","originalData","getSourceDataArray","lastColumnIndex","headers","indexes","i","column","origRow","j","toPhysicalColumn","Array","isArray","colHeaders","columnsMap","columnIndexMapper","rowsMap","RemoveColumnAction","fixedColumnsStart","countRows","stateBefore","range","type","alignment","CellAlignmentAction","conditionsStack","FiltersAction","rows","finalIndex","RowMoveAction","cellRange","auto","MergeCellsAction","UnmergeCellsAction","init","prototype","isBlockedByDefault","doneActionsCopy","slice","continueAction","runHooks","newAction","undoneActionsCopy","undo","isUndoAvailable","action","pop","actionClone","that","redo","isRedoAvailable","clear","isEnabled","enable","hot","exposeUndoRedoMethods","registerShortcuts","onAfterChange","disable","removeExposedUndoRedoMethods","unregisterShortcuts","removeHook","destroy","Action","actionType","undoneCallback","data","emptyRowsAtTheEnd","countEmptyRows","emptyColsAtTheEnd","countEmptyCols","len","splice","addHookOnce","setDataAtCell","row","minSpareRows","alter","parseInt","undoRedo","minSpareCols","selectedLast","getSelectedLast","undefined","changedRow","changedColumn","selectedRow","selectedColumn","firstFullyVisibleRow","view","getFirstFullyVisibleRow","firstFullyVisibleColumn","getFirstFullyVisibleColumn","isInVerticalViewPort","isInHorizontalViewPort","isInViewport","isChangedSelection","scrollConfig","col","verticalSnap","horizontalSnap","scrollViewportTo","selectCells","onFinishCallback","rowCount","redoneCallback","rowIndexesSequence","removedCellMetas","settings","forEach","dataRow","rowIndexDelta","columnProp","isNaN","_ref2","setCellMetaObject","setSourceDataAtCell","setIndexesSequence","columnPositions","rowPositions","ascendingIndexes","sort","sortByIndexes","elem","indexOf","removedDataLength","sortedData","sortedHeaders","rowData","changedIndex","contiquesIndex","headerData","_ref3","batchExecution","render","forAll","setCellMeta","value","filters","getPlugin","conditionCollection","importAllConditions","constructor","topStartCorner","getTopStartCorner","bottomEndCorner","getBottomEndCorner","rangeData","getData","mergeCellsPlugin","unmergeRange","populateFromArray","mergeRange","manualRowMove","copyOfRows","concat","rowsMovedUp","a","rowsMovedDown","allMovedRows","b","newPhysicalRow","toVisualRow","moveRow","deselectCell","selectRows","moveRows","pluginEnabled","shortcutManager","getShortcutManager","gridContext","getContext","runOnlyIf","event","altKey","config","group","addShortcuts","callback","removeShortcutsByGroup","clearUndo","hook","getSingleton","add","_this$getPlugin","register","SETTING_KEYS"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/undoRedo/undoRedo.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.from-entries.js\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { arrayMap, arrayEach } from \"../../helpers/array.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { inherit, deepClone } from \"../../helpers/object.mjs\";\nimport { align } from \"../contextMenu/utils.mjs\";\nconst SHORTCUTS_GROUP = 'undoRedo';\nexport const PLUGIN_KEY = 'undoRedo';\n\n/**\n * @description\n * Handsontable UndoRedo plugin allows to undo and redo certain actions done in the table.\n *\n * __Note__, that not all actions are currently undo-able. The UndoRedo plugin is enabled by default.\n * @example\n * ```js\n * undo: true\n * ```\n * @class UndoRedo\n * @plugin UndoRedo\n * @param {Core} instance The Handsontable instance.\n */\nfunction UndoRedo(instance) {\n  const plugin = this;\n  this.instance = instance;\n  this.doneActions = [];\n  this.undoneActions = [];\n  this.ignoreNewActions = false;\n  this.enabled = false;\n  instance.addHook('afterChange', function (changes, source) {\n    const changesLen = changes && changes.length;\n    if (!changesLen) {\n      return;\n    }\n    const hasDifferences = changes.find(change => {\n      const [,, oldValue, newValue] = change;\n      return oldValue !== newValue;\n    });\n    if (!hasDifferences) {\n      return;\n    }\n    const wrappedAction = () => {\n      const clonedChanges = changes.reduce((arr, change) => {\n        arr.push([...change]);\n        return arr;\n      }, []);\n      arrayEach(clonedChanges, change => {\n        change[1] = instance.propToCol(change[1]);\n      });\n      const selected = changesLen > 1 ? this.getSelected() : [[clonedChanges[0][0], clonedChanges[0][1]]];\n      return new UndoRedo.ChangeAction(clonedChanges, selected);\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('afterCreateRow', (index, amount, source) => {\n    plugin.done(() => new UndoRedo.CreateRowAction(index, amount), source);\n  });\n  const getCellMetas = (fromRow, toRow, fromColumn, toColumn) => {\n    const genericKeys = ['visualRow', 'visualCol', 'row', 'col', 'prop'];\n    const genericKeysLength = genericKeys.length;\n    const cellMetas = [];\n    rangeEach(fromColumn, toColumn, columnIndex => {\n      rangeEach(fromRow, toRow, rowIndex => {\n        const cellMeta = instance.getCellMeta(rowIndex, columnIndex);\n        if (Object.keys(cellMeta).length !== genericKeysLength) {\n          const uniqueMeta = Object.fromEntries(Object.entries(cellMeta).filter(_ref => {\n            let [key] = _ref;\n            return genericKeys.includes(key) === false;\n          }));\n          cellMetas.push([cellMeta.visualRow, cellMeta.visualCol, uniqueMeta]);\n        }\n      });\n    });\n    return cellMetas;\n  };\n  instance.addHook('beforeRemoveRow', (index, amount, logicRows, source) => {\n    const wrappedAction = () => {\n      const physicalRowIndex = instance.toPhysicalRow(index);\n      const lastRowIndex = physicalRowIndex + amount - 1;\n      const removedData = deepClone(plugin.instance.getSourceData(physicalRowIndex, 0, physicalRowIndex + amount - 1, plugin.instance.countSourceCols() - 1));\n      return new UndoRedo.RemoveRowAction(physicalRowIndex, removedData, instance.getSettings().fixedRowsBottom, instance.getSettings().fixedRowsTop, instance.rowIndexMapper.getIndexesSequence(), getCellMetas(physicalRowIndex, lastRowIndex, 0, instance.countCols() - 1));\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('afterCreateCol', (index, amount, source) => {\n    plugin.done(() => new UndoRedo.CreateColumnAction(index, amount), source);\n  });\n  instance.addHook('beforeRemoveCol', (index, amount, logicColumns, source) => {\n    const wrappedAction = () => {\n      const originalData = plugin.instance.getSourceDataArray();\n      const columnIndex = (plugin.instance.countCols() + index) % plugin.instance.countCols();\n      const lastColumnIndex = columnIndex + amount - 1;\n      const removedData = [];\n      const headers = [];\n      const indexes = [];\n      rangeEach(originalData.length - 1, i => {\n        const column = [];\n        const origRow = originalData[i];\n        rangeEach(columnIndex, lastColumnIndex, j => {\n          column.push(origRow[instance.toPhysicalColumn(j)]);\n        });\n        removedData.push(column);\n      });\n      rangeEach(amount - 1, i => {\n        indexes.push(instance.toPhysicalColumn(columnIndex + i));\n      });\n      if (Array.isArray(instance.getSettings().colHeaders)) {\n        rangeEach(amount - 1, i => {\n          headers.push(instance.getSettings().colHeaders[instance.toPhysicalColumn(columnIndex + i)] || null);\n        });\n      }\n      const columnsMap = instance.columnIndexMapper.getIndexesSequence();\n      const rowsMap = instance.rowIndexMapper.getIndexesSequence();\n      return new UndoRedo.RemoveColumnAction(columnIndex, indexes, removedData, headers, columnsMap, rowsMap, instance.getSettings().fixedColumnsStart, getCellMetas(0, instance.countRows(), columnIndex, lastColumnIndex));\n    };\n    plugin.done(wrappedAction, source);\n  });\n  instance.addHook('beforeCellAlignment', (stateBefore, range, type, alignment) => {\n    plugin.done(() => new UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment));\n  });\n  instance.addHook('beforeFilter', conditionsStack => {\n    plugin.done(() => new UndoRedo.FiltersAction(conditionsStack));\n  });\n  instance.addHook('beforeRowMove', (rows, finalIndex) => {\n    if (rows === false) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.RowMoveAction(rows, finalIndex));\n  });\n  instance.addHook('beforeMergeCells', (cellRange, auto) => {\n    if (auto) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.MergeCellsAction(instance, cellRange));\n  });\n  instance.addHook('afterUnmergeCells', (cellRange, auto) => {\n    if (auto) {\n      return;\n    }\n    plugin.done(() => new UndoRedo.UnmergeCellsAction(instance, cellRange));\n  });\n\n  // TODO: Why this callback is needed? One test doesn't pass after calling method right after plugin creation (outside the callback).\n  instance.addHook('afterInit', () => {\n    plugin.init();\n  });\n}\n\n/**\n * Stash information about performed actions.\n *\n * @function done\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @param {Function} wrappedAction The action descriptor wrapped in a closure.\n * @param {string} [source] Source of the action. It is defined just for more general actions (not related to plugins).\n */\nUndoRedo.prototype.done = function (wrappedAction, source) {\n  if (this.ignoreNewActions) {\n    return;\n  }\n  const isBlockedByDefault = source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n  if (isBlockedByDefault) {\n    return;\n  }\n  const doneActionsCopy = this.doneActions.slice();\n  const continueAction = this.instance.runHooks('beforeUndoStackChange', doneActionsCopy, source);\n  if (continueAction === false) {\n    return;\n  }\n  const newAction = wrappedAction();\n  const undoneActionsCopy = this.undoneActions.slice();\n  this.doneActions.push(newAction);\n  this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n  this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n  this.undoneActions.length = 0;\n  this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n};\n\n/**\n * Undo the last action performed to the table.\n *\n * @function undo\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @fires Hooks#beforeUndo\n * @fires Hooks#afterUndo\n */\nUndoRedo.prototype.undo = function () {\n  if (this.isUndoAvailable()) {\n    const doneActionsCopy = this.doneActions.slice();\n    this.instance.runHooks('beforeUndoStackChange', doneActionsCopy);\n    const action = this.doneActions.pop();\n    this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n    const actionClone = deepClone(action);\n    const continueAction = this.instance.runHooks('beforeUndo', actionClone);\n    if (continueAction === false) {\n      return;\n    }\n    this.ignoreNewActions = true;\n    const that = this;\n    const undoneActionsCopy = this.undoneActions.slice();\n    this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n    action.undo(this.instance, () => {\n      that.ignoreNewActions = false;\n      that.undoneActions.push(action);\n    });\n    this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n    this.instance.runHooks('afterUndo', actionClone);\n  }\n};\n\n/**\n * Redo the previous action performed to the table (used to reverse an undo).\n *\n * @function redo\n * @memberof UndoRedo#\n * @fires Hooks#beforeUndoStackChange\n * @fires Hooks#afterUndoStackChange\n * @fires Hooks#beforeRedoStackChange\n * @fires Hooks#afterRedoStackChange\n * @fires Hooks#beforeRedo\n * @fires Hooks#afterRedo\n */\nUndoRedo.prototype.redo = function () {\n  if (this.isRedoAvailable()) {\n    const undoneActionsCopy = this.undoneActions.slice();\n    this.instance.runHooks('beforeRedoStackChange', undoneActionsCopy);\n    const action = this.undoneActions.pop();\n    this.instance.runHooks('afterRedoStackChange', undoneActionsCopy, this.undoneActions.slice());\n    const actionClone = deepClone(action);\n    const continueAction = this.instance.runHooks('beforeRedo', actionClone);\n    if (continueAction === false) {\n      return;\n    }\n    this.ignoreNewActions = true;\n    const that = this;\n    const doneActionsCopy = this.doneActions.slice();\n    this.instance.runHooks('beforeUndoStackChange', doneActionsCopy);\n    action.redo(this.instance, () => {\n      that.ignoreNewActions = false;\n      that.doneActions.push(action);\n    });\n    this.instance.runHooks('afterUndoStackChange', doneActionsCopy, this.doneActions.slice());\n    this.instance.runHooks('afterRedo', actionClone);\n  }\n};\n\n/**\n * Checks if undo action is available.\n *\n * @function isUndoAvailable\n * @memberof UndoRedo#\n * @returns {boolean} Return `true` if undo can be performed, `false` otherwise.\n */\nUndoRedo.prototype.isUndoAvailable = function () {\n  return this.doneActions.length > 0;\n};\n\n/**\n * Checks if redo action is available.\n *\n * @function isRedoAvailable\n * @memberof UndoRedo#\n * @returns {boolean} Return `true` if redo can be performed, `false` otherwise.\n */\nUndoRedo.prototype.isRedoAvailable = function () {\n  return this.undoneActions.length > 0;\n};\n\n/**\n * Clears undo history.\n *\n * @function clear\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.clear = function () {\n  this.doneActions.length = 0;\n  this.undoneActions.length = 0;\n};\n\n/**\n * Checks if the plugin is enabled.\n *\n * @function isEnabled\n * @memberof UndoRedo#\n * @returns {boolean}\n */\nUndoRedo.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\n * Enables the plugin.\n *\n * @function enable\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.enable = function () {\n  if (this.isEnabled()) {\n    return;\n  }\n  const hot = this.instance;\n  this.enabled = true;\n  exposeUndoRedoMethods(hot);\n  this.registerShortcuts();\n  hot.addHook('afterChange', onAfterChange);\n};\n\n/**\n * Disables the plugin.\n *\n * @function disable\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.disable = function () {\n  if (!this.isEnabled()) {\n    return;\n  }\n  const hot = this.instance;\n  this.enabled = false;\n  removeExposedUndoRedoMethods(hot);\n  this.unregisterShortcuts();\n  hot.removeHook('afterChange', onAfterChange);\n};\n\n/**\n * Destroys the instance.\n *\n * @function destroy\n * @memberof UndoRedo#\n */\nUndoRedo.prototype.destroy = function () {\n  this.clear();\n  this.instance = null;\n  this.doneActions = null;\n  this.undoneActions = null;\n};\nUndoRedo.Action = function () {};\nUndoRedo.Action.prototype.undo = function () {};\nUndoRedo.Action.prototype.redo = function () {};\n\n/**\n * Change action.\n *\n * @private\n * @param {Array} changes 2D array containing information about each of the edited cells.\n * @param {number[]} selected The cell selection.\n */\nUndoRedo.ChangeAction = function (changes, selected) {\n  this.changes = changes;\n  this.selected = selected;\n  this.actionType = 'change';\n};\ninherit(UndoRedo.ChangeAction, UndoRedo.Action);\nUndoRedo.ChangeAction.prototype.undo = function (instance, undoneCallback) {\n  const data = deepClone(this.changes);\n  const emptyRowsAtTheEnd = instance.countEmptyRows(true);\n  const emptyColsAtTheEnd = instance.countEmptyCols(true);\n  for (let i = 0, len = data.length; i < len; i++) {\n    data[i].splice(3, 1);\n  }\n  instance.addHookOnce('afterChange', undoneCallback);\n  instance.setDataAtCell(data, null, null, 'UndoRedo.undo');\n  for (let i = 0, len = data.length; i < len; i++) {\n    const [row, column] = data[i];\n    if (instance.getSettings().minSpareRows && row + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd === instance.getSettings().minSpareRows) {\n      instance.alter('remove_row', parseInt(row + 1, 10), instance.getSettings().minSpareRows);\n      instance.undoRedo.doneActions.pop();\n    }\n    if (instance.getSettings().minSpareCols && column + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd === instance.getSettings().minSpareCols) {\n      instance.alter('remove_col', parseInt(column + 1, 10), instance.getSettings().minSpareCols);\n      instance.undoRedo.doneActions.pop();\n    }\n  }\n  const selectedLast = instance.getSelectedLast();\n  if (selectedLast !== undefined) {\n    const [changedRow, changedColumn] = data[0];\n    const [selectedRow, selectedColumn] = selectedLast;\n    const firstFullyVisibleRow = instance.view.getFirstFullyVisibleRow();\n    const firstFullyVisibleColumn = instance.view.getFirstFullyVisibleColumn();\n    const isInVerticalViewPort = changedRow >= firstFullyVisibleRow;\n    const isInHorizontalViewPort = changedColumn >= firstFullyVisibleColumn;\n    const isInViewport = isInVerticalViewPort && isInHorizontalViewPort;\n    const isChangedSelection = selectedRow !== changedRow || selectedColumn !== changedColumn;\n\n    // Performing scroll only when selection has been changed right after editing a cell.\n    if (isInViewport === false && isChangedSelection === true) {\n      const scrollConfig = {\n        row: changedRow,\n        col: changedColumn\n      };\n      if (isInVerticalViewPort === false) {\n        scrollConfig.verticalSnap = 'top';\n      }\n      if (isInHorizontalViewPort === false) {\n        scrollConfig.horizontalSnap = 'start';\n      }\n      instance.scrollViewportTo(scrollConfig);\n    }\n  }\n  instance.selectCells(this.selected, false, false);\n};\nUndoRedo.ChangeAction.prototype.redo = function (instance, onFinishCallback) {\n  const data = deepClone(this.changes);\n  for (let i = 0, len = data.length; i < len; i++) {\n    data[i].splice(2, 1);\n  }\n  instance.addHookOnce('afterChange', onFinishCallback);\n  instance.setDataAtCell(data, null, null, 'UndoRedo.redo');\n  if (this.selected) {\n    instance.selectCells(this.selected, false, false);\n  }\n};\n\n/**\n * Create row action.\n *\n * @private\n * @param {number} index The visual row index.\n * @param {number} amount The number of created rows.\n */\nUndoRedo.CreateRowAction = function (index, amount) {\n  this.index = index;\n  this.amount = amount;\n  this.actionType = 'insert_row';\n};\ninherit(UndoRedo.CreateRowAction, UndoRedo.Action);\nUndoRedo.CreateRowAction.prototype.undo = function (instance, undoneCallback) {\n  const rowCount = instance.countRows();\n  const minSpareRows = instance.getSettings().minSpareRows;\n  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {\n    this.index -= minSpareRows; // work around the situation where the needed row was removed due to an 'undo' of a made change\n  }\n  instance.addHookOnce('afterRemoveRow', undoneCallback);\n  instance.alter('remove_row', this.index, this.amount, 'UndoRedo.undo');\n};\nUndoRedo.CreateRowAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterCreateRow', redoneCallback);\n  instance.alter('insert_row_above', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Remove row action.\n *\n * @private\n * @param {number} index The visual row index.\n * @param {Array} data The removed data.\n * @param {number} fixedRowsBottom Number of fixed rows on the bottom. Remove row action change it sometimes.\n * @param {number} fixedRowsTop Number of fixed rows on the top. Remove row action change it sometimes.\n * @param {Array} rowIndexesSequence Row index sequence taken from the row index mapper.\n * @param {Array} removedCellMetas List of removed cell metas.\n */\nUndoRedo.RemoveRowAction = function (index, data, fixedRowsBottom, fixedRowsTop, rowIndexesSequence, removedCellMetas) {\n  this.index = index;\n  this.data = data;\n  this.actionType = 'remove_row';\n  this.fixedRowsBottom = fixedRowsBottom;\n  this.fixedRowsTop = fixedRowsTop;\n  this.rowIndexesSequence = rowIndexesSequence;\n  this.removedCellMetas = removedCellMetas;\n};\ninherit(UndoRedo.RemoveRowAction, UndoRedo.Action);\nUndoRedo.RemoveRowAction.prototype.undo = function (instance, undoneCallback) {\n  const settings = instance.getSettings();\n  const changes = [];\n\n  // Changing by the reference as `updateSettings` doesn't work the best.\n  settings.fixedRowsBottom = this.fixedRowsBottom;\n  settings.fixedRowsTop = this.fixedRowsTop;\n\n  // Prepare the change list to fill the source data.\n  this.data.forEach((dataRow, rowIndexDelta) => {\n    Object.keys(dataRow).forEach(columnProp => {\n      const columnIndex = parseInt(columnProp, 10);\n      changes.push([this.index + rowIndexDelta, isNaN(columnIndex) ? columnProp : columnIndex, dataRow[columnProp]]);\n    });\n  });\n  instance.alter('insert_row_above', this.index, this.data.length, 'UndoRedo.undo');\n  this.removedCellMetas.forEach(_ref2 => {\n    let [rowIndex, columnIndex, cellMeta] = _ref2;\n    instance.setCellMetaObject(rowIndex, columnIndex, cellMeta);\n  });\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.setSourceDataAtCell(changes, null, null, 'UndoRedo.undo');\n  instance.rowIndexMapper.setIndexesSequence(this.rowIndexesSequence);\n};\nUndoRedo.RemoveRowAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterRemoveRow', redoneCallback);\n  instance.alter('remove_row', this.index, this.data.length, 'UndoRedo.redo');\n};\n\n/**\n * Create column action.\n *\n * @private\n * @param {number} index The visual column index.\n * @param {number} amount The number of created columns.\n */\nUndoRedo.CreateColumnAction = function (index, amount) {\n  this.index = index;\n  this.amount = amount;\n  this.actionType = 'insert_col';\n};\ninherit(UndoRedo.CreateColumnAction, UndoRedo.Action);\nUndoRedo.CreateColumnAction.prototype.undo = function (instance, undoneCallback) {\n  instance.addHookOnce('afterRemoveCol', undoneCallback);\n  instance.alter('remove_col', this.index, this.amount, 'UndoRedo.undo');\n};\nUndoRedo.CreateColumnAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterCreateCol', redoneCallback);\n  instance.alter('insert_col_start', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Remove column action.\n *\n * @private\n * @param {number} index The visual column index.\n * @param {number[]} indexes The visual column indexes.\n * @param {Array} data The removed data.\n * @param {Array} headers The header values.\n * @param {number[]} columnPositions The column position.\n * @param {number[]} rowPositions The row position.\n * @param {number} fixedColumnsStart Number of fixed columns on the left. Remove column action change it sometimes.\n * @param {Array} removedCellMetas List of removed cell metas.\n */\nUndoRedo.RemoveColumnAction = function (index, indexes, data, headers, columnPositions, rowPositions, fixedColumnsStart, removedCellMetas) {\n  // eslint-disable-line max-len\n  this.index = index;\n  this.indexes = indexes;\n  this.data = data;\n  this.amount = this.data[0].length;\n  this.headers = headers;\n  this.columnPositions = columnPositions.slice(0);\n  this.rowPositions = rowPositions.slice(0);\n  this.actionType = 'remove_col';\n  this.fixedColumnsStart = fixedColumnsStart;\n  this.removedCellMetas = removedCellMetas;\n};\ninherit(UndoRedo.RemoveColumnAction, UndoRedo.Action);\nUndoRedo.RemoveColumnAction.prototype.undo = function (instance, undoneCallback) {\n  const settings = instance.getSettings();\n\n  // Changing by the reference as `updateSettings` doesn't work the best.\n  settings.fixedColumnsStart = this.fixedColumnsStart;\n  const ascendingIndexes = this.indexes.slice(0).sort();\n  const sortByIndexes = (elem, j, arr) => arr[this.indexes.indexOf(ascendingIndexes[j])];\n  const removedDataLength = this.data.length;\n  const sortedData = [];\n  for (let rowIndex = 0; rowIndex < removedDataLength; rowIndex++) {\n    sortedData.push(arrayMap(this.data[rowIndex], sortByIndexes));\n  }\n  const sortedHeaders = arrayMap(this.headers, sortByIndexes);\n  const changes = [];\n  instance.alter('insert_col_start', this.indexes[0], this.indexes.length, 'UndoRedo.undo');\n  arrayEach(instance.getSourceDataArray(), (rowData, rowIndex) => {\n    arrayEach(ascendingIndexes, (changedIndex, contiquesIndex) => {\n      rowData[changedIndex] = sortedData[rowIndex][contiquesIndex];\n      changes.push([rowIndex, changedIndex, rowData[changedIndex]]);\n    });\n  });\n  instance.setSourceDataAtCell(changes, undefined, undefined, 'UndoRedo.undo');\n  if (typeof this.headers !== 'undefined') {\n    arrayEach(sortedHeaders, (headerData, columnIndex) => {\n      instance.getSettings().colHeaders[ascendingIndexes[columnIndex]] = headerData;\n    });\n  }\n  this.removedCellMetas.forEach(_ref3 => {\n    let [rowIndex, columnIndex, cellMeta] = _ref3;\n    instance.setCellMetaObject(rowIndex, columnIndex, cellMeta);\n  });\n  instance.batchExecution(() => {\n    // Restore row sequence in a case when all columns are removed. the original\n    // row sequence is lost in that case.\n    instance.rowIndexMapper.setIndexesSequence(this.rowPositions);\n    instance.columnIndexMapper.setIndexesSequence(this.columnPositions);\n  }, true);\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\nUndoRedo.RemoveColumnAction.prototype.redo = function (instance, redoneCallback) {\n  instance.addHookOnce('afterRemoveCol', redoneCallback);\n  instance.alter('remove_col', this.index, this.amount, 'UndoRedo.redo');\n};\n\n/**\n * Cell alignment action.\n *\n * @private\n * @param {Array} stateBefore The previous state.\n * @param {object} range The cell range.\n * @param {string} type The type of the alignment (\"top\", \"left\", \"bottom\" or \"right\").\n * @param {string} alignment The alignment CSS class.\n */\nUndoRedo.CellAlignmentAction = function (stateBefore, range, type, alignment) {\n  this.stateBefore = stateBefore;\n  this.range = range;\n  this.type = type;\n  this.alignment = alignment;\n};\nUndoRedo.CellAlignmentAction.prototype.undo = function (instance, undoneCallback) {\n  arrayEach(this.range, range => {\n    range.forAll((row, col) => {\n      // Alignment classes should only collected within cell ranges. We skip header coordinates.\n      if (row >= 0 && col >= 0) {\n        instance.setCellMeta(row, col, 'className', this.stateBefore[row][col] || ' htLeft');\n      }\n    });\n  });\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\nUndoRedo.CellAlignmentAction.prototype.redo = function (instance, undoneCallback) {\n  align(this.range, this.type, this.alignment, (row, col) => instance.getCellMeta(row, col), (row, col, key, value) => instance.setCellMeta(row, col, key, value));\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  instance.render();\n};\n\n/**\n * Filters action.\n *\n * @private\n * @param {Array} conditionsStack An array of the filter condition.\n */\nUndoRedo.FiltersAction = function (conditionsStack) {\n  this.conditionsStack = conditionsStack;\n  this.actionType = 'filter';\n};\ninherit(UndoRedo.FiltersAction, UndoRedo.Action);\nUndoRedo.FiltersAction.prototype.undo = function (instance, undoneCallback) {\n  const filters = instance.getPlugin('filters');\n  instance.addHookOnce('afterViewRender', undoneCallback);\n  filters.conditionCollection.importAllConditions(this.conditionsStack.slice(0, this.conditionsStack.length - 1));\n  filters.filter();\n};\nUndoRedo.FiltersAction.prototype.redo = function (instance, redoneCallback) {\n  const filters = instance.getPlugin('filters');\n  instance.addHookOnce('afterViewRender', redoneCallback);\n  filters.conditionCollection.importAllConditions(this.conditionsStack);\n  filters.filter();\n};\n\n/**\n * Merge Cells action.\n *\n * @util\n */\nclass MergeCellsAction extends UndoRedo.Action {\n  constructor(instance, cellRange) {\n    super();\n    this.cellRange = cellRange;\n    const topStartCorner = this.cellRange.getTopStartCorner();\n    const bottomEndCorner = this.cellRange.getBottomEndCorner();\n    this.rangeData = instance.getData(topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col);\n  }\n  undo(instance, undoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', undoneCallback);\n    mergeCellsPlugin.unmergeRange(this.cellRange, true);\n    const topStartCorner = this.cellRange.getTopStartCorner();\n    instance.populateFromArray(topStartCorner.row, topStartCorner.col, this.rangeData, undefined, undefined, 'MergeCells');\n  }\n  redo(instance, redoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', redoneCallback);\n    mergeCellsPlugin.mergeRange(this.cellRange);\n  }\n}\nUndoRedo.MergeCellsAction = MergeCellsAction;\n\n/**\n * Unmerge Cells action.\n *\n * @util\n */\nclass UnmergeCellsAction extends UndoRedo.Action {\n  constructor(instance, cellRange) {\n    super();\n    this.cellRange = cellRange;\n  }\n  undo(instance, undoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', undoneCallback);\n    mergeCellsPlugin.mergeRange(this.cellRange, true);\n  }\n  redo(instance, redoneCallback) {\n    const mergeCellsPlugin = instance.getPlugin('mergeCells');\n    instance.addHookOnce('afterViewRender', redoneCallback);\n    mergeCellsPlugin.unmergeRange(this.cellRange, true);\n    instance.render();\n  }\n}\nUndoRedo.UnmergeCellsAction = UnmergeCellsAction;\n\n/**\n * ManualRowMove action.\n *\n * @TODO removeRow undo should works on logical index\n * @private\n * @param {number[]} rows An array with moved rows.\n * @param {number} finalIndex The destination index.\n */\nUndoRedo.RowMoveAction = function (rows, finalIndex) {\n  this.rows = rows.slice();\n  this.finalIndex = finalIndex;\n  this.actionType = 'row_move';\n};\ninherit(UndoRedo.RowMoveAction, UndoRedo.Action);\nUndoRedo.RowMoveAction.prototype.undo = function (instance, undoneCallback) {\n  const manualRowMove = instance.getPlugin('manualRowMove');\n  const copyOfRows = [].concat(this.rows);\n  const rowsMovedUp = copyOfRows.filter(a => a > this.finalIndex);\n  const rowsMovedDown = copyOfRows.filter(a => a <= this.finalIndex);\n  const allMovedRows = rowsMovedUp.sort((a, b) => b - a).concat(rowsMovedDown.sort((a, b) => a - b));\n  instance.addHookOnce('afterViewRender', undoneCallback);\n\n  // Moving rows from those with higher indexes to those with lower indexes when action was performed from bottom to top\n  // Moving rows from those with lower indexes to those with higher indexes when action was performed from top to bottom\n  for (let i = 0; i < allMovedRows.length; i += 1) {\n    const newPhysicalRow = instance.toVisualRow(allMovedRows[i]);\n    manualRowMove.moveRow(newPhysicalRow, allMovedRows[i]);\n  }\n  instance.render();\n  instance.deselectCell();\n  instance.selectRows(this.rows[0], this.rows[0] + this.rows.length - 1);\n};\nUndoRedo.RowMoveAction.prototype.redo = function (instance, redoneCallback) {\n  const manualRowMove = instance.getPlugin('manualRowMove');\n  instance.addHookOnce('afterViewRender', redoneCallback);\n  manualRowMove.moveRows(this.rows.slice(), this.finalIndex);\n  instance.render();\n  instance.deselectCell();\n  instance.selectRows(this.finalIndex, this.finalIndex + this.rows.length - 1);\n};\n\n/**\n * Enabling and disabling plugin and attaching its to an instance.\n *\n * @private\n */\nUndoRedo.prototype.init = function () {\n  const settings = this.instance.getSettings().undo;\n  const pluginEnabled = typeof settings === 'undefined' || settings;\n  if (!this.instance.undoRedo) {\n    this.instance.undoRedo = this;\n  }\n  if (pluginEnabled) {\n    this.instance.undoRedo.enable();\n  } else {\n    this.instance.undoRedo.disable();\n  }\n};\n\n/**\n * Registers shortcuts responsible for performing undo/redo.\n *\n * @private\n */\nUndoRedo.prototype.registerShortcuts = function () {\n  const shortcutManager = this.instance.getShortcutManager();\n  const gridContext = shortcutManager.getContext('grid');\n  const runOnlyIf = event => {\n    return !event.altKey; // right ALT in some systems triggers ALT+CTR\n  };\n  const config = {\n    runOnlyIf,\n    group: SHORTCUTS_GROUP\n  };\n  gridContext.addShortcuts([{\n    keys: [['Control/Meta', 'z']],\n    callback: () => {\n      this.undo();\n    }\n  }, {\n    keys: [['Control/Meta', 'y'], ['Control/Meta', 'Shift', 'z']],\n    callback: () => {\n      this.redo();\n    }\n  }], config);\n};\n\n/**\n * Unregister shortcuts responsible for performing undo/redo.\n *\n * @private\n */\nUndoRedo.prototype.unregisterShortcuts = function () {\n  const shortcutManager = this.instance.getShortcutManager();\n  const gridContext = shortcutManager.getContext('grid');\n  gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n};\n\n/**\n * @param {Array} changes 2D array containing information about each of the edited cells.\n * @param {string} source String that identifies source of hook call.\n * @returns {boolean}\n */\nfunction onAfterChange(changes, source) {\n  const instance = this;\n  if (source === 'loadData') {\n    return instance.undoRedo.clear();\n  }\n}\n\n/**\n * @param {Core} instance The Handsontable instance.\n */\nfunction exposeUndoRedoMethods(instance) {\n  /**\n   * {@link UndoRedo#undo}.\n   *\n   * @alias undo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.undo = function () {\n    return instance.undoRedo.undo();\n  };\n\n  /**\n   * {@link UndoRedo#redo}.\n   *\n   * @alias redo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.redo = function () {\n    return instance.undoRedo.redo();\n  };\n\n  /**\n   * {@link UndoRedo#isUndoAvailable}.\n   *\n   * @alias isUndoAvailable\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.isUndoAvailable = function () {\n    return instance.undoRedo.isUndoAvailable();\n  };\n\n  /**\n   * {@link UndoRedo#isRedoAvailable}.\n   *\n   * @alias isRedoAvailable\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.isRedoAvailable = function () {\n    return instance.undoRedo.isRedoAvailable();\n  };\n\n  /**\n   * {@link UndoRedo#clear}.\n   *\n   * @alias clearUndo\n   * @memberof! Core#\n   * @returns {boolean}\n   */\n  instance.clearUndo = function () {\n    return instance.undoRedo.clear();\n  };\n}\n\n/**\n * @param {Core} instance The Handsontable instance.\n */\nfunction removeExposedUndoRedoMethods(instance) {\n  delete instance.undo;\n  delete instance.redo;\n  delete instance.isUndoAvailable;\n  delete instance.isRedoAvailable;\n  delete instance.clearUndo;\n}\nconst hook = Hooks.getSingleton();\nhook.add('afterUpdateSettings', function () {\n  var _this$getPlugin;\n  (_this$getPlugin = this.getPlugin('undoRedo')) === null || _this$getPlugin === void 0 || _this$getPlugin.init();\n});\nhook.register('beforeUndo');\nhook.register('afterUndo');\nhook.register('beforeRedo');\nhook.register('afterRedo');\nUndoRedo.PLUGIN_KEY = PLUGIN_KEY;\nUndoRedo.SETTING_KEYS = true;\nexport default UndoRedo;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}