{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE } from \"./constants.mjs\";\n/**\n * @typedef {object} ViewportColumnsCalculatorOptions\n * @property {number} viewportWidth Width of the viewport.\n * @property {number} scrollOffset Current horizontal scroll position of the viewport.\n * @property {number} totalColumns Total number of columns.\n * @property {Function} columnWidthFn Function that returns the width of the column at a given index (in px).\n * @property {Function} overrideFn Function that changes calculated this.startRow, this.endRow (used by\n *   MergeCells plugin).\n * @property {string} calculationType String which describes types of calculation which will be performed.\n * @property {string} inlineStartOffset Inline-start offset of the parent container.\n * @property {string} stretchMode Stretch mode 'all' or 'last'.\n * @property {Function} stretchingColumnWidthFn Function that returns the new width of the stretched column.\n */\n/**\n * Calculates indexes of columns to render OR columns that are visible.\n * To redo the calculation, you need to create a new calculator.\n *\n * @class ViewportColumnsCalculator\n */\nvar _options = /*#__PURE__*/new WeakMap();\nexport class ViewportColumnsCalculator {\n  /**\n   * Default column width.\n   *\n   * @type {number}\n   */\n  static get DEFAULT_WIDTH() {\n    return 50;\n  }\n\n  /**\n   * Number of rendered/visible columns.\n   *\n   * @type {number}\n   */\n\n  /**\n   * @param {ViewportColumnsCalculatorOptions} options Object with all options specified for column viewport calculation.\n   */\n  constructor(options) {\n    _defineProperty(this, \"count\", 0);\n    /**\n     * Index of the first rendered/visible column (can be overwritten using overrideFn).\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startColumn\", null);\n    /**\n     * Index of the last rendered/visible column (can be overwritten using overrideFn).\n     *\n     * @type {null}\n     */\n    _defineProperty(this, \"endColumn\", null);\n    /**\n     * Position of the first rendered/visible column (in px).\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startPosition\", null);\n    /**\n     * Determines if the viewport is visible in the trimming container.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isVisibleInTrimmingContainer\", false);\n    /**\n     * The calculator options.\n     *\n     * @type {ViewportColumnsCalculatorOptions}\n     */\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _options, options);\n    this.calculate();\n  }\n\n  /**\n   * Calculates viewport.\n   */\n  calculate() {\n    const {\n      calculationType,\n      overrideFn,\n      scrollOffset,\n      totalColumns,\n      viewportWidth\n    } = _classPrivateFieldGet(this, _options);\n    const zeroBasedScrollOffset = Math.max(_classPrivateFieldGet(this, _options).scrollOffset, 0);\n    // +1 pixel for row header width compensation for horizontal scroll > 0\n    const compensatedViewportWidth = zeroBasedScrollOffset > 0 ? viewportWidth + 1 : viewportWidth;\n    let sum = 0;\n    let needReverse = true;\n    const startPositions = [];\n    let columnWidth;\n    let firstVisibleColumnWidth = 0;\n    let lastVisibleColumnWidth = 0;\n    for (let i = 0; i < totalColumns; i++) {\n      columnWidth = this._getColumnWidth(i);\n      if (sum <= zeroBasedScrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {\n        this.startColumn = i;\n        firstVisibleColumnWidth = columnWidth;\n      }\n      if (sum >= zeroBasedScrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? columnWidth : 0) <= zeroBasedScrollOffset + compensatedViewportWidth) {\n        if (this.startColumn === null || this.startColumn === undefined) {\n          this.startColumn = i;\n          firstVisibleColumnWidth = columnWidth;\n        }\n        this.endColumn = i;\n      }\n      startPositions.push(sum);\n      sum += columnWidth;\n      lastVisibleColumnWidth = columnWidth;\n      if (calculationType !== FULLY_VISIBLE_TYPE) {\n        this.endColumn = i;\n      }\n      if (sum >= zeroBasedScrollOffset + viewportWidth) {\n        needReverse = false;\n        break;\n      }\n    }\n    const mostRightScrollOffset = scrollOffset + viewportWidth - compensatedViewportWidth;\n    const inlineEndColumnOffset = calculationType === FULLY_VISIBLE_TYPE ? 0 : lastVisibleColumnWidth;\n    const inlineStartColumnOffset = calculationType === FULLY_VISIBLE_TYPE ? firstVisibleColumnWidth : 0;\n    if (\n    // the table is to the left of the viewport\n    mostRightScrollOffset < -1 * _classPrivateFieldGet(this, _options).inlineStartOffset || scrollOffset > startPositions.at(-1) + inlineEndColumnOffset ||\n    // the table is to the right of the viewport\n    -1 * _classPrivateFieldGet(this, _options).scrollOffset - _classPrivateFieldGet(this, _options).viewportWidth > -1 * inlineStartColumnOffset) {\n      this.isVisibleInTrimmingContainer = false;\n    } else {\n      this.isVisibleInTrimmingContainer = true;\n    }\n    if (this.endColumn === totalColumns - 1 && needReverse) {\n      this.startColumn = this.endColumn;\n      while (this.startColumn > 0) {\n        const viewportSum = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];\n        if (viewportSum <= viewportWidth || calculationType !== FULLY_VISIBLE_TYPE) {\n          this.startColumn -= 1;\n        }\n        if (viewportSum > viewportWidth) {\n          break;\n        }\n      }\n    }\n    if (calculationType === RENDER_TYPE && this.startColumn !== null && overrideFn) {\n      overrideFn(this);\n    }\n    this.startPosition = startPositions[this.startColumn];\n    if (this.startPosition === undefined) {\n      this.startPosition = null;\n    }\n\n    // If totalColumns exceeded its total columns size set endColumn to the latest item\n    if (totalColumns < this.endColumn) {\n      this.endColumn = totalColumns - 1;\n    }\n    if (this.startColumn !== null) {\n      this.count = this.endColumn - this.startColumn + 1;\n    }\n  }\n\n  /**\n   * @param {number} column The visual column index.\n   * @returns {number}\n   * @private\n   */\n  _getColumnWidth(column) {\n    let width = _classPrivateFieldGet(this, _options).columnWidthFn(column);\n    if (isNaN(width)) {\n      width = ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n    return width;\n  }\n}","map":{"version":3,"names":["_classPrivateFieldInitSpec","obj","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","TypeError","_defineProperty","key","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","_classPrivateFieldSet","_classApplyDescriptorSet","action","RENDER_TYPE","FULLY_VISIBLE_TYPE","_options","WeakMap","ViewportColumnsCalculator","DEFAULT_WIDTH","constructor","options","calculate","calculationType","overrideFn","scrollOffset","totalColumns","viewportWidth","zeroBasedScrollOffset","Math","max","compensatedViewportWidth","sum","needReverse","startPositions","columnWidth","firstVisibleColumnWidth","lastVisibleColumnWidth","_getColumnWidth","startColumn","undefined","endColumn","push","mostRightScrollOffset","inlineEndColumnOffset","inlineStartColumnOffset","inlineStartOffset","at","isVisibleInTrimmingContainer","viewportSum","startPosition","count","column","width","columnWidthFn","isNaN"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/3rdparty/walkontable/src/calculator/viewportColumns.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE } from \"./constants.mjs\";\n/**\n * @typedef {object} ViewportColumnsCalculatorOptions\n * @property {number} viewportWidth Width of the viewport.\n * @property {number} scrollOffset Current horizontal scroll position of the viewport.\n * @property {number} totalColumns Total number of columns.\n * @property {Function} columnWidthFn Function that returns the width of the column at a given index (in px).\n * @property {Function} overrideFn Function that changes calculated this.startRow, this.endRow (used by\n *   MergeCells plugin).\n * @property {string} calculationType String which describes types of calculation which will be performed.\n * @property {string} inlineStartOffset Inline-start offset of the parent container.\n * @property {string} stretchMode Stretch mode 'all' or 'last'.\n * @property {Function} stretchingColumnWidthFn Function that returns the new width of the stretched column.\n */\n/**\n * Calculates indexes of columns to render OR columns that are visible.\n * To redo the calculation, you need to create a new calculator.\n *\n * @class ViewportColumnsCalculator\n */\nvar _options = /*#__PURE__*/new WeakMap();\nexport class ViewportColumnsCalculator {\n  /**\n   * Default column width.\n   *\n   * @type {number}\n   */\n  static get DEFAULT_WIDTH() {\n    return 50;\n  }\n\n  /**\n   * Number of rendered/visible columns.\n   *\n   * @type {number}\n   */\n\n  /**\n   * @param {ViewportColumnsCalculatorOptions} options Object with all options specified for column viewport calculation.\n   */\n  constructor(options) {\n    _defineProperty(this, \"count\", 0);\n    /**\n     * Index of the first rendered/visible column (can be overwritten using overrideFn).\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startColumn\", null);\n    /**\n     * Index of the last rendered/visible column (can be overwritten using overrideFn).\n     *\n     * @type {null}\n     */\n    _defineProperty(this, \"endColumn\", null);\n    /**\n     * Position of the first rendered/visible column (in px).\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startPosition\", null);\n    /**\n     * Determines if the viewport is visible in the trimming container.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isVisibleInTrimmingContainer\", false);\n    /**\n     * The calculator options.\n     *\n     * @type {ViewportColumnsCalculatorOptions}\n     */\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _options, options);\n    this.calculate();\n  }\n\n  /**\n   * Calculates viewport.\n   */\n  calculate() {\n    const {\n      calculationType,\n      overrideFn,\n      scrollOffset,\n      totalColumns,\n      viewportWidth\n    } = _classPrivateFieldGet(this, _options);\n    const zeroBasedScrollOffset = Math.max(_classPrivateFieldGet(this, _options).scrollOffset, 0);\n    // +1 pixel for row header width compensation for horizontal scroll > 0\n    const compensatedViewportWidth = zeroBasedScrollOffset > 0 ? viewportWidth + 1 : viewportWidth;\n    let sum = 0;\n    let needReverse = true;\n    const startPositions = [];\n    let columnWidth;\n    let firstVisibleColumnWidth = 0;\n    let lastVisibleColumnWidth = 0;\n    for (let i = 0; i < totalColumns; i++) {\n      columnWidth = this._getColumnWidth(i);\n      if (sum <= zeroBasedScrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {\n        this.startColumn = i;\n        firstVisibleColumnWidth = columnWidth;\n      }\n      if (sum >= zeroBasedScrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? columnWidth : 0) <= zeroBasedScrollOffset + compensatedViewportWidth) {\n        if (this.startColumn === null || this.startColumn === undefined) {\n          this.startColumn = i;\n          firstVisibleColumnWidth = columnWidth;\n        }\n        this.endColumn = i;\n      }\n      startPositions.push(sum);\n      sum += columnWidth;\n      lastVisibleColumnWidth = columnWidth;\n      if (calculationType !== FULLY_VISIBLE_TYPE) {\n        this.endColumn = i;\n      }\n      if (sum >= zeroBasedScrollOffset + viewportWidth) {\n        needReverse = false;\n        break;\n      }\n    }\n    const mostRightScrollOffset = scrollOffset + viewportWidth - compensatedViewportWidth;\n    const inlineEndColumnOffset = calculationType === FULLY_VISIBLE_TYPE ? 0 : lastVisibleColumnWidth;\n    const inlineStartColumnOffset = calculationType === FULLY_VISIBLE_TYPE ? firstVisibleColumnWidth : 0;\n    if (\n    // the table is to the left of the viewport\n    mostRightScrollOffset < -1 * _classPrivateFieldGet(this, _options).inlineStartOffset || scrollOffset > startPositions.at(-1) + inlineEndColumnOffset ||\n    // the table is to the right of the viewport\n    -1 * _classPrivateFieldGet(this, _options).scrollOffset - _classPrivateFieldGet(this, _options).viewportWidth > -1 * inlineStartColumnOffset) {\n      this.isVisibleInTrimmingContainer = false;\n    } else {\n      this.isVisibleInTrimmingContainer = true;\n    }\n    if (this.endColumn === totalColumns - 1 && needReverse) {\n      this.startColumn = this.endColumn;\n      while (this.startColumn > 0) {\n        const viewportSum = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];\n        if (viewportSum <= viewportWidth || calculationType !== FULLY_VISIBLE_TYPE) {\n          this.startColumn -= 1;\n        }\n        if (viewportSum > viewportWidth) {\n          break;\n        }\n      }\n    }\n    if (calculationType === RENDER_TYPE && this.startColumn !== null && overrideFn) {\n      overrideFn(this);\n    }\n    this.startPosition = startPositions[this.startColumn];\n    if (this.startPosition === undefined) {\n      this.startPosition = null;\n    }\n\n    // If totalColumns exceeded its total columns size set endColumn to the latest item\n    if (totalColumns < this.endColumn) {\n      this.endColumn = totalColumns - 1;\n    }\n    if (this.startColumn !== null) {\n      this.count = this.endColumn - this.startColumn + 1;\n    }\n  }\n\n  /**\n   * @param {number} column The visual column index.\n   * @returns {number}\n   * @private\n   */\n  _getColumnWidth(column) {\n    let width = _classPrivateFieldGet(this, _options).columnWidthFn(column);\n    if (isNaN(width)) {\n      width = ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n    return width;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}