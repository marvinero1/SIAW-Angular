{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport AxisSyncer from \"./axisSyncer.mjs\";\n/**\n * @private\n * @class IndexSyncer\n * @description\n *\n * Indexes synchronizer responsible for providing logic for syncing actions done on indexes for HOT to actions performed\n * on HF's.\n *\n */\nvar _rowIndexSyncer = /*#__PURE__*/new WeakMap();\nvar _columnIndexSyncer = /*#__PURE__*/new WeakMap();\nvar _postponeAction = /*#__PURE__*/new WeakMap();\nvar _isPerformingUndo = /*#__PURE__*/new WeakMap();\nvar _isPerformingRedo = /*#__PURE__*/new WeakMap();\nvar _engine = /*#__PURE__*/new WeakMap();\nvar _sheetId = /*#__PURE__*/new WeakMap();\nclass IndexSyncer {\n  constructor(rowIndexMapper, columnIndexMapper, postponeAction) {\n    /**\n     * Indexes synchronizer for the axis of the rows.\n     *\n     * @private\n     * @type {AxisSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _rowIndexSyncer, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Indexes synchronizer for the axis of the columns.\n     *\n     * @private\n     * @type {AxisSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _columnIndexSyncer, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Method which will postpone execution of some action (needed when synchronization endpoint isn't setup yet).\n     *\n     * @private\n     * @type {Function}\n     */\n    _classPrivateFieldInitSpec(this, _postponeAction, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Flag informing whether undo is already performed (we don't perform synchronization in such case).\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isPerformingUndo, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Flag informing whether redo is already performed (we don't perform synchronization in such case).\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isPerformingRedo, {\n      writable: true,\n      value: false\n    });\n    /**\n     * The HF's engine instance which will be synced.\n     *\n     * @private\n     * @type {HyperFormula|null}\n     */\n    _classPrivateFieldInitSpec(this, _engine, {\n      writable: true,\n      value: null\n    });\n    /**\n     * HyperFormula's sheet name.\n     *\n     * @private\n     * @type {string|null}\n     */\n    _classPrivateFieldInitSpec(this, _sheetId, {\n      writable: true,\n      value: null\n    });\n    _classPrivateFieldSet(this, _rowIndexSyncer, new AxisSyncer('row', rowIndexMapper, this));\n    _classPrivateFieldSet(this, _columnIndexSyncer, new AxisSyncer('column', columnIndexMapper, this));\n    _classPrivateFieldSet(this, _postponeAction, postponeAction);\n  }\n\n  /**\n   * Gets index synchronizer for a particular axis.\n   *\n   * @param {'row'|'column'} indexType Type of indexes.\n   * @returns {AxisSyncer}\n   */\n  getForAxis(indexType) {\n    if (indexType === 'row') {\n      return _classPrivateFieldGet(this, _rowIndexSyncer);\n    }\n    return _classPrivateFieldGet(this, _columnIndexSyncer);\n  }\n\n  /**\n   * Sets flag informing whether an undo action is already performed (we don't execute synchronization in such case).\n   *\n   * @param {boolean} flagValue Boolean value for the flag.\n   */\n  setPerformUndo(flagValue) {\n    _classPrivateFieldSet(this, _isPerformingUndo, flagValue);\n  }\n\n  /**\n   * Sets flag informing whether a redo action is already performed (we don't execute synchronization in such case).\n   *\n   * @param {boolean} flagValue Boolean value for the flag.\n   */\n  setPerformRedo(flagValue) {\n    _classPrivateFieldSet(this, _isPerformingRedo, flagValue);\n  }\n\n  /**\n   * Gets information whether redo or undo action is already performed (we don't execute synchronization in such case).\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isPerformingUndoRedo() {\n    return _classPrivateFieldGet(this, _isPerformingUndo) || _classPrivateFieldGet(this, _isPerformingRedo);\n  }\n\n  /**\n   * Gets HyperFormula's sheet id.\n   *\n   * @returns {string|null}\n   */\n  getSheetId() {\n    return _classPrivateFieldGet(this, _sheetId);\n  }\n\n  /**\n   * Gets engine instance that will be used for handled instance of Handsontable.\n   *\n   * @type {HyperFormula|null}\n   */\n  getEngine() {\n    return _classPrivateFieldGet(this, _engine);\n  }\n\n  /**\n   * Gets method which will postpone execution of some action (needed when synchronization endpoint isn't setup yet).\n   *\n   * @returns {Function}\n   */\n  getPostponeAction() {\n    return _classPrivateFieldGet(this, _postponeAction);\n  }\n\n  /**\n   * Setups a synchronization endpoint.\n   *\n   * @param {HyperFormula|null} engine The HF's engine instance which will be synced.\n   * @param {string|null} sheetId HyperFormula's sheet name.\n   */\n  setupSyncEndpoint(engine, sheetId) {\n    _classPrivateFieldSet(this, _engine, engine);\n    _classPrivateFieldSet(this, _sheetId, sheetId);\n    _classPrivateFieldGet(this, _rowIndexSyncer).init();\n    _classPrivateFieldGet(this, _columnIndexSyncer).init();\n  }\n}\nexport default IndexSyncer;","map":{"version":3,"names":["_classPrivateFieldInitSpec","obj","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","TypeError","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","call","_classPrivateFieldSet","_classApplyDescriptorSet","action","writable","AxisSyncer","_rowIndexSyncer","WeakMap","_columnIndexSyncer","_postponeAction","_isPerformingUndo","_isPerformingRedo","_engine","_sheetId","IndexSyncer","constructor","rowIndexMapper","columnIndexMapper","postponeAction","getForAxis","indexType","setPerformUndo","flagValue","setPerformRedo","isPerformingUndoRedo","getSheetId","getEngine","getPostponeAction","setupSyncEndpoint","engine","sheetId","init"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/formulas/indexSyncer/index.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport AxisSyncer from \"./axisSyncer.mjs\";\n/**\n * @private\n * @class IndexSyncer\n * @description\n *\n * Indexes synchronizer responsible for providing logic for syncing actions done on indexes for HOT to actions performed\n * on HF's.\n *\n */\nvar _rowIndexSyncer = /*#__PURE__*/new WeakMap();\nvar _columnIndexSyncer = /*#__PURE__*/new WeakMap();\nvar _postponeAction = /*#__PURE__*/new WeakMap();\nvar _isPerformingUndo = /*#__PURE__*/new WeakMap();\nvar _isPerformingRedo = /*#__PURE__*/new WeakMap();\nvar _engine = /*#__PURE__*/new WeakMap();\nvar _sheetId = /*#__PURE__*/new WeakMap();\nclass IndexSyncer {\n  constructor(rowIndexMapper, columnIndexMapper, postponeAction) {\n    /**\n     * Indexes synchronizer for the axis of the rows.\n     *\n     * @private\n     * @type {AxisSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _rowIndexSyncer, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Indexes synchronizer for the axis of the columns.\n     *\n     * @private\n     * @type {AxisSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _columnIndexSyncer, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Method which will postpone execution of some action (needed when synchronization endpoint isn't setup yet).\n     *\n     * @private\n     * @type {Function}\n     */\n    _classPrivateFieldInitSpec(this, _postponeAction, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Flag informing whether undo is already performed (we don't perform synchronization in such case).\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isPerformingUndo, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Flag informing whether redo is already performed (we don't perform synchronization in such case).\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isPerformingRedo, {\n      writable: true,\n      value: false\n    });\n    /**\n     * The HF's engine instance which will be synced.\n     *\n     * @private\n     * @type {HyperFormula|null}\n     */\n    _classPrivateFieldInitSpec(this, _engine, {\n      writable: true,\n      value: null\n    });\n    /**\n     * HyperFormula's sheet name.\n     *\n     * @private\n     * @type {string|null}\n     */\n    _classPrivateFieldInitSpec(this, _sheetId, {\n      writable: true,\n      value: null\n    });\n    _classPrivateFieldSet(this, _rowIndexSyncer, new AxisSyncer('row', rowIndexMapper, this));\n    _classPrivateFieldSet(this, _columnIndexSyncer, new AxisSyncer('column', columnIndexMapper, this));\n    _classPrivateFieldSet(this, _postponeAction, postponeAction);\n  }\n\n  /**\n   * Gets index synchronizer for a particular axis.\n   *\n   * @param {'row'|'column'} indexType Type of indexes.\n   * @returns {AxisSyncer}\n   */\n  getForAxis(indexType) {\n    if (indexType === 'row') {\n      return _classPrivateFieldGet(this, _rowIndexSyncer);\n    }\n    return _classPrivateFieldGet(this, _columnIndexSyncer);\n  }\n\n  /**\n   * Sets flag informing whether an undo action is already performed (we don't execute synchronization in such case).\n   *\n   * @param {boolean} flagValue Boolean value for the flag.\n   */\n  setPerformUndo(flagValue) {\n    _classPrivateFieldSet(this, _isPerformingUndo, flagValue);\n  }\n\n  /**\n   * Sets flag informing whether a redo action is already performed (we don't execute synchronization in such case).\n   *\n   * @param {boolean} flagValue Boolean value for the flag.\n   */\n  setPerformRedo(flagValue) {\n    _classPrivateFieldSet(this, _isPerformingRedo, flagValue);\n  }\n\n  /**\n   * Gets information whether redo or undo action is already performed (we don't execute synchronization in such case).\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isPerformingUndoRedo() {\n    return _classPrivateFieldGet(this, _isPerformingUndo) || _classPrivateFieldGet(this, _isPerformingRedo);\n  }\n\n  /**\n   * Gets HyperFormula's sheet id.\n   *\n   * @returns {string|null}\n   */\n  getSheetId() {\n    return _classPrivateFieldGet(this, _sheetId);\n  }\n\n  /**\n   * Gets engine instance that will be used for handled instance of Handsontable.\n   *\n   * @type {HyperFormula|null}\n   */\n  getEngine() {\n    return _classPrivateFieldGet(this, _engine);\n  }\n\n  /**\n   * Gets method which will postpone execution of some action (needed when synchronization endpoint isn't setup yet).\n   *\n   * @returns {Function}\n   */\n  getPostponeAction() {\n    return _classPrivateFieldGet(this, _postponeAction);\n  }\n\n  /**\n   * Setups a synchronization endpoint.\n   *\n   * @param {HyperFormula|null} engine The HF's engine instance which will be synced.\n   * @param {string|null} sheetId HyperFormula's sheet name.\n   */\n  setupSyncEndpoint(engine, sheetId) {\n    _classPrivateFieldSet(this, _engine, engine);\n    _classPrivateFieldSet(this, _sheetId, sheetId);\n    _classPrivateFieldGet(this, _rowIndexSyncer).init();\n    _classPrivateFieldGet(this, _columnIndexSyncer).init();\n  }\n}\nexport default IndexSyncer;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}