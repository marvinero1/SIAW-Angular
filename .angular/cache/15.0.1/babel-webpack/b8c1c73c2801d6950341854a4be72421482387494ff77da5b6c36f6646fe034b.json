{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { arrayEach, arrayFilter } from \"../../helpers/array.mjs\";\nimport { cancelAnimationFrame, requestAnimationFrame } from \"../../helpers/feature.mjs\";\nimport { isVisible } from \"../../helpers/dom/element.mjs\";\nimport GhostTable from \"../../utils/ghostTable.mjs\";\nimport { isObject, hasOwnProperty } from \"../../helpers/object.mjs\";\nimport { valueAccordingPercent, rangeEach } from \"../../helpers/number.mjs\";\nimport SamplesGenerator from \"../../utils/samplesGenerator.mjs\";\nimport { isPercentValue } from \"../../helpers/string.mjs\";\nimport { PhysicalIndexToValueMap as IndexToValueMap } from \"../../translations/index.mjs\";\nexport const PLUGIN_KEY = 'autoRowSize';\nexport const PLUGIN_PRIORITY = 40;\nconst ROW_WIDTHS_MAP_NAME = 'autoRowSize';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @plugin AutoRowSize\n * @class AutoRowSize\n * @description\n * The `AutoRowSize` plugin allows you to set row heights based on their highest cells.\n *\n * By default, the plugin is declared as `undefined`, which makes it disabled (same as if it was declared as `false`).\n * Enabling this plugin may decrease the overall table performance, as it needs to calculate the heights of all cells to\n * resize the rows accordingly.\n * If you experience problems with the performance, try turning this feature off and declaring the row heights manually.\n *\n * But, to display Handsontable's [scrollbar](https://handsontable.com/docs/8.0.0/demo-scrolling.html)\n * in a proper size, you need to enable the `AutoRowSize` plugin,\n * by setting the [`autoRowSize`](@/api/options.md#autoRowSize) option to `true`.\n *\n * Row height calculations are divided into sync and async part. Each of this parts has their own advantages and\n * disadvantages. Synchronous calculations are faster but they block the browser UI, while the slower asynchronous\n * operations don't block the browser UI.\n *\n * To configure the sync/async distribution, you can pass an absolute value (number of rows) or a percentage value to a config object:\n * ```js\n * // as a number (300 rows in sync, rest async)\n * autoRowSize: {syncLimit: 300},\n *\n * // as a string (percent)\n * autoRowSize: {syncLimit: '40%'},\n *\n * // allow sample duplication\n * autoRowSize: {syncLimit: '40%', allowSampleDuplicates: true},\n * ```\n *\n * You can also use the `allowSampleDuplicates` option to allow sampling duplicate values when calculating the row\n * height. __Note__, that this might have a negative impact on performance.\n *\n * To configure this plugin see {@link Options#autoRowSize}.\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *   data: getData(),\n *   autoRowSize: true\n * });\n * // Access to plugin instance:\n * const plugin = hot.getPlugin('autoRowSize');\n *\n * plugin.getRowHeight(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * // First, let's contruct Handsontable\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   autoRowSize={true}\n * />\n *\n * ...\n *\n * // Access to plugin instance:\n * const hot = hotRef.current.hotInstance;\n * const plugin = hot.getPlugin('autoRowSize');\n *\n * plugin.getRowHeight(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _onBeforeViewRender = /*#__PURE__*/new WeakSet();\nvar _onBeforeRowResize = /*#__PURE__*/new WeakSet();\nvar _onAfterLoadData = /*#__PURE__*/new WeakSet();\nvar _onBeforeChange = /*#__PURE__*/new WeakSet();\nexport class AutoRowSize extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return true;\n  }\n  static get CALCULATION_STEP() {\n    return 50;\n  }\n  static get SYNC_CALCULATION_LIMIT() {\n    return 500;\n  }\n\n  /**\n   * Columns header's height cache.\n   *\n   * @private\n   * @type {number}\n   */\n\n  constructor(hotInstance) {\n    super(hotInstance);\n    /**\n     * On before change listener.\n     *\n     * @param {Array} changes 2D array containing information about each of the edited cells.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeChange);\n    /**\n     * On after load data listener.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterLoadData);\n    /**\n     * On before row resize listener.\n     *\n     * @param {number} size The size of the current row index.\n     * @param {number} row Current row index.\n     * @param {boolean} isDblClick Indicates if the resize was triggered by doubleclick.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeRowResize);\n    /**\n     * On before view render listener.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeViewRender);\n    _defineProperty(this, \"headerHeight\", null);\n    /**\n     * Instance of {@link GhostTable} for rows and columns size calculations.\n     *\n     * @private\n     * @type {GhostTable}\n     */\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot));\n    /**\n     * Instance of {@link SamplesGenerator} for generating samples necessary for rows height calculations.\n     *\n     * @private\n     * @type {SamplesGenerator}\n     */\n    _defineProperty(this, \"samplesGenerator\", new SamplesGenerator((row, column) => {\n      if (row >= 0 && column >= 0) {\n        const cellMeta = this.hot.getCellMeta(row, column);\n        if (cellMeta.hidden) {\n          // do not generate samples for cells that are covered by merged cell (null values)\n          return false;\n        }\n      }\n      let cellValue;\n      if (row >= 0) {\n        cellValue = this.hot.getDataAtCell(row, column);\n      } else if (row === -1) {\n        cellValue = this.hot.getColHeader(column);\n      }\n      return {\n        value: cellValue\n      };\n    }));\n    /**\n     * `true` if only the first calculation was performed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"firstCalculation\", true);\n    /**\n     * `true` if the size calculation is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Number of already measured rows (we already know their sizes).\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"measuredRows\", 0);\n    /**\n     * PhysicalIndexToValueMap to keep and track heights for physical row indexes.\n     *\n     * @private\n     * @type {PhysicalIndexToValueMap}\n     */\n    _defineProperty(this, \"rowHeightsMap\", new IndexToValueMap());\n    this.hot.rowIndexMapper.registerMap(ROW_WIDTHS_MAP_NAME, this.rowHeightsMap);\n\n    // Leave the listener active to allow auto-sizing the rows when the plugin is disabled.\n    // This is necessary for height recalculation for resize handler doubleclick (ManualRowResize).\n    this.addHook('beforeRowResize', (size, row, isDblClick) => _classPrivateMethodGet(this, _onBeforeRowResize, _onBeforeRowResize2).call(this, size, row, isDblClick));\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    return settings === true || isObject(settings);\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.setSamplingOptions();\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onAfterLoadData, _onAfterLoadData2).call(_this, ...args);\n    });\n    this.addHook('beforeChangeRender', changes => _classPrivateMethodGet(this, _onBeforeChange, _onBeforeChange2).call(this, changes));\n    this.addHook('beforeColumnResize', () => this.recalculateAllRowsHeight());\n    this.addHook('beforeViewRender', force => _classPrivateMethodGet(this, _onBeforeViewRender, _onBeforeViewRender2).call(this, force));\n    this.addHook('modifyRowHeight', (height, row) => this.getRowHeight(row, height));\n    this.addHook('modifyColumnHeaderHeight', () => this.getColumnHeaderHeight());\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.headerHeight = null;\n    super.disablePlugin();\n\n    // Leave the listener active to allow auto-sizing the rows when the plugin is disabled.\n    // This is necesseary for height recalculation for resize handler doubleclick (ManualRowResize).\n    this.addHook('beforeRowResize', (size, row, isDblClick) => _classPrivateMethodGet(this, _onBeforeRowResize, _onBeforeRowResize2).call(this, size, row, isDblClick));\n  }\n\n  /**\n   * Calculate a given rows height.\n   *\n   * @param {number|object} rowRange Row index or an object with `from` and `to` indexes as a range.\n   * @param {number|object} colRange Column index or an object with `from` and `to` indexes as a range.\n   * @param {boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateRowsHeight() {\n    let rowRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let colRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // eslint-disable-line max-len\n    const rowsRange = typeof rowRange === 'number' ? {\n      from: rowRange,\n      to: rowRange\n    } : rowRange;\n    const columnsRange = typeof colRange === 'number' ? {\n      from: colRange,\n      to: colRange\n    } : colRange;\n    if (this.hot.getColHeader(0) !== null) {\n      const samples = this.samplesGenerator.generateRowSamples(-1, columnsRange);\n      this.ghostTable.addColumnHeadersRow(samples.get(-1));\n    }\n    rangeEach(rowsRange.from, rowsRange.to, row => {\n      // For rows we must calculate row height even when user had set height value manually.\n      // We can shrink column but cannot shrink rows!\n      if (force || this.rowHeightsMap.getValueAtIndex(row) === null) {\n        const samples = this.samplesGenerator.generateRowSamples(row, columnsRange);\n        arrayEach(samples, _ref => {\n          let [rowIndex, sample] = _ref;\n          return this.ghostTable.addRow(rowIndex, sample);\n        });\n      }\n    });\n    if (this.ghostTable.rows.length) {\n      this.hot.batchExecution(() => {\n        this.ghostTable.getHeights((row, height) => {\n          if (row < 0) {\n            this.headerHeight = height;\n          } else {\n            this.rowHeightsMap.setValueAtIndex(this.hot.toPhysicalRow(row), height);\n          }\n        });\n      }, true);\n      this.measuredRows = rowsRange.to + 1;\n      this.ghostTable.clean();\n    }\n  }\n\n  /**\n   * Calculate all rows heights. The calculated row will be cached in the {@link AutoRowSize#heights} property.\n   * To retrieve height for specified row use {@link AutoRowSize#getRowHeight} method.\n   *\n   * @param {object|number} colRange Row index or an object with `from` and `to` properties which define row range.\n   */\n  calculateAllRowsHeight() {\n    let colRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let current = 0;\n    const length = this.hot.countRows() - 1;\n    let timer = null;\n    this.inProgress = true;\n    const loop = () => {\n      // When hot was destroyed after calculating finished cancel frame\n      if (!this.hot) {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n        return;\n      }\n      this.calculateRowsHeight({\n        from: current,\n        to: Math.min(current + AutoRowSize.CALCULATION_STEP, length)\n      }, colRange);\n      current = current + AutoRowSize.CALCULATION_STEP + 1;\n      if (current < length) {\n        timer = requestAnimationFrame(loop);\n      } else {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n\n        // @TODO Should call once per render cycle, currently fired separately in different plugins\n        this.hot.view.adjustElementsSize(true);\n\n        // tmp\n        if (this.hot.view._wt.wtOverlays.inlineStartOverlay.needFullRender) {\n          this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.draw();\n        }\n      }\n    };\n    const syncLimit = this.getSyncCalculationLimit();\n\n    // sync\n    if (this.firstCalculation && syncLimit >= 0) {\n      this.calculateRowsHeight({\n        from: 0,\n        to: syncLimit\n      }, colRange);\n      this.firstCalculation = false;\n      current = syncLimit + 1;\n    }\n    // async\n    if (current < length) {\n      loop();\n    } else {\n      this.inProgress = false;\n      this.hot.view.adjustElementsSize(false);\n    }\n  }\n\n  /**\n   * Sets the sampling options.\n   *\n   * @private\n   */\n  setSamplingOptions() {\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    const samplingRatio = setting && hasOwnProperty(setting, 'samplingRatio') ? setting.samplingRatio : undefined;\n    const allowSampleDuplicates = setting && hasOwnProperty(setting, 'allowSampleDuplicates') ? setting.allowSampleDuplicates : undefined;\n    if (samplingRatio && !isNaN(samplingRatio)) {\n      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));\n    }\n    if (allowSampleDuplicates) {\n      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);\n    }\n  }\n\n  /**\n   * Recalculates all rows height (overwrite cache values).\n   */\n  recalculateAllRowsHeight() {\n    if (isVisible(this.hot.view._wt.wtTable.TABLE)) {\n      this.clearCache();\n      this.calculateAllRowsHeight();\n    }\n  }\n\n  /**\n   * Gets value which tells how many rows should be calculated synchronously (rest of the rows will be calculated\n   * asynchronously). The limit is calculated based on `syncLimit` set to autoRowSize option (see {@link Options#autoRowSize}).\n   *\n   * @returns {number}\n   */\n  getSyncCalculationLimit() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    /* eslint-disable no-bitwise */\n    let limit = AutoRowSize.SYNC_CALCULATION_LIMIT;\n    const rowsLimit = this.hot.countRows() - 1;\n    if (isObject(settings)) {\n      limit = settings.syncLimit;\n      if (isPercentValue(limit)) {\n        limit = valueAccordingPercent(rowsLimit, limit);\n      } else {\n        // Force to Number\n        limit >>= 0;\n      }\n    }\n    return Math.min(limit, rowsLimit);\n  }\n\n  /**\n   * Get a row's height, as measured in the DOM.\n   *\n   * The height returned includes 1 px of the row's bottom border.\n   *\n   * Mind that this method is different from the\n   * [`getRowHeight()`](@/api/core.md#getrowheight) method\n   * of Handsontable's [Core](@/api/core.md).\n   *\n   * @param {number} row A visual row index.\n   * @param {number} [defaultHeight] If no height is found, `defaultHeight` is returned instead.\n   * @returns {number} The height of the specified row, in pixels.\n   */\n  getRowHeight(row) {\n    let defaultHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    const cachedHeight = row < 0 ? this.headerHeight : this.rowHeightsMap.getValueAtIndex(this.hot.toPhysicalRow(row));\n    let height = defaultHeight;\n    if (cachedHeight !== null && cachedHeight > (defaultHeight || 0)) {\n      height = cachedHeight;\n    }\n    return height;\n  }\n\n  /**\n   * Get the calculated column header height.\n   *\n   * @returns {number|undefined}\n   */\n  getColumnHeaderHeight() {\n    return this.headerHeight;\n  }\n\n  /**\n   * Get the first visible row.\n   *\n   * @returns {number} Returns row index, -1 if table is not rendered or if there are no rows to base the the calculations on.\n   */\n  getFirstVisibleRow() {\n    const wot = this.hot.view._wt;\n    if (wot.wtViewport.rowsVisibleCalculator) {\n      return wot.wtTable.getFirstVisibleRow();\n    }\n    if (wot.wtViewport.rowsRenderCalculator) {\n      return wot.wtTable.getFirstRenderedRow();\n    }\n    return -1;\n  }\n\n  /**\n   * Gets the last visible row.\n   *\n   * @returns {number} Returns row index or -1 if table is not rendered.\n   */\n  getLastVisibleRow() {\n    const wot = this.hot.view._wt;\n    if (wot.wtViewport.rowsVisibleCalculator) {\n      return wot.wtTable.getLastVisibleRow();\n    }\n    if (wot.wtViewport.rowsRenderCalculator) {\n      return wot.wtTable.getLastRenderedRow();\n    }\n    return -1;\n  }\n\n  /**\n   * Clears cached heights.\n   */\n  clearCache() {\n    this.headerHeight = null;\n    this.rowHeightsMap.init();\n  }\n\n  /**\n   * Clears cache by range.\n   *\n   * @param {object|number} range Row index or an object with `from` and `to` properties which define row range.\n   */\n  clearCacheByRange(range) {\n    const {\n      from,\n      to\n    } = typeof range === 'number' ? {\n      from: range,\n      to: range\n    } : range;\n    this.hot.batchExecution(() => {\n      rangeEach(Math.min(from, to), Math.max(from, to), row => {\n        this.rowHeightsMap.setValueAtIndex(row, null);\n      });\n    }, true);\n  }\n\n  /**\n   * Checks if all heights were calculated. If not then return `true` (need recalculate).\n   *\n   * @returns {boolean}\n   */\n  isNeedRecalculate() {\n    return !!arrayFilter(this.rowHeightsMap.getValues().slice(0, this.measuredRows), item => item === null).length;\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    this.ghostTable.clean();\n    super.destroy();\n  }\n}\nfunction _onBeforeViewRender2() {\n  const force = this.hot.renderCall;\n  const fixedRowsBottom = this.hot.getSettings().fixedRowsBottom;\n  const firstVisibleRow = this.getFirstVisibleRow();\n  const lastVisibleRow = this.getLastVisibleRow();\n  if (firstVisibleRow === -1 || lastVisibleRow === -1) {\n    return;\n  }\n  this.calculateRowsHeight({\n    from: firstVisibleRow,\n    to: lastVisibleRow\n  }, undefined, force);\n\n  // Calculate rows height synchronously for bottom overlay\n  if (fixedRowsBottom) {\n    const totalRows = this.hot.countRows() - 1;\n    this.calculateRowsHeight({\n      from: totalRows - fixedRowsBottom,\n      to: totalRows\n    });\n  }\n  if (this.isNeedRecalculate() && !this.inProgress) {\n    this.calculateAllRowsHeight();\n  }\n}\nfunction _onBeforeRowResize2(size, row, isDblClick) {\n  let newSize = size;\n  if (isDblClick) {\n    this.calculateRowsHeight(row, undefined, true);\n    newSize = this.getRowHeight(row);\n  }\n  return newSize;\n}\nfunction _onAfterLoadData2() {\n  if (this.hot.view) {\n    this.recalculateAllRowsHeight();\n  } else {\n    // first load - initialization\n    this.hot._registerTimeout(() => {\n      if (this.hot) {\n        this.recalculateAllRowsHeight();\n      }\n    });\n  }\n}\nfunction _onBeforeChange2(changes) {\n  let range = null;\n  if (changes.length === 1) {\n    range = changes[0][0];\n  } else if (changes.length > 1) {\n    range = {\n      from: changes[0][0],\n      to: changes[changes.length - 1][0]\n    };\n  }\n  if (range !== null) {\n    this.clearCacheByRange(range);\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","privateCollection","has","TypeError","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateMethodGet","receiver","fn","BasePlugin","arrayEach","arrayFilter","cancelAnimationFrame","requestAnimationFrame","isVisible","GhostTable","isObject","hasOwnProperty","valueAccordingPercent","rangeEach","SamplesGenerator","isPercentValue","PhysicalIndexToValueMap","IndexToValueMap","PLUGIN_KEY","PLUGIN_PRIORITY","ROW_WIDTHS_MAP_NAME","_onBeforeViewRender","WeakSet","_onBeforeRowResize","_onAfterLoadData","_onBeforeChange","AutoRowSize","SETTING_KEYS","CALCULATION_STEP","SYNC_CALCULATION_LIMIT","constructor","hotInstance","hot","row","column","cellMeta","getCellMeta","hidden","cellValue","getDataAtCell","getColHeader","rowIndexMapper","registerMap","rowHeightsMap","addHook","size","isDblClick","_onBeforeRowResize2","isEnabled","settings","getSettings","enablePlugin","_this","enabled","setSamplingOptions","_len","arguments","length","args","Array","_key","_onAfterLoadData2","changes","_onBeforeChange2","recalculateAllRowsHeight","force","_onBeforeViewRender2","height","getRowHeight","getColumnHeaderHeight","disablePlugin","headerHeight","calculateRowsHeight","rowRange","undefined","from","to","countRows","colRange","countCols","rowsRange","columnsRange","samples","samplesGenerator","generateRowSamples","ghostTable","addColumnHeadersRow","get","getValueAtIndex","_ref","rowIndex","sample","addRow","rows","batchExecution","getHeights","setValueAtIndex","toPhysicalRow","measuredRows","clean","calculateAllRowsHeight","current","timer","inProgress","loop","Math","min","view","adjustElementsSize","_wt","wtOverlays","inlineStartOverlay","needFullRender","clone","draw","syncLimit","getSyncCalculationLimit","firstCalculation","setting","samplingRatio","allowSampleDuplicates","isNaN","setSampleCount","parseInt","setAllowDuplicates","wtTable","TABLE","clearCache","limit","rowsLimit","defaultHeight","cachedHeight","getFirstVisibleRow","wot","wtViewport","rowsVisibleCalculator","rowsRenderCalculator","getFirstRenderedRow","getLastVisibleRow","getLastRenderedRow","init","clearCacheByRange","range","max","isNeedRecalculate","getValues","slice","item","destroy","renderCall","fixedRowsBottom","firstVisibleRow","lastVisibleRow","totalRows","newSize","_registerTimeout"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/autoRowSize/autoRowSize.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { arrayEach, arrayFilter } from \"../../helpers/array.mjs\";\nimport { cancelAnimationFrame, requestAnimationFrame } from \"../../helpers/feature.mjs\";\nimport { isVisible } from \"../../helpers/dom/element.mjs\";\nimport GhostTable from \"../../utils/ghostTable.mjs\";\nimport { isObject, hasOwnProperty } from \"../../helpers/object.mjs\";\nimport { valueAccordingPercent, rangeEach } from \"../../helpers/number.mjs\";\nimport SamplesGenerator from \"../../utils/samplesGenerator.mjs\";\nimport { isPercentValue } from \"../../helpers/string.mjs\";\nimport { PhysicalIndexToValueMap as IndexToValueMap } from \"../../translations/index.mjs\";\nexport const PLUGIN_KEY = 'autoRowSize';\nexport const PLUGIN_PRIORITY = 40;\nconst ROW_WIDTHS_MAP_NAME = 'autoRowSize';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @plugin AutoRowSize\n * @class AutoRowSize\n * @description\n * The `AutoRowSize` plugin allows you to set row heights based on their highest cells.\n *\n * By default, the plugin is declared as `undefined`, which makes it disabled (same as if it was declared as `false`).\n * Enabling this plugin may decrease the overall table performance, as it needs to calculate the heights of all cells to\n * resize the rows accordingly.\n * If you experience problems with the performance, try turning this feature off and declaring the row heights manually.\n *\n * But, to display Handsontable's [scrollbar](https://handsontable.com/docs/8.0.0/demo-scrolling.html)\n * in a proper size, you need to enable the `AutoRowSize` plugin,\n * by setting the [`autoRowSize`](@/api/options.md#autoRowSize) option to `true`.\n *\n * Row height calculations are divided into sync and async part. Each of this parts has their own advantages and\n * disadvantages. Synchronous calculations are faster but they block the browser UI, while the slower asynchronous\n * operations don't block the browser UI.\n *\n * To configure the sync/async distribution, you can pass an absolute value (number of rows) or a percentage value to a config object:\n * ```js\n * // as a number (300 rows in sync, rest async)\n * autoRowSize: {syncLimit: 300},\n *\n * // as a string (percent)\n * autoRowSize: {syncLimit: '40%'},\n *\n * // allow sample duplication\n * autoRowSize: {syncLimit: '40%', allowSampleDuplicates: true},\n * ```\n *\n * You can also use the `allowSampleDuplicates` option to allow sampling duplicate values when calculating the row\n * height. __Note__, that this might have a negative impact on performance.\n *\n * To configure this plugin see {@link Options#autoRowSize}.\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *   data: getData(),\n *   autoRowSize: true\n * });\n * // Access to plugin instance:\n * const plugin = hot.getPlugin('autoRowSize');\n *\n * plugin.getRowHeight(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * // First, let's contruct Handsontable\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   autoRowSize={true}\n * />\n *\n * ...\n *\n * // Access to plugin instance:\n * const hot = hotRef.current.hotInstance;\n * const plugin = hot.getPlugin('autoRowSize');\n *\n * plugin.getRowHeight(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _onBeforeViewRender = /*#__PURE__*/new WeakSet();\nvar _onBeforeRowResize = /*#__PURE__*/new WeakSet();\nvar _onAfterLoadData = /*#__PURE__*/new WeakSet();\nvar _onBeforeChange = /*#__PURE__*/new WeakSet();\nexport class AutoRowSize extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return true;\n  }\n  static get CALCULATION_STEP() {\n    return 50;\n  }\n  static get SYNC_CALCULATION_LIMIT() {\n    return 500;\n  }\n\n  /**\n   * Columns header's height cache.\n   *\n   * @private\n   * @type {number}\n   */\n\n  constructor(hotInstance) {\n    super(hotInstance);\n    /**\n     * On before change listener.\n     *\n     * @param {Array} changes 2D array containing information about each of the edited cells.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeChange);\n    /**\n     * On after load data listener.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterLoadData);\n    /**\n     * On before row resize listener.\n     *\n     * @param {number} size The size of the current row index.\n     * @param {number} row Current row index.\n     * @param {boolean} isDblClick Indicates if the resize was triggered by doubleclick.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeRowResize);\n    /**\n     * On before view render listener.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeViewRender);\n    _defineProperty(this, \"headerHeight\", null);\n    /**\n     * Instance of {@link GhostTable} for rows and columns size calculations.\n     *\n     * @private\n     * @type {GhostTable}\n     */\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot));\n    /**\n     * Instance of {@link SamplesGenerator} for generating samples necessary for rows height calculations.\n     *\n     * @private\n     * @type {SamplesGenerator}\n     */\n    _defineProperty(this, \"samplesGenerator\", new SamplesGenerator((row, column) => {\n      if (row >= 0 && column >= 0) {\n        const cellMeta = this.hot.getCellMeta(row, column);\n        if (cellMeta.hidden) {\n          // do not generate samples for cells that are covered by merged cell (null values)\n          return false;\n        }\n      }\n      let cellValue;\n      if (row >= 0) {\n        cellValue = this.hot.getDataAtCell(row, column);\n      } else if (row === -1) {\n        cellValue = this.hot.getColHeader(column);\n      }\n      return {\n        value: cellValue\n      };\n    }));\n    /**\n     * `true` if only the first calculation was performed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"firstCalculation\", true);\n    /**\n     * `true` if the size calculation is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Number of already measured rows (we already know their sizes).\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"measuredRows\", 0);\n    /**\n     * PhysicalIndexToValueMap to keep and track heights for physical row indexes.\n     *\n     * @private\n     * @type {PhysicalIndexToValueMap}\n     */\n    _defineProperty(this, \"rowHeightsMap\", new IndexToValueMap());\n    this.hot.rowIndexMapper.registerMap(ROW_WIDTHS_MAP_NAME, this.rowHeightsMap);\n\n    // Leave the listener active to allow auto-sizing the rows when the plugin is disabled.\n    // This is necessary for height recalculation for resize handler doubleclick (ManualRowResize).\n    this.addHook('beforeRowResize', (size, row, isDblClick) => _classPrivateMethodGet(this, _onBeforeRowResize, _onBeforeRowResize2).call(this, size, row, isDblClick));\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    return settings === true || isObject(settings);\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.setSamplingOptions();\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onAfterLoadData, _onAfterLoadData2).call(_this, ...args);\n    });\n    this.addHook('beforeChangeRender', changes => _classPrivateMethodGet(this, _onBeforeChange, _onBeforeChange2).call(this, changes));\n    this.addHook('beforeColumnResize', () => this.recalculateAllRowsHeight());\n    this.addHook('beforeViewRender', force => _classPrivateMethodGet(this, _onBeforeViewRender, _onBeforeViewRender2).call(this, force));\n    this.addHook('modifyRowHeight', (height, row) => this.getRowHeight(row, height));\n    this.addHook('modifyColumnHeaderHeight', () => this.getColumnHeaderHeight());\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.headerHeight = null;\n    super.disablePlugin();\n\n    // Leave the listener active to allow auto-sizing the rows when the plugin is disabled.\n    // This is necesseary for height recalculation for resize handler doubleclick (ManualRowResize).\n    this.addHook('beforeRowResize', (size, row, isDblClick) => _classPrivateMethodGet(this, _onBeforeRowResize, _onBeforeRowResize2).call(this, size, row, isDblClick));\n  }\n\n  /**\n   * Calculate a given rows height.\n   *\n   * @param {number|object} rowRange Row index or an object with `from` and `to` indexes as a range.\n   * @param {number|object} colRange Column index or an object with `from` and `to` indexes as a range.\n   * @param {boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateRowsHeight() {\n    let rowRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let colRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // eslint-disable-line max-len\n    const rowsRange = typeof rowRange === 'number' ? {\n      from: rowRange,\n      to: rowRange\n    } : rowRange;\n    const columnsRange = typeof colRange === 'number' ? {\n      from: colRange,\n      to: colRange\n    } : colRange;\n    if (this.hot.getColHeader(0) !== null) {\n      const samples = this.samplesGenerator.generateRowSamples(-1, columnsRange);\n      this.ghostTable.addColumnHeadersRow(samples.get(-1));\n    }\n    rangeEach(rowsRange.from, rowsRange.to, row => {\n      // For rows we must calculate row height even when user had set height value manually.\n      // We can shrink column but cannot shrink rows!\n      if (force || this.rowHeightsMap.getValueAtIndex(row) === null) {\n        const samples = this.samplesGenerator.generateRowSamples(row, columnsRange);\n        arrayEach(samples, _ref => {\n          let [rowIndex, sample] = _ref;\n          return this.ghostTable.addRow(rowIndex, sample);\n        });\n      }\n    });\n    if (this.ghostTable.rows.length) {\n      this.hot.batchExecution(() => {\n        this.ghostTable.getHeights((row, height) => {\n          if (row < 0) {\n            this.headerHeight = height;\n          } else {\n            this.rowHeightsMap.setValueAtIndex(this.hot.toPhysicalRow(row), height);\n          }\n        });\n      }, true);\n      this.measuredRows = rowsRange.to + 1;\n      this.ghostTable.clean();\n    }\n  }\n\n  /**\n   * Calculate all rows heights. The calculated row will be cached in the {@link AutoRowSize#heights} property.\n   * To retrieve height for specified row use {@link AutoRowSize#getRowHeight} method.\n   *\n   * @param {object|number} colRange Row index or an object with `from` and `to` properties which define row range.\n   */\n  calculateAllRowsHeight() {\n    let colRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let current = 0;\n    const length = this.hot.countRows() - 1;\n    let timer = null;\n    this.inProgress = true;\n    const loop = () => {\n      // When hot was destroyed after calculating finished cancel frame\n      if (!this.hot) {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n        return;\n      }\n      this.calculateRowsHeight({\n        from: current,\n        to: Math.min(current + AutoRowSize.CALCULATION_STEP, length)\n      }, colRange);\n      current = current + AutoRowSize.CALCULATION_STEP + 1;\n      if (current < length) {\n        timer = requestAnimationFrame(loop);\n      } else {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n\n        // @TODO Should call once per render cycle, currently fired separately in different plugins\n        this.hot.view.adjustElementsSize(true);\n\n        // tmp\n        if (this.hot.view._wt.wtOverlays.inlineStartOverlay.needFullRender) {\n          this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.draw();\n        }\n      }\n    };\n    const syncLimit = this.getSyncCalculationLimit();\n\n    // sync\n    if (this.firstCalculation && syncLimit >= 0) {\n      this.calculateRowsHeight({\n        from: 0,\n        to: syncLimit\n      }, colRange);\n      this.firstCalculation = false;\n      current = syncLimit + 1;\n    }\n    // async\n    if (current < length) {\n      loop();\n    } else {\n      this.inProgress = false;\n      this.hot.view.adjustElementsSize(false);\n    }\n  }\n\n  /**\n   * Sets the sampling options.\n   *\n   * @private\n   */\n  setSamplingOptions() {\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    const samplingRatio = setting && hasOwnProperty(setting, 'samplingRatio') ? setting.samplingRatio : undefined;\n    const allowSampleDuplicates = setting && hasOwnProperty(setting, 'allowSampleDuplicates') ? setting.allowSampleDuplicates : undefined;\n    if (samplingRatio && !isNaN(samplingRatio)) {\n      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));\n    }\n    if (allowSampleDuplicates) {\n      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);\n    }\n  }\n\n  /**\n   * Recalculates all rows height (overwrite cache values).\n   */\n  recalculateAllRowsHeight() {\n    if (isVisible(this.hot.view._wt.wtTable.TABLE)) {\n      this.clearCache();\n      this.calculateAllRowsHeight();\n    }\n  }\n\n  /**\n   * Gets value which tells how many rows should be calculated synchronously (rest of the rows will be calculated\n   * asynchronously). The limit is calculated based on `syncLimit` set to autoRowSize option (see {@link Options#autoRowSize}).\n   *\n   * @returns {number}\n   */\n  getSyncCalculationLimit() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    /* eslint-disable no-bitwise */\n    let limit = AutoRowSize.SYNC_CALCULATION_LIMIT;\n    const rowsLimit = this.hot.countRows() - 1;\n    if (isObject(settings)) {\n      limit = settings.syncLimit;\n      if (isPercentValue(limit)) {\n        limit = valueAccordingPercent(rowsLimit, limit);\n      } else {\n        // Force to Number\n        limit >>= 0;\n      }\n    }\n    return Math.min(limit, rowsLimit);\n  }\n\n  /**\n   * Get a row's height, as measured in the DOM.\n   *\n   * The height returned includes 1 px of the row's bottom border.\n   *\n   * Mind that this method is different from the\n   * [`getRowHeight()`](@/api/core.md#getrowheight) method\n   * of Handsontable's [Core](@/api/core.md).\n   *\n   * @param {number} row A visual row index.\n   * @param {number} [defaultHeight] If no height is found, `defaultHeight` is returned instead.\n   * @returns {number} The height of the specified row, in pixels.\n   */\n  getRowHeight(row) {\n    let defaultHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    const cachedHeight = row < 0 ? this.headerHeight : this.rowHeightsMap.getValueAtIndex(this.hot.toPhysicalRow(row));\n    let height = defaultHeight;\n    if (cachedHeight !== null && cachedHeight > (defaultHeight || 0)) {\n      height = cachedHeight;\n    }\n    return height;\n  }\n\n  /**\n   * Get the calculated column header height.\n   *\n   * @returns {number|undefined}\n   */\n  getColumnHeaderHeight() {\n    return this.headerHeight;\n  }\n\n  /**\n   * Get the first visible row.\n   *\n   * @returns {number} Returns row index, -1 if table is not rendered or if there are no rows to base the the calculations on.\n   */\n  getFirstVisibleRow() {\n    const wot = this.hot.view._wt;\n    if (wot.wtViewport.rowsVisibleCalculator) {\n      return wot.wtTable.getFirstVisibleRow();\n    }\n    if (wot.wtViewport.rowsRenderCalculator) {\n      return wot.wtTable.getFirstRenderedRow();\n    }\n    return -1;\n  }\n\n  /**\n   * Gets the last visible row.\n   *\n   * @returns {number} Returns row index or -1 if table is not rendered.\n   */\n  getLastVisibleRow() {\n    const wot = this.hot.view._wt;\n    if (wot.wtViewport.rowsVisibleCalculator) {\n      return wot.wtTable.getLastVisibleRow();\n    }\n    if (wot.wtViewport.rowsRenderCalculator) {\n      return wot.wtTable.getLastRenderedRow();\n    }\n    return -1;\n  }\n\n  /**\n   * Clears cached heights.\n   */\n  clearCache() {\n    this.headerHeight = null;\n    this.rowHeightsMap.init();\n  }\n\n  /**\n   * Clears cache by range.\n   *\n   * @param {object|number} range Row index or an object with `from` and `to` properties which define row range.\n   */\n  clearCacheByRange(range) {\n    const {\n      from,\n      to\n    } = typeof range === 'number' ? {\n      from: range,\n      to: range\n    } : range;\n    this.hot.batchExecution(() => {\n      rangeEach(Math.min(from, to), Math.max(from, to), row => {\n        this.rowHeightsMap.setValueAtIndex(row, null);\n      });\n    }, true);\n  }\n\n  /**\n   * Checks if all heights were calculated. If not then return `true` (need recalculate).\n   *\n   * @returns {boolean}\n   */\n  isNeedRecalculate() {\n    return !!arrayFilter(this.rowHeightsMap.getValues().slice(0, this.measuredRows), item => item === null).length;\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    this.ghostTable.clean();\n    super.destroy();\n  }\n}\nfunction _onBeforeViewRender2() {\n  const force = this.hot.renderCall;\n  const fixedRowsBottom = this.hot.getSettings().fixedRowsBottom;\n  const firstVisibleRow = this.getFirstVisibleRow();\n  const lastVisibleRow = this.getLastVisibleRow();\n  if (firstVisibleRow === -1 || lastVisibleRow === -1) {\n    return;\n  }\n  this.calculateRowsHeight({\n    from: firstVisibleRow,\n    to: lastVisibleRow\n  }, undefined, force);\n\n  // Calculate rows height synchronously for bottom overlay\n  if (fixedRowsBottom) {\n    const totalRows = this.hot.countRows() - 1;\n    this.calculateRowsHeight({\n      from: totalRows - fixedRowsBottom,\n      to: totalRows\n    });\n  }\n  if (this.isNeedRecalculate() && !this.inProgress) {\n    this.calculateAllRowsHeight();\n  }\n}\nfunction _onBeforeRowResize2(size, row, isDblClick) {\n  let newSize = size;\n  if (isDblClick) {\n    this.calculateRowsHeight(row, undefined, true);\n    newSize = this.getRowHeight(row);\n  }\n  return newSize;\n}\nfunction _onAfterLoadData2() {\n  if (this.hot.view) {\n    this.recalculateAllRowsHeight();\n  } else {\n    // first load - initialization\n    this.hot._registerTimeout(() => {\n      if (this.hot) {\n        this.recalculateAllRowsHeight();\n      }\n    });\n  }\n}\nfunction _onBeforeChange2(changes) {\n  let range = null;\n  if (changes.length === 1) {\n    range = changes[0][0];\n  } else if (changes.length > 1) {\n    range = {\n      from: changes[0][0],\n      to: changes[changes.length - 1][0]\n    };\n  }\n  if (range !== null) {\n    this.clearCacheByRange(range);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}