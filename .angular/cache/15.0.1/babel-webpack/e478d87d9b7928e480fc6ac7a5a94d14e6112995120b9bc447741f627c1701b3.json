{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { innerHeight, innerWidth, getScrollLeft, getScrollTop, offset } from \"../../../helpers/dom/element.mjs\";\n/**\n * @class Scroll\n */\nclass Scroll {\n  /**\n   * @param {ScrollDao} dataAccessObject Tha data access object.\n   */\n  constructor(dataAccessObject) {\n    /**\n     * The data access object.\n     *\n     * @protected\n     * @type {ScrollDao}\n     */\n    _defineProperty(this, \"dataAccessObject\", void 0);\n    /**\n     * Holds the last column reached by the scroll, which determines the scroll snapping direction\n     * (left or right) for a next horizontal scroll.\n     *\n     * @protected\n     * @type {number}\n     */\n    _defineProperty(this, \"lastScrolledColumnPos\", -1);\n    /**\n     * Holds the last row reached by the scroll, which determines the scroll snapping direction\n     * (top or bottom) for a next vertical scroll.\n     *\n     * @protected\n     * @type {number}\n     */\n    _defineProperty(this, \"lastScrolledRowPos\", -1);\n    this.dataAccessObject = dataAccessObject;\n  }\n\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    const scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n    const scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n    return scrolledHorizontally || scrolledVertically;\n  }\n\n  /**\n   * Scrolls viewport to a column.\n   *\n   * @param {number} column Visual column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    const {\n      drawn,\n      totalColumns\n    } = this.dataAccessObject;\n\n    // do not scroll the viewport when the column points to a range outside of the dataset\n    if (!drawn || !Number.isInteger(column) || column < 0 || column > totalColumns) {\n      return false;\n    }\n    const firstVisibleColumn = this.getFirstVisibleColumn();\n    const lastVisibleColumn = this.getLastVisibleColumn();\n    const autoSnapping = snapToRight === undefined && snapToLeft === undefined;\n    const {\n      fixedColumnsStart,\n      inlineStartOverlay\n    } = this.dataAccessObject;\n\n    // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n    // when the columns points to the overlays\n    if (autoSnapping && column < fixedColumnsStart) {\n      return false;\n    }\n    let result = false;\n    column = this.dataAccessObject.wtSettings.getSetting('onBeforeViewportScrollHorizontally', column);\n\n    // if there is no fully visible columns use the supporting variable (lastScrolledColumnPos) to\n    // determine the snapping direction (left or right)\n    if (firstVisibleColumn === -1) {\n      result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > this.lastScrolledColumnPos : snapToRight);\n    } else if (autoSnapping && (column < firstVisibleColumn || column > lastVisibleColumn) || !autoSnapping) {\n      // if there is at least one fully visible column determine the snapping direction based on\n      // that columns or by snapToRight/snapToLeft flags, if provided.\n      result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > lastVisibleColumn : snapToRight);\n    }\n    if (result) {\n      this.lastScrolledColumnPos = column;\n    }\n    return result;\n  }\n\n  /**\n   * Scrolls viewport to a row.\n   *\n   * @param {number} row Visual row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    const {\n      drawn,\n      totalRows\n    } = this.dataAccessObject;\n\n    // do not scroll the viewport when the row points to a range outside of the dataset\n    if (!drawn || !Number.isInteger(row) || row < 0 || row > totalRows) {\n      return false;\n    }\n    const firstVisibleRow = this.getFirstVisibleRow();\n    const lastVisibleRow = this.getLastVisibleRow();\n    const autoSnapping = snapToTop === undefined && snapToBottom === undefined;\n    const {\n      fixedRowsBottom,\n      fixedRowsTop,\n      topOverlay\n    } = this.dataAccessObject;\n\n    // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n    // when the rows points to the overlays\n    if (autoSnapping && (row < fixedRowsTop || row > totalRows - fixedRowsBottom - 1)) {\n      return false;\n    }\n    let result = false;\n    row = this.dataAccessObject.wtSettings.getSetting('onBeforeViewportScrollVertically', row);\n\n    // if there is no fully visible rows use the supporting variable (lastScrolledRowPos) to\n    // determine the snapping direction (top or bottom)\n    if (firstVisibleRow === -1) {\n      result = topOverlay.scrollTo(row, autoSnapping ? row > this.lastScrolledRowPos : snapToBottom);\n    } else if (autoSnapping && (row < firstVisibleRow || row > lastVisibleRow) || !autoSnapping) {\n      // if there is at least one fully visible row determine the snapping direction based on\n      // that rows or by snapToTop/snapToBottom flags, if provided.\n      result = topOverlay.scrollTo(row, autoSnapping ? row > lastVisibleRow : snapToBottom);\n    }\n    if (result) {\n      this.lastScrolledRowPos = row;\n    }\n    return result;\n  }\n\n  /**\n   * Get first visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstVisibleRow() {\n    return this.dataAccessObject.wtTable.getFirstVisibleRow();\n  }\n\n  /**\n   * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastVisibleRow() {\n    const {\n      topOverlay,\n      wtTable,\n      wtViewport,\n      totalRows,\n      rootWindow\n    } = this.dataAccessObject;\n    let lastVisibleRow = wtTable.getLastVisibleRow();\n    if (topOverlay.mainTableScrollableElement === rootWindow) {\n      const rootElementOffset = offset(wtTable.wtRootElement);\n      const windowScrollTop = getScrollTop(rootWindow, rootWindow);\n\n      // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space\n      if (rootElementOffset.top > windowScrollTop) {\n        const windowHeight = innerHeight(rootWindow);\n        let rowsHeight = wtViewport.getColumnHeaderHeight();\n        for (let row = 1; row <= totalRows; row++) {\n          rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n          if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n            // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n            lastVisibleRow = row - 2;\n            break;\n          }\n        }\n      }\n    }\n    return lastVisibleRow;\n  }\n\n  /**\n   * Get first visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstVisibleColumn() {\n    return this.dataAccessObject.wtTable.getFirstVisibleColumn();\n  }\n\n  /**\n   * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastVisibleColumn() {\n    const {\n      wtSettings,\n      inlineStartOverlay,\n      wtTable,\n      wtViewport,\n      totalColumns,\n      rootWindow\n    } = this.dataAccessObject;\n    let lastVisibleColumn = wtTable.getLastVisibleColumn();\n    if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {\n      const isRtl = wtSettings.getSetting('rtlMode');\n      let inlineStartRootElementOffset = null;\n      if (isRtl) {\n        const tableRect = wtTable.TABLE.getBoundingClientRect();\n        const rootDocument = this.dataAccessObject.rootWindow.document;\n        const docOffsetWidth = rootDocument.documentElement.offsetWidth;\n        inlineStartRootElementOffset = Math.abs(tableRect.right - docOffsetWidth);\n      } else {\n        const rootElementOffset = offset(wtTable.wtRootElement);\n        inlineStartRootElementOffset = rootElementOffset.left;\n      }\n      const windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));\n\n      // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space\n      if (inlineStartRootElementOffset > windowScrollLeft) {\n        const windowWidth = innerWidth(rootWindow);\n        let columnsWidth = wtViewport.getRowHeaderWidth();\n        for (let column = 1; column <= totalColumns; column++) {\n          columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);\n          if (inlineStartRootElementOffset + columnsWidth - windowScrollLeft >= windowWidth) {\n            // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n            lastVisibleColumn = column - 2;\n            break;\n          }\n        }\n      }\n    }\n    return lastVisibleColumn;\n  }\n}\nexport default Scroll;","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","innerHeight","innerWidth","getScrollLeft","getScrollTop","offset","Scroll","constructor","dataAccessObject","scrollViewport","coords","snapToTop","snapToRight","snapToBottom","snapToLeft","scrolledHorizontally","scrollViewportHorizontally","col","scrolledVertically","scrollViewportVertically","row","column","drawn","totalColumns","isInteger","firstVisibleColumn","getFirstVisibleColumn","lastVisibleColumn","getLastVisibleColumn","autoSnapping","undefined","fixedColumnsStart","inlineStartOverlay","result","wtSettings","getSetting","scrollTo","lastScrolledColumnPos","totalRows","firstVisibleRow","getFirstVisibleRow","lastVisibleRow","getLastVisibleRow","fixedRowsBottom","fixedRowsTop","topOverlay","lastScrolledRowPos","wtTable","wtViewport","rootWindow","mainTableScrollableElement","rootElementOffset","wtRootElement","windowScrollTop","top","windowHeight","rowsHeight","getColumnHeaderHeight","sumCellSizes","isRtl","inlineStartRootElementOffset","tableRect","TABLE","getBoundingClientRect","rootDocument","document","docOffsetWidth","documentElement","offsetWidth","Math","abs","right","left","windowScrollLeft","windowWidth","columnsWidth","getRowHeaderWidth"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/3rdparty/walkontable/src/scroll.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { innerHeight, innerWidth, getScrollLeft, getScrollTop, offset } from \"../../../helpers/dom/element.mjs\";\n/**\n * @class Scroll\n */\nclass Scroll {\n  /**\n   * @param {ScrollDao} dataAccessObject Tha data access object.\n   */\n  constructor(dataAccessObject) {\n    /**\n     * The data access object.\n     *\n     * @protected\n     * @type {ScrollDao}\n     */\n    _defineProperty(this, \"dataAccessObject\", void 0);\n    /**\n     * Holds the last column reached by the scroll, which determines the scroll snapping direction\n     * (left or right) for a next horizontal scroll.\n     *\n     * @protected\n     * @type {number}\n     */\n    _defineProperty(this, \"lastScrolledColumnPos\", -1);\n    /**\n     * Holds the last row reached by the scroll, which determines the scroll snapping direction\n     * (top or bottom) for a next vertical scroll.\n     *\n     * @protected\n     * @type {number}\n     */\n    _defineProperty(this, \"lastScrolledRowPos\", -1);\n    this.dataAccessObject = dataAccessObject;\n  }\n\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    const scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n    const scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n    return scrolledHorizontally || scrolledVertically;\n  }\n\n  /**\n   * Scrolls viewport to a column.\n   *\n   * @param {number} column Visual column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    const {\n      drawn,\n      totalColumns\n    } = this.dataAccessObject;\n\n    // do not scroll the viewport when the column points to a range outside of the dataset\n    if (!drawn || !Number.isInteger(column) || column < 0 || column > totalColumns) {\n      return false;\n    }\n    const firstVisibleColumn = this.getFirstVisibleColumn();\n    const lastVisibleColumn = this.getLastVisibleColumn();\n    const autoSnapping = snapToRight === undefined && snapToLeft === undefined;\n    const {\n      fixedColumnsStart,\n      inlineStartOverlay\n    } = this.dataAccessObject;\n\n    // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n    // when the columns points to the overlays\n    if (autoSnapping && column < fixedColumnsStart) {\n      return false;\n    }\n    let result = false;\n    column = this.dataAccessObject.wtSettings.getSetting('onBeforeViewportScrollHorizontally', column);\n\n    // if there is no fully visible columns use the supporting variable (lastScrolledColumnPos) to\n    // determine the snapping direction (left or right)\n    if (firstVisibleColumn === -1) {\n      result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > this.lastScrolledColumnPos : snapToRight);\n    } else if (autoSnapping && (column < firstVisibleColumn || column > lastVisibleColumn) || !autoSnapping) {\n      // if there is at least one fully visible column determine the snapping direction based on\n      // that columns or by snapToRight/snapToLeft flags, if provided.\n      result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > lastVisibleColumn : snapToRight);\n    }\n    if (result) {\n      this.lastScrolledColumnPos = column;\n    }\n    return result;\n  }\n\n  /**\n   * Scrolls viewport to a row.\n   *\n   * @param {number} row Visual row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    const {\n      drawn,\n      totalRows\n    } = this.dataAccessObject;\n\n    // do not scroll the viewport when the row points to a range outside of the dataset\n    if (!drawn || !Number.isInteger(row) || row < 0 || row > totalRows) {\n      return false;\n    }\n    const firstVisibleRow = this.getFirstVisibleRow();\n    const lastVisibleRow = this.getLastVisibleRow();\n    const autoSnapping = snapToTop === undefined && snapToBottom === undefined;\n    const {\n      fixedRowsBottom,\n      fixedRowsTop,\n      topOverlay\n    } = this.dataAccessObject;\n\n    // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n    // when the rows points to the overlays\n    if (autoSnapping && (row < fixedRowsTop || row > totalRows - fixedRowsBottom - 1)) {\n      return false;\n    }\n    let result = false;\n    row = this.dataAccessObject.wtSettings.getSetting('onBeforeViewportScrollVertically', row);\n\n    // if there is no fully visible rows use the supporting variable (lastScrolledRowPos) to\n    // determine the snapping direction (top or bottom)\n    if (firstVisibleRow === -1) {\n      result = topOverlay.scrollTo(row, autoSnapping ? row > this.lastScrolledRowPos : snapToBottom);\n    } else if (autoSnapping && (row < firstVisibleRow || row > lastVisibleRow) || !autoSnapping) {\n      // if there is at least one fully visible row determine the snapping direction based on\n      // that rows or by snapToTop/snapToBottom flags, if provided.\n      result = topOverlay.scrollTo(row, autoSnapping ? row > lastVisibleRow : snapToBottom);\n    }\n    if (result) {\n      this.lastScrolledRowPos = row;\n    }\n    return result;\n  }\n\n  /**\n   * Get first visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstVisibleRow() {\n    return this.dataAccessObject.wtTable.getFirstVisibleRow();\n  }\n\n  /**\n   * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastVisibleRow() {\n    const {\n      topOverlay,\n      wtTable,\n      wtViewport,\n      totalRows,\n      rootWindow\n    } = this.dataAccessObject;\n    let lastVisibleRow = wtTable.getLastVisibleRow();\n    if (topOverlay.mainTableScrollableElement === rootWindow) {\n      const rootElementOffset = offset(wtTable.wtRootElement);\n      const windowScrollTop = getScrollTop(rootWindow, rootWindow);\n\n      // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space\n      if (rootElementOffset.top > windowScrollTop) {\n        const windowHeight = innerHeight(rootWindow);\n        let rowsHeight = wtViewport.getColumnHeaderHeight();\n        for (let row = 1; row <= totalRows; row++) {\n          rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n          if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n            // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n            lastVisibleRow = row - 2;\n            break;\n          }\n        }\n      }\n    }\n    return lastVisibleRow;\n  }\n\n  /**\n   * Get first visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getFirstVisibleColumn() {\n    return this.dataAccessObject.wtTable.getFirstVisibleColumn();\n  }\n\n  /**\n   * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n   *\n   * @returns {number}\n   */\n  getLastVisibleColumn() {\n    const {\n      wtSettings,\n      inlineStartOverlay,\n      wtTable,\n      wtViewport,\n      totalColumns,\n      rootWindow\n    } = this.dataAccessObject;\n    let lastVisibleColumn = wtTable.getLastVisibleColumn();\n    if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {\n      const isRtl = wtSettings.getSetting('rtlMode');\n      let inlineStartRootElementOffset = null;\n      if (isRtl) {\n        const tableRect = wtTable.TABLE.getBoundingClientRect();\n        const rootDocument = this.dataAccessObject.rootWindow.document;\n        const docOffsetWidth = rootDocument.documentElement.offsetWidth;\n        inlineStartRootElementOffset = Math.abs(tableRect.right - docOffsetWidth);\n      } else {\n        const rootElementOffset = offset(wtTable.wtRootElement);\n        inlineStartRootElementOffset = rootElementOffset.left;\n      }\n      const windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));\n\n      // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space\n      if (inlineStartRootElementOffset > windowScrollLeft) {\n        const windowWidth = innerWidth(rootWindow);\n        let columnsWidth = wtViewport.getRowHeaderWidth();\n        for (let column = 1; column <= totalColumns; column++) {\n          columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);\n          if (inlineStartRootElementOffset + columnsWidth - windowScrollLeft >= windowWidth) {\n            // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n            lastVisibleColumn = column - 2;\n            break;\n          }\n        }\n      }\n    }\n    return lastVisibleColumn;\n  }\n}\nexport default Scroll;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}