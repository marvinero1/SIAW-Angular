{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport freezeColumnItem from \"./contextMenuItem/freezeColumn.mjs\";\nimport unfreezeColumnItem from \"./contextMenuItem/unfreezeColumn.mjs\";\nHooks.getSingleton().register('beforeColumnFreeze');\nHooks.getSingleton().register('afterColumnFreeze');\nHooks.getSingleton().register('beforeColumnUnfreeze');\nHooks.getSingleton().register('afterColumnUnfreeze');\nexport const PLUGIN_KEY = 'manualColumnFreeze';\nexport const PLUGIN_PRIORITY = 110;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin ManualColumnFreeze\n * @class ManualColumnFreeze\n *\n * @description\n * This plugin allows to manually \"freeze\" and \"unfreeze\" a column using an entry in the Context Menu or using API.\n * You can turn it on by setting a {@link Options#manualColumnFreeze} property to `true`.\n *\n * @example\n * ```js\n * // Enables the plugin\n * manualColumnFreeze: true,\n * ```\n */\nvar _afterFirstUse = /*#__PURE__*/new WeakMap();\nvar _addContextMenuEntry = /*#__PURE__*/new WeakSet();\nvar _onBeforeColumnMove = /*#__PURE__*/new WeakSet();\nexport class ManualColumnFreeze extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Prevents moving the columns from/to fixed area.\n     *\n     * @private\n     * @param {Array} columns Array of visual column indexes to be moved.\n     * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.\n     * @returns {boolean|undefined}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeColumnMove);\n    /**\n     * Adds the manualColumnFreeze context menu entries.\n     *\n     * @private\n     * @param {object} options Context menu options.\n     */\n    _classPrivateMethodInitSpec(this, _addContextMenuEntry);\n    /**\n     * Determines when the moving operation is allowed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _afterFirstUse, {\n      writable: true,\n      value: false\n    });\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link ManualColumnFreeze#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => _classPrivateMethodGet(this, _addContextMenuEntry, _addContextMenuEntry2).call(this, options));\n    this.addHook('beforeColumnMove', (columns, finalIndex) => _classPrivateMethodGet(this, _onBeforeColumnMove, _onBeforeColumnMove2).call(this, columns, finalIndex));\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    _classPrivateFieldSet(this, _afterFirstUse, false);\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`manualColumnFreeze`](@/api/options.md#manualcolumnfreeze)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  }\n\n  /**\n   * Freezes the specified column (adds it to fixed columns).\n   *\n   * `freezeColumn()` doesn't re-render the table,\n   * so you need to call the `render()` method afterward.\n   *\n   * @param {number} column Visual column index.\n   */\n  freezeColumn(column) {\n    const settings = this.hot.getSettings();\n    // columns are already fixed (frozen)\n    const freezePerformed = settings.fixedColumnsStart < this.hot.countCols() && column > settings.fixedColumnsStart - 1;\n    if (!_classPrivateFieldGet(this, _afterFirstUse)) {\n      _classPrivateFieldSet(this, _afterFirstUse, true);\n    }\n    const beforeColumnFreezeHook = this.hot.runHooks('beforeColumnFreeze', column, freezePerformed);\n    if (beforeColumnFreezeHook === false) {\n      return;\n    }\n    if (freezePerformed) {\n      this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);\n\n      // Since 12.0.0, the \"fixedColumnsLeft\" is replaced with the \"fixedColumnsStart\" option.\n      // However, keeping the old name still in effect. When both option names are used together,\n      // the error is thrown. To prevent that, the plugin needs to modify the original option key\n      // to bypass the validation.\n      settings._fixedColumnsStart += 1;\n    }\n    this.hot.runHooks('afterColumnFreeze', column, freezePerformed);\n  }\n\n  /**\n   * Unfreezes the given column (remove it from fixed columns and bring to it's previous position).\n   *\n   * @param {number} column Visual column index.\n   */\n  unfreezeColumn(column) {\n    const settings = this.hot.getSettings();\n    // columns are not fixed (not frozen)\n    const unfreezePerformed = settings.fixedColumnsStart > 0 && column <= settings.fixedColumnsStart - 1;\n    if (!_classPrivateFieldGet(this, _afterFirstUse)) {\n      _classPrivateFieldSet(this, _afterFirstUse, true);\n    }\n    const beforeColumnUnfreezeHook = this.hot.runHooks('beforeColumnUnfreeze', column, unfreezePerformed);\n    if (beforeColumnUnfreezeHook === false) {\n      return;\n    }\n    if (unfreezePerformed) {\n      // Since 12.0.0, the \"fixedColumnsLeft\" is replaced with the \"fixedColumnsStart\" option.\n      // However, keeping the old name still in effect. When both option names are used together,\n      // the error is thrown. To prevent that, the plugin needs to modify the original option key\n      // to bypass the validation.\n      settings._fixedColumnsStart -= 1;\n      this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);\n    }\n    this.hot.runHooks('afterColumnUnfreeze', column, unfreezePerformed);\n  }\n}\nfunction _addContextMenuEntry2(options) {\n  options.items.push({\n    name: '---------'\n  }, freezeColumnItem(this), unfreezeColumnItem(this));\n}\nfunction _onBeforeColumnMove2(columns, finalIndex) {\n  if (_classPrivateFieldGet(this, _afterFirstUse)) {\n    const freezeLine = this.hot.getSettings().fixedColumnsStart;\n\n    // Moving any column before the \"freeze line\" isn't possible.\n    if (finalIndex < freezeLine) {\n      return false;\n    }\n\n    // Moving frozen column isn't possible.\n    if (columns.some(column => column < freezeLine)) {\n      return false;\n    }\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","privateMap","value","set","privateCollection","has","TypeError","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","call","_classPrivateFieldSet","_classApplyDescriptorSet","action","writable","_classPrivateMethodGet","fn","BasePlugin","Hooks","freezeColumnItem","unfreezeColumnItem","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","_afterFirstUse","WeakMap","_addContextMenuEntry","WeakSet","_onBeforeColumnMove","ManualColumnFreeze","constructor","arguments","isEnabled","hot","getSettings","enablePlugin","enabled","addHook","options","_addContextMenuEntry2","columns","finalIndex","_onBeforeColumnMove2","disablePlugin","updatePlugin","freezeColumn","column","settings","freezePerformed","fixedColumnsStart","countCols","beforeColumnFreezeHook","runHooks","columnIndexMapper","moveIndexes","_fixedColumnsStart","unfreezeColumn","unfreezePerformed","beforeColumnUnfreezeHook","items","push","name","freezeLine","some"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/manualColumnFreeze/manualColumnFreeze.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport freezeColumnItem from \"./contextMenuItem/freezeColumn.mjs\";\nimport unfreezeColumnItem from \"./contextMenuItem/unfreezeColumn.mjs\";\nHooks.getSingleton().register('beforeColumnFreeze');\nHooks.getSingleton().register('afterColumnFreeze');\nHooks.getSingleton().register('beforeColumnUnfreeze');\nHooks.getSingleton().register('afterColumnUnfreeze');\nexport const PLUGIN_KEY = 'manualColumnFreeze';\nexport const PLUGIN_PRIORITY = 110;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin ManualColumnFreeze\n * @class ManualColumnFreeze\n *\n * @description\n * This plugin allows to manually \"freeze\" and \"unfreeze\" a column using an entry in the Context Menu or using API.\n * You can turn it on by setting a {@link Options#manualColumnFreeze} property to `true`.\n *\n * @example\n * ```js\n * // Enables the plugin\n * manualColumnFreeze: true,\n * ```\n */\nvar _afterFirstUse = /*#__PURE__*/new WeakMap();\nvar _addContextMenuEntry = /*#__PURE__*/new WeakSet();\nvar _onBeforeColumnMove = /*#__PURE__*/new WeakSet();\nexport class ManualColumnFreeze extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Prevents moving the columns from/to fixed area.\n     *\n     * @private\n     * @param {Array} columns Array of visual column indexes to be moved.\n     * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.\n     * @returns {boolean|undefined}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeColumnMove);\n    /**\n     * Adds the manualColumnFreeze context menu entries.\n     *\n     * @private\n     * @param {object} options Context menu options.\n     */\n    _classPrivateMethodInitSpec(this, _addContextMenuEntry);\n    /**\n     * Determines when the moving operation is allowed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _afterFirstUse, {\n      writable: true,\n      value: false\n    });\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link ManualColumnFreeze#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => _classPrivateMethodGet(this, _addContextMenuEntry, _addContextMenuEntry2).call(this, options));\n    this.addHook('beforeColumnMove', (columns, finalIndex) => _classPrivateMethodGet(this, _onBeforeColumnMove, _onBeforeColumnMove2).call(this, columns, finalIndex));\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    _classPrivateFieldSet(this, _afterFirstUse, false);\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`manualColumnFreeze`](@/api/options.md#manualcolumnfreeze)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  }\n\n  /**\n   * Freezes the specified column (adds it to fixed columns).\n   *\n   * `freezeColumn()` doesn't re-render the table,\n   * so you need to call the `render()` method afterward.\n   *\n   * @param {number} column Visual column index.\n   */\n  freezeColumn(column) {\n    const settings = this.hot.getSettings();\n    // columns are already fixed (frozen)\n    const freezePerformed = settings.fixedColumnsStart < this.hot.countCols() && column > settings.fixedColumnsStart - 1;\n    if (!_classPrivateFieldGet(this, _afterFirstUse)) {\n      _classPrivateFieldSet(this, _afterFirstUse, true);\n    }\n    const beforeColumnFreezeHook = this.hot.runHooks('beforeColumnFreeze', column, freezePerformed);\n    if (beforeColumnFreezeHook === false) {\n      return;\n    }\n    if (freezePerformed) {\n      this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);\n\n      // Since 12.0.0, the \"fixedColumnsLeft\" is replaced with the \"fixedColumnsStart\" option.\n      // However, keeping the old name still in effect. When both option names are used together,\n      // the error is thrown. To prevent that, the plugin needs to modify the original option key\n      // to bypass the validation.\n      settings._fixedColumnsStart += 1;\n    }\n    this.hot.runHooks('afterColumnFreeze', column, freezePerformed);\n  }\n\n  /**\n   * Unfreezes the given column (remove it from fixed columns and bring to it's previous position).\n   *\n   * @param {number} column Visual column index.\n   */\n  unfreezeColumn(column) {\n    const settings = this.hot.getSettings();\n    // columns are not fixed (not frozen)\n    const unfreezePerformed = settings.fixedColumnsStart > 0 && column <= settings.fixedColumnsStart - 1;\n    if (!_classPrivateFieldGet(this, _afterFirstUse)) {\n      _classPrivateFieldSet(this, _afterFirstUse, true);\n    }\n    const beforeColumnUnfreezeHook = this.hot.runHooks('beforeColumnUnfreeze', column, unfreezePerformed);\n    if (beforeColumnUnfreezeHook === false) {\n      return;\n    }\n    if (unfreezePerformed) {\n      // Since 12.0.0, the \"fixedColumnsLeft\" is replaced with the \"fixedColumnsStart\" option.\n      // However, keeping the old name still in effect. When both option names are used together,\n      // the error is thrown. To prevent that, the plugin needs to modify the original option key\n      // to bypass the validation.\n      settings._fixedColumnsStart -= 1;\n      this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);\n    }\n    this.hot.runHooks('afterColumnUnfreeze', column, unfreezePerformed);\n  }\n}\nfunction _addContextMenuEntry2(options) {\n  options.items.push({\n    name: '---------'\n  }, freezeColumnItem(this), unfreezeColumnItem(this));\n}\nfunction _onBeforeColumnMove2(columns, finalIndex) {\n  if (_classPrivateFieldGet(this, _afterFirstUse)) {\n    const freezeLine = this.hot.getSettings().fixedColumnsStart;\n\n    // Moving any column before the \"freeze line\" isn't possible.\n    if (finalIndex < freezeLine) {\n      return false;\n    }\n\n    // Moving frozen column isn't possible.\n    if (columns.some(column => column < freezeLine)) {\n      return false;\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}