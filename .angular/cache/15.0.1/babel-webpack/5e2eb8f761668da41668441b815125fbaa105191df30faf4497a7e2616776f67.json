{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { arrayEach, arrayFilter, arrayReduce, arrayMap } from \"../../helpers/array.mjs\";\nimport { cancelAnimationFrame, requestAnimationFrame } from \"../../helpers/feature.mjs\";\nimport GhostTable from \"../../utils/ghostTable.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { isObject, hasOwnProperty } from \"../../helpers/object.mjs\";\nimport { valueAccordingPercent, rangeEach } from \"../../helpers/number.mjs\";\nimport SamplesGenerator from \"../../utils/samplesGenerator.mjs\";\nimport { isPercentValue } from \"../../helpers/string.mjs\";\nimport { ViewportColumnsCalculator } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { PhysicalIndexToValueMap as IndexToValueMap } from \"../../translations/index.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nHooks.getSingleton().register('modifyAutoColumnSizeSeed');\nexport const PLUGIN_KEY = 'autoColumnSize';\nexport const PLUGIN_PRIORITY = 10;\nconst COLUMN_SIZE_MAP_NAME = 'autoColumnSize';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @plugin AutoColumnSize\n * @class AutoColumnSize\n *\n * @description\n * This plugin allows to set column widths based on their widest cells.\n *\n * By default, the plugin is declared as `undefined`, which makes it enabled (same as if it was declared as `true`).\n * Enabling this plugin may decrease the overall table performance, as it needs to calculate the widths of all cells to\n * resize the columns accordingly.\n * If you experience problems with the performance, try turning this feature off and declaring the column widths manually.\n *\n * Column width calculations are divided into sync and async part. Each of this parts has their own advantages and\n * disadvantages. Synchronous calculations are faster but they block the browser UI, while the slower asynchronous\n * operations don't block the browser UI.\n *\n * To configure the sync/async distribution, you can pass an absolute value (number of columns) or a percentage value to a config object:\n *\n * ```js\n * // as a number (300 columns in sync, rest async)\n * autoColumnSize: {syncLimit: 300},\n *\n * // as a string (percent)\n * autoColumnSize: {syncLimit: '40%'},\n * ```\n *\n * The plugin uses {@link GhostTable} and {@link SamplesGenerator} for calculations.\n * First, {@link SamplesGenerator} prepares samples of data with its coordinates.\n * Next {@link GhostTable} uses coordinates to get cells' renderers and append all to the DOM through DocumentFragment.\n *\n * Sampling accepts additional options:\n * - *samplingRatio* - Defines how many samples for the same length will be used to calculate. Default is `3`.\n *\n * ```js\n *   autoColumnSize: {\n *     samplingRatio: 10,\n *   }\n * ```\n *\n * - *allowSampleDuplicates* - Defines if duplicated values might be used in sampling. Default is `false`.\n *\n * ```js\n *   autoColumnSize: {\n *     allowSampleDuplicates: true,\n *   }\n * ```\n *\n * To configure this plugin see {@link Options#autoColumnSize}.\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *   data: getData(),\n *   autoColumnSize: true\n * });\n * // Access to plugin instance:\n * const plugin = hot.getPlugin('autoColumnSize');\n *\n * plugin.getColumnWidth(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * // First, let's contruct Handsontable\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   autoColumnSize={true}\n * />\n *\n * ...\n *\n * // Access to plugin instance:\n * const hot = hotRef.current.hotInstance;\n * const plugin = hot.getPlugin('autoColumnSize');\n *\n * plugin.getColumnWidth(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _cachedColumnHeaders = /*#__PURE__*/new WeakMap();\nvar _onBeforeViewRender = /*#__PURE__*/new WeakSet();\nvar _onAfterLoadData = /*#__PURE__*/new WeakSet();\nvar _onBeforeChange = /*#__PURE__*/new WeakSet();\nvar _onBeforeColumnResize = /*#__PURE__*/new WeakSet();\nvar _onAfterInit = /*#__PURE__*/new WeakSet();\nvar _onAfterFormulasValuesUpdate = /*#__PURE__*/new WeakSet();\nexport class AutoColumnSize extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return true;\n  }\n  static get CALCULATION_STEP() {\n    return 50;\n  }\n  static get SYNC_CALCULATION_LIMIT() {\n    return 50;\n  }\n\n  /**\n   * Instance of {@link GhostTable} for rows and columns size calculations.\n   *\n   * @private\n   * @type {GhostTable}\n   */\n\n  constructor(hotInstance) {\n    super(hotInstance);\n    /**\n     * After formulas values updated listener.\n     *\n     * @param {Array} changes An array of modified data.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterFormulasValuesUpdate);\n    /**\n     * On after Handsontable init fill plugin with all necessary values.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterInit);\n    /**\n     * On before column resize listener.\n     *\n     * @param {number} size Calculated new column width.\n     * @param {number} column Visual index of the resized column.\n     * @param {boolean} isDblClick  Flag that determines whether there was a double-click.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeColumnResize);\n    /**\n     * On before change listener.\n     *\n     * @param {Array} changes An array of modified data.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeChange);\n    /**\n     * On after load data listener.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterLoadData);\n    /**\n     * On before view render listener.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeViewRender);\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot));\n    /**\n     * Instance of {@link SamplesGenerator} for generating samples necessary for columns width calculations.\n     *\n     * @private\n     * @type {SamplesGenerator}\n     * @fires Hooks#modifyAutoColumnSizeSeed\n     */\n    _defineProperty(this, \"samplesGenerator\", new SamplesGenerator((row, column) => {\n      const cellMeta = this.hot.getCellMeta(row, column);\n      let cellValue = '';\n      if (!cellMeta.spanned) {\n        cellValue = this.hot.getDataAtCell(row, column);\n      }\n      let bundleSeed = '';\n      if (this.hot.hasHook('modifyAutoColumnSizeSeed')) {\n        bundleSeed = this.hot.runHooks('modifyAutoColumnSizeSeed', bundleSeed, cellMeta, cellValue);\n      }\n      return {\n        value: cellValue,\n        bundleSeed\n      };\n    }));\n    /**\n     * `true` only if the first calculation was performed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"firstCalculation\", true);\n    /**\n     * `true` if the size calculation is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Number of already measured columns (we already know their sizes).\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"measuredColumns\", 0);\n    /**\n     * PhysicalIndexToValueMap to keep and track widths for physical column indexes.\n     *\n     * @private\n     * @type {PhysicalIndexToValueMap}\n     */\n    _defineProperty(this, \"columnWidthsMap\", new IndexToValueMap());\n    /**\n     * Cached column header names. It is used to diff current column headers with previous state and detect which\n     * columns width should be updated.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _cachedColumnHeaders, {\n      writable: true,\n      value: []\n    });\n    this.hot.columnIndexMapper.registerMap(COLUMN_SIZE_MAP_NAME, this.columnWidthsMap);\n\n    // Leave the listener active to allow auto-sizing the columns when the plugin is disabled.\n    // This is necessary for width recalculation for resize handler doubleclick (ManualColumnResize).\n    this.addHook('beforeColumnResize', (size, column, isDblClick) => _classPrivateMethodGet(this, _onBeforeColumnResize, _onBeforeColumnResize2).call(this, size, column, isDblClick));\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link #enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return this.hot.getSettings()[PLUGIN_KEY] !== false && !this.hot.getSettings().colWidths;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    if (setting && setting.useHeaders !== null && setting.useHeaders !== undefined) {\n      this.ghostTable.setSetting('useHeaders', setting.useHeaders);\n    }\n    this.setSamplingOptions();\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onAfterLoadData, _onAfterLoadData2).call(_this, ...args);\n    });\n    this.addHook('beforeChangeRender', changes => _classPrivateMethodGet(this, _onBeforeChange, _onBeforeChange2).call(this, changes));\n    this.addHook('afterFormulasValuesUpdate', changes => _classPrivateMethodGet(this, _onAfterFormulasValuesUpdate, _onAfterFormulasValuesUpdate2).call(this, changes));\n    this.addHook('beforeViewRender', force => _classPrivateMethodGet(this, _onBeforeViewRender, _onBeforeViewRender2).call(this, force));\n    this.addHook('modifyColWidth', (width, col) => this.getColumnWidth(col, width));\n    this.addHook('afterInit', () => _classPrivateMethodGet(this, _onAfterInit, _onAfterInit2).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state. This method is executed when {@link Core#updateSettings} is invoked.\n   */\n  updatePlugin() {\n    const changedColumns = this.findColumnsWhereHeaderWasChanged();\n    if (changedColumns.length) {\n      this.clearCache(changedColumns);\n      this.calculateVisibleColumnsWidth();\n    }\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    super.disablePlugin();\n\n    // Leave the listener active to allow auto-sizing the columns when the plugin is disabled.\n    // This is necessary for width recalculation for resize handler doubleclick (ManualColumnResize).\n    this.addHook('beforeColumnResize', (size, column, isDblClick) => _classPrivateMethodGet(this, _onBeforeColumnResize, _onBeforeColumnResize2).call(this, size, column, isDblClick));\n  }\n\n  /**\n   * Calculates visible columns width.\n   */\n  calculateVisibleColumnsWidth() {\n    const rowsCount = this.hot.countRows();\n\n    // Keep last column widths unchanged for situation when all rows was deleted or trimmed (pro #6)\n    if (!rowsCount) {\n      return;\n    }\n    const force = this.hot.renderCall;\n    const firstVisibleColumn = this.getFirstVisibleColumn();\n    const lastVisibleColumn = this.getLastVisibleColumn();\n    if (firstVisibleColumn === -1 || lastVisibleColumn === -1) {\n      return;\n    }\n    this.calculateColumnsWidth({\n      from: firstVisibleColumn,\n      to: lastVisibleColumn\n    }, undefined, force);\n  }\n\n  /**\n   * Calculates a columns width.\n   *\n   * @param {number|object} colRange Visual column index or an object with `from` and `to` visual indexes as a range.\n   * @param {number|object} rowRange Visual row index or an object with `from` and `to` visual indexes as a range.\n   * @param {boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateColumnsWidth() {\n    let colRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let rowRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // eslint-disable-line max-len\n    const columnsRange = typeof colRange === 'number' ? {\n      from: colRange,\n      to: colRange\n    } : colRange;\n    const rowsRange = typeof rowRange === 'number' ? {\n      from: rowRange,\n      to: rowRange\n    } : rowRange;\n    rangeEach(columnsRange.from, columnsRange.to, visualColumn => {\n      let physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n      if (physicalColumn === null) {\n        physicalColumn = visualColumn;\n      }\n      if (force || this.columnWidthsMap.getValueAtIndex(physicalColumn) === null && !this.hot._getColWidthFromSettings(physicalColumn)) {\n        const samples = this.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);\n        arrayEach(samples, _ref => {\n          let [column, sample] = _ref;\n          return this.ghostTable.addColumn(column, sample);\n        });\n      }\n    });\n    if (this.ghostTable.columns.length) {\n      this.hot.batchExecution(() => {\n        this.ghostTable.getWidths((visualColumn, width) => {\n          const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n          this.columnWidthsMap.setValueAtIndex(physicalColumn, width);\n        });\n      }, true);\n      this.measuredColumns = columnsRange.to + 1;\n      this.ghostTable.clean();\n    }\n  }\n\n  /**\n   * Calculates all columns width. The calculated column will be cached in the {@link AutoColumnSize#widths} property.\n   * To retrieve width for specified column use {@link AutoColumnSize##getColumnWidth} method.\n   *\n   * @param {object|number} rowRange Row index or an object with `from` and `to` properties which define row range.\n   */\n  calculateAllColumnsWidth() {\n    let rowRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let current = 0;\n    const length = this.hot.countCols() - 1;\n    let timer = null;\n    this.inProgress = true;\n    const loop = () => {\n      // When hot was destroyed after calculating finished cancel frame\n      if (!this.hot) {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n        return;\n      }\n      this.calculateColumnsWidth({\n        from: current,\n        to: Math.min(current + AutoColumnSize.CALCULATION_STEP, length)\n      }, rowRange);\n      current = current + AutoColumnSize.CALCULATION_STEP + 1;\n      if (current < length) {\n        timer = requestAnimationFrame(loop);\n      } else {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n\n        // @TODO Should call once per render cycle, currently fired separately in different plugins\n        this.hot.view.adjustElementsSize();\n      }\n    };\n    const syncLimit = this.getSyncCalculationLimit();\n\n    // sync\n    if (this.firstCalculation && syncLimit >= 0) {\n      this.calculateColumnsWidth({\n        from: 0,\n        to: syncLimit\n      }, rowRange);\n      this.firstCalculation = false;\n      current = syncLimit + 1;\n    }\n    // async\n    if (current < length) {\n      loop();\n    } else {\n      this.inProgress = false;\n    }\n  }\n\n  /**\n   * Sets the sampling options.\n   *\n   * @private\n   */\n  setSamplingOptions() {\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    const samplingRatio = setting && hasOwnProperty(setting, 'samplingRatio') ? setting.samplingRatio : undefined;\n    const allowSampleDuplicates = setting && hasOwnProperty(setting, 'allowSampleDuplicates') ? setting.allowSampleDuplicates : undefined;\n    if (samplingRatio && !isNaN(samplingRatio)) {\n      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));\n    }\n    if (allowSampleDuplicates) {\n      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);\n    }\n  }\n\n  /**\n   * Recalculates all columns width (overwrite cache values).\n   */\n  recalculateAllColumnsWidth() {\n    if (this.hot.view && this.hot.view._wt.wtTable.isVisible()) {\n      this.clearCache();\n      this.calculateAllColumnsWidth();\n    }\n  }\n\n  /**\n   * Gets value which tells how many columns should be calculated synchronously (rest of the columns will be calculated\n   * asynchronously). The limit is calculated based on `syncLimit` set to `autoColumnSize` option (see {@link Options#autoColumnSize}).\n   *\n   * @returns {number}\n   */\n  getSyncCalculationLimit() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    /* eslint-disable no-bitwise */\n    let limit = AutoColumnSize.SYNC_CALCULATION_LIMIT;\n    const colsLimit = this.hot.countCols() - 1;\n    if (isObject(settings)) {\n      limit = settings.syncLimit;\n      if (isPercentValue(limit)) {\n        limit = valueAccordingPercent(colsLimit, limit);\n      } else {\n        // Force to Number\n        limit >>= 0;\n      }\n    }\n    return Math.min(limit, colsLimit);\n  }\n\n  /**\n   * Gets the calculated column width.\n   *\n   * @param {number} column Visual column index.\n   * @param {number} [defaultWidth] Default column width. It will be picked up if no calculated width found.\n   * @param {boolean} [keepMinimum=true] If `true` then returned value won't be smaller then 50 (default column width).\n   * @returns {number}\n   */\n  getColumnWidth(column) {\n    let defaultWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let keepMinimum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let width = defaultWidth;\n    if (width === undefined) {\n      width = this.columnWidthsMap.getValueAtIndex(this.hot.toPhysicalColumn(column));\n      if (keepMinimum && typeof width === 'number') {\n        width = Math.max(width, ViewportColumnsCalculator.DEFAULT_WIDTH);\n      }\n    }\n    return width;\n  }\n\n  /**\n   * Gets the first visible column.\n   *\n   * @returns {number} Returns visual column index, -1 if table is not rendered or if there are no columns to base the the calculations on.\n   */\n  getFirstVisibleColumn() {\n    const wot = this.hot.view._wt;\n    if (wot.wtViewport.columnsVisibleCalculator) {\n      // Fist fully visible column is stored as renderable index.\n      const firstFullyVisibleColumn = wot.wtTable.getFirstVisibleColumn();\n      if (firstFullyVisibleColumn !== -1) {\n        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstFullyVisibleColumn);\n      }\n    }\n    if (wot.wtViewport.columnsRenderCalculator) {\n      const firstRenderedColumn = wot.wtTable.getFirstRenderedColumn();\n\n      // There are no rendered column.\n      if (firstRenderedColumn !== -1) {\n        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstRenderedColumn);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Gets the last visible column.\n   *\n   * @returns {number} Returns visual column index or -1 if table is not rendered.\n   */\n  getLastVisibleColumn() {\n    const wot = this.hot.view._wt;\n    if (wot.wtViewport.columnsVisibleCalculator) {\n      // Last fully visible column is stored as renderable index.\n      const lastFullyVisibleColumn = wot.wtTable.getLastVisibleColumn();\n      if (lastFullyVisibleColumn !== -1) {\n        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastFullyVisibleColumn);\n      }\n    }\n    if (wot.wtViewport.columnsRenderCalculator) {\n      // Last fully visible column is stored as renderable index.\n      const lastRenderedColumn = wot.wtTable.getLastRenderedColumn();\n\n      // There are no rendered columns.\n      if (lastRenderedColumn !== -1) {\n        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastRenderedColumn);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Collects all columns which titles has been changed in comparison to the previous state.\n   *\n   * @private\n   * @returns {Array} It returns an array of physical column indexes.\n   */\n  findColumnsWhereHeaderWasChanged() {\n    const columnHeaders = this.hot.getColHeader();\n    const changedColumns = arrayReduce(columnHeaders, (acc, columnTitle, physicalColumn) => {\n      const cachedColumnsLength = _classPrivateFieldGet(this, _cachedColumnHeaders).length;\n      if (cachedColumnsLength - 1 < physicalColumn || _classPrivateFieldGet(this, _cachedColumnHeaders)[physicalColumn] !== columnTitle) {\n        acc.push(physicalColumn);\n      }\n      if (cachedColumnsLength - 1 < physicalColumn) {\n        _classPrivateFieldGet(this, _cachedColumnHeaders).push(columnTitle);\n      } else {\n        _classPrivateFieldGet(this, _cachedColumnHeaders)[physicalColumn] = columnTitle;\n      }\n      return acc;\n    }, []);\n    return changedColumns;\n  }\n\n  /**\n   * Clears cache of calculated column widths. If you want to clear only selected columns pass an array with their indexes.\n   * Otherwise whole cache will be cleared.\n   *\n   * @param {number[]} [columns] List of physical column indexes to clear.\n   */\n  clearCache() {\n    let columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    if (columns.length) {\n      this.hot.batchExecution(() => {\n        arrayEach(columns, physicalIndex => {\n          this.columnWidthsMap.setValueAtIndex(physicalIndex, null);\n        });\n      }, true);\n    } else {\n      this.columnWidthsMap.clear();\n    }\n  }\n\n  /**\n   * Checks if all widths were calculated. If not then return `true` (need recalculate).\n   *\n   * @returns {boolean}\n   */\n  isNeedRecalculate() {\n    return !!arrayFilter(this.columnWidthsMap.getValues().slice(0, this.measuredColumns), item => item === null).length;\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    this.ghostTable.clean();\n    super.destroy();\n  }\n}\nfunction _onBeforeViewRender2() {\n  this.calculateVisibleColumnsWidth();\n  if (this.isNeedRecalculate() && !this.inProgress) {\n    this.calculateAllColumnsWidth();\n  }\n}\nfunction _onAfterLoadData2() {\n  if (this.hot.view) {\n    this.recalculateAllColumnsWidth();\n  } else {\n    // first load - initialization\n    setTimeout(() => {\n      if (this.hot) {\n        this.recalculateAllColumnsWidth();\n      }\n    }, 0);\n  }\n}\nfunction _onBeforeChange2(changes) {\n  const changedColumns = arrayMap(changes, _ref2 => {\n    let [, columnProperty] = _ref2;\n    return this.hot.toPhysicalColumn(this.hot.propToCol(columnProperty));\n  });\n  this.clearCache(Array.from(new Set(changedColumns)));\n}\nfunction _onBeforeColumnResize2(size, column, isDblClick) {\n  let newSize = size;\n  if (isDblClick) {\n    this.calculateColumnsWidth(column, undefined, true);\n    newSize = this.getColumnWidth(column, undefined, false);\n  }\n  return newSize;\n}\nfunction _onAfterInit2() {\n  _classPrivateFieldSet(this, _cachedColumnHeaders, this.hot.getColHeader());\n}\nfunction _onAfterFormulasValuesUpdate2(changes) {\n  const filteredChanges = arrayFilter(changes, change => {\n    var _change$address;\n    return isDefined((_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.col);\n  });\n  const changedColumns = arrayMap(filteredChanges, change => change.address.col);\n  this.clearCache(Array.from(new Set(changedColumns)));\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","privateMap","value","set","privateCollection","has","TypeError","_defineProperty","key","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateFieldSet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorSet","_classPrivateFieldGet","_classApplyDescriptorGet","action","get","_classPrivateMethodGet","fn","BasePlugin","arrayEach","arrayFilter","arrayReduce","arrayMap","cancelAnimationFrame","requestAnimationFrame","GhostTable","Hooks","isObject","hasOwnProperty","valueAccordingPercent","rangeEach","SamplesGenerator","isPercentValue","ViewportColumnsCalculator","PhysicalIndexToValueMap","IndexToValueMap","isDefined","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","COLUMN_SIZE_MAP_NAME","_cachedColumnHeaders","WeakMap","_onBeforeViewRender","WeakSet","_onAfterLoadData","_onBeforeChange","_onBeforeColumnResize","_onAfterInit","_onAfterFormulasValuesUpdate","AutoColumnSize","SETTING_KEYS","CALCULATION_STEP","SYNC_CALCULATION_LIMIT","constructor","hotInstance","hot","row","column","cellMeta","getCellMeta","cellValue","spanned","getDataAtCell","bundleSeed","hasHook","runHooks","columnIndexMapper","registerMap","columnWidthsMap","addHook","size","isDblClick","_onBeforeColumnResize2","isEnabled","getSettings","colWidths","enablePlugin","_this","enabled","setting","useHeaders","undefined","ghostTable","setSetting","setSamplingOptions","_len","arguments","length","args","Array","_key","_onAfterLoadData2","changes","_onBeforeChange2","_onAfterFormulasValuesUpdate2","force","_onBeforeViewRender2","width","col","getColumnWidth","_onAfterInit2","updatePlugin","changedColumns","findColumnsWhereHeaderWasChanged","clearCache","calculateVisibleColumnsWidth","disablePlugin","rowsCount","countRows","renderCall","firstVisibleColumn","getFirstVisibleColumn","lastVisibleColumn","getLastVisibleColumn","calculateColumnsWidth","from","to","colRange","countCols","rowRange","columnsRange","rowsRange","visualColumn","physicalColumn","toPhysicalColumn","getValueAtIndex","_getColWidthFromSettings","samples","samplesGenerator","generateColumnSamples","_ref","sample","addColumn","columns","batchExecution","getWidths","setValueAtIndex","measuredColumns","clean","calculateAllColumnsWidth","current","timer","inProgress","loop","Math","min","view","adjustElementsSize","syncLimit","getSyncCalculationLimit","firstCalculation","samplingRatio","allowSampleDuplicates","isNaN","setSampleCount","parseInt","setAllowDuplicates","recalculateAllColumnsWidth","_wt","wtTable","isVisible","settings","limit","colsLimit","defaultWidth","keepMinimum","max","DEFAULT_WIDTH","wot","wtViewport","columnsVisibleCalculator","firstFullyVisibleColumn","getVisualFromRenderableIndex","columnsRenderCalculator","firstRenderedColumn","getFirstRenderedColumn","lastFullyVisibleColumn","lastRenderedColumn","getLastRenderedColumn","columnHeaders","getColHeader","acc","columnTitle","cachedColumnsLength","push","physicalIndex","clear","isNeedRecalculate","getValues","slice","item","destroy","setTimeout","_ref2","columnProperty","propToCol","Set","newSize","filteredChanges","change","_change$address","address"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/autoColumnSize/autoColumnSize.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { arrayEach, arrayFilter, arrayReduce, arrayMap } from \"../../helpers/array.mjs\";\nimport { cancelAnimationFrame, requestAnimationFrame } from \"../../helpers/feature.mjs\";\nimport GhostTable from \"../../utils/ghostTable.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { isObject, hasOwnProperty } from \"../../helpers/object.mjs\";\nimport { valueAccordingPercent, rangeEach } from \"../../helpers/number.mjs\";\nimport SamplesGenerator from \"../../utils/samplesGenerator.mjs\";\nimport { isPercentValue } from \"../../helpers/string.mjs\";\nimport { ViewportColumnsCalculator } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { PhysicalIndexToValueMap as IndexToValueMap } from \"../../translations/index.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nHooks.getSingleton().register('modifyAutoColumnSizeSeed');\nexport const PLUGIN_KEY = 'autoColumnSize';\nexport const PLUGIN_PRIORITY = 10;\nconst COLUMN_SIZE_MAP_NAME = 'autoColumnSize';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @plugin AutoColumnSize\n * @class AutoColumnSize\n *\n * @description\n * This plugin allows to set column widths based on their widest cells.\n *\n * By default, the plugin is declared as `undefined`, which makes it enabled (same as if it was declared as `true`).\n * Enabling this plugin may decrease the overall table performance, as it needs to calculate the widths of all cells to\n * resize the columns accordingly.\n * If you experience problems with the performance, try turning this feature off and declaring the column widths manually.\n *\n * Column width calculations are divided into sync and async part. Each of this parts has their own advantages and\n * disadvantages. Synchronous calculations are faster but they block the browser UI, while the slower asynchronous\n * operations don't block the browser UI.\n *\n * To configure the sync/async distribution, you can pass an absolute value (number of columns) or a percentage value to a config object:\n *\n * ```js\n * // as a number (300 columns in sync, rest async)\n * autoColumnSize: {syncLimit: 300},\n *\n * // as a string (percent)\n * autoColumnSize: {syncLimit: '40%'},\n * ```\n *\n * The plugin uses {@link GhostTable} and {@link SamplesGenerator} for calculations.\n * First, {@link SamplesGenerator} prepares samples of data with its coordinates.\n * Next {@link GhostTable} uses coordinates to get cells' renderers and append all to the DOM through DocumentFragment.\n *\n * Sampling accepts additional options:\n * - *samplingRatio* - Defines how many samples for the same length will be used to calculate. Default is `3`.\n *\n * ```js\n *   autoColumnSize: {\n *     samplingRatio: 10,\n *   }\n * ```\n *\n * - *allowSampleDuplicates* - Defines if duplicated values might be used in sampling. Default is `false`.\n *\n * ```js\n *   autoColumnSize: {\n *     allowSampleDuplicates: true,\n *   }\n * ```\n *\n * To configure this plugin see {@link Options#autoColumnSize}.\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *   data: getData(),\n *   autoColumnSize: true\n * });\n * // Access to plugin instance:\n * const plugin = hot.getPlugin('autoColumnSize');\n *\n * plugin.getColumnWidth(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * // First, let's contruct Handsontable\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   autoColumnSize={true}\n * />\n *\n * ...\n *\n * // Access to plugin instance:\n * const hot = hotRef.current.hotInstance;\n * const plugin = hot.getPlugin('autoColumnSize');\n *\n * plugin.getColumnWidth(4);\n *\n * if (plugin.isEnabled()) {\n *   // code...\n * }\n * ```\n * :::\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _cachedColumnHeaders = /*#__PURE__*/new WeakMap();\nvar _onBeforeViewRender = /*#__PURE__*/new WeakSet();\nvar _onAfterLoadData = /*#__PURE__*/new WeakSet();\nvar _onBeforeChange = /*#__PURE__*/new WeakSet();\nvar _onBeforeColumnResize = /*#__PURE__*/new WeakSet();\nvar _onAfterInit = /*#__PURE__*/new WeakSet();\nvar _onAfterFormulasValuesUpdate = /*#__PURE__*/new WeakSet();\nexport class AutoColumnSize extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return true;\n  }\n  static get CALCULATION_STEP() {\n    return 50;\n  }\n  static get SYNC_CALCULATION_LIMIT() {\n    return 50;\n  }\n\n  /**\n   * Instance of {@link GhostTable} for rows and columns size calculations.\n   *\n   * @private\n   * @type {GhostTable}\n   */\n\n  constructor(hotInstance) {\n    super(hotInstance);\n    /**\n     * After formulas values updated listener.\n     *\n     * @param {Array} changes An array of modified data.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterFormulasValuesUpdate);\n    /**\n     * On after Handsontable init fill plugin with all necessary values.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterInit);\n    /**\n     * On before column resize listener.\n     *\n     * @param {number} size Calculated new column width.\n     * @param {number} column Visual index of the resized column.\n     * @param {boolean} isDblClick  Flag that determines whether there was a double-click.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeColumnResize);\n    /**\n     * On before change listener.\n     *\n     * @param {Array} changes An array of modified data.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeChange);\n    /**\n     * On after load data listener.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterLoadData);\n    /**\n     * On before view render listener.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeViewRender);\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot));\n    /**\n     * Instance of {@link SamplesGenerator} for generating samples necessary for columns width calculations.\n     *\n     * @private\n     * @type {SamplesGenerator}\n     * @fires Hooks#modifyAutoColumnSizeSeed\n     */\n    _defineProperty(this, \"samplesGenerator\", new SamplesGenerator((row, column) => {\n      const cellMeta = this.hot.getCellMeta(row, column);\n      let cellValue = '';\n      if (!cellMeta.spanned) {\n        cellValue = this.hot.getDataAtCell(row, column);\n      }\n      let bundleSeed = '';\n      if (this.hot.hasHook('modifyAutoColumnSizeSeed')) {\n        bundleSeed = this.hot.runHooks('modifyAutoColumnSizeSeed', bundleSeed, cellMeta, cellValue);\n      }\n      return {\n        value: cellValue,\n        bundleSeed\n      };\n    }));\n    /**\n     * `true` only if the first calculation was performed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"firstCalculation\", true);\n    /**\n     * `true` if the size calculation is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Number of already measured columns (we already know their sizes).\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"measuredColumns\", 0);\n    /**\n     * PhysicalIndexToValueMap to keep and track widths for physical column indexes.\n     *\n     * @private\n     * @type {PhysicalIndexToValueMap}\n     */\n    _defineProperty(this, \"columnWidthsMap\", new IndexToValueMap());\n    /**\n     * Cached column header names. It is used to diff current column headers with previous state and detect which\n     * columns width should be updated.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _cachedColumnHeaders, {\n      writable: true,\n      value: []\n    });\n    this.hot.columnIndexMapper.registerMap(COLUMN_SIZE_MAP_NAME, this.columnWidthsMap);\n\n    // Leave the listener active to allow auto-sizing the columns when the plugin is disabled.\n    // This is necessary for width recalculation for resize handler doubleclick (ManualColumnResize).\n    this.addHook('beforeColumnResize', (size, column, isDblClick) => _classPrivateMethodGet(this, _onBeforeColumnResize, _onBeforeColumnResize2).call(this, size, column, isDblClick));\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link #enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return this.hot.getSettings()[PLUGIN_KEY] !== false && !this.hot.getSettings().colWidths;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    if (setting && setting.useHeaders !== null && setting.useHeaders !== undefined) {\n      this.ghostTable.setSetting('useHeaders', setting.useHeaders);\n    }\n    this.setSamplingOptions();\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onAfterLoadData, _onAfterLoadData2).call(_this, ...args);\n    });\n    this.addHook('beforeChangeRender', changes => _classPrivateMethodGet(this, _onBeforeChange, _onBeforeChange2).call(this, changes));\n    this.addHook('afterFormulasValuesUpdate', changes => _classPrivateMethodGet(this, _onAfterFormulasValuesUpdate, _onAfterFormulasValuesUpdate2).call(this, changes));\n    this.addHook('beforeViewRender', force => _classPrivateMethodGet(this, _onBeforeViewRender, _onBeforeViewRender2).call(this, force));\n    this.addHook('modifyColWidth', (width, col) => this.getColumnWidth(col, width));\n    this.addHook('afterInit', () => _classPrivateMethodGet(this, _onAfterInit, _onAfterInit2).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state. This method is executed when {@link Core#updateSettings} is invoked.\n   */\n  updatePlugin() {\n    const changedColumns = this.findColumnsWhereHeaderWasChanged();\n    if (changedColumns.length) {\n      this.clearCache(changedColumns);\n      this.calculateVisibleColumnsWidth();\n    }\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    super.disablePlugin();\n\n    // Leave the listener active to allow auto-sizing the columns when the plugin is disabled.\n    // This is necessary for width recalculation for resize handler doubleclick (ManualColumnResize).\n    this.addHook('beforeColumnResize', (size, column, isDblClick) => _classPrivateMethodGet(this, _onBeforeColumnResize, _onBeforeColumnResize2).call(this, size, column, isDblClick));\n  }\n\n  /**\n   * Calculates visible columns width.\n   */\n  calculateVisibleColumnsWidth() {\n    const rowsCount = this.hot.countRows();\n\n    // Keep last column widths unchanged for situation when all rows was deleted or trimmed (pro #6)\n    if (!rowsCount) {\n      return;\n    }\n    const force = this.hot.renderCall;\n    const firstVisibleColumn = this.getFirstVisibleColumn();\n    const lastVisibleColumn = this.getLastVisibleColumn();\n    if (firstVisibleColumn === -1 || lastVisibleColumn === -1) {\n      return;\n    }\n    this.calculateColumnsWidth({\n      from: firstVisibleColumn,\n      to: lastVisibleColumn\n    }, undefined, force);\n  }\n\n  /**\n   * Calculates a columns width.\n   *\n   * @param {number|object} colRange Visual column index or an object with `from` and `to` visual indexes as a range.\n   * @param {number|object} rowRange Visual row index or an object with `from` and `to` visual indexes as a range.\n   * @param {boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.\n   */\n  calculateColumnsWidth() {\n    let colRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countCols() - 1\n    };\n    let rowRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // eslint-disable-line max-len\n    const columnsRange = typeof colRange === 'number' ? {\n      from: colRange,\n      to: colRange\n    } : colRange;\n    const rowsRange = typeof rowRange === 'number' ? {\n      from: rowRange,\n      to: rowRange\n    } : rowRange;\n    rangeEach(columnsRange.from, columnsRange.to, visualColumn => {\n      let physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n      if (physicalColumn === null) {\n        physicalColumn = visualColumn;\n      }\n      if (force || this.columnWidthsMap.getValueAtIndex(physicalColumn) === null && !this.hot._getColWidthFromSettings(physicalColumn)) {\n        const samples = this.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);\n        arrayEach(samples, _ref => {\n          let [column, sample] = _ref;\n          return this.ghostTable.addColumn(column, sample);\n        });\n      }\n    });\n    if (this.ghostTable.columns.length) {\n      this.hot.batchExecution(() => {\n        this.ghostTable.getWidths((visualColumn, width) => {\n          const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n          this.columnWidthsMap.setValueAtIndex(physicalColumn, width);\n        });\n      }, true);\n      this.measuredColumns = columnsRange.to + 1;\n      this.ghostTable.clean();\n    }\n  }\n\n  /**\n   * Calculates all columns width. The calculated column will be cached in the {@link AutoColumnSize#widths} property.\n   * To retrieve width for specified column use {@link AutoColumnSize##getColumnWidth} method.\n   *\n   * @param {object|number} rowRange Row index or an object with `from` and `to` properties which define row range.\n   */\n  calculateAllColumnsWidth() {\n    let rowRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      from: 0,\n      to: this.hot.countRows() - 1\n    };\n    let current = 0;\n    const length = this.hot.countCols() - 1;\n    let timer = null;\n    this.inProgress = true;\n    const loop = () => {\n      // When hot was destroyed after calculating finished cancel frame\n      if (!this.hot) {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n        return;\n      }\n      this.calculateColumnsWidth({\n        from: current,\n        to: Math.min(current + AutoColumnSize.CALCULATION_STEP, length)\n      }, rowRange);\n      current = current + AutoColumnSize.CALCULATION_STEP + 1;\n      if (current < length) {\n        timer = requestAnimationFrame(loop);\n      } else {\n        cancelAnimationFrame(timer);\n        this.inProgress = false;\n\n        // @TODO Should call once per render cycle, currently fired separately in different plugins\n        this.hot.view.adjustElementsSize();\n      }\n    };\n    const syncLimit = this.getSyncCalculationLimit();\n\n    // sync\n    if (this.firstCalculation && syncLimit >= 0) {\n      this.calculateColumnsWidth({\n        from: 0,\n        to: syncLimit\n      }, rowRange);\n      this.firstCalculation = false;\n      current = syncLimit + 1;\n    }\n    // async\n    if (current < length) {\n      loop();\n    } else {\n      this.inProgress = false;\n    }\n  }\n\n  /**\n   * Sets the sampling options.\n   *\n   * @private\n   */\n  setSamplingOptions() {\n    const setting = this.hot.getSettings()[PLUGIN_KEY];\n    const samplingRatio = setting && hasOwnProperty(setting, 'samplingRatio') ? setting.samplingRatio : undefined;\n    const allowSampleDuplicates = setting && hasOwnProperty(setting, 'allowSampleDuplicates') ? setting.allowSampleDuplicates : undefined;\n    if (samplingRatio && !isNaN(samplingRatio)) {\n      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));\n    }\n    if (allowSampleDuplicates) {\n      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);\n    }\n  }\n\n  /**\n   * Recalculates all columns width (overwrite cache values).\n   */\n  recalculateAllColumnsWidth() {\n    if (this.hot.view && this.hot.view._wt.wtTable.isVisible()) {\n      this.clearCache();\n      this.calculateAllColumnsWidth();\n    }\n  }\n\n  /**\n   * Gets value which tells how many columns should be calculated synchronously (rest of the columns will be calculated\n   * asynchronously). The limit is calculated based on `syncLimit` set to `autoColumnSize` option (see {@link Options#autoColumnSize}).\n   *\n   * @returns {number}\n   */\n  getSyncCalculationLimit() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    /* eslint-disable no-bitwise */\n    let limit = AutoColumnSize.SYNC_CALCULATION_LIMIT;\n    const colsLimit = this.hot.countCols() - 1;\n    if (isObject(settings)) {\n      limit = settings.syncLimit;\n      if (isPercentValue(limit)) {\n        limit = valueAccordingPercent(colsLimit, limit);\n      } else {\n        // Force to Number\n        limit >>= 0;\n      }\n    }\n    return Math.min(limit, colsLimit);\n  }\n\n  /**\n   * Gets the calculated column width.\n   *\n   * @param {number} column Visual column index.\n   * @param {number} [defaultWidth] Default column width. It will be picked up if no calculated width found.\n   * @param {boolean} [keepMinimum=true] If `true` then returned value won't be smaller then 50 (default column width).\n   * @returns {number}\n   */\n  getColumnWidth(column) {\n    let defaultWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let keepMinimum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let width = defaultWidth;\n    if (width === undefined) {\n      width = this.columnWidthsMap.getValueAtIndex(this.hot.toPhysicalColumn(column));\n      if (keepMinimum && typeof width === 'number') {\n        width = Math.max(width, ViewportColumnsCalculator.DEFAULT_WIDTH);\n      }\n    }\n    return width;\n  }\n\n  /**\n   * Gets the first visible column.\n   *\n   * @returns {number} Returns visual column index, -1 if table is not rendered or if there are no columns to base the the calculations on.\n   */\n  getFirstVisibleColumn() {\n    const wot = this.hot.view._wt;\n    if (wot.wtViewport.columnsVisibleCalculator) {\n      // Fist fully visible column is stored as renderable index.\n      const firstFullyVisibleColumn = wot.wtTable.getFirstVisibleColumn();\n      if (firstFullyVisibleColumn !== -1) {\n        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstFullyVisibleColumn);\n      }\n    }\n    if (wot.wtViewport.columnsRenderCalculator) {\n      const firstRenderedColumn = wot.wtTable.getFirstRenderedColumn();\n\n      // There are no rendered column.\n      if (firstRenderedColumn !== -1) {\n        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstRenderedColumn);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Gets the last visible column.\n   *\n   * @returns {number} Returns visual column index or -1 if table is not rendered.\n   */\n  getLastVisibleColumn() {\n    const wot = this.hot.view._wt;\n    if (wot.wtViewport.columnsVisibleCalculator) {\n      // Last fully visible column is stored as renderable index.\n      const lastFullyVisibleColumn = wot.wtTable.getLastVisibleColumn();\n      if (lastFullyVisibleColumn !== -1) {\n        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastFullyVisibleColumn);\n      }\n    }\n    if (wot.wtViewport.columnsRenderCalculator) {\n      // Last fully visible column is stored as renderable index.\n      const lastRenderedColumn = wot.wtTable.getLastRenderedColumn();\n\n      // There are no rendered columns.\n      if (lastRenderedColumn !== -1) {\n        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastRenderedColumn);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Collects all columns which titles has been changed in comparison to the previous state.\n   *\n   * @private\n   * @returns {Array} It returns an array of physical column indexes.\n   */\n  findColumnsWhereHeaderWasChanged() {\n    const columnHeaders = this.hot.getColHeader();\n    const changedColumns = arrayReduce(columnHeaders, (acc, columnTitle, physicalColumn) => {\n      const cachedColumnsLength = _classPrivateFieldGet(this, _cachedColumnHeaders).length;\n      if (cachedColumnsLength - 1 < physicalColumn || _classPrivateFieldGet(this, _cachedColumnHeaders)[physicalColumn] !== columnTitle) {\n        acc.push(physicalColumn);\n      }\n      if (cachedColumnsLength - 1 < physicalColumn) {\n        _classPrivateFieldGet(this, _cachedColumnHeaders).push(columnTitle);\n      } else {\n        _classPrivateFieldGet(this, _cachedColumnHeaders)[physicalColumn] = columnTitle;\n      }\n      return acc;\n    }, []);\n    return changedColumns;\n  }\n\n  /**\n   * Clears cache of calculated column widths. If you want to clear only selected columns pass an array with their indexes.\n   * Otherwise whole cache will be cleared.\n   *\n   * @param {number[]} [columns] List of physical column indexes to clear.\n   */\n  clearCache() {\n    let columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    if (columns.length) {\n      this.hot.batchExecution(() => {\n        arrayEach(columns, physicalIndex => {\n          this.columnWidthsMap.setValueAtIndex(physicalIndex, null);\n        });\n      }, true);\n    } else {\n      this.columnWidthsMap.clear();\n    }\n  }\n\n  /**\n   * Checks if all widths were calculated. If not then return `true` (need recalculate).\n   *\n   * @returns {boolean}\n   */\n  isNeedRecalculate() {\n    return !!arrayFilter(this.columnWidthsMap.getValues().slice(0, this.measuredColumns), item => item === null).length;\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    this.ghostTable.clean();\n    super.destroy();\n  }\n}\nfunction _onBeforeViewRender2() {\n  this.calculateVisibleColumnsWidth();\n  if (this.isNeedRecalculate() && !this.inProgress) {\n    this.calculateAllColumnsWidth();\n  }\n}\nfunction _onAfterLoadData2() {\n  if (this.hot.view) {\n    this.recalculateAllColumnsWidth();\n  } else {\n    // first load - initialization\n    setTimeout(() => {\n      if (this.hot) {\n        this.recalculateAllColumnsWidth();\n      }\n    }, 0);\n  }\n}\nfunction _onBeforeChange2(changes) {\n  const changedColumns = arrayMap(changes, _ref2 => {\n    let [, columnProperty] = _ref2;\n    return this.hot.toPhysicalColumn(this.hot.propToCol(columnProperty));\n  });\n  this.clearCache(Array.from(new Set(changedColumns)));\n}\nfunction _onBeforeColumnResize2(size, column, isDblClick) {\n  let newSize = size;\n  if (isDblClick) {\n    this.calculateColumnsWidth(column, undefined, true);\n    newSize = this.getColumnWidth(column, undefined, false);\n  }\n  return newSize;\n}\nfunction _onAfterInit2() {\n  _classPrivateFieldSet(this, _cachedColumnHeaders, this.hot.getColHeader());\n}\nfunction _onAfterFormulasValuesUpdate2(changes) {\n  const filteredChanges = arrayFilter(changes, change => {\n    var _change$address;\n    return isDefined((_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.col);\n  });\n  const changedColumns = arrayMap(filteredChanges, change => change.address.col);\n  this.clearCache(Array.from(new Set(changedColumns)));\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}