{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { addClass, removeClass } from \"../../helpers/dom/element.mjs\";\nimport { isNumeric, clamp } from \"../../helpers/number.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\nimport { isLeftClick, isRightClick } from \"../../helpers/dom/event.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { ACTIVE_HEADER_TYPE, HEADER_TYPE } from \"../../selection/index.mjs\";\nimport { BasePlugin } from \"../base/index.mjs\";\nimport StateManager from \"./stateManager/index.mjs\";\nimport GhostTable from \"./utils/ghostTable.mjs\";\nexport const PLUGIN_KEY = 'nestedHeaders';\nexport const PLUGIN_PRIORITY = 280;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin NestedHeaders\n * @class NestedHeaders\n *\n * @description\n * The plugin allows to create a nested header structure, using the HTML's colspan attribute.\n *\n * To make any header wider (covering multiple table columns), it's corresponding configuration array element should be\n * provided as an object with `label` and `colspan` properties. The `label` property defines the header's label,\n * while the `colspan` property defines a number of columns that the header should cover.\n *\n * __Note__ that the plugin supports a *nested* structure, which means, any header cannot be wider than it's \"parent\". In\n * other words, headers cannot overlap each other.\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   nestedHeaders: [\n *     ['A', {label: 'B', colspan: 8}, 'C'],\n *     ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],\n *     ['H', {label: 'I', colspan: 2}, {label: 'J', colspan: 2}, {label: 'K', colspan: 2}, {label: 'L', colspan: 2}, 'M'],\n *     ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W']\n *  ],\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   nestedHeaders={[\n *     ['A', {label: 'B', colspan: 8}, 'C'],\n *     ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],\n *     ['H', {label: 'I', colspan: 2}, {label: 'J', colspan: 2}, {label: 'K', colspan: 2}, {label: 'L', colspan: 2}, 'M'],\n *     ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W']\n *  ]}\n * />\n * ```\n * :::\n */\nvar _stateManager = /*#__PURE__*/new WeakMap();\nvar _hidingIndexMapObserver = /*#__PURE__*/new WeakMap();\nvar _focusInitialCoords = /*#__PURE__*/new WeakMap();\nvar _isColumnsSelectionInProgress = /*#__PURE__*/new WeakMap();\nvar _updateFocusHighlightPosition = /*#__PURE__*/new WeakSet();\nvar _onBeforeViewportScrollHorizontally = /*#__PURE__*/new WeakSet();\nvar _onBeforeHighlightingColumnHeader = /*#__PURE__*/new WeakSet();\nvar _onBeforeCopy = /*#__PURE__*/new WeakSet();\nvar _onBeforeOnCellMouseDown = /*#__PURE__*/new WeakSet();\nvar _onAfterOnCellMouseDown = /*#__PURE__*/new WeakSet();\nvar _onBeforeOnCellMouseOver = /*#__PURE__*/new WeakSet();\nvar _onBeforeOnCellMouseUp = /*#__PURE__*/new WeakSet();\nvar _onBeforeSelectionHighlightSet = /*#__PURE__*/new WeakSet();\nvar _onModifyTransformStart = /*#__PURE__*/new WeakSet();\nvar _onBeforeSelectColumns = /*#__PURE__*/new WeakSet();\nvar _onAfterGetColumnHeaderRenderers = /*#__PURE__*/new WeakSet();\nvar _onAfterViewportColumnCalculatorOverride = /*#__PURE__*/new WeakSet();\nvar _onModifyColWidth = /*#__PURE__*/new WeakSet();\nvar _onModifyColumnHeaderValue = /*#__PURE__*/new WeakSet();\nvar _onModifyFocusedElement = /*#__PURE__*/new WeakSet();\nvar _onInit = /*#__PURE__*/new WeakSet();\nvar _onAfterLoadData = /*#__PURE__*/new WeakSet();\nexport class NestedHeaders extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Updates the plugin state after new dataset load.\n     *\n     * @param {Array[]} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded\n     *                              during the initialization.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterLoadData);\n    /**\n     * Updates the plugin state after HoT initialization.\n     */\n    _classPrivateMethodInitSpec(this, _onInit);\n    /**\n     * `modifyFocusedElement` hook callback.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Column index.\n     * @returns {HTMLTableCellElement} The `TH` element to be focused.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyFocusedElement);\n    /**\n     * Listens the `modifyColumnHeaderValue` hook that overwrites the column headers values based on\n     * the internal state and settings of the plugin.\n     *\n     * @param {string} value The column header value.\n     * @param {number} visualColumnIndex The visual column index.\n     * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)\n     *                             and negative (-1 to -N) values. For positive values, 0 points to the\n     *                             top most header, and for negative direction, -1 points to the most bottom\n     *                             header (the header closest to the cells).\n     * @returns {string} Returns the column header value to update.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyColumnHeaderValue);\n    /**\n     * `modifyColWidth` hook callback - returns width from cache, when is greater than incoming from hook.\n     *\n     * @param {number} width Width from hook.\n     * @param {number} column Visual index of an column.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _onModifyColWidth);\n    /**\n     * Make the renderer render the first nested column in its entirety.\n     *\n     * @param {object} calc Viewport column calculator.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterViewportColumnCalculatorOverride);\n    /**\n     * `afterGetColumnHeader` hook callback - prepares the header structure.\n     *\n     * @param {Array} renderersArray Array of renderers.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterGetColumnHeaderRenderers);\n    /**\n     * The hook observes the column selection from the Selection API and modifies the column range to\n     * ensure that the whole nested column will be covered.\n     *\n     * @param {CellCoords} from The coords object where the selection starts.\n     * @param {CellCoords} to The coords object where the selection ends.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeSelectColumns);\n    /**\n     * `modifyTransformStart` hook is called every time the keyboard navigation is used.\n     *\n     * @param {object} delta The transformation delta.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyTransformStart);\n    /**\n     * The hook checks and ensures that the focus position that depends on the selected columns\n     * range is always positioned within the range.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeSelectionHighlightSet);\n    /**\n     * Switches internal flag about selection progress to `false`.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeOnCellMouseUp);\n    /**\n     * Makes the header-selection properly select the nested headers.\n     *\n     * @param {MouseEvent} event Mouse event.\n     * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n     * @param {HTMLElement} TD The cell element.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeOnCellMouseOver);\n    /**\n     * Allows to control how the column selection based on the coordinates and the nested headers is made.\n     *\n     * @param {MouseEvent} event Mouse event.\n     * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterOnCellMouseDown);\n    /**\n     * Allows blocking the column selection that is controlled by the core Selection module.\n     *\n     * @param {MouseEvent} event Mouse event.\n     * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n     * @param {CellCoords} TD The table cell or header element.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeOnCellMouseDown);\n    /**\n     * Listens the `beforeCopy` hook that allows processing the copied column headers so that the\n     * merged column headers do not propagate the value for each column but only once at the beginning\n     * of the column.\n     *\n     * @private\n     * @param {Array[]} data An array of arrays which contains data to copied.\n     * @param {object[]} copyableRanges An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n     *                                  which will copied.\n     * @param {{ columnHeadersCount: number }} copiedHeadersCount An object with keys that holds information with\n     *                                                            the number of copied headers.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeCopy);\n    /**\n     * Allows to control which header DOM element will be used to highlight.\n     *\n     * @param {number} visualColumn A visual column index of the highlighted row header.\n     * @param {number} headerLevel A row header level that is currently highlighted.\n     * @param {object} highlightMeta An object with meta data that describes the highlight state.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeHighlightingColumnHeader);\n    /**\n     * Allows to control to which column index the viewport will be scrolled. To ensure that the viewport\n     * is scrolled to the correct column for the nested header the most left and the most right visual column\n     * indexes are used.\n     *\n     * @param {number} visualColumn A visual column index to which the viewport will be scrolled.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeViewportScrollHorizontally);\n    /**\n     * Updates the selection focus highlight position to point to the nested header root element (TH)\n     * even when the logical coordinates point in-between the header.\n     */\n    _classPrivateMethodInitSpec(this, _updateFocusHighlightPosition);\n    /**\n     * The state manager for the nested headers.\n     *\n     * @type {StateManager}\n     */\n    _classPrivateFieldInitSpec(this, _stateManager, {\n      writable: true,\n      value: new StateManager()\n    });\n    /**\n     * The instance of the ChangesObservable class that allows track the changes that happens in the\n     * column indexes.\n     *\n     * @type {ChangesObservable}\n     */\n    _classPrivateFieldInitSpec(this, _hidingIndexMapObserver, {\n      writable: true,\n      value: null\n    });\n    /**\n     * Holds the coords that points to the place where the column selection starts.\n     *\n     * @type {number|null}\n     */\n    _classPrivateFieldInitSpec(this, _focusInitialCoords, {\n      writable: true,\n      value: null\n    });\n    /**\n     * Determines if there is performed the column selection.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isColumnsSelectionInProgress, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Custom helper for getting widths of the nested headers.\n     *\n     * @private\n     * @type {GhostTable}\n     */\n    // @TODO This should be changed after refactor handsontable/utils/ghostTable.\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot, (row, column) => this.getHeaderSettings(row, column)));\n    /**\n     * The flag which determines that the nested header settings contains overlapping headers\n     * configuration.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"detectedOverlappedHeaders\", false);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Check if plugin is enabled.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const {\n      nestedHeaders\n    } = this.hot.getSettings();\n    if (!Array.isArray(nestedHeaders) || !Array.isArray(nestedHeaders[0])) {\n      warn(toSingleLine`Your Nested Headers plugin configuration is invalid. The settings has to be\\x20\n                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]`);\n    }\n    this.addHook('init', () => _classPrivateMethodGet(this, _onInit, _onInit2).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onAfterLoadData, _onAfterLoadData2).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeOnCellMouseDown, _onBeforeOnCellMouseDown2).call(_this, ...args);\n    });\n    this.addHook('afterOnCellMouseDown', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _classPrivateMethodGet(_this, _onAfterOnCellMouseDown, _onAfterOnCellMouseDown2).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeOnCellMouseOver, _onBeforeOnCellMouseOver2).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseUp', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeOnCellMouseUp, _onBeforeOnCellMouseUp2).call(_this, ...args);\n    });\n    this.addHook('beforeSelectionHighlightSet', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeSelectionHighlightSet, _onBeforeSelectionHighlightSet2).call(_this, ...args);\n    });\n    this.addHook('modifyTransformStart', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _classPrivateMethodGet(_this, _onModifyTransformStart, _onModifyTransformStart2).call(_this, ...args);\n    });\n    this.addHook('afterSelection', () => _classPrivateMethodGet(this, _updateFocusHighlightPosition, _updateFocusHighlightPosition2).call(this));\n    this.addHook('beforeViewportScrollHorizontally', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeViewportScrollHorizontally, _onBeforeViewportScrollHorizontally2).call(_this, ...args);\n    });\n    this.addHook('afterGetColumnHeaderRenderers', array => _classPrivateMethodGet(this, _onAfterGetColumnHeaderRenderers, _onAfterGetColumnHeaderRenderers2).call(this, array));\n    this.addHook('modifyColWidth', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _classPrivateMethodGet(_this, _onModifyColWidth, _onModifyColWidth2).call(_this, ...args);\n    });\n    this.addHook('modifyColumnHeaderValue', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _classPrivateMethodGet(_this, _onModifyColumnHeaderValue, _onModifyColumnHeaderValue2).call(_this, ...args);\n    });\n    this.addHook('beforeHighlightingColumnHeader', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeHighlightingColumnHeader, _onBeforeHighlightingColumnHeader2).call(_this, ...args);\n    });\n    this.addHook('beforeCopy', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeCopy, _onBeforeCopy2).call(_this, ...args);\n    });\n    this.addHook('beforeSelectColumns', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeSelectColumns, _onBeforeSelectColumns2).call(_this, ...args);\n    });\n    this.addHook('afterViewportColumnCalculatorOverride', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _classPrivateMethodGet(_this, _onAfterViewportColumnCalculatorOverride, _onAfterViewportColumnCalculatorOverride2).call(_this, ...args);\n    });\n    this.addHook('modifyFocusedElement', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _classPrivateMethodGet(_this, _onModifyFocusedElement, _onModifyFocusedElement2).call(_this, ...args);\n    });\n    this.hot.columnIndexMapper.addLocalHook('cacheUpdated', () => _classPrivateMethodGet(this, _updateFocusHighlightPosition, _updateFocusHighlightPosition2).call(this));\n    this.hot.rowIndexMapper.addLocalHook('cacheUpdated', () => _classPrivateMethodGet(this, _updateFocusHighlightPosition, _updateFocusHighlightPosition2).call(this));\n    super.enablePlugin();\n    this.updatePlugin(); // @TODO: Workaround for broken plugin initialization abstraction.\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`nestedHeaders`](@/api/options.md#nestedheaders)\n   */\n  updatePlugin() {\n    if (!this.hot.view) {\n      // @TODO: Workaround for broken plugin initialization abstraction.\n      return;\n    }\n    const {\n      nestedHeaders\n    } = this.hot.getSettings();\n    _classPrivateFieldGet(this, _stateManager).setColumnsLimit(this.hot.countCols());\n    if (Array.isArray(nestedHeaders)) {\n      this.detectedOverlappedHeaders = _classPrivateFieldGet(this, _stateManager).setState(nestedHeaders);\n    }\n    if (this.detectedOverlappedHeaders) {\n      warn(toSingleLine`Your Nested Headers plugin setup contains overlapping headers. This kind of configuration\\x20\n                        is currently not supported.`);\n    }\n    if (this.enabled) {\n      // This line covers the case when a developer uses the external hiding maps to manipulate\n      // the columns' visibility. The tree state built from the settings - which is always built\n      // as if all the columns are visible, needs to be modified to be in sync with a dataset.\n      this.hot.columnIndexMapper.hidingMapsCollection.getMergedValues().forEach((isColumnHidden, physicalColumnIndex) => {\n        const actionName = isColumnHidden === true ? 'hide-column' : 'show-column';\n        _classPrivateFieldGet(this, _stateManager).triggerColumnModification(actionName, physicalColumnIndex);\n      });\n    }\n    if (!_classPrivateFieldGet(this, _hidingIndexMapObserver) && this.enabled) {\n      _classPrivateFieldSet(this, _hidingIndexMapObserver, this.hot.columnIndexMapper.createChangesObserver('hiding').subscribe(changes => {\n        changes.forEach(_ref => {\n          let {\n            op,\n            index: columnIndex,\n            newValue\n          } = _ref;\n          if (op === 'replace') {\n            const actionName = newValue === true ? 'hide-column' : 'show-column';\n            _classPrivateFieldGet(this, _stateManager).triggerColumnModification(actionName, columnIndex);\n          }\n        });\n        this.ghostTable.buildWidthsMap();\n      }));\n    }\n    this.ghostTable.setLayersCount(this.getLayersCount()).buildWidthsMap();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearColspans();\n    _classPrivateFieldGet(this, _stateManager).clear();\n    _classPrivateFieldGet(this, _hidingIndexMapObserver).unsubscribe();\n    _classPrivateFieldSet(this, _hidingIndexMapObserver, null);\n    this.ghostTable.clear();\n    super.disablePlugin();\n  }\n\n  /**\n   * Returns an instance of the internal state manager of the plugin.\n   *\n   * @private\n   * @returns {StateManager}\n   */\n  getStateManager() {\n    return _classPrivateFieldGet(this, _stateManager);\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @private\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(this, _stateManager).getLayersCount();\n  }\n\n  /**\n   * Gets column settings for a specified header. The returned object contains\n   * information about the header label, its colspan length, or if it is hidden\n   * in the header renderers.\n   *\n   * @private\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    return _classPrivateFieldGet(this, _stateManager).getHeaderSettings(headerLevel, columnIndex);\n  }\n\n  /**\n   * Clear the colspans remaining after plugin usage.\n   *\n   * @private\n   */\n  clearColspans() {\n    if (!this.hot.view) {\n      return;\n    }\n    const {\n      _wt: wt\n    } = this.hot.view;\n    const headerLevels = wt.getSetting('columnHeaders').length;\n    const mainHeaders = wt.wtTable.THEAD;\n    const topHeaders = wt.wtOverlays.topOverlay.clone.wtTable.THEAD;\n    const topLeftCornerHeaders = wt.wtOverlays.topInlineStartCornerOverlay ? wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;\n    for (let i = 0; i < headerLevels; i++) {\n      const masterLevel = mainHeaders.childNodes[i];\n      if (!masterLevel) {\n        break;\n      }\n      const topLevel = topHeaders.childNodes[i];\n      const topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;\n      for (let j = 0, masterNodes = masterLevel.childNodes.length; j < masterNodes; j++) {\n        masterLevel.childNodes[j].removeAttribute('colspan');\n        removeClass(masterLevel.childNodes[j], 'hiddenHeader');\n        if (topLevel && topLevel.childNodes[j]) {\n          topLevel.childNodes[j].removeAttribute('colspan');\n          removeClass(topLevel.childNodes[j], 'hiddenHeader');\n        }\n        if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {\n          topLeftCornerLevel.childNodes[j].removeAttribute('colspan');\n          removeClass(topLeftCornerLevel.childNodes[j], 'hiddenHeader');\n        }\n      }\n    }\n  }\n\n  /**\n   * Generates the appropriate header renderer for a header row.\n   *\n   * @private\n   * @param {number} headerLevel The index of header level counting from the top (positive\n   *                             values counting from 0 to N).\n   * @returns {Function}\n   * @fires Hooks#afterGetColHeader\n   */\n  headerRendererFactory(headerLevel) {\n    var _this2 = this;\n    const fixedColumnsStart = this.hot.view._wt.getSetting('fixedColumnsStart');\n    return (renderedColumnIndex, TH) => {\n      var _classPrivateFieldGet2;\n      const {\n        columnIndexMapper,\n        view\n      } = this.hot;\n      let visualColumnIndex = columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n      if (visualColumnIndex === null) {\n        visualColumnIndex = renderedColumnIndex;\n      }\n      TH.removeAttribute('colspan');\n      removeClass(TH, 'hiddenHeader');\n      const {\n        colspan,\n        isHidden,\n        isPlaceholder\n      } = (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _stateManager).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : {\n        label: ''\n      };\n      if (isPlaceholder || isHidden) {\n        addClass(TH, 'hiddenHeader');\n      } else if (colspan > 1) {\n        var _wtOverlays$topInline, _wtOverlays$inlineSta;\n        const {\n          wtOverlays\n        } = view._wt;\n        const isTopInlineStartOverlay = (_wtOverlays$topInline = wtOverlays.topInlineStartCornerOverlay) === null || _wtOverlays$topInline === void 0 ? void 0 : _wtOverlays$topInline.clone.wtTable.THEAD.contains(TH);\n        const isInlineStartOverlay = (_wtOverlays$inlineSta = wtOverlays.inlineStartOverlay) === null || _wtOverlays$inlineSta === void 0 ? void 0 : _wtOverlays$inlineSta.clone.wtTable.THEAD.contains(TH);\n\n        // Check if there is a fixed column enabled, if so then reduce colspan to fixed column width.\n        const correctedColspan = isTopInlineStartOverlay || isInlineStartOverlay ? Math.min(colspan, fixedColumnsStart - renderedColumnIndex) : colspan;\n        if (correctedColspan > 1) {\n          TH.setAttribute('colspan', correctedColspan);\n        }\n      }\n      this.hot.view.appendColHeader(visualColumnIndex, TH, function () {\n        return _this2.getColumnHeaderValue(...arguments);\n      }, headerLevel);\n    };\n  }\n\n  /**\n   * Returns the column header value for specified column and header level index.\n   *\n   * @private\n   * @param {number} visualColumnIndex Visual column index.\n   * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)\n   *                             and negative (-1 to -N) values. For positive values, 0 points to the\n   *                             top most header, and for negative direction, -1 points to the most bottom\n   *                             header (the header closest to the cells).\n   * @returns {string} Returns the column header value to update.\n   */\n  getColumnHeaderValue(visualColumnIndex, headerLevel) {\n    var _classPrivateFieldGet3;\n    const {\n      isHidden,\n      isPlaceholder\n    } = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _stateManager).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : {};\n    if (isPlaceholder || isHidden) {\n      return '';\n    }\n    return this.hot.getColHeader(visualColumnIndex, headerLevel);\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldSet(this, _stateManager, null);\n    if (_classPrivateFieldGet(this, _hidingIndexMapObserver) !== null) {\n      _classPrivateFieldGet(this, _hidingIndexMapObserver).unsubscribe();\n      _classPrivateFieldSet(this, _hidingIndexMapObserver, null);\n    }\n    super.destroy();\n  }\n\n  /**\n   * Gets the tree data that belongs to the column headers pointed by the passed coordinates.\n   *\n   * @private\n   * @param {CellCoords} coords The CellCoords instance.\n   * @returns {object|undefined}\n   */\n  _getHeaderTreeNodeDataByCoords(coords) {\n    if (coords.row >= 0 || coords.col < 0) {\n      return;\n    }\n    return _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(coords.row, coords.col);\n  }\n}\nfunction _updateFocusHighlightPosition2() {\n  var _this$hot;\n  const selection = (_this$hot = this.hot) === null || _this$hot === void 0 ? void 0 : _this$hot.getSelectedRangeLast();\n  if (!selection) {\n    return;\n  }\n  const {\n    highlight\n  } = selection;\n  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;\n  if (isNestedHeadersRange) {\n    const columnIndex = _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(highlight.row, highlight.col);\n    const focusHighlight = this.hot.selection.highlight.getFocus();\n\n    // Correct the highlight/focus selection to highlight the correct TH element\n    focusHighlight.visualCellRange.highlight.col = columnIndex;\n    focusHighlight.visualCellRange.from.col = columnIndex;\n    focusHighlight.visualCellRange.to.col = columnIndex;\n    focusHighlight.commit();\n  }\n}\nfunction _onBeforeViewportScrollHorizontally2(visualColumn) {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection) {\n    return visualColumn;\n  }\n  const {\n    highlight\n  } = selection;\n  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;\n  if (!isNestedHeadersRange) {\n    return visualColumn;\n  }\n  const firstColumn = this.hot.view.getFirstFullyVisibleColumn();\n  const lastColumn = this.hot.view.getLastFullyVisibleColumn();\n  const mostLeftColumnIndex = _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(highlight.row, highlight.col);\n  const mostRightColumnIndex = _classPrivateFieldGet(this, _stateManager).findRightMostColumnIndex(highlight.row, highlight.col);\n\n  // do not scroll the viewport when the header is wider than the viewport\n  if (mostLeftColumnIndex < firstColumn && mostRightColumnIndex > lastColumn) {\n    return visualColumn;\n  }\n  return mostLeftColumnIndex < firstColumn ? mostLeftColumnIndex : mostRightColumnIndex;\n}\nfunction _onBeforeHighlightingColumnHeader2(visualColumn, headerLevel, highlightMeta) {\n  const headerNodeData = _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(headerLevel, visualColumn);\n  if (!headerNodeData) {\n    return visualColumn;\n  }\n  const {\n    columnCursor,\n    selectionType,\n    selectionWidth\n  } = highlightMeta;\n  const {\n    isRoot,\n    colspan\n  } = _classPrivateFieldGet(this, _stateManager).getHeaderSettings(headerLevel, visualColumn);\n  if (selectionType === HEADER_TYPE) {\n    if (!isRoot) {\n      return headerNodeData.columnIndex;\n    }\n  } else if (selectionType === ACTIVE_HEADER_TYPE) {\n    if (colspan > selectionWidth - columnCursor || !isRoot) {\n      // Prevents adding any CSS class names to the TH element\n      return null;\n    }\n  }\n  return visualColumn;\n}\nfunction _onBeforeCopy2(data, copyableRanges, _ref2) {\n  let {\n    columnHeadersCount\n  } = _ref2;\n  if (columnHeadersCount === 0) {\n    return;\n  }\n  for (let rangeIndex = 0; rangeIndex < copyableRanges.length; rangeIndex++) {\n    const {\n      startRow,\n      startCol,\n      endRow,\n      endCol\n    } = copyableRanges[rangeIndex];\n    const rowsCount = endRow - startRow + 1;\n    const columnsCount = startCol - endCol + 1;\n\n    // do not process dataset ranges and column headers where only one column is copied\n    if (startRow >= 0 || columnsCount === 1) {\n      break;\n    }\n    for (let column = startCol; column <= endCol; column++) {\n      for (let row = startRow; row <= endRow; row++) {\n        var _classPrivateFieldGet4;\n        const zeroBasedColumnHeaderLevel = rowsCount + row;\n        const zeroBasedColumnIndex = column - startCol;\n        if (zeroBasedColumnIndex === 0) {\n          continue; // eslint-disable-line no-continue\n        }\n\n        const isRoot = (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(row, column)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.isRoot;\n        if (isRoot === false) {\n          data[zeroBasedColumnHeaderLevel][zeroBasedColumnIndex] = '';\n        }\n      }\n    }\n  }\n}\nfunction _onBeforeOnCellMouseDown2(event, coords, TD, controller) {\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (headerNodeData) {\n    // Block the Selection module in controlling how the columns are selected. Pass the\n    // responsibility of the column selection to this plugin (see \"onAfterOnCellMouseDown\" hook).\n    controller.column = true;\n  }\n}\nfunction _onAfterOnCellMouseDown2(event, coords) {\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (!headerNodeData) {\n    return;\n  }\n  _classPrivateFieldSet(this, _focusInitialCoords, coords.clone());\n  _classPrivateFieldSet(this, _isColumnsSelectionInProgress, true);\n  const {\n    selection\n  } = this.hot;\n  const currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;\n  const columnsToSelect = [];\n  const {\n    columnIndex,\n    origColspan\n  } = headerNodeData;\n\n  // The Selection module doesn't allow it to extend its behavior easily. That's why here we need\n  // to re-implement the \"click\" and \"shift\" behavior. As a workaround, the logic for the nested\n  // headers must implement a similar logic as in the original Selection handler\n  // (see src/selection/mouseEventHandler.js).\n  const allowRightClickSelection = !selection.inInSelection(coords);\n  if (event.shiftKey && currentSelection) {\n    if (coords.col < currentSelection.from.col) {\n      columnsToSelect.push(currentSelection.getTopEndCorner().col, columnIndex, coords.row);\n    } else if (coords.col > currentSelection.from.col) {\n      columnsToSelect.push(currentSelection.getTopStartCorner().col, columnIndex + origColspan - 1, coords.row);\n    } else {\n      columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);\n    }\n  } else if (isLeftClick(event) || isRightClick(event) && allowRightClickSelection) {\n    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);\n  }\n\n  // The plugin takes control of how the columns are selected.\n  selection.selectColumns(...columnsToSelect);\n}\nfunction _onBeforeOnCellMouseOver2(event, coords, TD, controller) {\n  if (!this.hot.view.isMouseDown()) {\n    return;\n  }\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (!headerNodeData) {\n    return;\n  }\n  const {\n    columnIndex,\n    origColspan\n  } = headerNodeData;\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const topStartCoords = selectedRange.getTopStartCorner();\n  const bottomEndCoords = selectedRange.getBottomEndCorner();\n  const {\n    from\n  } = selectedRange;\n\n  // Block the Selection module in controlling how the columns and cells are selected.\n  // From now on, the plugin is responsible for the selection.\n  controller.column = true;\n  controller.cell = true;\n  const columnsToSelect = [];\n  const headerLevel = clamp(coords.row, -Infinity, -1);\n  if (coords.col < from.col) {\n    columnsToSelect.push(bottomEndCoords.col, columnIndex, headerLevel);\n  } else if (coords.col > from.col) {\n    columnsToSelect.push(topStartCoords.col, columnIndex + origColspan - 1, headerLevel);\n  } else {\n    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, headerLevel);\n  }\n  this.hot.selection.selectColumns(...columnsToSelect);\n}\nfunction _onBeforeOnCellMouseUp2() {\n  _classPrivateFieldSet(this, _isColumnsSelectionInProgress, false);\n}\nfunction _onBeforeSelectionHighlightSet2() {\n  const {\n    navigableHeaders\n  } = this.hot.getSettings();\n  if (!this.hot.view.isMouseDown() || !_classPrivateFieldGet(this, _isColumnsSelectionInProgress) || !navigableHeaders) {\n    return;\n  }\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const columnStart = selectedRange.getTopStartCorner().col;\n  const columnEnd = selectedRange.getBottomEndCorner().col;\n  const {\n    columnIndex,\n    origColspan\n  } = _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(_classPrivateFieldGet(this, _focusInitialCoords).row, _classPrivateFieldGet(this, _focusInitialCoords).col);\n  selectedRange.setHighlight(_classPrivateFieldGet(this, _focusInitialCoords));\n  if (origColspan > selectedRange.getWidth() || columnIndex < columnStart || columnIndex + origColspan - 1 > columnEnd) {\n    const headerLevel = _classPrivateFieldGet(this, _stateManager).findTopMostEntireHeaderLevel(clamp(columnStart, columnIndex, columnIndex + origColspan - 1), clamp(columnEnd, columnIndex, columnIndex + origColspan - 1));\n    selectedRange.highlight.row = headerLevel;\n    selectedRange.highlight.col = selectedRange.from.col;\n  }\n}\nfunction _onModifyTransformStart2(delta) {\n  const {\n    highlight\n  } = this.hot.getSelectedRangeLast();\n  const nextCoords = this.hot._createCellCoords(highlight.row + delta.row, highlight.col + delta.col);\n  const isNestedHeadersRange = nextCoords.isHeader() && nextCoords.col >= 0;\n  if (!isNestedHeadersRange) {\n    return;\n  }\n  const visualColumnIndexStart = _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(nextCoords.row, nextCoords.col);\n  const visualColumnIndexEnd = _classPrivateFieldGet(this, _stateManager).findRightMostColumnIndex(nextCoords.row, nextCoords.col);\n  if (delta.col < 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexStart - 1 : visualColumnIndexEnd;\n    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, -1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the previous row (if autoWrapRow is enabled).\n      delta.col = -this.hot.view.countRenderableColumnsInRange(0, highlight.col);\n    } else {\n      delta.col = -Math.max(this.hot.view.countRenderableColumnsInRange(notHiddenColumnIndex, highlight.col) - 1, 1);\n    }\n  } else if (delta.col > 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexEnd + 1 : visualColumnIndexStart;\n    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, 1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the next row (if autoWrapRow is enabled).\n      delta.col = this.hot.view.countRenderableColumnsInRange(highlight.col, this.hot.countCols());\n    } else {\n      delta.col = Math.max(this.hot.view.countRenderableColumnsInRange(highlight.col, notHiddenColumnIndex) - 1, 1);\n    }\n  }\n}\nfunction _onBeforeSelectColumns2(from, to) {\n  const headerLevel = from.row;\n  const startNodeData = this._getHeaderTreeNodeDataByCoords({\n    row: headerLevel,\n    col: from.col\n  });\n  const endNodeData = this._getHeaderTreeNodeDataByCoords({\n    row: headerLevel,\n    col: to.col\n  });\n  if (to.col < from.col) {\n    // Column selection from right to left\n    if (startNodeData) {\n      from.col = startNodeData.columnIndex + startNodeData.origColspan - 1;\n    }\n    if (endNodeData) {\n      to.col = endNodeData.columnIndex;\n    }\n  } else if (to.col >= from.col) {\n    // Column selection from left to right or a single column selection\n    if (startNodeData) {\n      from.col = startNodeData.columnIndex;\n    }\n    if (endNodeData) {\n      to.col = endNodeData.columnIndex + endNodeData.origColspan - 1;\n    }\n  }\n}\nfunction _onAfterGetColumnHeaderRenderers2(renderersArray) {\n  renderersArray.length = 0;\n  for (let headerLayer = 0; headerLayer < _classPrivateFieldGet(this, _stateManager).getLayersCount(); headerLayer++) {\n    renderersArray.push(this.headerRendererFactory(headerLayer));\n  }\n}\nfunction _onAfterViewportColumnCalculatorOverride2(calc) {\n  const headerLayersCount = _classPrivateFieldGet(this, _stateManager).getLayersCount();\n  let newStartColumn = calc.startColumn;\n  let nonRenderable = !!headerLayersCount;\n  for (let headerLayer = 0; headerLayer < headerLayersCount; headerLayer++) {\n    const startColumn = _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(headerLayer, calc.startColumn);\n    const renderedStartColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(startColumn);\n\n    // If any of the headers for that column index is rendered, all of them should be rendered properly, see\n    // comment below.\n    if (startColumn >= 0) {\n      nonRenderable = false;\n    }\n\n    // `renderedStartColumn` can be `null` if the leftmost columns are hidden. In that case -> ignore that header\n    // level, as it should be handled by the \"parent\" header\n    if (isNumeric(renderedStartColumn) && renderedStartColumn < calc.startColumn) {\n      newStartColumn = renderedStartColumn;\n      break;\n    }\n  }\n\n  // If no headers for the provided column index are renderable, start rendering from the beginning of the upmost\n  // header for that position.\n  calc.startColumn = nonRenderable ? _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(0, newStartColumn).columnIndex : newStartColumn;\n}\nfunction _onModifyColWidth2(width, column) {\n  const cachedWidth = this.ghostTable.getWidth(column);\n  return width > cachedWidth ? width : cachedWidth;\n}\nfunction _onModifyColumnHeaderValue2(value, visualColumnIndex, headerLevel) {\n  var _classPrivateFieldGet5;\n  const {\n    label\n  } = (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet5 !== void 0 ? _classPrivateFieldGet5 : {\n    label: ''\n  };\n  return label;\n}\nfunction _onModifyFocusedElement2(row, column) {\n  if (row < 0) {\n    return this.hot.getCell(row, _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(row, column), true);\n  }\n}\nfunction _onInit2() {\n  // @TODO: Workaround for broken plugin initialization abstraction.\n  this.updatePlugin();\n}\nfunction _onAfterLoadData2(sourceData, initialLoad) {\n  if (!initialLoad) {\n    this.updatePlugin();\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","_classPrivateFieldInitSpec","privateMap","set","privateCollection","has","_classPrivateFieldSet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorSet","_classPrivateFieldGet","_classApplyDescriptorGet","action","get","_classPrivateMethodGet","fn","addClass","removeClass","isNumeric","clamp","toSingleLine","isLeftClick","isRightClick","warn","ACTIVE_HEADER_TYPE","HEADER_TYPE","BasePlugin","StateManager","GhostTable","PLUGIN_KEY","PLUGIN_PRIORITY","_stateManager","WeakMap","_hidingIndexMapObserver","_focusInitialCoords","_isColumnsSelectionInProgress","_updateFocusHighlightPosition","WeakSet","_onBeforeViewportScrollHorizontally","_onBeforeHighlightingColumnHeader","_onBeforeCopy","_onBeforeOnCellMouseDown","_onAfterOnCellMouseDown","_onBeforeOnCellMouseOver","_onBeforeOnCellMouseUp","_onBeforeSelectionHighlightSet","_onModifyTransformStart","_onBeforeSelectColumns","_onAfterGetColumnHeaderRenderers","_onAfterViewportColumnCalculatorOverride","_onModifyColWidth","_onModifyColumnHeaderValue","_onModifyFocusedElement","_onInit","_onAfterLoadData","NestedHeaders","constructor","arguments","hot","row","column","getHeaderSettings","isEnabled","getSettings","enablePlugin","_this","enabled","nestedHeaders","Array","isArray","addHook","_onInit2","_len","length","args","_key","_onAfterLoadData2","_len2","_key2","_onBeforeOnCellMouseDown2","_len3","_key3","_onAfterOnCellMouseDown2","_len4","_key4","_onBeforeOnCellMouseOver2","_len5","_key5","_onBeforeOnCellMouseUp2","_len6","_key6","_onBeforeSelectionHighlightSet2","_len7","_key7","_onModifyTransformStart2","_updateFocusHighlightPosition2","_len8","_key8","_onBeforeViewportScrollHorizontally2","array","_onAfterGetColumnHeaderRenderers2","_len9","_key9","_onModifyColWidth2","_len10","_key10","_onModifyColumnHeaderValue2","_len11","_key11","_onBeforeHighlightingColumnHeader2","_len12","_key12","_onBeforeCopy2","_len13","_key13","_onBeforeSelectColumns2","_len14","_key14","_onAfterViewportColumnCalculatorOverride2","_len15","_key15","_onModifyFocusedElement2","columnIndexMapper","addLocalHook","rowIndexMapper","updatePlugin","view","setColumnsLimit","countCols","detectedOverlappedHeaders","setState","hidingMapsCollection","getMergedValues","forEach","isColumnHidden","physicalColumnIndex","actionName","triggerColumnModification","createChangesObserver","subscribe","changes","_ref","op","index","columnIndex","newValue","ghostTable","buildWidthsMap","setLayersCount","getLayersCount","disablePlugin","clearColspans","clear","unsubscribe","getStateManager","headerLevel","_wt","wt","headerLevels","getSetting","mainHeaders","wtTable","THEAD","topHeaders","wtOverlays","topOverlay","clone","topLeftCornerHeaders","topInlineStartCornerOverlay","masterLevel","childNodes","topLevel","topLeftCornerLevel","j","masterNodes","removeAttribute","headerRendererFactory","_this2","fixedColumnsStart","renderedColumnIndex","TH","_classPrivateFieldGet2","visualColumnIndex","getVisualFromRenderableIndex","colspan","isHidden","isPlaceholder","label","_wtOverlays$topInline","_wtOverlays$inlineSta","isTopInlineStartOverlay","contains","isInlineStartOverlay","inlineStartOverlay","correctedColspan","Math","min","setAttribute","appendColHeader","getColumnHeaderValue","_classPrivateFieldGet3","getColHeader","destroy","_getHeaderTreeNodeDataByCoords","coords","col","getHeaderTreeNodeData","_this$hot","selection","getSelectedRangeLast","highlight","isNestedHeadersRange","isHeader","findLeftMostColumnIndex","focusHighlight","getFocus","visualCellRange","from","to","commit","visualColumn","firstColumn","getFirstFullyVisibleColumn","lastColumn","getLastFullyVisibleColumn","mostLeftColumnIndex","mostRightColumnIndex","findRightMostColumnIndex","highlightMeta","headerNodeData","columnCursor","selectionType","selectionWidth","isRoot","data","copyableRanges","_ref2","columnHeadersCount","rangeIndex","startRow","startCol","endRow","endCol","rowsCount","columnsCount","_classPrivateFieldGet4","zeroBasedColumnHeaderLevel","zeroBasedColumnIndex","event","TD","controller","currentSelection","isSelected","getSelectedRange","current","columnsToSelect","origColspan","allowRightClickSelection","inInSelection","shiftKey","push","getTopEndCorner","getTopStartCorner","selectColumns","isMouseDown","selectedRange","topStartCoords","bottomEndCoords","getBottomEndCorner","cell","Infinity","navigableHeaders","columnStart","columnEnd","setHighlight","getWidth","findTopMostEntireHeaderLevel","delta","nextCoords","_createCellCoords","visualColumnIndexStart","visualColumnIndexEnd","nextColumn","notHiddenColumnIndex","getNearestNotHiddenIndex","countRenderableColumnsInRange","max","startNodeData","endNodeData","renderersArray","headerLayer","calc","headerLayersCount","newStartColumn","startColumn","nonRenderable","renderedStartColumn","getRenderableFromVisualIndex","width","cachedWidth","_classPrivateFieldGet5","getCell","sourceData","initialLoad"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/nestedHeaders/nestedHeaders.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { addClass, removeClass } from \"../../helpers/dom/element.mjs\";\nimport { isNumeric, clamp } from \"../../helpers/number.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\nimport { isLeftClick, isRightClick } from \"../../helpers/dom/event.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { ACTIVE_HEADER_TYPE, HEADER_TYPE } from \"../../selection/index.mjs\";\nimport { BasePlugin } from \"../base/index.mjs\";\nimport StateManager from \"./stateManager/index.mjs\";\nimport GhostTable from \"./utils/ghostTable.mjs\";\nexport const PLUGIN_KEY = 'nestedHeaders';\nexport const PLUGIN_PRIORITY = 280;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin NestedHeaders\n * @class NestedHeaders\n *\n * @description\n * The plugin allows to create a nested header structure, using the HTML's colspan attribute.\n *\n * To make any header wider (covering multiple table columns), it's corresponding configuration array element should be\n * provided as an object with `label` and `colspan` properties. The `label` property defines the header's label,\n * while the `colspan` property defines a number of columns that the header should cover.\n *\n * __Note__ that the plugin supports a *nested* structure, which means, any header cannot be wider than it's \"parent\". In\n * other words, headers cannot overlap each other.\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   nestedHeaders: [\n *     ['A', {label: 'B', colspan: 8}, 'C'],\n *     ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],\n *     ['H', {label: 'I', colspan: 2}, {label: 'J', colspan: 2}, {label: 'K', colspan: 2}, {label: 'L', colspan: 2}, 'M'],\n *     ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W']\n *  ],\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   nestedHeaders={[\n *     ['A', {label: 'B', colspan: 8}, 'C'],\n *     ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],\n *     ['H', {label: 'I', colspan: 2}, {label: 'J', colspan: 2}, {label: 'K', colspan: 2}, {label: 'L', colspan: 2}, 'M'],\n *     ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W']\n *  ]}\n * />\n * ```\n * :::\n */\nvar _stateManager = /*#__PURE__*/new WeakMap();\nvar _hidingIndexMapObserver = /*#__PURE__*/new WeakMap();\nvar _focusInitialCoords = /*#__PURE__*/new WeakMap();\nvar _isColumnsSelectionInProgress = /*#__PURE__*/new WeakMap();\nvar _updateFocusHighlightPosition = /*#__PURE__*/new WeakSet();\nvar _onBeforeViewportScrollHorizontally = /*#__PURE__*/new WeakSet();\nvar _onBeforeHighlightingColumnHeader = /*#__PURE__*/new WeakSet();\nvar _onBeforeCopy = /*#__PURE__*/new WeakSet();\nvar _onBeforeOnCellMouseDown = /*#__PURE__*/new WeakSet();\nvar _onAfterOnCellMouseDown = /*#__PURE__*/new WeakSet();\nvar _onBeforeOnCellMouseOver = /*#__PURE__*/new WeakSet();\nvar _onBeforeOnCellMouseUp = /*#__PURE__*/new WeakSet();\nvar _onBeforeSelectionHighlightSet = /*#__PURE__*/new WeakSet();\nvar _onModifyTransformStart = /*#__PURE__*/new WeakSet();\nvar _onBeforeSelectColumns = /*#__PURE__*/new WeakSet();\nvar _onAfterGetColumnHeaderRenderers = /*#__PURE__*/new WeakSet();\nvar _onAfterViewportColumnCalculatorOverride = /*#__PURE__*/new WeakSet();\nvar _onModifyColWidth = /*#__PURE__*/new WeakSet();\nvar _onModifyColumnHeaderValue = /*#__PURE__*/new WeakSet();\nvar _onModifyFocusedElement = /*#__PURE__*/new WeakSet();\nvar _onInit = /*#__PURE__*/new WeakSet();\nvar _onAfterLoadData = /*#__PURE__*/new WeakSet();\nexport class NestedHeaders extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Updates the plugin state after new dataset load.\n     *\n     * @param {Array[]} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded\n     *                              during the initialization.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterLoadData);\n    /**\n     * Updates the plugin state after HoT initialization.\n     */\n    _classPrivateMethodInitSpec(this, _onInit);\n    /**\n     * `modifyFocusedElement` hook callback.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Column index.\n     * @returns {HTMLTableCellElement} The `TH` element to be focused.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyFocusedElement);\n    /**\n     * Listens the `modifyColumnHeaderValue` hook that overwrites the column headers values based on\n     * the internal state and settings of the plugin.\n     *\n     * @param {string} value The column header value.\n     * @param {number} visualColumnIndex The visual column index.\n     * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)\n     *                             and negative (-1 to -N) values. For positive values, 0 points to the\n     *                             top most header, and for negative direction, -1 points to the most bottom\n     *                             header (the header closest to the cells).\n     * @returns {string} Returns the column header value to update.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyColumnHeaderValue);\n    /**\n     * `modifyColWidth` hook callback - returns width from cache, when is greater than incoming from hook.\n     *\n     * @param {number} width Width from hook.\n     * @param {number} column Visual index of an column.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _onModifyColWidth);\n    /**\n     * Make the renderer render the first nested column in its entirety.\n     *\n     * @param {object} calc Viewport column calculator.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterViewportColumnCalculatorOverride);\n    /**\n     * `afterGetColumnHeader` hook callback - prepares the header structure.\n     *\n     * @param {Array} renderersArray Array of renderers.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterGetColumnHeaderRenderers);\n    /**\n     * The hook observes the column selection from the Selection API and modifies the column range to\n     * ensure that the whole nested column will be covered.\n     *\n     * @param {CellCoords} from The coords object where the selection starts.\n     * @param {CellCoords} to The coords object where the selection ends.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeSelectColumns);\n    /**\n     * `modifyTransformStart` hook is called every time the keyboard navigation is used.\n     *\n     * @param {object} delta The transformation delta.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyTransformStart);\n    /**\n     * The hook checks and ensures that the focus position that depends on the selected columns\n     * range is always positioned within the range.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeSelectionHighlightSet);\n    /**\n     * Switches internal flag about selection progress to `false`.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeOnCellMouseUp);\n    /**\n     * Makes the header-selection properly select the nested headers.\n     *\n     * @param {MouseEvent} event Mouse event.\n     * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n     * @param {HTMLElement} TD The cell element.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeOnCellMouseOver);\n    /**\n     * Allows to control how the column selection based on the coordinates and the nested headers is made.\n     *\n     * @param {MouseEvent} event Mouse event.\n     * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterOnCellMouseDown);\n    /**\n     * Allows blocking the column selection that is controlled by the core Selection module.\n     *\n     * @param {MouseEvent} event Mouse event.\n     * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n     * @param {CellCoords} TD The table cell or header element.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeOnCellMouseDown);\n    /**\n     * Listens the `beforeCopy` hook that allows processing the copied column headers so that the\n     * merged column headers do not propagate the value for each column but only once at the beginning\n     * of the column.\n     *\n     * @private\n     * @param {Array[]} data An array of arrays which contains data to copied.\n     * @param {object[]} copyableRanges An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n     *                                  which will copied.\n     * @param {{ columnHeadersCount: number }} copiedHeadersCount An object with keys that holds information with\n     *                                                            the number of copied headers.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeCopy);\n    /**\n     * Allows to control which header DOM element will be used to highlight.\n     *\n     * @param {number} visualColumn A visual column index of the highlighted row header.\n     * @param {number} headerLevel A row header level that is currently highlighted.\n     * @param {object} highlightMeta An object with meta data that describes the highlight state.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeHighlightingColumnHeader);\n    /**\n     * Allows to control to which column index the viewport will be scrolled. To ensure that the viewport\n     * is scrolled to the correct column for the nested header the most left and the most right visual column\n     * indexes are used.\n     *\n     * @param {number} visualColumn A visual column index to which the viewport will be scrolled.\n     * @returns {number}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeViewportScrollHorizontally);\n    /**\n     * Updates the selection focus highlight position to point to the nested header root element (TH)\n     * even when the logical coordinates point in-between the header.\n     */\n    _classPrivateMethodInitSpec(this, _updateFocusHighlightPosition);\n    /**\n     * The state manager for the nested headers.\n     *\n     * @type {StateManager}\n     */\n    _classPrivateFieldInitSpec(this, _stateManager, {\n      writable: true,\n      value: new StateManager()\n    });\n    /**\n     * The instance of the ChangesObservable class that allows track the changes that happens in the\n     * column indexes.\n     *\n     * @type {ChangesObservable}\n     */\n    _classPrivateFieldInitSpec(this, _hidingIndexMapObserver, {\n      writable: true,\n      value: null\n    });\n    /**\n     * Holds the coords that points to the place where the column selection starts.\n     *\n     * @type {number|null}\n     */\n    _classPrivateFieldInitSpec(this, _focusInitialCoords, {\n      writable: true,\n      value: null\n    });\n    /**\n     * Determines if there is performed the column selection.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isColumnsSelectionInProgress, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Custom helper for getting widths of the nested headers.\n     *\n     * @private\n     * @type {GhostTable}\n     */\n    // @TODO This should be changed after refactor handsontable/utils/ghostTable.\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot, (row, column) => this.getHeaderSettings(row, column)));\n    /**\n     * The flag which determines that the nested header settings contains overlapping headers\n     * configuration.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"detectedOverlappedHeaders\", false);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Check if plugin is enabled.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const {\n      nestedHeaders\n    } = this.hot.getSettings();\n    if (!Array.isArray(nestedHeaders) || !Array.isArray(nestedHeaders[0])) {\n      warn(toSingleLine`Your Nested Headers plugin configuration is invalid. The settings has to be\\x20\n                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]`);\n    }\n    this.addHook('init', () => _classPrivateMethodGet(this, _onInit, _onInit2).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onAfterLoadData, _onAfterLoadData2).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeOnCellMouseDown, _onBeforeOnCellMouseDown2).call(_this, ...args);\n    });\n    this.addHook('afterOnCellMouseDown', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _classPrivateMethodGet(_this, _onAfterOnCellMouseDown, _onAfterOnCellMouseDown2).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeOnCellMouseOver, _onBeforeOnCellMouseOver2).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseUp', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeOnCellMouseUp, _onBeforeOnCellMouseUp2).call(_this, ...args);\n    });\n    this.addHook('beforeSelectionHighlightSet', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeSelectionHighlightSet, _onBeforeSelectionHighlightSet2).call(_this, ...args);\n    });\n    this.addHook('modifyTransformStart', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _classPrivateMethodGet(_this, _onModifyTransformStart, _onModifyTransformStart2).call(_this, ...args);\n    });\n    this.addHook('afterSelection', () => _classPrivateMethodGet(this, _updateFocusHighlightPosition, _updateFocusHighlightPosition2).call(this));\n    this.addHook('beforeViewportScrollHorizontally', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeViewportScrollHorizontally, _onBeforeViewportScrollHorizontally2).call(_this, ...args);\n    });\n    this.addHook('afterGetColumnHeaderRenderers', array => _classPrivateMethodGet(this, _onAfterGetColumnHeaderRenderers, _onAfterGetColumnHeaderRenderers2).call(this, array));\n    this.addHook('modifyColWidth', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _classPrivateMethodGet(_this, _onModifyColWidth, _onModifyColWidth2).call(_this, ...args);\n    });\n    this.addHook('modifyColumnHeaderValue', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _classPrivateMethodGet(_this, _onModifyColumnHeaderValue, _onModifyColumnHeaderValue2).call(_this, ...args);\n    });\n    this.addHook('beforeHighlightingColumnHeader', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeHighlightingColumnHeader, _onBeforeHighlightingColumnHeader2).call(_this, ...args);\n    });\n    this.addHook('beforeCopy', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeCopy, _onBeforeCopy2).call(_this, ...args);\n    });\n    this.addHook('beforeSelectColumns', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeSelectColumns, _onBeforeSelectColumns2).call(_this, ...args);\n    });\n    this.addHook('afterViewportColumnCalculatorOverride', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _classPrivateMethodGet(_this, _onAfterViewportColumnCalculatorOverride, _onAfterViewportColumnCalculatorOverride2).call(_this, ...args);\n    });\n    this.addHook('modifyFocusedElement', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _classPrivateMethodGet(_this, _onModifyFocusedElement, _onModifyFocusedElement2).call(_this, ...args);\n    });\n    this.hot.columnIndexMapper.addLocalHook('cacheUpdated', () => _classPrivateMethodGet(this, _updateFocusHighlightPosition, _updateFocusHighlightPosition2).call(this));\n    this.hot.rowIndexMapper.addLocalHook('cacheUpdated', () => _classPrivateMethodGet(this, _updateFocusHighlightPosition, _updateFocusHighlightPosition2).call(this));\n    super.enablePlugin();\n    this.updatePlugin(); // @TODO: Workaround for broken plugin initialization abstraction.\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`nestedHeaders`](@/api/options.md#nestedheaders)\n   */\n  updatePlugin() {\n    if (!this.hot.view) {\n      // @TODO: Workaround for broken plugin initialization abstraction.\n      return;\n    }\n    const {\n      nestedHeaders\n    } = this.hot.getSettings();\n    _classPrivateFieldGet(this, _stateManager).setColumnsLimit(this.hot.countCols());\n    if (Array.isArray(nestedHeaders)) {\n      this.detectedOverlappedHeaders = _classPrivateFieldGet(this, _stateManager).setState(nestedHeaders);\n    }\n    if (this.detectedOverlappedHeaders) {\n      warn(toSingleLine`Your Nested Headers plugin setup contains overlapping headers. This kind of configuration\\x20\n                        is currently not supported.`);\n    }\n    if (this.enabled) {\n      // This line covers the case when a developer uses the external hiding maps to manipulate\n      // the columns' visibility. The tree state built from the settings - which is always built\n      // as if all the columns are visible, needs to be modified to be in sync with a dataset.\n      this.hot.columnIndexMapper.hidingMapsCollection.getMergedValues().forEach((isColumnHidden, physicalColumnIndex) => {\n        const actionName = isColumnHidden === true ? 'hide-column' : 'show-column';\n        _classPrivateFieldGet(this, _stateManager).triggerColumnModification(actionName, physicalColumnIndex);\n      });\n    }\n    if (!_classPrivateFieldGet(this, _hidingIndexMapObserver) && this.enabled) {\n      _classPrivateFieldSet(this, _hidingIndexMapObserver, this.hot.columnIndexMapper.createChangesObserver('hiding').subscribe(changes => {\n        changes.forEach(_ref => {\n          let {\n            op,\n            index: columnIndex,\n            newValue\n          } = _ref;\n          if (op === 'replace') {\n            const actionName = newValue === true ? 'hide-column' : 'show-column';\n            _classPrivateFieldGet(this, _stateManager).triggerColumnModification(actionName, columnIndex);\n          }\n        });\n        this.ghostTable.buildWidthsMap();\n      }));\n    }\n    this.ghostTable.setLayersCount(this.getLayersCount()).buildWidthsMap();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearColspans();\n    _classPrivateFieldGet(this, _stateManager).clear();\n    _classPrivateFieldGet(this, _hidingIndexMapObserver).unsubscribe();\n    _classPrivateFieldSet(this, _hidingIndexMapObserver, null);\n    this.ghostTable.clear();\n    super.disablePlugin();\n  }\n\n  /**\n   * Returns an instance of the internal state manager of the plugin.\n   *\n   * @private\n   * @returns {StateManager}\n   */\n  getStateManager() {\n    return _classPrivateFieldGet(this, _stateManager);\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @private\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(this, _stateManager).getLayersCount();\n  }\n\n  /**\n   * Gets column settings for a specified header. The returned object contains\n   * information about the header label, its colspan length, or if it is hidden\n   * in the header renderers.\n   *\n   * @private\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    return _classPrivateFieldGet(this, _stateManager).getHeaderSettings(headerLevel, columnIndex);\n  }\n\n  /**\n   * Clear the colspans remaining after plugin usage.\n   *\n   * @private\n   */\n  clearColspans() {\n    if (!this.hot.view) {\n      return;\n    }\n    const {\n      _wt: wt\n    } = this.hot.view;\n    const headerLevels = wt.getSetting('columnHeaders').length;\n    const mainHeaders = wt.wtTable.THEAD;\n    const topHeaders = wt.wtOverlays.topOverlay.clone.wtTable.THEAD;\n    const topLeftCornerHeaders = wt.wtOverlays.topInlineStartCornerOverlay ? wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;\n    for (let i = 0; i < headerLevels; i++) {\n      const masterLevel = mainHeaders.childNodes[i];\n      if (!masterLevel) {\n        break;\n      }\n      const topLevel = topHeaders.childNodes[i];\n      const topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;\n      for (let j = 0, masterNodes = masterLevel.childNodes.length; j < masterNodes; j++) {\n        masterLevel.childNodes[j].removeAttribute('colspan');\n        removeClass(masterLevel.childNodes[j], 'hiddenHeader');\n        if (topLevel && topLevel.childNodes[j]) {\n          topLevel.childNodes[j].removeAttribute('colspan');\n          removeClass(topLevel.childNodes[j], 'hiddenHeader');\n        }\n        if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {\n          topLeftCornerLevel.childNodes[j].removeAttribute('colspan');\n          removeClass(topLeftCornerLevel.childNodes[j], 'hiddenHeader');\n        }\n      }\n    }\n  }\n\n  /**\n   * Generates the appropriate header renderer for a header row.\n   *\n   * @private\n   * @param {number} headerLevel The index of header level counting from the top (positive\n   *                             values counting from 0 to N).\n   * @returns {Function}\n   * @fires Hooks#afterGetColHeader\n   */\n  headerRendererFactory(headerLevel) {\n    var _this2 = this;\n    const fixedColumnsStart = this.hot.view._wt.getSetting('fixedColumnsStart');\n    return (renderedColumnIndex, TH) => {\n      var _classPrivateFieldGet2;\n      const {\n        columnIndexMapper,\n        view\n      } = this.hot;\n      let visualColumnIndex = columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n      if (visualColumnIndex === null) {\n        visualColumnIndex = renderedColumnIndex;\n      }\n      TH.removeAttribute('colspan');\n      removeClass(TH, 'hiddenHeader');\n      const {\n        colspan,\n        isHidden,\n        isPlaceholder\n      } = (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _stateManager).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : {\n        label: ''\n      };\n      if (isPlaceholder || isHidden) {\n        addClass(TH, 'hiddenHeader');\n      } else if (colspan > 1) {\n        var _wtOverlays$topInline, _wtOverlays$inlineSta;\n        const {\n          wtOverlays\n        } = view._wt;\n        const isTopInlineStartOverlay = (_wtOverlays$topInline = wtOverlays.topInlineStartCornerOverlay) === null || _wtOverlays$topInline === void 0 ? void 0 : _wtOverlays$topInline.clone.wtTable.THEAD.contains(TH);\n        const isInlineStartOverlay = (_wtOverlays$inlineSta = wtOverlays.inlineStartOverlay) === null || _wtOverlays$inlineSta === void 0 ? void 0 : _wtOverlays$inlineSta.clone.wtTable.THEAD.contains(TH);\n\n        // Check if there is a fixed column enabled, if so then reduce colspan to fixed column width.\n        const correctedColspan = isTopInlineStartOverlay || isInlineStartOverlay ? Math.min(colspan, fixedColumnsStart - renderedColumnIndex) : colspan;\n        if (correctedColspan > 1) {\n          TH.setAttribute('colspan', correctedColspan);\n        }\n      }\n      this.hot.view.appendColHeader(visualColumnIndex, TH, function () {\n        return _this2.getColumnHeaderValue(...arguments);\n      }, headerLevel);\n    };\n  }\n\n  /**\n   * Returns the column header value for specified column and header level index.\n   *\n   * @private\n   * @param {number} visualColumnIndex Visual column index.\n   * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)\n   *                             and negative (-1 to -N) values. For positive values, 0 points to the\n   *                             top most header, and for negative direction, -1 points to the most bottom\n   *                             header (the header closest to the cells).\n   * @returns {string} Returns the column header value to update.\n   */\n  getColumnHeaderValue(visualColumnIndex, headerLevel) {\n    var _classPrivateFieldGet3;\n    const {\n      isHidden,\n      isPlaceholder\n    } = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _stateManager).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : {};\n    if (isPlaceholder || isHidden) {\n      return '';\n    }\n    return this.hot.getColHeader(visualColumnIndex, headerLevel);\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldSet(this, _stateManager, null);\n    if (_classPrivateFieldGet(this, _hidingIndexMapObserver) !== null) {\n      _classPrivateFieldGet(this, _hidingIndexMapObserver).unsubscribe();\n      _classPrivateFieldSet(this, _hidingIndexMapObserver, null);\n    }\n    super.destroy();\n  }\n\n  /**\n   * Gets the tree data that belongs to the column headers pointed by the passed coordinates.\n   *\n   * @private\n   * @param {CellCoords} coords The CellCoords instance.\n   * @returns {object|undefined}\n   */\n  _getHeaderTreeNodeDataByCoords(coords) {\n    if (coords.row >= 0 || coords.col < 0) {\n      return;\n    }\n    return _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(coords.row, coords.col);\n  }\n}\nfunction _updateFocusHighlightPosition2() {\n  var _this$hot;\n  const selection = (_this$hot = this.hot) === null || _this$hot === void 0 ? void 0 : _this$hot.getSelectedRangeLast();\n  if (!selection) {\n    return;\n  }\n  const {\n    highlight\n  } = selection;\n  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;\n  if (isNestedHeadersRange) {\n    const columnIndex = _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(highlight.row, highlight.col);\n    const focusHighlight = this.hot.selection.highlight.getFocus();\n\n    // Correct the highlight/focus selection to highlight the correct TH element\n    focusHighlight.visualCellRange.highlight.col = columnIndex;\n    focusHighlight.visualCellRange.from.col = columnIndex;\n    focusHighlight.visualCellRange.to.col = columnIndex;\n    focusHighlight.commit();\n  }\n}\nfunction _onBeforeViewportScrollHorizontally2(visualColumn) {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection) {\n    return visualColumn;\n  }\n  const {\n    highlight\n  } = selection;\n  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;\n  if (!isNestedHeadersRange) {\n    return visualColumn;\n  }\n  const firstColumn = this.hot.view.getFirstFullyVisibleColumn();\n  const lastColumn = this.hot.view.getLastFullyVisibleColumn();\n  const mostLeftColumnIndex = _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(highlight.row, highlight.col);\n  const mostRightColumnIndex = _classPrivateFieldGet(this, _stateManager).findRightMostColumnIndex(highlight.row, highlight.col);\n\n  // do not scroll the viewport when the header is wider than the viewport\n  if (mostLeftColumnIndex < firstColumn && mostRightColumnIndex > lastColumn) {\n    return visualColumn;\n  }\n  return mostLeftColumnIndex < firstColumn ? mostLeftColumnIndex : mostRightColumnIndex;\n}\nfunction _onBeforeHighlightingColumnHeader2(visualColumn, headerLevel, highlightMeta) {\n  const headerNodeData = _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(headerLevel, visualColumn);\n  if (!headerNodeData) {\n    return visualColumn;\n  }\n  const {\n    columnCursor,\n    selectionType,\n    selectionWidth\n  } = highlightMeta;\n  const {\n    isRoot,\n    colspan\n  } = _classPrivateFieldGet(this, _stateManager).getHeaderSettings(headerLevel, visualColumn);\n  if (selectionType === HEADER_TYPE) {\n    if (!isRoot) {\n      return headerNodeData.columnIndex;\n    }\n  } else if (selectionType === ACTIVE_HEADER_TYPE) {\n    if (colspan > selectionWidth - columnCursor || !isRoot) {\n      // Prevents adding any CSS class names to the TH element\n      return null;\n    }\n  }\n  return visualColumn;\n}\nfunction _onBeforeCopy2(data, copyableRanges, _ref2) {\n  let {\n    columnHeadersCount\n  } = _ref2;\n  if (columnHeadersCount === 0) {\n    return;\n  }\n  for (let rangeIndex = 0; rangeIndex < copyableRanges.length; rangeIndex++) {\n    const {\n      startRow,\n      startCol,\n      endRow,\n      endCol\n    } = copyableRanges[rangeIndex];\n    const rowsCount = endRow - startRow + 1;\n    const columnsCount = startCol - endCol + 1;\n\n    // do not process dataset ranges and column headers where only one column is copied\n    if (startRow >= 0 || columnsCount === 1) {\n      break;\n    }\n    for (let column = startCol; column <= endCol; column++) {\n      for (let row = startRow; row <= endRow; row++) {\n        var _classPrivateFieldGet4;\n        const zeroBasedColumnHeaderLevel = rowsCount + row;\n        const zeroBasedColumnIndex = column - startCol;\n        if (zeroBasedColumnIndex === 0) {\n          continue; // eslint-disable-line no-continue\n        }\n        const isRoot = (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(row, column)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.isRoot;\n        if (isRoot === false) {\n          data[zeroBasedColumnHeaderLevel][zeroBasedColumnIndex] = '';\n        }\n      }\n    }\n  }\n}\nfunction _onBeforeOnCellMouseDown2(event, coords, TD, controller) {\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (headerNodeData) {\n    // Block the Selection module in controlling how the columns are selected. Pass the\n    // responsibility of the column selection to this plugin (see \"onAfterOnCellMouseDown\" hook).\n    controller.column = true;\n  }\n}\nfunction _onAfterOnCellMouseDown2(event, coords) {\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (!headerNodeData) {\n    return;\n  }\n  _classPrivateFieldSet(this, _focusInitialCoords, coords.clone());\n  _classPrivateFieldSet(this, _isColumnsSelectionInProgress, true);\n  const {\n    selection\n  } = this.hot;\n  const currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;\n  const columnsToSelect = [];\n  const {\n    columnIndex,\n    origColspan\n  } = headerNodeData;\n\n  // The Selection module doesn't allow it to extend its behavior easily. That's why here we need\n  // to re-implement the \"click\" and \"shift\" behavior. As a workaround, the logic for the nested\n  // headers must implement a similar logic as in the original Selection handler\n  // (see src/selection/mouseEventHandler.js).\n  const allowRightClickSelection = !selection.inInSelection(coords);\n  if (event.shiftKey && currentSelection) {\n    if (coords.col < currentSelection.from.col) {\n      columnsToSelect.push(currentSelection.getTopEndCorner().col, columnIndex, coords.row);\n    } else if (coords.col > currentSelection.from.col) {\n      columnsToSelect.push(currentSelection.getTopStartCorner().col, columnIndex + origColspan - 1, coords.row);\n    } else {\n      columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);\n    }\n  } else if (isLeftClick(event) || isRightClick(event) && allowRightClickSelection) {\n    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);\n  }\n\n  // The plugin takes control of how the columns are selected.\n  selection.selectColumns(...columnsToSelect);\n}\nfunction _onBeforeOnCellMouseOver2(event, coords, TD, controller) {\n  if (!this.hot.view.isMouseDown()) {\n    return;\n  }\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (!headerNodeData) {\n    return;\n  }\n  const {\n    columnIndex,\n    origColspan\n  } = headerNodeData;\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const topStartCoords = selectedRange.getTopStartCorner();\n  const bottomEndCoords = selectedRange.getBottomEndCorner();\n  const {\n    from\n  } = selectedRange;\n\n  // Block the Selection module in controlling how the columns and cells are selected.\n  // From now on, the plugin is responsible for the selection.\n  controller.column = true;\n  controller.cell = true;\n  const columnsToSelect = [];\n  const headerLevel = clamp(coords.row, -Infinity, -1);\n  if (coords.col < from.col) {\n    columnsToSelect.push(bottomEndCoords.col, columnIndex, headerLevel);\n  } else if (coords.col > from.col) {\n    columnsToSelect.push(topStartCoords.col, columnIndex + origColspan - 1, headerLevel);\n  } else {\n    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, headerLevel);\n  }\n  this.hot.selection.selectColumns(...columnsToSelect);\n}\nfunction _onBeforeOnCellMouseUp2() {\n  _classPrivateFieldSet(this, _isColumnsSelectionInProgress, false);\n}\nfunction _onBeforeSelectionHighlightSet2() {\n  const {\n    navigableHeaders\n  } = this.hot.getSettings();\n  if (!this.hot.view.isMouseDown() || !_classPrivateFieldGet(this, _isColumnsSelectionInProgress) || !navigableHeaders) {\n    return;\n  }\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const columnStart = selectedRange.getTopStartCorner().col;\n  const columnEnd = selectedRange.getBottomEndCorner().col;\n  const {\n    columnIndex,\n    origColspan\n  } = _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(_classPrivateFieldGet(this, _focusInitialCoords).row, _classPrivateFieldGet(this, _focusInitialCoords).col);\n  selectedRange.setHighlight(_classPrivateFieldGet(this, _focusInitialCoords));\n  if (origColspan > selectedRange.getWidth() || columnIndex < columnStart || columnIndex + origColspan - 1 > columnEnd) {\n    const headerLevel = _classPrivateFieldGet(this, _stateManager).findTopMostEntireHeaderLevel(clamp(columnStart, columnIndex, columnIndex + origColspan - 1), clamp(columnEnd, columnIndex, columnIndex + origColspan - 1));\n    selectedRange.highlight.row = headerLevel;\n    selectedRange.highlight.col = selectedRange.from.col;\n  }\n}\nfunction _onModifyTransformStart2(delta) {\n  const {\n    highlight\n  } = this.hot.getSelectedRangeLast();\n  const nextCoords = this.hot._createCellCoords(highlight.row + delta.row, highlight.col + delta.col);\n  const isNestedHeadersRange = nextCoords.isHeader() && nextCoords.col >= 0;\n  if (!isNestedHeadersRange) {\n    return;\n  }\n  const visualColumnIndexStart = _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(nextCoords.row, nextCoords.col);\n  const visualColumnIndexEnd = _classPrivateFieldGet(this, _stateManager).findRightMostColumnIndex(nextCoords.row, nextCoords.col);\n  if (delta.col < 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexStart - 1 : visualColumnIndexEnd;\n    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, -1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the previous row (if autoWrapRow is enabled).\n      delta.col = -this.hot.view.countRenderableColumnsInRange(0, highlight.col);\n    } else {\n      delta.col = -Math.max(this.hot.view.countRenderableColumnsInRange(notHiddenColumnIndex, highlight.col) - 1, 1);\n    }\n  } else if (delta.col > 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexEnd + 1 : visualColumnIndexStart;\n    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, 1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the next row (if autoWrapRow is enabled).\n      delta.col = this.hot.view.countRenderableColumnsInRange(highlight.col, this.hot.countCols());\n    } else {\n      delta.col = Math.max(this.hot.view.countRenderableColumnsInRange(highlight.col, notHiddenColumnIndex) - 1, 1);\n    }\n  }\n}\nfunction _onBeforeSelectColumns2(from, to) {\n  const headerLevel = from.row;\n  const startNodeData = this._getHeaderTreeNodeDataByCoords({\n    row: headerLevel,\n    col: from.col\n  });\n  const endNodeData = this._getHeaderTreeNodeDataByCoords({\n    row: headerLevel,\n    col: to.col\n  });\n  if (to.col < from.col) {\n    // Column selection from right to left\n    if (startNodeData) {\n      from.col = startNodeData.columnIndex + startNodeData.origColspan - 1;\n    }\n    if (endNodeData) {\n      to.col = endNodeData.columnIndex;\n    }\n  } else if (to.col >= from.col) {\n    // Column selection from left to right or a single column selection\n    if (startNodeData) {\n      from.col = startNodeData.columnIndex;\n    }\n    if (endNodeData) {\n      to.col = endNodeData.columnIndex + endNodeData.origColspan - 1;\n    }\n  }\n}\nfunction _onAfterGetColumnHeaderRenderers2(renderersArray) {\n  renderersArray.length = 0;\n  for (let headerLayer = 0; headerLayer < _classPrivateFieldGet(this, _stateManager).getLayersCount(); headerLayer++) {\n    renderersArray.push(this.headerRendererFactory(headerLayer));\n  }\n}\nfunction _onAfterViewportColumnCalculatorOverride2(calc) {\n  const headerLayersCount = _classPrivateFieldGet(this, _stateManager).getLayersCount();\n  let newStartColumn = calc.startColumn;\n  let nonRenderable = !!headerLayersCount;\n  for (let headerLayer = 0; headerLayer < headerLayersCount; headerLayer++) {\n    const startColumn = _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(headerLayer, calc.startColumn);\n    const renderedStartColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(startColumn);\n\n    // If any of the headers for that column index is rendered, all of them should be rendered properly, see\n    // comment below.\n    if (startColumn >= 0) {\n      nonRenderable = false;\n    }\n\n    // `renderedStartColumn` can be `null` if the leftmost columns are hidden. In that case -> ignore that header\n    // level, as it should be handled by the \"parent\" header\n    if (isNumeric(renderedStartColumn) && renderedStartColumn < calc.startColumn) {\n      newStartColumn = renderedStartColumn;\n      break;\n    }\n  }\n\n  // If no headers for the provided column index are renderable, start rendering from the beginning of the upmost\n  // header for that position.\n  calc.startColumn = nonRenderable ? _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(0, newStartColumn).columnIndex : newStartColumn;\n}\nfunction _onModifyColWidth2(width, column) {\n  const cachedWidth = this.ghostTable.getWidth(column);\n  return width > cachedWidth ? width : cachedWidth;\n}\nfunction _onModifyColumnHeaderValue2(value, visualColumnIndex, headerLevel) {\n  var _classPrivateFieldGet5;\n  const {\n    label\n  } = (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _stateManager).getHeaderTreeNodeData(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet5 !== void 0 ? _classPrivateFieldGet5 : {\n    label: ''\n  };\n  return label;\n}\nfunction _onModifyFocusedElement2(row, column) {\n  if (row < 0) {\n    return this.hot.getCell(row, _classPrivateFieldGet(this, _stateManager).findLeftMostColumnIndex(row, column), true);\n  }\n}\nfunction _onInit2() {\n  // @TODO: Workaround for broken plugin initialization abstraction.\n  this.updatePlugin();\n}\nfunction _onAfterLoadData2(sourceData, initialLoad) {\n  if (!initialLoad) {\n    this.updatePlugin();\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}