{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nimport { arrayMap, arrayReduce } from \"../../../helpers/array.mjs\";\nimport SourceSettings from \"./sourceSettings.mjs\";\nimport HeadersTree from \"./headersTree.mjs\";\nimport { triggerNodeModification } from \"./nodeModifiers/index.mjs\";\nimport { generateMatrix } from \"./matrixGenerator.mjs\";\nimport { TRAVERSAL_DF_PRE } from \"../../../utils/dataStructures/tree.mjs\";\n/**\n * The state manager is a source of truth for nested headers configuration.\n * The state generation process is divided into three stages.\n *\n *   +---------------------+  1. User-defined configuration normalization;\n *   │                     │  The source settings class normalizes and shares API for\n *   │   SourceSettings    │  raw settings passed by the developer. It is only consumed by\n *   │                     │  the header tree module.\n *   +---------------------+\n *             │\n *            \\│/\n *   +---------------------+  2. Building a tree structure for validation and easier node manipulation;\n *   │                     │  The header tree generates a tree based on source settings for future\n *   │     HeadersTree     │  node manipulation (such as collapsible columns feature). While generating a tree\n *   │                     │  the source settings is checked to see if the configuration has overlapping headers.\n *   +---------------------+  If `true` the colspan matrix generation is skipped, overlapped headers are not supported.\n *             │\n *            \\│/\n *   +---------------------+  3. Matrix generation;\n *   │                     │  Based on built trees the matrix generation is performed. That part of code\n *   │  matrix generation  │  generates an array structure similar to normalized data from the SourceSettings\n *   │                     │  but with the difference that this structure contains column settings which changed\n *   +---------------------+  during runtime (after the tree manipulation) e.q after collapse or expand column.\n *                            That settings describes how the TH element should be modified (colspan attribute,\n *                            CSS classes, etc) for a specific column and layer level.\n *\n * @class StateManager\n */\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\nvar _headersTree = /*#__PURE__*/new WeakMap();\nvar _stateMatrix = /*#__PURE__*/new WeakMap();\nexport default class StateManager {\n  constructor() {\n    /**\n     * The instance of the source settings class.\n     *\n     * @private\n     * @type {SourceSettings}\n     */\n    _classPrivateFieldInitSpec(this, _sourceSettings, {\n      writable: true,\n      value: new SourceSettings()\n    });\n    /**\n     * The instance of the headers tree. The tree is generated after setting new configuration data.\n     *\n     * @private\n     * @type {HeadersTree}\n     */\n    _classPrivateFieldInitSpec(this, _headersTree, {\n      writable: true,\n      value: new HeadersTree(_classPrivateFieldGet(this, _sourceSettings))\n    });\n    /**\n     * Cached matrix which is generated from the tree structure.\n     *\n     * @private\n     * @type {Array[]}\n     */\n    _classPrivateFieldInitSpec(this, _stateMatrix, {\n      writable: true,\n      value: [[]]\n    });\n  }\n  /**\n   * Sets a new state for the nested headers plugin based on settings passed\n   * directly to the plugin.\n   *\n   * @param {Array[]} nestedHeadersSettings The user-defined settings.\n   * @returns {boolean} Returns `true` if the settings are processed correctly, `false` otherwise.\n   */\n  setState(nestedHeadersSettings) {\n    _classPrivateFieldGet(this, _sourceSettings).setData(nestedHeadersSettings);\n    let hasError = false;\n    try {\n      _classPrivateFieldGet(this, _headersTree).buildTree();\n    } catch (ex) {\n      _classPrivateFieldGet(this, _headersTree).clear();\n      _classPrivateFieldGet(this, _sourceSettings).clear();\n      hasError = true;\n    }\n    _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n    return hasError;\n  }\n\n  /**\n   * Sets columns limit to the state will be trimmed. All headers (colspans) which\n   * overlap the column limit will be reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount The number of columns to limit to.\n   */\n  setColumnsLimit(columnsCount) {\n    _classPrivateFieldGet(this, _sourceSettings).setColumnsLimit(columnsCount);\n  }\n\n  /**\n   * Merges settings with current plugin state.\n   *\n   * By default only foreign keys are merged with source state and passed to the tree. But only\n   * known keys are exported to matrix.\n   *\n   * @param {object[]} settings An array of objects to merge with the current source settings.\n   *                            It is a requirement that every object has `row` and `col` properties\n   *                            which points to the specific header settings object.\n   */\n  mergeStateWith(settings) {\n    const transformedSettings = arrayMap(settings, _ref => {\n      let {\n        row,\n        ...rest\n      } = _ref;\n      return {\n        row: row < 0 ? this.rowCoordsToLevel(row) : row,\n        ...rest\n      };\n    });\n    _classPrivateFieldGet(this, _sourceSettings).mergeWith(transformedSettings);\n    _classPrivateFieldGet(this, _headersTree).buildTree();\n    _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n  }\n\n  /**\n   * Maps the current state with a callback. For each header settings the callback function\n   * is called. If the function returns value that value is merged with the state.\n   *\n   * By default only foreign keys are merged with source state and passed to the tree. But only\n   * known keys are exported to matrix.\n   *\n   * @param {Function} callback A function that is called for every header source settings.\n   *                            Each time the callback is called, the returned value extends\n   *                            header settings.\n   */\n  mapState(callback) {\n    _classPrivateFieldGet(this, _sourceSettings).map(callback);\n    _classPrivateFieldGet(this, _headersTree).buildTree();\n    _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n  }\n\n  /**\n   * Maps the current tree nodes with a callback. For each node the callback function\n   * is called. If the function returns value that value is added to returned array.\n   *\n   * @param {Function} callback A function that is called for every tree node.\n   *                            Each time the callback is called, the returned value is\n   *                            added to returned array.\n   * @returns {Array}\n   */\n  mapNodes(callback) {\n    return arrayReduce(_classPrivateFieldGet(this, _headersTree).getRoots(), (acc, rootNode) => {\n      rootNode.walkDown(node => {\n        const result = callback(node.data);\n        if (result !== undefined) {\n          acc.push(result);\n        }\n      });\n      return acc;\n    }, []);\n  }\n\n  /**\n   * Triggers an action (e.g. \"collapse\") from the NodeModifiers module. The module\n   * modifies a tree structure in such a way as to obtain the correct structure consistent with the\n   * called action.\n   *\n   * @param {string} action An action name to trigger.\n   * @param {number} headerLevel Header level index (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|undefined}\n   */\n  triggerNodeModification(action, headerLevel, columnIndex) {\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    const nodeToProcess = _classPrivateFieldGet(this, _headersTree).getNode(headerLevel, columnIndex);\n    let actionResult;\n    if (nodeToProcess) {\n      actionResult = triggerNodeModification(action, nodeToProcess, columnIndex);\n\n      // TODO (perf-tip): Trigger matrix generation once after multiple node modifications.\n      _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n    }\n    return actionResult;\n  }\n\n  /**\n   * Triggers an action (e.g. \"hide-column\") from the NodeModifiers module. The action is\n   * triggered starting from the lowest header. The module modifies a tree structure in\n   * such a way as to obtain the correct structure consistent with the called action.\n   *\n   * @param {string} action An action name to trigger.\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|undefined}\n   */\n  triggerColumnModification(action, columnIndex) {\n    return this.triggerNodeModification(action, -1, columnIndex);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof StateManager#\n   * @function rowCoordsToLevel\n   *\n   * Translates row coordinates into header level. The row coordinates counts from -1 to -N\n   * and describes headers counting from most closest to most distant from the table.\n   * The header levels are counted from 0 to N where 0 describes most distant header\n   * from the table.\n   *\n   *  Row coords             Header level\n   *           +--------------+\n   *       -3  │ A1 │ A1      │  0\n   *           +--------------+\n   *       -2  │ B1 │ B2 │ B3 │  1\n   *           +--------------+\n   *       -1  │ C1 │ C2 │ C3 │  2\n   *           +==============+\n   *           │    │    │    │\n   *           +--------------+\n   *           │    │    │    │\n   *\n   * @param {number} rowIndex A visual row index.\n   * @returns {number|null} Returns unsigned number.\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  rowCoordsToLevel(rowIndex) {\n    if (rowIndex >= 0) {\n      return null;\n    }\n    const headerLevel = rowIndex + Math.max(this.getLayersCount(), 1);\n    if (headerLevel < 0) {\n      return null;\n    }\n    return headerLevel;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof StateManager#\n   * @function levelToRowCoords\n   *\n   * Translates header level into row coordinates. The row coordinates counts from -1 to -N\n   * and describes headers counting from most closest to most distant from the table.\n   * The header levels are counted from 0 to N where 0 describes most distant header\n   * from the table.\n   *\n   *  Header level            Row coords\n   *           +--------------+\n   *        0  │ A1 │ A1      │  -3\n   *           +--------------+\n   *        1  │ B1 │ B2 │ B3 │  -2\n   *           +--------------+\n   *        2  │ C1 │ C2 │ C3 │  -1\n   *           +==============+\n   *           │    │    │    │\n   *           +--------------+\n   *           │    │    │    │\n   *\n   * @param {number} headerLevel Header level index.\n   * @returns {number} Returns negative number.\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  levelToRowCoords(headerLevel) {\n    if (headerLevel < 0) {\n      return null;\n    }\n    const rowIndex = headerLevel - Math.max(this.getLayersCount(), 1);\n    if (rowIndex >= 0) {\n      return null;\n    }\n    return rowIndex;\n  }\n\n  /**\n   * Gets column header settings for a specified column and header index. The returned object contains\n   * all information necessary for header renderers. It contains header label, colspan length, or hidden\n   * flag.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    var _classPrivateFieldGet2, _classPrivateFieldGet3;\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    if (headerLevel === null || headerLevel >= this.getLayersCount()) {\n      return null;\n    }\n    return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _stateMatrix)[headerLevel]) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3[columnIndex]) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;\n  }\n\n  /**\n   * Gets tree data that is connected to the column header. The returned object contains all information\n   * necessary for modifying tree structure (column collapsing, hiding, etc.). It contains a header\n   * label, colspan length, or visual column index that indicates which column index the node is rendered from.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderTreeNodeData(headerLevel, columnIndex) {\n    const node = this.getHeaderTreeNode(headerLevel, columnIndex);\n    if (!node) {\n      return null;\n    }\n    return {\n      ...node.data\n    };\n  }\n\n  /**\n   * Gets tree node that is connected to the column header.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|null}\n   */\n  getHeaderTreeNode(headerLevel, columnIndex) {\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    if (headerLevel === null || headerLevel >= this.getLayersCount()) {\n      return null;\n    }\n    const node = _classPrivateFieldGet(this, _headersTree).getNode(headerLevel, columnIndex);\n    if (!node) {\n      return null;\n    }\n    return node;\n  }\n\n  /**\n   * Finds the most top header level of the column header that is rendered entirely within\n   * the passed visual columns range. If multiple columns headers are found within the range the\n   * most top header level value will be returned.\n   *\n   * @param {number} columnIndexFrom A visual column index.\n   * @param {number} [columnIndexTo] A visual column index.\n   * @returns {number} Returns a header level in format -1 to -N.\n   */\n  findTopMostEntireHeaderLevel(columnIndexFrom) {\n    var _headerLevel;\n    let columnIndexTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : columnIndexFrom;\n    const columnsWidth = columnIndexTo - columnIndexFrom + 1;\n    let atLeastOneRootFound = false;\n    let headerLevel = null;\n    for (let columnIndex = columnIndexFrom; columnIndex <= columnIndexTo; columnIndex++) {\n      const rootNode = _classPrivateFieldGet(this, _headersTree).getRootByColumn(columnIndex);\n      if (!rootNode) {\n        break;\n      }\n      atLeastOneRootFound = true;\n\n      // eslint-disable-next-line\n      rootNode.walkDown(node => {\n        const {\n          columnIndex: nodeColumnIndex,\n          headerLevel: nodeHeaderLevel,\n          origColspan,\n          isHidden\n        } = node.data;\n        if (isHidden) {\n          return;\n        }\n\n        // if the header fits entirely within the columns range get and save the node header level\n        if (origColspan <= columnsWidth && nodeColumnIndex >= columnIndexFrom && nodeColumnIndex + origColspan - 1 <= columnIndexTo && (headerLevel === null || nodeHeaderLevel < headerLevel)) {\n          headerLevel = nodeHeaderLevel;\n        }\n      }, TRAVERSAL_DF_PRE);\n    }\n    if (atLeastOneRootFound && headerLevel === null) {\n      return -1;\n    }\n    return this.levelToRowCoords((_headerLevel = headerLevel) !== null && _headerLevel !== void 0 ? _headerLevel : 0);\n  }\n\n  /**\n   * The method is helpful in cases where the column index targets in-between currently\n   * collapsed column. In that case, the method returns the left-most column index\n   * where the nested header begins.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {number}\n   */\n  findLeftMostColumnIndex(headerLevel, columnIndex) {\n    var _this$getHeaderSettin;\n    const {\n      isRoot\n    } = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? _this$getHeaderSettin : {\n      isRoot: true\n    };\n    if (isRoot) {\n      return columnIndex;\n    }\n    let stepBackColumn = columnIndex - 1;\n    while (stepBackColumn >= 0) {\n      var _this$getHeaderSettin2;\n      const {\n        isRoot: isRootNode\n      } = (_this$getHeaderSettin2 = this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && _this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {\n        isRoot: true\n      };\n      if (isRootNode) {\n        break;\n      }\n      stepBackColumn -= 1;\n    }\n    return stepBackColumn;\n  }\n\n  /**\n   * The method is helpful in cases where the column index targets in-between currently\n   * collapsed column. In that case, the method returns the right-most column index\n   * where the nested header ends.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {number}\n   */\n  findRightMostColumnIndex(headerLevel, columnIndex) {\n    var _this$getHeaderSettin3;\n    const {\n      isRoot,\n      origColspan\n    } = (_this$getHeaderSettin3 = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin3 !== void 0 ? _this$getHeaderSettin3 : {\n      isRoot: true,\n      origColspan: 1\n    };\n    if (isRoot) {\n      return columnIndex + origColspan - 1;\n    }\n    let stepForthColumn = columnIndex + 1;\n    while (stepForthColumn < this.getColumnsCount()) {\n      var _this$getHeaderSettin4;\n      const {\n        isRoot: isRootNode\n      } = (_this$getHeaderSettin4 = this.getHeaderSettings(headerLevel, stepForthColumn)) !== null && _this$getHeaderSettin4 !== void 0 ? _this$getHeaderSettin4 : {\n        isRoot: true\n      };\n      if (isRootNode) {\n        break;\n      }\n      stepForthColumn += 1;\n    }\n    return stepForthColumn - 1;\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(this, _sourceSettings).getLayersCount();\n  }\n\n  /**\n   * Gets a total number of columns count.\n   *\n   * @returns {number}\n   */\n  getColumnsCount() {\n    return _classPrivateFieldGet(this, _sourceSettings).getColumnsCount();\n  }\n\n  /**\n   * Clears the column state manager to the initial state.\n   */\n  clear() {\n    _classPrivateFieldSet(this, _stateMatrix, []);\n    _classPrivateFieldGet(this, _sourceSettings).clear();\n    _classPrivateFieldGet(this, _headersTree).clear();\n  }\n}","map":{"version":3,"names":["_classPrivateFieldInitSpec","obj","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","TypeError","_classPrivateFieldSet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorSet","call","writable","_classPrivateFieldGet","_classApplyDescriptorGet","action","get","arrayMap","arrayReduce","SourceSettings","HeadersTree","triggerNodeModification","generateMatrix","TRAVERSAL_DF_PRE","_sourceSettings","WeakMap","_headersTree","_stateMatrix","StateManager","constructor","setState","nestedHeadersSettings","setData","hasError","buildTree","ex","clear","getRoots","setColumnsLimit","columnsCount","mergeStateWith","settings","transformedSettings","_ref","row","rest","rowCoordsToLevel","mergeWith","mapState","callback","map","mapNodes","acc","rootNode","walkDown","node","result","data","undefined","push","headerLevel","columnIndex","nodeToProcess","getNode","actionResult","triggerColumnModification","rowIndex","Math","max","getLayersCount","levelToRowCoords","getHeaderSettings","_classPrivateFieldGet2","_classPrivateFieldGet3","getHeaderTreeNodeData","getHeaderTreeNode","findTopMostEntireHeaderLevel","columnIndexFrom","_headerLevel","columnIndexTo","arguments","length","columnsWidth","atLeastOneRootFound","getRootByColumn","nodeColumnIndex","nodeHeaderLevel","origColspan","isHidden","findLeftMostColumnIndex","_this$getHeaderSettin","isRoot","stepBackColumn","_this$getHeaderSettin2","isRootNode","findRightMostColumnIndex","_this$getHeaderSettin3","stepForthColumn","getColumnsCount","_this$getHeaderSettin4"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/nestedHeaders/stateManager/index.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nimport { arrayMap, arrayReduce } from \"../../../helpers/array.mjs\";\nimport SourceSettings from \"./sourceSettings.mjs\";\nimport HeadersTree from \"./headersTree.mjs\";\nimport { triggerNodeModification } from \"./nodeModifiers/index.mjs\";\nimport { generateMatrix } from \"./matrixGenerator.mjs\";\nimport { TRAVERSAL_DF_PRE } from \"../../../utils/dataStructures/tree.mjs\";\n/**\n * The state manager is a source of truth for nested headers configuration.\n * The state generation process is divided into three stages.\n *\n *   +---------------------+  1. User-defined configuration normalization;\n *   │                     │  The source settings class normalizes and shares API for\n *   │   SourceSettings    │  raw settings passed by the developer. It is only consumed by\n *   │                     │  the header tree module.\n *   +---------------------+\n *             │\n *            \\│/\n *   +---------------------+  2. Building a tree structure for validation and easier node manipulation;\n *   │                     │  The header tree generates a tree based on source settings for future\n *   │     HeadersTree     │  node manipulation (such as collapsible columns feature). While generating a tree\n *   │                     │  the source settings is checked to see if the configuration has overlapping headers.\n *   +---------------------+  If `true` the colspan matrix generation is skipped, overlapped headers are not supported.\n *             │\n *            \\│/\n *   +---------------------+  3. Matrix generation;\n *   │                     │  Based on built trees the matrix generation is performed. That part of code\n *   │  matrix generation  │  generates an array structure similar to normalized data from the SourceSettings\n *   │                     │  but with the difference that this structure contains column settings which changed\n *   +---------------------+  during runtime (after the tree manipulation) e.q after collapse or expand column.\n *                            That settings describes how the TH element should be modified (colspan attribute,\n *                            CSS classes, etc) for a specific column and layer level.\n *\n * @class StateManager\n */\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\nvar _headersTree = /*#__PURE__*/new WeakMap();\nvar _stateMatrix = /*#__PURE__*/new WeakMap();\nexport default class StateManager {\n  constructor() {\n    /**\n     * The instance of the source settings class.\n     *\n     * @private\n     * @type {SourceSettings}\n     */\n    _classPrivateFieldInitSpec(this, _sourceSettings, {\n      writable: true,\n      value: new SourceSettings()\n    });\n    /**\n     * The instance of the headers tree. The tree is generated after setting new configuration data.\n     *\n     * @private\n     * @type {HeadersTree}\n     */\n    _classPrivateFieldInitSpec(this, _headersTree, {\n      writable: true,\n      value: new HeadersTree(_classPrivateFieldGet(this, _sourceSettings))\n    });\n    /**\n     * Cached matrix which is generated from the tree structure.\n     *\n     * @private\n     * @type {Array[]}\n     */\n    _classPrivateFieldInitSpec(this, _stateMatrix, {\n      writable: true,\n      value: [[]]\n    });\n  }\n  /**\n   * Sets a new state for the nested headers plugin based on settings passed\n   * directly to the plugin.\n   *\n   * @param {Array[]} nestedHeadersSettings The user-defined settings.\n   * @returns {boolean} Returns `true` if the settings are processed correctly, `false` otherwise.\n   */\n  setState(nestedHeadersSettings) {\n    _classPrivateFieldGet(this, _sourceSettings).setData(nestedHeadersSettings);\n    let hasError = false;\n    try {\n      _classPrivateFieldGet(this, _headersTree).buildTree();\n    } catch (ex) {\n      _classPrivateFieldGet(this, _headersTree).clear();\n      _classPrivateFieldGet(this, _sourceSettings).clear();\n      hasError = true;\n    }\n    _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n    return hasError;\n  }\n\n  /**\n   * Sets columns limit to the state will be trimmed. All headers (colspans) which\n   * overlap the column limit will be reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount The number of columns to limit to.\n   */\n  setColumnsLimit(columnsCount) {\n    _classPrivateFieldGet(this, _sourceSettings).setColumnsLimit(columnsCount);\n  }\n\n  /**\n   * Merges settings with current plugin state.\n   *\n   * By default only foreign keys are merged with source state and passed to the tree. But only\n   * known keys are exported to matrix.\n   *\n   * @param {object[]} settings An array of objects to merge with the current source settings.\n   *                            It is a requirement that every object has `row` and `col` properties\n   *                            which points to the specific header settings object.\n   */\n  mergeStateWith(settings) {\n    const transformedSettings = arrayMap(settings, _ref => {\n      let {\n        row,\n        ...rest\n      } = _ref;\n      return {\n        row: row < 0 ? this.rowCoordsToLevel(row) : row,\n        ...rest\n      };\n    });\n    _classPrivateFieldGet(this, _sourceSettings).mergeWith(transformedSettings);\n    _classPrivateFieldGet(this, _headersTree).buildTree();\n    _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n  }\n\n  /**\n   * Maps the current state with a callback. For each header settings the callback function\n   * is called. If the function returns value that value is merged with the state.\n   *\n   * By default only foreign keys are merged with source state and passed to the tree. But only\n   * known keys are exported to matrix.\n   *\n   * @param {Function} callback A function that is called for every header source settings.\n   *                            Each time the callback is called, the returned value extends\n   *                            header settings.\n   */\n  mapState(callback) {\n    _classPrivateFieldGet(this, _sourceSettings).map(callback);\n    _classPrivateFieldGet(this, _headersTree).buildTree();\n    _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n  }\n\n  /**\n   * Maps the current tree nodes with a callback. For each node the callback function\n   * is called. If the function returns value that value is added to returned array.\n   *\n   * @param {Function} callback A function that is called for every tree node.\n   *                            Each time the callback is called, the returned value is\n   *                            added to returned array.\n   * @returns {Array}\n   */\n  mapNodes(callback) {\n    return arrayReduce(_classPrivateFieldGet(this, _headersTree).getRoots(), (acc, rootNode) => {\n      rootNode.walkDown(node => {\n        const result = callback(node.data);\n        if (result !== undefined) {\n          acc.push(result);\n        }\n      });\n      return acc;\n    }, []);\n  }\n\n  /**\n   * Triggers an action (e.g. \"collapse\") from the NodeModifiers module. The module\n   * modifies a tree structure in such a way as to obtain the correct structure consistent with the\n   * called action.\n   *\n   * @param {string} action An action name to trigger.\n   * @param {number} headerLevel Header level index (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|undefined}\n   */\n  triggerNodeModification(action, headerLevel, columnIndex) {\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    const nodeToProcess = _classPrivateFieldGet(this, _headersTree).getNode(headerLevel, columnIndex);\n    let actionResult;\n    if (nodeToProcess) {\n      actionResult = triggerNodeModification(action, nodeToProcess, columnIndex);\n\n      // TODO (perf-tip): Trigger matrix generation once after multiple node modifications.\n      _classPrivateFieldSet(this, _stateMatrix, generateMatrix(_classPrivateFieldGet(this, _headersTree).getRoots()));\n    }\n    return actionResult;\n  }\n\n  /**\n   * Triggers an action (e.g. \"hide-column\") from the NodeModifiers module. The action is\n   * triggered starting from the lowest header. The module modifies a tree structure in\n   * such a way as to obtain the correct structure consistent with the called action.\n   *\n   * @param {string} action An action name to trigger.\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|undefined}\n   */\n  triggerColumnModification(action, columnIndex) {\n    return this.triggerNodeModification(action, -1, columnIndex);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof StateManager#\n   * @function rowCoordsToLevel\n   *\n   * Translates row coordinates into header level. The row coordinates counts from -1 to -N\n   * and describes headers counting from most closest to most distant from the table.\n   * The header levels are counted from 0 to N where 0 describes most distant header\n   * from the table.\n   *\n   *  Row coords             Header level\n   *           +--------------+\n   *       -3  │ A1 │ A1      │  0\n   *           +--------------+\n   *       -2  │ B1 │ B2 │ B3 │  1\n   *           +--------------+\n   *       -1  │ C1 │ C2 │ C3 │  2\n   *           +==============+\n   *           │    │    │    │\n   *           +--------------+\n   *           │    │    │    │\n   *\n   * @param {number} rowIndex A visual row index.\n   * @returns {number|null} Returns unsigned number.\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  rowCoordsToLevel(rowIndex) {\n    if (rowIndex >= 0) {\n      return null;\n    }\n    const headerLevel = rowIndex + Math.max(this.getLayersCount(), 1);\n    if (headerLevel < 0) {\n      return null;\n    }\n    return headerLevel;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof StateManager#\n   * @function levelToRowCoords\n   *\n   * Translates header level into row coordinates. The row coordinates counts from -1 to -N\n   * and describes headers counting from most closest to most distant from the table.\n   * The header levels are counted from 0 to N where 0 describes most distant header\n   * from the table.\n   *\n   *  Header level            Row coords\n   *           +--------------+\n   *        0  │ A1 │ A1      │  -3\n   *           +--------------+\n   *        1  │ B1 │ B2 │ B3 │  -2\n   *           +--------------+\n   *        2  │ C1 │ C2 │ C3 │  -1\n   *           +==============+\n   *           │    │    │    │\n   *           +--------------+\n   *           │    │    │    │\n   *\n   * @param {number} headerLevel Header level index.\n   * @returns {number} Returns negative number.\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  levelToRowCoords(headerLevel) {\n    if (headerLevel < 0) {\n      return null;\n    }\n    const rowIndex = headerLevel - Math.max(this.getLayersCount(), 1);\n    if (rowIndex >= 0) {\n      return null;\n    }\n    return rowIndex;\n  }\n\n  /**\n   * Gets column header settings for a specified column and header index. The returned object contains\n   * all information necessary for header renderers. It contains header label, colspan length, or hidden\n   * flag.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    var _classPrivateFieldGet2, _classPrivateFieldGet3;\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    if (headerLevel === null || headerLevel >= this.getLayersCount()) {\n      return null;\n    }\n    return (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _stateMatrix)[headerLevel]) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3[columnIndex]) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;\n  }\n\n  /**\n   * Gets tree data that is connected to the column header. The returned object contains all information\n   * necessary for modifying tree structure (column collapsing, hiding, etc.). It contains a header\n   * label, colspan length, or visual column index that indicates which column index the node is rendered from.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderTreeNodeData(headerLevel, columnIndex) {\n    const node = this.getHeaderTreeNode(headerLevel, columnIndex);\n    if (!node) {\n      return null;\n    }\n    return {\n      ...node.data\n    };\n  }\n\n  /**\n   * Gets tree node that is connected to the column header.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|null}\n   */\n  getHeaderTreeNode(headerLevel, columnIndex) {\n    if (headerLevel < 0) {\n      headerLevel = this.rowCoordsToLevel(headerLevel);\n    }\n    if (headerLevel === null || headerLevel >= this.getLayersCount()) {\n      return null;\n    }\n    const node = _classPrivateFieldGet(this, _headersTree).getNode(headerLevel, columnIndex);\n    if (!node) {\n      return null;\n    }\n    return node;\n  }\n\n  /**\n   * Finds the most top header level of the column header that is rendered entirely within\n   * the passed visual columns range. If multiple columns headers are found within the range the\n   * most top header level value will be returned.\n   *\n   * @param {number} columnIndexFrom A visual column index.\n   * @param {number} [columnIndexTo] A visual column index.\n   * @returns {number} Returns a header level in format -1 to -N.\n   */\n  findTopMostEntireHeaderLevel(columnIndexFrom) {\n    var _headerLevel;\n    let columnIndexTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : columnIndexFrom;\n    const columnsWidth = columnIndexTo - columnIndexFrom + 1;\n    let atLeastOneRootFound = false;\n    let headerLevel = null;\n    for (let columnIndex = columnIndexFrom; columnIndex <= columnIndexTo; columnIndex++) {\n      const rootNode = _classPrivateFieldGet(this, _headersTree).getRootByColumn(columnIndex);\n      if (!rootNode) {\n        break;\n      }\n      atLeastOneRootFound = true;\n\n      // eslint-disable-next-line\n      rootNode.walkDown(node => {\n        const {\n          columnIndex: nodeColumnIndex,\n          headerLevel: nodeHeaderLevel,\n          origColspan,\n          isHidden\n        } = node.data;\n        if (isHidden) {\n          return;\n        }\n\n        // if the header fits entirely within the columns range get and save the node header level\n        if (origColspan <= columnsWidth && nodeColumnIndex >= columnIndexFrom && nodeColumnIndex + origColspan - 1 <= columnIndexTo && (headerLevel === null || nodeHeaderLevel < headerLevel)) {\n          headerLevel = nodeHeaderLevel;\n        }\n      }, TRAVERSAL_DF_PRE);\n    }\n    if (atLeastOneRootFound && headerLevel === null) {\n      return -1;\n    }\n    return this.levelToRowCoords((_headerLevel = headerLevel) !== null && _headerLevel !== void 0 ? _headerLevel : 0);\n  }\n\n  /**\n   * The method is helpful in cases where the column index targets in-between currently\n   * collapsed column. In that case, the method returns the left-most column index\n   * where the nested header begins.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {number}\n   */\n  findLeftMostColumnIndex(headerLevel, columnIndex) {\n    var _this$getHeaderSettin;\n    const {\n      isRoot\n    } = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? _this$getHeaderSettin : {\n      isRoot: true\n    };\n    if (isRoot) {\n      return columnIndex;\n    }\n    let stepBackColumn = columnIndex - 1;\n    while (stepBackColumn >= 0) {\n      var _this$getHeaderSettin2;\n      const {\n        isRoot: isRootNode\n      } = (_this$getHeaderSettin2 = this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && _this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {\n        isRoot: true\n      };\n      if (isRootNode) {\n        break;\n      }\n      stepBackColumn -= 1;\n    }\n    return stepBackColumn;\n  }\n\n  /**\n   * The method is helpful in cases where the column index targets in-between currently\n   * collapsed column. In that case, the method returns the right-most column index\n   * where the nested header ends.\n   *\n   * @param {number} headerLevel Header level (there is support for negative and positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {number}\n   */\n  findRightMostColumnIndex(headerLevel, columnIndex) {\n    var _this$getHeaderSettin3;\n    const {\n      isRoot,\n      origColspan\n    } = (_this$getHeaderSettin3 = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin3 !== void 0 ? _this$getHeaderSettin3 : {\n      isRoot: true,\n      origColspan: 1\n    };\n    if (isRoot) {\n      return columnIndex + origColspan - 1;\n    }\n    let stepForthColumn = columnIndex + 1;\n    while (stepForthColumn < this.getColumnsCount()) {\n      var _this$getHeaderSettin4;\n      const {\n        isRoot: isRootNode\n      } = (_this$getHeaderSettin4 = this.getHeaderSettings(headerLevel, stepForthColumn)) !== null && _this$getHeaderSettin4 !== void 0 ? _this$getHeaderSettin4 : {\n        isRoot: true\n      };\n      if (isRootNode) {\n        break;\n      }\n      stepForthColumn += 1;\n    }\n    return stepForthColumn - 1;\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(this, _sourceSettings).getLayersCount();\n  }\n\n  /**\n   * Gets a total number of columns count.\n   *\n   * @returns {number}\n   */\n  getColumnsCount() {\n    return _classPrivateFieldGet(this, _sourceSettings).getColumnsCount();\n  }\n\n  /**\n   * Clears the column state manager to the initial state.\n   */\n  clear() {\n    _classPrivateFieldSet(this, _stateMatrix, []);\n    _classPrivateFieldGet(this, _sourceSettings).clear();\n    _classPrivateFieldGet(this, _headersTree).clear();\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}