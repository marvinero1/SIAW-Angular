{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport { mixin, createObjectPropListener } from \"../helpers/object.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\n/**\n * The Transformation class implements algorithms for transforming coordinates based on current settings\n * passed to the Handsontable. The class performs the calculations based on the renderable indexes.\n *\n * Transformation is always applied relative to the current selection.\n *\n * The class operates on a table size defined by the renderable indexes. If the `navigableHeaders`\n * option is enabled, the table size is increased by the number of row and/or column headers.\n * Because the headers are treated as cells as part of the table size (indexes always go from 0 to N),\n * the algorithm can be written as simply as possible (without new if's that distinguish the headers\n * logic).\n *\n * @class Transformation\n * @util\n */\nvar _range = /*#__PURE__*/new WeakMap();\nvar _options = /*#__PURE__*/new WeakMap();\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _setOffsetSize = /*#__PURE__*/new WeakSet();\nvar _clampCoords = /*#__PURE__*/new WeakSet();\nvar _getTableSize = /*#__PURE__*/new WeakSet();\nvar _visualToZeroBasedCoords = /*#__PURE__*/new WeakSet();\nvar _zeroBasedToVisualCoords = /*#__PURE__*/new WeakSet();\nclass Transformation {\n  constructor(range, options) {\n    /**\n     * Translates the zero-based coordinates to visual ones.\n     *\n     * @param {CellCoords} zeroBasedCoords The coordinates to process.\n     * @returns {CellCoords}\n     */\n    _classPrivateMethodInitSpec(this, _zeroBasedToVisualCoords);\n    /**\n     * Translates the visual coordinates to zero-based ones.\n     *\n     * @param {CellCoords} visualCoords The visual coords to process.\n     * @returns {CellCoords}\n     */\n    _classPrivateMethodInitSpec(this, _visualToZeroBasedCoords);\n    /**\n     * Gets the table size in number of rows with headers as \"height\" and number of columns with\n     * headers as \"width\".\n     *\n     * @returns {{width: number, height: number}}\n     */\n    _classPrivateMethodInitSpec(this, _getTableSize);\n    /**\n     * Clamps the coords to make sure they points to the cell (or header) in the table range.\n     *\n     * @param {CellCoords} zeroBasedCoords The coords object to clamp.\n     * @returns {{rowDir: 1|0|-1, colDir: 1|0|-1}}\n     */\n    _classPrivateMethodInitSpec(this, _clampCoords);\n    /**\n     * Sets the additional offset in table size that may occur when the `navigableHeaders` option\n     * is enabled.\n     *\n     * @param {{x: number, y: number}} offset Offset as x and y properties.\n     */\n    _classPrivateMethodInitSpec(this, _setOffsetSize);\n    /**\n     * Instance of the SelectionRange, holder for visual coordinates applied to the table.\n     *\n     * @type {SelectionRange}\n     */\n    _classPrivateFieldInitSpec(this, _range, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Additional options which define the state of the settings which can infer transformation and\n     * give the possibility to translate indexes.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Increases the table size by applying the offsets. The option is used by the `navigableHeaders`\n     * option.\n     *\n     * @type {{ x: number, y: number }}\n     */\n    _classPrivateFieldInitSpec(this, _offset, {\n      writable: true,\n      value: {\n        x: 0,\n        y: 0\n      }\n    });\n    _classPrivateFieldSet(this, _range, range);\n    _classPrivateFieldSet(this, _options, options);\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   * @returns {CellCoords} Visual coordinates after transformation.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    _classPrivateMethodGet(this, _setOffsetSize, _setOffsetSize2).call(this, {\n      x: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countRowHeaders() : 0,\n      y: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countColHeaders() : 0\n    });\n    const delta = _classPrivateFieldGet(this, _options).createCellCoords(rowDelta, colDelta);\n    let visualCoords = _classPrivateFieldGet(this, _range).current().highlight;\n    const highlightRenderableCoords = _classPrivateFieldGet(this, _options).visualToRenderableCoords(visualCoords);\n    let rowTransformDir = 0;\n    let colTransformDir = 0;\n    this.runLocalHooks('beforeTransformStart', delta);\n    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {\n      const {\n        width,\n        height\n      } = _classPrivateMethodGet(this, _getTableSize, _getTableSize2).call(this);\n      const {\n        row,\n        col\n      } = _classPrivateMethodGet(this, _visualToZeroBasedCoords, _visualToZeroBasedCoords2).call(this, visualCoords);\n      const fixedRowsBottom = _classPrivateFieldGet(this, _options).fixedRowsBottom();\n      const minSpareRows = _classPrivateFieldGet(this, _options).minSpareRows();\n      const minSpareCols = _classPrivateFieldGet(this, _options).minSpareCols();\n      const autoWrapRow = _classPrivateFieldGet(this, _options).autoWrapRow();\n      const autoWrapCol = _classPrivateFieldGet(this, _options).autoWrapCol();\n      const zeroBasedCoords = _classPrivateFieldGet(this, _options).createCellCoords(row + delta.row, col + delta.col);\n      if (zeroBasedCoords.row >= height) {\n        const isActionInterrupted = createObjectPropListener(createMissingRecords && minSpareRows > 0 && fixedRowsBottom === 0);\n        const nextColumn = zeroBasedCoords.col + 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(zeroBasedCoords.row - height, nextColumn >= width ? nextColumn - width : nextColumn);\n        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), nextColumn >= width);\n        if (isActionInterrupted.value) {\n          this.runLocalHooks('insertRowRequire', _classPrivateFieldGet(this, _options).countRenderableRows());\n        } else if (autoWrapCol) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      } else if (zeroBasedCoords.row < 0) {\n        const isActionInterrupted = createObjectPropListener(autoWrapCol);\n        const previousColumn = zeroBasedCoords.col - 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(height + zeroBasedCoords.row, previousColumn < 0 ? width + previousColumn : previousColumn);\n        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), previousColumn < 0);\n        if (autoWrapCol) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      }\n      if (zeroBasedCoords.col >= width) {\n        const isActionInterrupted = createObjectPropListener(createMissingRecords && minSpareCols > 0);\n        const nextRow = zeroBasedCoords.row + 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(nextRow >= height ? nextRow - height : nextRow, zeroBasedCoords.col - width);\n        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), nextRow >= height);\n        if (isActionInterrupted.value) {\n          this.runLocalHooks('insertColRequire', _classPrivateFieldGet(this, _options).countRenderableColumns());\n        } else if (autoWrapRow) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      } else if (zeroBasedCoords.col < 0) {\n        const isActionInterrupted = createObjectPropListener(autoWrapRow);\n        const previousRow = zeroBasedCoords.row - 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(previousRow < 0 ? height + previousRow : previousRow, width + zeroBasedCoords.col);\n        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), previousRow < 0);\n        if (autoWrapRow) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      }\n      const {\n        rowDir,\n        colDir\n      } = _classPrivateMethodGet(this, _clampCoords, _clampCoords2).call(this, zeroBasedCoords);\n      rowTransformDir = rowDir;\n      colTransformDir = colDir;\n      visualCoords = _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, zeroBasedCoords);\n    }\n    this.runLocalHooks('afterTransformStart', visualCoords, rowTransformDir, colTransformDir);\n    return visualCoords;\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @returns {CellCoords} Visual coordinates after transformation.\n   */\n  transformEnd(rowDelta, colDelta) {\n    _classPrivateMethodGet(this, _setOffsetSize, _setOffsetSize2).call(this, {\n      x: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countRowHeaders() : 0,\n      y: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countColHeaders() : 0\n    });\n    const delta = _classPrivateFieldGet(this, _options).createCellCoords(rowDelta, colDelta);\n    const cellRange = _classPrivateFieldGet(this, _range).current();\n    const highlightRenderableCoords = _classPrivateFieldGet(this, _options).visualToRenderableCoords(cellRange.highlight);\n    const visualCoords = cellRange.to.clone();\n    let rowTransformDir = 0;\n    let colTransformDir = 0;\n    this.runLocalHooks('beforeTransformEnd', delta);\n    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {\n      const {\n        row,\n        col\n      } = _classPrivateMethodGet(this, _visualToZeroBasedCoords, _visualToZeroBasedCoords2).call(this, cellRange.to);\n      const coords = _classPrivateFieldGet(this, _options).createCellCoords(row + delta.row, col + delta.col);\n      const {\n        rowDir,\n        colDir\n      } = _classPrivateMethodGet(this, _clampCoords, _clampCoords2).call(this, coords);\n      rowTransformDir = rowDir;\n      colTransformDir = colDir;\n      const newVisualCoords = _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, coords);\n      if (delta.row === 0 && delta.col !== 0) {\n        visualCoords.col = newVisualCoords.col;\n      } else if (delta.row !== 0 && delta.col === 0) {\n        visualCoords.row = newVisualCoords.row;\n      } else {\n        visualCoords.row = newVisualCoords.row;\n        visualCoords.col = newVisualCoords.col;\n      }\n    }\n    this.runLocalHooks('afterTransformEnd', visualCoords, rowTransformDir, colTransformDir);\n    return visualCoords;\n  }\n}\nfunction _setOffsetSize2(_ref) {\n  let {\n    x,\n    y\n  } = _ref;\n  _classPrivateFieldSet(this, _offset, {\n    x,\n    y\n  });\n}\nfunction _clampCoords2(zeroBasedCoords) {\n  const {\n    width,\n    height\n  } = _classPrivateMethodGet(this, _getTableSize, _getTableSize2).call(this);\n  let rowDir = 0;\n  let colDir = 0;\n  if (zeroBasedCoords.row < 0) {\n    rowDir = -1;\n    zeroBasedCoords.row = 0;\n  } else if (zeroBasedCoords.row > 0 && zeroBasedCoords.row >= height) {\n    rowDir = 1;\n    zeroBasedCoords.row = height - 1;\n  }\n  if (zeroBasedCoords.col < 0) {\n    colDir = -1;\n    zeroBasedCoords.col = 0;\n  } else if (zeroBasedCoords.col > 0 && zeroBasedCoords.col >= width) {\n    colDir = 1;\n    zeroBasedCoords.col = width - 1;\n  }\n  return {\n    rowDir,\n    colDir\n  };\n}\nfunction _getTableSize2() {\n  return {\n    width: _classPrivateFieldGet(this, _offset).x + _classPrivateFieldGet(this, _options).countRenderableColumns(),\n    height: _classPrivateFieldGet(this, _offset).y + _classPrivateFieldGet(this, _options).countRenderableRows()\n  };\n}\nfunction _visualToZeroBasedCoords2(visualCoords) {\n  const {\n    row,\n    col\n  } = _classPrivateFieldGet(this, _options).visualToRenderableCoords(visualCoords);\n  return _classPrivateFieldGet(this, _options).createCellCoords(_classPrivateFieldGet(this, _offset).y + row, _classPrivateFieldGet(this, _offset).x + col);\n}\nfunction _zeroBasedToVisualCoords2(zeroBasedCoords) {\n  const coords = zeroBasedCoords.clone();\n  coords.col = zeroBasedCoords.col - _classPrivateFieldGet(this, _offset).x;\n  coords.row = zeroBasedCoords.row - _classPrivateFieldGet(this, _offset).y;\n  return _classPrivateFieldGet(this, _options).renderableToVisualCoords(coords);\n}\nmixin(Transformation, localHooks);\nexport default Transformation;","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","privateMap","value","set","privateCollection","has","TypeError","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","call","_classPrivateMethodGet","fn","_classPrivateFieldSet","_classApplyDescriptorSet","action","writable","mixin","createObjectPropListener","localHooks","_range","WeakMap","_options","_offset","_setOffsetSize","WeakSet","_clampCoords","_getTableSize","_visualToZeroBasedCoords","_zeroBasedToVisualCoords","Transformation","constructor","range","options","x","y","transformStart","rowDelta","colDelta","createMissingRecords","arguments","length","undefined","_setOffsetSize2","navigableHeaders","countRowHeaders","countColHeaders","delta","createCellCoords","visualCoords","current","highlight","highlightRenderableCoords","visualToRenderableCoords","rowTransformDir","colTransformDir","runLocalHooks","row","col","width","height","_getTableSize2","_visualToZeroBasedCoords2","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","zeroBasedCoords","isActionInterrupted","nextColumn","newCoords","_zeroBasedToVisualCoords2","countRenderableRows","assign","previousColumn","nextRow","countRenderableColumns","previousRow","rowDir","colDir","_clampCoords2","transformEnd","cellRange","to","clone","coords","newVisualCoords","_ref","renderableToVisualCoords"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/selection/transformation.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { mixin, createObjectPropListener } from \"../helpers/object.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\n/**\n * The Transformation class implements algorithms for transforming coordinates based on current settings\n * passed to the Handsontable. The class performs the calculations based on the renderable indexes.\n *\n * Transformation is always applied relative to the current selection.\n *\n * The class operates on a table size defined by the renderable indexes. If the `navigableHeaders`\n * option is enabled, the table size is increased by the number of row and/or column headers.\n * Because the headers are treated as cells as part of the table size (indexes always go from 0 to N),\n * the algorithm can be written as simply as possible (without new if's that distinguish the headers\n * logic).\n *\n * @class Transformation\n * @util\n */\nvar _range = /*#__PURE__*/new WeakMap();\nvar _options = /*#__PURE__*/new WeakMap();\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _setOffsetSize = /*#__PURE__*/new WeakSet();\nvar _clampCoords = /*#__PURE__*/new WeakSet();\nvar _getTableSize = /*#__PURE__*/new WeakSet();\nvar _visualToZeroBasedCoords = /*#__PURE__*/new WeakSet();\nvar _zeroBasedToVisualCoords = /*#__PURE__*/new WeakSet();\nclass Transformation {\n  constructor(range, options) {\n    /**\n     * Translates the zero-based coordinates to visual ones.\n     *\n     * @param {CellCoords} zeroBasedCoords The coordinates to process.\n     * @returns {CellCoords}\n     */\n    _classPrivateMethodInitSpec(this, _zeroBasedToVisualCoords);\n    /**\n     * Translates the visual coordinates to zero-based ones.\n     *\n     * @param {CellCoords} visualCoords The visual coords to process.\n     * @returns {CellCoords}\n     */\n    _classPrivateMethodInitSpec(this, _visualToZeroBasedCoords);\n    /**\n     * Gets the table size in number of rows with headers as \"height\" and number of columns with\n     * headers as \"width\".\n     *\n     * @returns {{width: number, height: number}}\n     */\n    _classPrivateMethodInitSpec(this, _getTableSize);\n    /**\n     * Clamps the coords to make sure they points to the cell (or header) in the table range.\n     *\n     * @param {CellCoords} zeroBasedCoords The coords object to clamp.\n     * @returns {{rowDir: 1|0|-1, colDir: 1|0|-1}}\n     */\n    _classPrivateMethodInitSpec(this, _clampCoords);\n    /**\n     * Sets the additional offset in table size that may occur when the `navigableHeaders` option\n     * is enabled.\n     *\n     * @param {{x: number, y: number}} offset Offset as x and y properties.\n     */\n    _classPrivateMethodInitSpec(this, _setOffsetSize);\n    /**\n     * Instance of the SelectionRange, holder for visual coordinates applied to the table.\n     *\n     * @type {SelectionRange}\n     */\n    _classPrivateFieldInitSpec(this, _range, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Additional options which define the state of the settings which can infer transformation and\n     * give the possibility to translate indexes.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Increases the table size by applying the offsets. The option is used by the `navigableHeaders`\n     * option.\n     *\n     * @type {{ x: number, y: number }}\n     */\n    _classPrivateFieldInitSpec(this, _offset, {\n      writable: true,\n      value: {\n        x: 0,\n        y: 0\n      }\n    });\n    _classPrivateFieldSet(this, _range, range);\n    _classPrivateFieldSet(this, _options, options);\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   * @returns {CellCoords} Visual coordinates after transformation.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    _classPrivateMethodGet(this, _setOffsetSize, _setOffsetSize2).call(this, {\n      x: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countRowHeaders() : 0,\n      y: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countColHeaders() : 0\n    });\n    const delta = _classPrivateFieldGet(this, _options).createCellCoords(rowDelta, colDelta);\n    let visualCoords = _classPrivateFieldGet(this, _range).current().highlight;\n    const highlightRenderableCoords = _classPrivateFieldGet(this, _options).visualToRenderableCoords(visualCoords);\n    let rowTransformDir = 0;\n    let colTransformDir = 0;\n    this.runLocalHooks('beforeTransformStart', delta);\n    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {\n      const {\n        width,\n        height\n      } = _classPrivateMethodGet(this, _getTableSize, _getTableSize2).call(this);\n      const {\n        row,\n        col\n      } = _classPrivateMethodGet(this, _visualToZeroBasedCoords, _visualToZeroBasedCoords2).call(this, visualCoords);\n      const fixedRowsBottom = _classPrivateFieldGet(this, _options).fixedRowsBottom();\n      const minSpareRows = _classPrivateFieldGet(this, _options).minSpareRows();\n      const minSpareCols = _classPrivateFieldGet(this, _options).minSpareCols();\n      const autoWrapRow = _classPrivateFieldGet(this, _options).autoWrapRow();\n      const autoWrapCol = _classPrivateFieldGet(this, _options).autoWrapCol();\n      const zeroBasedCoords = _classPrivateFieldGet(this, _options).createCellCoords(row + delta.row, col + delta.col);\n      if (zeroBasedCoords.row >= height) {\n        const isActionInterrupted = createObjectPropListener(createMissingRecords && minSpareRows > 0 && fixedRowsBottom === 0);\n        const nextColumn = zeroBasedCoords.col + 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(zeroBasedCoords.row - height, nextColumn >= width ? nextColumn - width : nextColumn);\n        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), nextColumn >= width);\n        if (isActionInterrupted.value) {\n          this.runLocalHooks('insertRowRequire', _classPrivateFieldGet(this, _options).countRenderableRows());\n        } else if (autoWrapCol) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      } else if (zeroBasedCoords.row < 0) {\n        const isActionInterrupted = createObjectPropListener(autoWrapCol);\n        const previousColumn = zeroBasedCoords.col - 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(height + zeroBasedCoords.row, previousColumn < 0 ? width + previousColumn : previousColumn);\n        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), previousColumn < 0);\n        if (autoWrapCol) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      }\n      if (zeroBasedCoords.col >= width) {\n        const isActionInterrupted = createObjectPropListener(createMissingRecords && minSpareCols > 0);\n        const nextRow = zeroBasedCoords.row + 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(nextRow >= height ? nextRow - height : nextRow, zeroBasedCoords.col - width);\n        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), nextRow >= height);\n        if (isActionInterrupted.value) {\n          this.runLocalHooks('insertColRequire', _classPrivateFieldGet(this, _options).countRenderableColumns());\n        } else if (autoWrapRow) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      } else if (zeroBasedCoords.col < 0) {\n        const isActionInterrupted = createObjectPropListener(autoWrapRow);\n        const previousRow = zeroBasedCoords.row - 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(previousRow < 0 ? height + previousRow : previousRow, width + zeroBasedCoords.col);\n        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), previousRow < 0);\n        if (autoWrapRow) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      }\n      const {\n        rowDir,\n        colDir\n      } = _classPrivateMethodGet(this, _clampCoords, _clampCoords2).call(this, zeroBasedCoords);\n      rowTransformDir = rowDir;\n      colTransformDir = colDir;\n      visualCoords = _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, zeroBasedCoords);\n    }\n    this.runLocalHooks('afterTransformStart', visualCoords, rowTransformDir, colTransformDir);\n    return visualCoords;\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @returns {CellCoords} Visual coordinates after transformation.\n   */\n  transformEnd(rowDelta, colDelta) {\n    _classPrivateMethodGet(this, _setOffsetSize, _setOffsetSize2).call(this, {\n      x: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countRowHeaders() : 0,\n      y: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countColHeaders() : 0\n    });\n    const delta = _classPrivateFieldGet(this, _options).createCellCoords(rowDelta, colDelta);\n    const cellRange = _classPrivateFieldGet(this, _range).current();\n    const highlightRenderableCoords = _classPrivateFieldGet(this, _options).visualToRenderableCoords(cellRange.highlight);\n    const visualCoords = cellRange.to.clone();\n    let rowTransformDir = 0;\n    let colTransformDir = 0;\n    this.runLocalHooks('beforeTransformEnd', delta);\n    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {\n      const {\n        row,\n        col\n      } = _classPrivateMethodGet(this, _visualToZeroBasedCoords, _visualToZeroBasedCoords2).call(this, cellRange.to);\n      const coords = _classPrivateFieldGet(this, _options).createCellCoords(row + delta.row, col + delta.col);\n      const {\n        rowDir,\n        colDir\n      } = _classPrivateMethodGet(this, _clampCoords, _clampCoords2).call(this, coords);\n      rowTransformDir = rowDir;\n      colTransformDir = colDir;\n      const newVisualCoords = _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, coords);\n      if (delta.row === 0 && delta.col !== 0) {\n        visualCoords.col = newVisualCoords.col;\n      } else if (delta.row !== 0 && delta.col === 0) {\n        visualCoords.row = newVisualCoords.row;\n      } else {\n        visualCoords.row = newVisualCoords.row;\n        visualCoords.col = newVisualCoords.col;\n      }\n    }\n    this.runLocalHooks('afterTransformEnd', visualCoords, rowTransformDir, colTransformDir);\n    return visualCoords;\n  }\n}\nfunction _setOffsetSize2(_ref) {\n  let {\n    x,\n    y\n  } = _ref;\n  _classPrivateFieldSet(this, _offset, {\n    x,\n    y\n  });\n}\nfunction _clampCoords2(zeroBasedCoords) {\n  const {\n    width,\n    height\n  } = _classPrivateMethodGet(this, _getTableSize, _getTableSize2).call(this);\n  let rowDir = 0;\n  let colDir = 0;\n  if (zeroBasedCoords.row < 0) {\n    rowDir = -1;\n    zeroBasedCoords.row = 0;\n  } else if (zeroBasedCoords.row > 0 && zeroBasedCoords.row >= height) {\n    rowDir = 1;\n    zeroBasedCoords.row = height - 1;\n  }\n  if (zeroBasedCoords.col < 0) {\n    colDir = -1;\n    zeroBasedCoords.col = 0;\n  } else if (zeroBasedCoords.col > 0 && zeroBasedCoords.col >= width) {\n    colDir = 1;\n    zeroBasedCoords.col = width - 1;\n  }\n  return {\n    rowDir,\n    colDir\n  };\n}\nfunction _getTableSize2() {\n  return {\n    width: _classPrivateFieldGet(this, _offset).x + _classPrivateFieldGet(this, _options).countRenderableColumns(),\n    height: _classPrivateFieldGet(this, _offset).y + _classPrivateFieldGet(this, _options).countRenderableRows()\n  };\n}\nfunction _visualToZeroBasedCoords2(visualCoords) {\n  const {\n    row,\n    col\n  } = _classPrivateFieldGet(this, _options).visualToRenderableCoords(visualCoords);\n  return _classPrivateFieldGet(this, _options).createCellCoords(_classPrivateFieldGet(this, _offset).y + row, _classPrivateFieldGet(this, _offset).x + col);\n}\nfunction _zeroBasedToVisualCoords2(zeroBasedCoords) {\n  const coords = zeroBasedCoords.clone();\n  coords.col = zeroBasedCoords.col - _classPrivateFieldGet(this, _offset).x;\n  coords.row = zeroBasedCoords.row - _classPrivateFieldGet(this, _offset).y;\n  return _classPrivateFieldGet(this, _options).renderableToVisualCoords(coords);\n}\nmixin(Transformation, localHooks);\nexport default Transformation;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}