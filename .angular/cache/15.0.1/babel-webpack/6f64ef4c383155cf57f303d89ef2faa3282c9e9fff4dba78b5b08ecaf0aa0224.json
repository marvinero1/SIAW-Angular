{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { getScrollableElement, getTrimmingContainer, getScrollbarWidth, setAttribute } from \"../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"../../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { warn } from \"../../../../helpers/console.mjs\";\nimport { CLONE_TYPES, CLONE_CLASS_NAMES, CLONE_TOP, CLONE_INLINE_START } from \"./constants.mjs\";\nimport Clone from \"../core/clone.mjs\";\nimport { A11Y_PRESENTATION } from \"../../../../helpers/a11y.mjs\";\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @abstract\n * @class Overlay\n * @property {Walkontable} wot The Walkontable instance.\n */\nexport class Overlay {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {CLONE_TYPES_ENUM} type The overlay type name (clone name).\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  constructor(wotInstance, facadeGetter, type, wtSettings, domBindings) {\n    /**\n     *  The Walkontable settings.\n     *\n     * @private\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n    const {\n      TABLE,\n      hider,\n      spreader,\n      holder,\n      wtRootElement\n    } = this.wot.wtTable; // todo ioc\n\n    // legacy support, deprecated in the future\n    this.instance = this.wot;\n    this.type = type;\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.updateStateOfRendering();\n    this.clone = this.makeClone();\n  }\n\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {boolean} Returns `true` if the state has changed since the last check.\n   */\n  updateStateOfRendering() {\n    // todo refactoring: conceive introducing final state machine, normal -> changed (once) -> needs-full-render -> ...? -> normal\n    const previousState = this.needFullRender;\n    this.needFullRender = this.shouldBeRendered();\n    const changed = previousState !== this.needFullRender;\n    if (changed && !this.needFullRender) {\n      this.reset();\n    }\n    return changed;\n  }\n\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    return true;\n  }\n\n  /**\n   * Update the trimming container.\n   */\n  updateTrimmingContainer() {\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n  }\n\n  /**\n   * Update the main scrollable element.\n   */\n  updateMainScrollableElement() {\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      rootWindow\n    } = this.domBindings;\n    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n      this.mainTableScrollableElement = this.wot.wtTable.holder;\n    } else {\n      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element.\n   * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n   *\n   * @param {HTMLElement} element The cell element to calculate the position for.\n   * @param {number} rowIndex Visual row index.\n   * @param {number} columnIndex Visual column index.\n   * @returns {{top: number, start: number}|undefined}\n   */\n  getRelativeCellPosition(element, rowIndex, columnIndex) {\n    if (this.clone.wtTable.holder.contains(element) === false) {\n      warn(`The provided element is not a child of the ${this.type} overlay`);\n      return;\n    }\n    const windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;\n    const fixedColumnStart = columnIndex < this.wtSettings.getSetting('fixedColumnsStart');\n    const fixedRowTop = rowIndex < this.wtSettings.getSetting('fixedRowsTop');\n    const fixedRowBottom = rowIndex >= this.wtSettings.getSetting('totalRows') - this.wtSettings.getSetting('fixedRowsBottom');\n    const spreader = this.clone.wtTable.spreader;\n    const spreaderOffset = {\n      start: this.getRelativeStartPosition(spreader),\n      top: spreader.offsetTop\n    };\n    const elementOffset = {\n      start: this.getRelativeStartPosition(element),\n      top: element.offsetTop\n    };\n    let offsetObject = null;\n    if (windowScroll) {\n      offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);\n    } else {\n      offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);\n    }\n    return offsetObject;\n  }\n\n  /**\n   * Get inline start value depending of direction.\n   *\n   * @param {HTMLElement} el Element.\n   * @returns {number}\n   */\n  getRelativeStartPosition(el) {\n    return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n   * @param {number} elementOffset Offset position of the cell element.\n   * @param {number} spreaderOffset Offset position of the spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n    const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n    let horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) {\n      horizontalOffset = spreaderOffset.start;\n    } else {\n      let absoluteRootElementStartPosition = absoluteRootElementPosition.left;\n      if (this.isRtl()) {\n        absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + getScrollbarWidth());\n      }\n      horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;\n    }\n    if (onFixedRowTop) {\n      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n      verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n    } else {\n      verticalOffset = spreaderOffset.top;\n    }\n    return {\n      start: elementOffset.start + horizontalOffset,\n      top: elementOffset.top + verticalOffset\n    };\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n   * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n   * @param {number} elementOffset Offset position of the cell element.\n   * @param {number} spreaderOffset Offset position of the spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n    const tableScrollPosition = {\n      horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),\n      vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()\n    };\n    let horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) {\n      horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;\n    }\n    if (onFixedRowBottom) {\n      const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect(); // todo refactoring: DEMETER\n\n      verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n    } else if (!onFixedRowTop) {\n      verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n    }\n    return {\n      start: elementOffset.start - horizontalOffset,\n      top: elementOffset.top - verticalOffset\n    };\n  }\n\n  /**\n   * Make a clone of table for overlay.\n   *\n   * @returns {Clone}\n   */\n  makeClone() {\n    if (CLONE_TYPES.indexOf(this.type) === -1) {\n      throw new Error(`Clone type \"${this.type}\" is not supported.`);\n    }\n    const {\n      wtTable,\n      wtSettings\n    } = this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const clone = rootDocument.createElement('div');\n    const clonedTable = rootDocument.createElement('table');\n    const tableParent = wtTable.wtRootElement.parentNode;\n    clone.className = `${CLONE_CLASS_NAMES.get(this.type)} handsontable`;\n    clone.setAttribute('dir', this.isRtl() ? 'rtl' : 'ltr');\n    clone.style.position = 'absolute';\n    clone.style.top = 0;\n    clone.style.overflow = 'visible';\n    if (this.isRtl()) {\n      clone.style.right = 0;\n    } else {\n      clone.style.left = 0;\n    }\n    if (wtSettings.getSetting('ariaTags')) {\n      setAttribute(clone, [A11Y_PRESENTATION()]);\n    }\n    clonedTable.className = wtTable.TABLE.className;\n\n    // Clone the main table's `role` attribute to the cloned table.\n    const mainTableRole = wtTable.TABLE.getAttribute('role');\n    if (mainTableRole) {\n      clonedTable.setAttribute('role', wtTable.TABLE.getAttribute('role'));\n    }\n    clone.appendChild(clonedTable);\n    tableParent.appendChild(clone);\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_INLINE_START) {\n      this.mainTableScrollableElement = rootWindow;\n    } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n      this.mainTableScrollableElement = wtTable.holder;\n    } else {\n      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n\n    // Create a new instance of the Walkontable class\n    return new Clone(clonedTable, this.wtSettings, {\n      // todo ioc factory\n      source: this.wot,\n      overlay: this,\n      viewport: this.wot.wtViewport,\n      // todo ioc , or factor func if used only here\n      event: this.wot.wtEvent,\n      // todo ioc , or factory func if used only here\n      selectionManager: this.wot.selectionManager // todo ioc , or factory func if used only here\n    });\n  }\n\n  /**\n   * Refresh/Redraw overlay.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   */\n  refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    // When hot settings are changed we allow to refresh overlay once before blocking\n    const nextCycleRenderFlag = this.shouldBeRendered();\n    if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n      this.clone.draw(fastDraw);\n    }\n    this.needFullRender = nextCycleRenderFlag;\n  }\n\n  /**\n   * Reset overlay styles to initial values.\n   */\n  reset() {\n    if (!this.clone) {\n      return;\n    }\n    const holder = this.clone.wtTable.holder; // todo refactoring: DEMETER\n    const hider = this.clone.wtTable.hider; // todo refactoring: DEMETER\n    const holderStyle = holder.style;\n    const hiderStyle = hider.style;\n    const rootStyle = holder.parentNode.style;\n    arrayEach([holderStyle, hiderStyle, rootStyle], style => {\n      style.width = '';\n      style.height = '';\n    });\n  }\n\n  /**\n   * Determine if Walkontable is running in RTL mode.\n   *\n   * @returns {boolean}\n   */\n  isRtl() {\n    return this.wtSettings.getSetting('rtlMode');\n  }\n\n  /**\n   * Destroy overlay instance.\n   */\n  destroy() {\n    this.clone.eventManager.destroy(); // todo check if it is good place for that operation\n  }\n}","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","getScrollableElement","getTrimmingContainer","getScrollbarWidth","setAttribute","defineGetter","arrayEach","warn","CLONE_TYPES","CLONE_CLASS_NAMES","CLONE_TOP","CLONE_INLINE_START","Clone","A11Y_PRESENTATION","Overlay","constructor","wotInstance","facadeGetter","type","wtSettings","domBindings","TABLE","hider","spreader","holder","wtRootElement","wot","wtTable","instance","mainTableScrollableElement","trimmingContainer","parentNode","updateStateOfRendering","clone","makeClone","previousState","needFullRender","shouldBeRendered","changed","reset","updateTrimmingContainer","updateMainScrollableElement","rootWindow","getComputedStyle","getPropertyValue","getRelativeCellPosition","element","rowIndex","columnIndex","contains","windowScroll","fixedColumnStart","getSetting","fixedRowTop","fixedRowBottom","spreaderOffset","start","getRelativeStartPosition","top","offsetTop","elementOffset","offsetObject","getRelativeCellPositionWithinWindow","getRelativeCellPositionWithinHolder","el","isRtl","offsetParent","offsetWidth","offsetLeft","onFixedRowTop","onFixedColumn","absoluteRootElementPosition","getBoundingClientRect","horizontalOffset","verticalOffset","absoluteRootElementStartPosition","left","innerWidth","width","absoluteOverlayPosition","onFixedRowBottom","tableScrollPosition","horizontal","wtOverlays","inlineStartOverlay","getScrollPosition","vertical","topOverlay","indexOf","Error","rootDocument","createElement","clonedTable","tableParent","className","get","style","position","overflow","right","mainTableRole","getAttribute","appendChild","preventOverflow","source","overlay","viewport","wtViewport","event","wtEvent","selectionManager","refresh","fastDraw","arguments","length","undefined","nextCycleRenderFlag","draw","holderStyle","hiderStyle","rootStyle","height","destroy","eventManager"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/3rdparty/walkontable/src/overlay/_base.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { getScrollableElement, getTrimmingContainer, getScrollbarWidth, setAttribute } from \"../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"../../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { warn } from \"../../../../helpers/console.mjs\";\nimport { CLONE_TYPES, CLONE_CLASS_NAMES, CLONE_TOP, CLONE_INLINE_START } from \"./constants.mjs\";\nimport Clone from \"../core/clone.mjs\";\nimport { A11Y_PRESENTATION } from \"../../../../helpers/a11y.mjs\";\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @abstract\n * @class Overlay\n * @property {Walkontable} wot The Walkontable instance.\n */\nexport class Overlay {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {CLONE_TYPES_ENUM} type The overlay type name (clone name).\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  constructor(wotInstance, facadeGetter, type, wtSettings, domBindings) {\n    /**\n     *  The Walkontable settings.\n     *\n     * @private\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n    const {\n      TABLE,\n      hider,\n      spreader,\n      holder,\n      wtRootElement\n    } = this.wot.wtTable; // todo ioc\n\n    // legacy support, deprecated in the future\n    this.instance = this.wot;\n    this.type = type;\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.updateStateOfRendering();\n    this.clone = this.makeClone();\n  }\n\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {boolean} Returns `true` if the state has changed since the last check.\n   */\n  updateStateOfRendering() {\n    // todo refactoring: conceive introducing final state machine, normal -> changed (once) -> needs-full-render -> ...? -> normal\n    const previousState = this.needFullRender;\n    this.needFullRender = this.shouldBeRendered();\n    const changed = previousState !== this.needFullRender;\n    if (changed && !this.needFullRender) {\n      this.reset();\n    }\n    return changed;\n  }\n\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    return true;\n  }\n\n  /**\n   * Update the trimming container.\n   */\n  updateTrimmingContainer() {\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n  }\n\n  /**\n   * Update the main scrollable element.\n   */\n  updateMainScrollableElement() {\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      rootWindow\n    } = this.domBindings;\n    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n      this.mainTableScrollableElement = this.wot.wtTable.holder;\n    } else {\n      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element.\n   * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n   *\n   * @param {HTMLElement} element The cell element to calculate the position for.\n   * @param {number} rowIndex Visual row index.\n   * @param {number} columnIndex Visual column index.\n   * @returns {{top: number, start: number}|undefined}\n   */\n  getRelativeCellPosition(element, rowIndex, columnIndex) {\n    if (this.clone.wtTable.holder.contains(element) === false) {\n      warn(`The provided element is not a child of the ${this.type} overlay`);\n      return;\n    }\n    const windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;\n    const fixedColumnStart = columnIndex < this.wtSettings.getSetting('fixedColumnsStart');\n    const fixedRowTop = rowIndex < this.wtSettings.getSetting('fixedRowsTop');\n    const fixedRowBottom = rowIndex >= this.wtSettings.getSetting('totalRows') - this.wtSettings.getSetting('fixedRowsBottom');\n    const spreader = this.clone.wtTable.spreader;\n    const spreaderOffset = {\n      start: this.getRelativeStartPosition(spreader),\n      top: spreader.offsetTop\n    };\n    const elementOffset = {\n      start: this.getRelativeStartPosition(element),\n      top: element.offsetTop\n    };\n    let offsetObject = null;\n    if (windowScroll) {\n      offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);\n    } else {\n      offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);\n    }\n    return offsetObject;\n  }\n\n  /**\n   * Get inline start value depending of direction.\n   *\n   * @param {HTMLElement} el Element.\n   * @returns {number}\n   */\n  getRelativeStartPosition(el) {\n    return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n   * @param {number} elementOffset Offset position of the cell element.\n   * @param {number} spreaderOffset Offset position of the spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n    const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n    let horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) {\n      horizontalOffset = spreaderOffset.start;\n    } else {\n      let absoluteRootElementStartPosition = absoluteRootElementPosition.left;\n      if (this.isRtl()) {\n        absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + getScrollbarWidth());\n      }\n      horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;\n    }\n    if (onFixedRowTop) {\n      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n      verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n    } else {\n      verticalOffset = spreaderOffset.top;\n    }\n    return {\n      start: elementOffset.start + horizontalOffset,\n      top: elementOffset.top + verticalOffset\n    };\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n   * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n   * @param {number} elementOffset Offset position of the cell element.\n   * @param {number} spreaderOffset Offset position of the spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n    const tableScrollPosition = {\n      horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),\n      vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()\n    };\n    let horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) {\n      horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;\n    }\n    if (onFixedRowBottom) {\n      const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect(); // todo refactoring: DEMETER\n\n      verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n    } else if (!onFixedRowTop) {\n      verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n    }\n    return {\n      start: elementOffset.start - horizontalOffset,\n      top: elementOffset.top - verticalOffset\n    };\n  }\n\n  /**\n   * Make a clone of table for overlay.\n   *\n   * @returns {Clone}\n   */\n  makeClone() {\n    if (CLONE_TYPES.indexOf(this.type) === -1) {\n      throw new Error(`Clone type \"${this.type}\" is not supported.`);\n    }\n    const {\n      wtTable,\n      wtSettings\n    } = this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const clone = rootDocument.createElement('div');\n    const clonedTable = rootDocument.createElement('table');\n    const tableParent = wtTable.wtRootElement.parentNode;\n    clone.className = `${CLONE_CLASS_NAMES.get(this.type)} handsontable`;\n    clone.setAttribute('dir', this.isRtl() ? 'rtl' : 'ltr');\n    clone.style.position = 'absolute';\n    clone.style.top = 0;\n    clone.style.overflow = 'visible';\n    if (this.isRtl()) {\n      clone.style.right = 0;\n    } else {\n      clone.style.left = 0;\n    }\n    if (wtSettings.getSetting('ariaTags')) {\n      setAttribute(clone, [A11Y_PRESENTATION()]);\n    }\n    clonedTable.className = wtTable.TABLE.className;\n\n    // Clone the main table's `role` attribute to the cloned table.\n    const mainTableRole = wtTable.TABLE.getAttribute('role');\n    if (mainTableRole) {\n      clonedTable.setAttribute('role', wtTable.TABLE.getAttribute('role'));\n    }\n    clone.appendChild(clonedTable);\n    tableParent.appendChild(clone);\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_INLINE_START) {\n      this.mainTableScrollableElement = rootWindow;\n    } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n      this.mainTableScrollableElement = wtTable.holder;\n    } else {\n      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n\n    // Create a new instance of the Walkontable class\n    return new Clone(clonedTable, this.wtSettings, {\n      // todo ioc factory\n      source: this.wot,\n      overlay: this,\n      viewport: this.wot.wtViewport,\n      // todo ioc , or factor func if used only here\n      event: this.wot.wtEvent,\n      // todo ioc , or factory func if used only here\n      selectionManager: this.wot.selectionManager // todo ioc , or factory func if used only here\n    });\n  }\n\n  /**\n   * Refresh/Redraw overlay.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   */\n  refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    // When hot settings are changed we allow to refresh overlay once before blocking\n    const nextCycleRenderFlag = this.shouldBeRendered();\n    if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n      this.clone.draw(fastDraw);\n    }\n    this.needFullRender = nextCycleRenderFlag;\n  }\n\n  /**\n   * Reset overlay styles to initial values.\n   */\n  reset() {\n    if (!this.clone) {\n      return;\n    }\n    const holder = this.clone.wtTable.holder; // todo refactoring: DEMETER\n    const hider = this.clone.wtTable.hider; // todo refactoring: DEMETER\n    const holderStyle = holder.style;\n    const hiderStyle = hider.style;\n    const rootStyle = holder.parentNode.style;\n    arrayEach([holderStyle, hiderStyle, rootStyle], style => {\n      style.width = '';\n      style.height = '';\n    });\n  }\n\n  /**\n   * Determine if Walkontable is running in RTL mode.\n   *\n   * @returns {boolean}\n   */\n  isRtl() {\n    return this.wtSettings.getSetting('rtlMode');\n  }\n\n  /**\n   * Destroy overlay instance.\n   */\n  destroy() {\n    this.clone.eventManager.destroy(); // todo check if it is good place for that operation\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}