{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport { toUpperCaseFirst } from \"../../../helpers/string.mjs\";\n/**\n * @private\n * @class IndexSyncer\n * @description\n *\n * Indexes synchronizer responsible for providing logic for particular axis. It respects an idea to represent trimmed\n * elements in HF's engine to perform formulas calculations on them. It also provides method for translation from visual\n * row/column indexes to HF's row/column indexes.\n */\nvar _axis = /*#__PURE__*/new WeakMap();\nvar _indexMapper = /*#__PURE__*/new WeakMap();\nvar _indexSyncer = /*#__PURE__*/new WeakMap();\nvar _indexesSequence = /*#__PURE__*/new WeakMap();\nvar _movedIndexes = /*#__PURE__*/new WeakMap();\nvar _finalIndex = /*#__PURE__*/new WeakMap();\nvar _removedIndexes = /*#__PURE__*/new WeakMap();\nclass AxisSyncer {\n  constructor(axis, indexMapper, indexSyncer) {\n    /**\n     * The axis for which the actions are performed.\n     *\n     * @private\n     * @type {'row'|'column'}\n     */\n    _classPrivateFieldInitSpec(this, _axis, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Reference to index mapper.\n     *\n     * @private\n     * @type {IndexMapper}\n     */\n    _classPrivateFieldInitSpec(this, _indexMapper, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The index synchronizer for both axis (is storing some more general information).\n     *\n     * @private\n     * @type {IndexSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _indexSyncer, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Sequence of physical indexes stored for watching changes and calculating some transformations.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _indexesSequence, {\n      writable: true,\n      value: []\n    });\n    /**\n     * List of moved HF indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _movedIndexes, {\n      writable: true,\n      value: []\n    });\n    /**\n     * Final HF's place where to move indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {number|undefined}\n     */\n    _classPrivateFieldInitSpec(this, _finalIndex, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * List of removed HF indexes, stored before performing removal on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _removedIndexes, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldSet(this, _axis, axis);\n    _classPrivateFieldSet(this, _indexMapper, indexMapper);\n    _classPrivateFieldSet(this, _indexSyncer, indexSyncer);\n  }\n\n  /**\n   * Sets removed HF indexes (it should be done right before performing move on HOT).\n   *\n   * @param {Array<number>} removedIndexes List of removed physical indexes.\n   * @returns {Array<number>} List of removed visual indexes.\n   */\n  setRemovedHfIndexes(removedIndexes) {\n    _classPrivateFieldSet(this, _removedIndexes, removedIndexes.map(physicalIndex => {\n      const visualIndex = _classPrivateFieldGet(this, _indexMapper).getVisualFromPhysicalIndex(physicalIndex);\n      return this.getHfIndexFromVisualIndex(visualIndex);\n    }));\n    return _classPrivateFieldGet(this, _removedIndexes);\n  }\n\n  /**\n   * Gets removed HF indexes (right before performing removal on HOT).\n   *\n   * @returns {Array<number>} List of removed HF indexes.\n   */\n  getRemovedHfIndexes() {\n    return _classPrivateFieldGet(this, _removedIndexes);\n  }\n\n  /**\n   * Gets corresponding HyperFormula index for particular visual index. It's respecting the idea that HF's engine\n   * is fed also with trimmed indexes (business requirements for formula result calculation also for trimmed elements).\n   *\n   * @param {number} visualIndex Visual index.\n   * @returns {number}\n   */\n  getHfIndexFromVisualIndex(visualIndex) {\n    const indexesSequence = _classPrivateFieldGet(this, _indexMapper).getIndexesSequence();\n    const notTrimmedIndexes = _classPrivateFieldGet(this, _indexMapper).getNotTrimmedIndexes();\n    return indexesSequence.indexOf(notTrimmedIndexes[visualIndex]);\n  }\n\n  /**\n   * Synchronizes moves done on HOT to HF engine (based on previously calculated positions).\n   *\n   * @private\n   * @param {Array<{from: number, to: number}>} moves Calculated HF's move positions.\n   */\n  syncMoves(moves) {\n    const NUMBER_OF_MOVED_INDEXES = 1;\n    const SYNC_MOVE_METHOD_NAME = `move${toUpperCaseFirst(_classPrivateFieldGet(this, _axis))}s`;\n    _classPrivateFieldGet(this, _indexSyncer).getEngine().batch(() => {\n      moves.forEach(move => {\n        const moveToTheSamePosition = move.from !== move.to;\n        // Moving from left to right (or top to bottom) to a line (drop index) right after already moved element.\n        const anotherMoveWithoutEffect = move.from + 1 !== move.to;\n        if (moveToTheSamePosition && anotherMoveWithoutEffect) {\n          _classPrivateFieldGet(this, _indexSyncer).getEngine()[SYNC_MOVE_METHOD_NAME](_classPrivateFieldGet(this, _indexSyncer).getSheetId(), move.from, NUMBER_OF_MOVED_INDEXES, move.to);\n        }\n      });\n    });\n  }\n\n  /**\n   * Stores information about performed HOT moves for purpose of calculating where to move HF elements.\n   *\n   * @param {Array<number>} movedVisualIndexes Sequence of moved visual indexes for certain axis.\n   * @param {number} visualFinalIndex Final visual place where to move HOT indexes.\n   * @param {boolean} movePossible Indicates if it's possible to move HOT indexes to the desired position.\n   */\n  storeMovesInformation(movedVisualIndexes, visualFinalIndex, movePossible) {\n    if (movePossible === false) {\n      return;\n    }\n    _classPrivateFieldSet(this, _movedIndexes, movedVisualIndexes.map(index => this.getHfIndexFromVisualIndex(index)));\n    _classPrivateFieldSet(this, _finalIndex, this.getHfIndexFromVisualIndex(visualFinalIndex));\n  }\n\n  /**\n   * Gets first position where to move element (respecting the fact that some element will be sooner or later\n   * taken out of the dataset in order to move them).\n   *\n   * @param {Array<number>} movedHfIndexes Sequence of moved HF indexes for certain axis.\n   * @param {number} finalHfIndex Final HF place where to move rows.\n   * @returns {number} HF's index informing where to move the first element.\n   * @private\n   */\n  getMoveLine(movedHfIndexes, finalHfIndex) {\n    const numberOfElements = _classPrivateFieldGet(this, _indexMapper).getNumberOfIndexes();\n    const notMovedElements = Array.from(Array(numberOfElements).keys()).filter(index => movedHfIndexes.includes(index) === false);\n    if (finalHfIndex === 0) {\n      var _notMovedElements$fin;\n      return (_notMovedElements$fin = notMovedElements[finalHfIndex]) !== null && _notMovedElements$fin !== void 0 ? _notMovedElements$fin : 0; // Moving before the first dataset's element.\n    }\n\n    return notMovedElements[finalHfIndex - 1] + 1; // Moving before another element.\n  }\n\n  /**\n   * Gets initially calculated HF's move positions.\n   *\n   * @private\n   * @param {Array<number>} movedHfIndexes Sequence of moved HF indexes for certain axis.\n   * @param {number} finalHfIndex Final HF place where to move rows.\n   * @returns {Array<{from: number, to: number}>} Initially calculated HF's move positions.\n   */\n  getInitiallyCalculatedMoves(movedHfIndexes, finalHfIndex) {\n    let moveLine = this.getMoveLine(movedHfIndexes, finalHfIndex);\n    const moves = [];\n    movedHfIndexes.forEach(movedHfIndex => {\n      const move = {\n        from: movedHfIndex,\n        to: moveLine\n      };\n      moves.forEach(previouslyMovedIndex => {\n        const isMovingFromEndToStart = previouslyMovedIndex.from > previouslyMovedIndex.to;\n        const isMovingElementBefore = previouslyMovedIndex.to <= move.from;\n        const isMovingAfterElement = previouslyMovedIndex.from > move.from;\n        if (isMovingAfterElement && isMovingElementBefore && isMovingFromEndToStart) {\n          move.from += 1;\n        }\n      });\n\n      // Moved element from right to left (or bottom to top).\n      if (move.from >= moveLine) {\n        moveLine += 1;\n      }\n      moves.push(move);\n    });\n    return moves;\n  }\n\n  /**\n   * Gets finally calculated HF's move positions (after adjusting).\n   *\n   * @private\n   * @param {Array<{from: number, to: number}>} moves Initially calculated HF's move positions.\n   * @returns {Array<{from: number, to: number}>} Finally calculated HF's move positions (after adjusting).\n   */\n  adjustedCalculatedMoves(moves) {\n    moves.forEach((move, index) => {\n      const nextMoved = moves.slice(index + 1);\n      nextMoved.forEach(nextMovedIndex => {\n        const isMovingFromStartToEnd = nextMovedIndex.from < nextMovedIndex.to;\n        if (nextMovedIndex.from > move.from && isMovingFromStartToEnd) {\n          nextMovedIndex.from -= 1;\n        }\n      });\n    });\n    return moves;\n  }\n\n  /**\n   * Calculating where to move HF elements and performing already calculated moves.\n   *\n   * @param {boolean} movePossible Indicates if it was possible to move HOT indexes to the desired position.\n   * @param {boolean} orderChanged Indicates if order of HOT indexes was changed by move.\n   */\n  calculateAndSyncMoves(movePossible, orderChanged) {\n    if (_classPrivateFieldGet(this, _indexSyncer).isPerformingUndoRedo()) {\n      return;\n    }\n    if (movePossible === false || orderChanged === false) {\n      return;\n    }\n    const calculatedMoves = this.adjustedCalculatedMoves(this.getInitiallyCalculatedMoves(_classPrivateFieldGet(this, _movedIndexes), _classPrivateFieldGet(this, _finalIndex)));\n    if (_classPrivateFieldGet(this, _indexSyncer).getSheetId() === null) {\n      _classPrivateFieldGet(this, _indexSyncer).getPostponeAction(() => this.syncMoves(calculatedMoves));\n    } else {\n      this.syncMoves(calculatedMoves);\n    }\n  }\n\n  /**\n   * Gets callback for hook triggered after performing change of indexes order.\n   *\n   * @returns {Function}\n   */\n  getIndexesChangeSyncMethod() {\n    const SYNC_ORDER_CHANGE_METHOD_NAME = `set${toUpperCaseFirst(_classPrivateFieldGet(this, _axis))}Order`;\n    return source => {\n      if (_classPrivateFieldGet(this, _indexSyncer).isPerformingUndoRedo()) {\n        return;\n      }\n      const newSequence = _classPrivateFieldGet(this, _indexMapper).getIndexesSequence();\n      if (source === 'update') {\n        const relativeTransformation = _classPrivateFieldGet(this, _indexesSequence).map(index => newSequence.indexOf(index));\n        const sheetDimensions = _classPrivateFieldGet(this, _indexSyncer).getEngine().getSheetDimensions(_classPrivateFieldGet(this, _indexSyncer).getSheetId());\n        let sizeForAxis;\n        if (_classPrivateFieldGet(this, _axis) === 'row') {\n          sizeForAxis = sheetDimensions.height;\n        } else {\n          sizeForAxis = sheetDimensions.width;\n        }\n        const numberOfReorganisedIndexes = relativeTransformation.length;\n\n        // Sheet dimension can be changed by HF's engine for purpose of calculating values. It extends dependency\n        // graph to calculate values outside of a defined dataset. This part of code could be removed after resolving\n        // feature request from HF issue board (handsontable/hyperformula#1179).\n        for (let i = numberOfReorganisedIndexes; i < sizeForAxis; i += 1) {\n          relativeTransformation.push(i);\n        }\n        _classPrivateFieldGet(this, _indexSyncer).getEngine()[SYNC_ORDER_CHANGE_METHOD_NAME](_classPrivateFieldGet(this, _indexSyncer).getSheetId(), relativeTransformation);\n      }\n      _classPrivateFieldSet(this, _indexesSequence, newSequence);\n    };\n  }\n\n  /**\n   * Initialize the AxisSyncer.\n   */\n  init() {\n    _classPrivateFieldSet(this, _indexesSequence, _classPrivateFieldGet(this, _indexMapper).getIndexesSequence());\n  }\n}\nexport default AxisSyncer;","map":{"version":3,"names":["_classPrivateFieldInitSpec","obj","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","TypeError","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","call","_classPrivateFieldSet","_classApplyDescriptorSet","action","writable","toUpperCaseFirst","_axis","WeakMap","_indexMapper","_indexSyncer","_indexesSequence","_movedIndexes","_finalIndex","_removedIndexes","AxisSyncer","constructor","axis","indexMapper","indexSyncer","setRemovedHfIndexes","removedIndexes","map","physicalIndex","visualIndex","getVisualFromPhysicalIndex","getHfIndexFromVisualIndex","getRemovedHfIndexes","indexesSequence","getIndexesSequence","notTrimmedIndexes","getNotTrimmedIndexes","indexOf","syncMoves","moves","NUMBER_OF_MOVED_INDEXES","SYNC_MOVE_METHOD_NAME","getEngine","batch","forEach","move","moveToTheSamePosition","from","to","anotherMoveWithoutEffect","getSheetId","storeMovesInformation","movedVisualIndexes","visualFinalIndex","movePossible","index","getMoveLine","movedHfIndexes","finalHfIndex","numberOfElements","getNumberOfIndexes","notMovedElements","Array","keys","filter","includes","_notMovedElements$fin","getInitiallyCalculatedMoves","moveLine","movedHfIndex","previouslyMovedIndex","isMovingFromEndToStart","isMovingElementBefore","isMovingAfterElement","push","adjustedCalculatedMoves","nextMoved","slice","nextMovedIndex","isMovingFromStartToEnd","calculateAndSyncMoves","orderChanged","isPerformingUndoRedo","calculatedMoves","getPostponeAction","getIndexesChangeSyncMethod","SYNC_ORDER_CHANGE_METHOD_NAME","source","newSequence","relativeTransformation","sheetDimensions","getSheetDimensions","sizeForAxis","height","width","numberOfReorganisedIndexes","length","i","init"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/formulas/indexSyncer/axisSyncer.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { toUpperCaseFirst } from \"../../../helpers/string.mjs\";\n/**\n * @private\n * @class IndexSyncer\n * @description\n *\n * Indexes synchronizer responsible for providing logic for particular axis. It respects an idea to represent trimmed\n * elements in HF's engine to perform formulas calculations on them. It also provides method for translation from visual\n * row/column indexes to HF's row/column indexes.\n */\nvar _axis = /*#__PURE__*/new WeakMap();\nvar _indexMapper = /*#__PURE__*/new WeakMap();\nvar _indexSyncer = /*#__PURE__*/new WeakMap();\nvar _indexesSequence = /*#__PURE__*/new WeakMap();\nvar _movedIndexes = /*#__PURE__*/new WeakMap();\nvar _finalIndex = /*#__PURE__*/new WeakMap();\nvar _removedIndexes = /*#__PURE__*/new WeakMap();\nclass AxisSyncer {\n  constructor(axis, indexMapper, indexSyncer) {\n    /**\n     * The axis for which the actions are performed.\n     *\n     * @private\n     * @type {'row'|'column'}\n     */\n    _classPrivateFieldInitSpec(this, _axis, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Reference to index mapper.\n     *\n     * @private\n     * @type {IndexMapper}\n     */\n    _classPrivateFieldInitSpec(this, _indexMapper, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The index synchronizer for both axis (is storing some more general information).\n     *\n     * @private\n     * @type {IndexSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _indexSyncer, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Sequence of physical indexes stored for watching changes and calculating some transformations.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _indexesSequence, {\n      writable: true,\n      value: []\n    });\n    /**\n     * List of moved HF indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _movedIndexes, {\n      writable: true,\n      value: []\n    });\n    /**\n     * Final HF's place where to move indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {number|undefined}\n     */\n    _classPrivateFieldInitSpec(this, _finalIndex, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * List of removed HF indexes, stored before performing removal on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _removedIndexes, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldSet(this, _axis, axis);\n    _classPrivateFieldSet(this, _indexMapper, indexMapper);\n    _classPrivateFieldSet(this, _indexSyncer, indexSyncer);\n  }\n\n  /**\n   * Sets removed HF indexes (it should be done right before performing move on HOT).\n   *\n   * @param {Array<number>} removedIndexes List of removed physical indexes.\n   * @returns {Array<number>} List of removed visual indexes.\n   */\n  setRemovedHfIndexes(removedIndexes) {\n    _classPrivateFieldSet(this, _removedIndexes, removedIndexes.map(physicalIndex => {\n      const visualIndex = _classPrivateFieldGet(this, _indexMapper).getVisualFromPhysicalIndex(physicalIndex);\n      return this.getHfIndexFromVisualIndex(visualIndex);\n    }));\n    return _classPrivateFieldGet(this, _removedIndexes);\n  }\n\n  /**\n   * Gets removed HF indexes (right before performing removal on HOT).\n   *\n   * @returns {Array<number>} List of removed HF indexes.\n   */\n  getRemovedHfIndexes() {\n    return _classPrivateFieldGet(this, _removedIndexes);\n  }\n\n  /**\n   * Gets corresponding HyperFormula index for particular visual index. It's respecting the idea that HF's engine\n   * is fed also with trimmed indexes (business requirements for formula result calculation also for trimmed elements).\n   *\n   * @param {number} visualIndex Visual index.\n   * @returns {number}\n   */\n  getHfIndexFromVisualIndex(visualIndex) {\n    const indexesSequence = _classPrivateFieldGet(this, _indexMapper).getIndexesSequence();\n    const notTrimmedIndexes = _classPrivateFieldGet(this, _indexMapper).getNotTrimmedIndexes();\n    return indexesSequence.indexOf(notTrimmedIndexes[visualIndex]);\n  }\n\n  /**\n   * Synchronizes moves done on HOT to HF engine (based on previously calculated positions).\n   *\n   * @private\n   * @param {Array<{from: number, to: number}>} moves Calculated HF's move positions.\n   */\n  syncMoves(moves) {\n    const NUMBER_OF_MOVED_INDEXES = 1;\n    const SYNC_MOVE_METHOD_NAME = `move${toUpperCaseFirst(_classPrivateFieldGet(this, _axis))}s`;\n    _classPrivateFieldGet(this, _indexSyncer).getEngine().batch(() => {\n      moves.forEach(move => {\n        const moveToTheSamePosition = move.from !== move.to;\n        // Moving from left to right (or top to bottom) to a line (drop index) right after already moved element.\n        const anotherMoveWithoutEffect = move.from + 1 !== move.to;\n        if (moveToTheSamePosition && anotherMoveWithoutEffect) {\n          _classPrivateFieldGet(this, _indexSyncer).getEngine()[SYNC_MOVE_METHOD_NAME](_classPrivateFieldGet(this, _indexSyncer).getSheetId(), move.from, NUMBER_OF_MOVED_INDEXES, move.to);\n        }\n      });\n    });\n  }\n\n  /**\n   * Stores information about performed HOT moves for purpose of calculating where to move HF elements.\n   *\n   * @param {Array<number>} movedVisualIndexes Sequence of moved visual indexes for certain axis.\n   * @param {number} visualFinalIndex Final visual place where to move HOT indexes.\n   * @param {boolean} movePossible Indicates if it's possible to move HOT indexes to the desired position.\n   */\n  storeMovesInformation(movedVisualIndexes, visualFinalIndex, movePossible) {\n    if (movePossible === false) {\n      return;\n    }\n    _classPrivateFieldSet(this, _movedIndexes, movedVisualIndexes.map(index => this.getHfIndexFromVisualIndex(index)));\n    _classPrivateFieldSet(this, _finalIndex, this.getHfIndexFromVisualIndex(visualFinalIndex));\n  }\n\n  /**\n   * Gets first position where to move element (respecting the fact that some element will be sooner or later\n   * taken out of the dataset in order to move them).\n   *\n   * @param {Array<number>} movedHfIndexes Sequence of moved HF indexes for certain axis.\n   * @param {number} finalHfIndex Final HF place where to move rows.\n   * @returns {number} HF's index informing where to move the first element.\n   * @private\n   */\n  getMoveLine(movedHfIndexes, finalHfIndex) {\n    const numberOfElements = _classPrivateFieldGet(this, _indexMapper).getNumberOfIndexes();\n    const notMovedElements = Array.from(Array(numberOfElements).keys()).filter(index => movedHfIndexes.includes(index) === false);\n    if (finalHfIndex === 0) {\n      var _notMovedElements$fin;\n      return (_notMovedElements$fin = notMovedElements[finalHfIndex]) !== null && _notMovedElements$fin !== void 0 ? _notMovedElements$fin : 0; // Moving before the first dataset's element.\n    }\n    return notMovedElements[finalHfIndex - 1] + 1; // Moving before another element.\n  }\n\n  /**\n   * Gets initially calculated HF's move positions.\n   *\n   * @private\n   * @param {Array<number>} movedHfIndexes Sequence of moved HF indexes for certain axis.\n   * @param {number} finalHfIndex Final HF place where to move rows.\n   * @returns {Array<{from: number, to: number}>} Initially calculated HF's move positions.\n   */\n  getInitiallyCalculatedMoves(movedHfIndexes, finalHfIndex) {\n    let moveLine = this.getMoveLine(movedHfIndexes, finalHfIndex);\n    const moves = [];\n    movedHfIndexes.forEach(movedHfIndex => {\n      const move = {\n        from: movedHfIndex,\n        to: moveLine\n      };\n      moves.forEach(previouslyMovedIndex => {\n        const isMovingFromEndToStart = previouslyMovedIndex.from > previouslyMovedIndex.to;\n        const isMovingElementBefore = previouslyMovedIndex.to <= move.from;\n        const isMovingAfterElement = previouslyMovedIndex.from > move.from;\n        if (isMovingAfterElement && isMovingElementBefore && isMovingFromEndToStart) {\n          move.from += 1;\n        }\n      });\n\n      // Moved element from right to left (or bottom to top).\n      if (move.from >= moveLine) {\n        moveLine += 1;\n      }\n      moves.push(move);\n    });\n    return moves;\n  }\n\n  /**\n   * Gets finally calculated HF's move positions (after adjusting).\n   *\n   * @private\n   * @param {Array<{from: number, to: number}>} moves Initially calculated HF's move positions.\n   * @returns {Array<{from: number, to: number}>} Finally calculated HF's move positions (after adjusting).\n   */\n  adjustedCalculatedMoves(moves) {\n    moves.forEach((move, index) => {\n      const nextMoved = moves.slice(index + 1);\n      nextMoved.forEach(nextMovedIndex => {\n        const isMovingFromStartToEnd = nextMovedIndex.from < nextMovedIndex.to;\n        if (nextMovedIndex.from > move.from && isMovingFromStartToEnd) {\n          nextMovedIndex.from -= 1;\n        }\n      });\n    });\n    return moves;\n  }\n\n  /**\n   * Calculating where to move HF elements and performing already calculated moves.\n   *\n   * @param {boolean} movePossible Indicates if it was possible to move HOT indexes to the desired position.\n   * @param {boolean} orderChanged Indicates if order of HOT indexes was changed by move.\n   */\n  calculateAndSyncMoves(movePossible, orderChanged) {\n    if (_classPrivateFieldGet(this, _indexSyncer).isPerformingUndoRedo()) {\n      return;\n    }\n    if (movePossible === false || orderChanged === false) {\n      return;\n    }\n    const calculatedMoves = this.adjustedCalculatedMoves(this.getInitiallyCalculatedMoves(_classPrivateFieldGet(this, _movedIndexes), _classPrivateFieldGet(this, _finalIndex)));\n    if (_classPrivateFieldGet(this, _indexSyncer).getSheetId() === null) {\n      _classPrivateFieldGet(this, _indexSyncer).getPostponeAction(() => this.syncMoves(calculatedMoves));\n    } else {\n      this.syncMoves(calculatedMoves);\n    }\n  }\n\n  /**\n   * Gets callback for hook triggered after performing change of indexes order.\n   *\n   * @returns {Function}\n   */\n  getIndexesChangeSyncMethod() {\n    const SYNC_ORDER_CHANGE_METHOD_NAME = `set${toUpperCaseFirst(_classPrivateFieldGet(this, _axis))}Order`;\n    return source => {\n      if (_classPrivateFieldGet(this, _indexSyncer).isPerformingUndoRedo()) {\n        return;\n      }\n      const newSequence = _classPrivateFieldGet(this, _indexMapper).getIndexesSequence();\n      if (source === 'update') {\n        const relativeTransformation = _classPrivateFieldGet(this, _indexesSequence).map(index => newSequence.indexOf(index));\n        const sheetDimensions = _classPrivateFieldGet(this, _indexSyncer).getEngine().getSheetDimensions(_classPrivateFieldGet(this, _indexSyncer).getSheetId());\n        let sizeForAxis;\n        if (_classPrivateFieldGet(this, _axis) === 'row') {\n          sizeForAxis = sheetDimensions.height;\n        } else {\n          sizeForAxis = sheetDimensions.width;\n        }\n        const numberOfReorganisedIndexes = relativeTransformation.length;\n\n        // Sheet dimension can be changed by HF's engine for purpose of calculating values. It extends dependency\n        // graph to calculate values outside of a defined dataset. This part of code could be removed after resolving\n        // feature request from HF issue board (handsontable/hyperformula#1179).\n        for (let i = numberOfReorganisedIndexes; i < sizeForAxis; i += 1) {\n          relativeTransformation.push(i);\n        }\n        _classPrivateFieldGet(this, _indexSyncer).getEngine()[SYNC_ORDER_CHANGE_METHOD_NAME](_classPrivateFieldGet(this, _indexSyncer).getSheetId(), relativeTransformation);\n      }\n      _classPrivateFieldSet(this, _indexesSequence, newSequence);\n    };\n  }\n\n  /**\n   * Initialize the AxisSyncer.\n   */\n  init() {\n    _classPrivateFieldSet(this, _indexesSequence, _classPrivateFieldGet(this, _indexMapper).getIndexesSequence());\n  }\n}\nexport default AxisSyncer;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}