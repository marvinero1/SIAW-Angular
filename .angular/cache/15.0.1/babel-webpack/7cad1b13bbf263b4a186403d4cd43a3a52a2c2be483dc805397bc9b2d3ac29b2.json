{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { fastInnerText } from \"../../../../helpers/dom/element.mjs\";\nimport { randomString } from \"../../../../helpers/string.mjs\";\nimport EventManager from \"../../../../eventManager.mjs\";\nimport Scroll from \"../scroll.mjs\";\nimport CellCoords from \"../cell/coords.mjs\";\nimport CellRange from \"../cell/range.mjs\";\n/**\n * @abstract\n * @class Walkontable\n */\nexport default class CoreAbstract {\n  get eventManager() {\n    return new EventManager(this);\n  }\n\n  /**\n   * @param {HTMLTableElement} table Main table.\n   * @param {Settings} settings The Walkontable settings.\n   */\n  constructor(table, settings) {\n    _defineProperty(this, \"wtTable\", void 0);\n    _defineProperty(this, \"wtScroll\", void 0);\n    _defineProperty(this, \"wtViewport\", void 0);\n    _defineProperty(this, \"wtOverlays\", void 0);\n    _defineProperty(this, \"selectionManager\", void 0);\n    _defineProperty(this, \"wtEvent\", void 0);\n    /**\n     * The walkontable instance id.\n     *\n     * @public\n     * @type {Readonly<string>}\n     */\n    _defineProperty(this, \"guid\", `wt_${randomString()}`);\n    _defineProperty(this, \"drawInterrupted\", false);\n    _defineProperty(this, \"drawn\", false);\n    /**\n     * The DOM bindings.\n     *\n     * @public\n     * @type {DomBindings}\n     */\n    _defineProperty(this, \"domBindings\", void 0);\n    /**\n     * Settings.\n     *\n     * @public\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", void 0);\n    this.domBindings = {\n      rootTable: table,\n      rootDocument: table.ownerDocument,\n      rootWindow: table.ownerDocument.defaultView\n    };\n    this.wtSettings = settings;\n    this.wtScroll = new Scroll(this.createScrollDao());\n  }\n  findOriginalHeaders() {\n    const originalHeaders = [];\n\n    // find original headers\n    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {\n      for (let c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {\n        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);\n      }\n      if (!this.wtSettings.getSetting('columnHeaders').length) {\n        this.wtSettings.update('columnHeaders', [function (column, TH) {\n          fastInnerText(TH, originalHeaders[column]);\n        }]);\n      }\n    }\n  }\n\n  /**\n   * Creates and returns the CellCoords object.\n   *\n   * @param {*} row The row index.\n   * @param {*} column The column index.\n   * @returns {CellCoords}\n   */\n  createCellCoords(row, column) {\n    return new CellCoords(row, column, this.wtSettings.getSetting('rtlMode'));\n  }\n\n  /**\n   * Creates and returns the CellRange object.\n   *\n   * @param {CellCoords} highlight The highlight coordinates.\n   * @param {CellCoords} from The from coordinates.\n   * @param {CellCoords} to The to coordinates.\n   * @returns {CellRange}\n   */\n  createCellRange(highlight, from, to) {\n    return new CellRange(highlight, from, to, this.wtSettings.getSetting('rtlMode'));\n  }\n\n  /**\n   * Force rerender of Walkontable.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   * @returns {Walkontable}\n   */\n  draw() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.drawInterrupted = false;\n    if (!fastDraw && !this.wtTable.isVisible()) {\n      // draw interrupted because TABLE is not visible\n      this.drawInterrupted = true;\n    } else {\n      this.wtTable.draw(fastDraw);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,\n   * if not set or set to false, returns TD from the master table.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   *                                  if the wanted cell is in the range of fixed rows, it will return a TD element\n   *                                  from the top overlay.\n   * @returns {HTMLElement}\n   */\n  getCell(coords) {\n    let topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!topmost) {\n      return this.wtTable.getCell(coords);\n    }\n    const totalRows = this.wtSettings.getSetting('totalRows');\n    const fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');\n    const fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');\n    const fixedColumnsStart = this.wtSettings.getSetting('fixedColumnsStart');\n    if (coords.row < fixedRowsTop && coords.col < fixedColumnsStart) {\n      return this.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.row < fixedRowsTop) {\n      return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.col < fixedColumnsStart && coords.row >= totalRows - fixedRowsBottom) {\n      if (this.wtOverlays.bottomInlineStartCornerOverlay && this.wtOverlays.bottomInlineStartCornerOverlay.clone) {\n        return this.wtOverlays.bottomInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n      }\n    } else if (coords.col < fixedColumnsStart) {\n      return this.wtOverlays.inlineStartOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {\n      if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {\n        return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);\n      }\n    }\n    return this.wtTable.getCell(coords);\n  }\n\n  /**\n   * Scrolls the viewport to a cell (rerenders if needed).\n   *\n   * @param {CellCoords} coords The cell coordinates to scroll to.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    if (coords.col < 0 || coords.row < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n  }\n\n  /**\n   * Scrolls the viewport to a column (rerenders if needed).\n   *\n   * @param {number} column Visual column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    if (column < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n  }\n\n  /**\n   * Scrolls the viewport to a row (rerenders if needed).\n   *\n   * @param {number} row Visual row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    if (row < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);\n  }\n\n  /**\n   * @returns {Array}\n   */\n  getViewport() {\n    return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];\n  }\n\n  /**\n   * Destroy instance.\n   */\n  destroy() {\n    this.wtOverlays.destroy();\n    this.wtEvent.destroy();\n  }\n\n  /**\n   * Create data access object for scroll.\n   *\n   * @protected\n   * @returns {ScrollDao}\n   */\n  createScrollDao() {\n    const wot = this;\n    return {\n      get drawn() {\n        return wot.drawn; // TODO refactoring: consider about injecting `isDrawn` function : ()=>return wot.drawn. (it'll enables remove dao layer)\n      },\n\n      get topOverlay() {\n        return wot.wtOverlays.topOverlay; // TODO refactoring: move outside dao, use IOC\n      },\n\n      get inlineStartOverlay() {\n        return wot.wtOverlays.inlineStartOverlay; // TODO refactoring: move outside dao, use IOC\n      },\n\n      get wtTable() {\n        return wot.wtTable; // TODO refactoring: move outside dao, use IOC\n      },\n\n      get wtViewport() {\n        return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n      },\n\n      get wtSettings() {\n        return wot.wtSettings;\n      },\n      get rootWindow() {\n        return wot.domBindings.rootWindow; // TODO refactoring: move outside dao\n      },\n\n      // TODO refactoring, consider about using injecting wtSettings into scroll (it'll enables remove dao layer)\n      get totalRows() {\n        return wot.wtSettings.getSetting('totalRows');\n      },\n      get totalColumns() {\n        return wot.wtSettings.getSetting('totalColumns');\n      },\n      get fixedRowsTop() {\n        return wot.wtSettings.getSetting('fixedRowsTop');\n      },\n      get fixedRowsBottom() {\n        return wot.wtSettings.getSetting('fixedRowsBottom');\n      },\n      get fixedColumnsStart() {\n        return wot.wtSettings.getSetting('fixedColumnsStart');\n      }\n    };\n  }\n  // TODO refactoring: it will be much better to not use DAO objects. They are needed for now to provide\n  // dynamically access to related objects\n  /**\n   * Create data access object for wtTable.\n   *\n   * @protected\n   * @returns {TableDao}\n   */\n  getTableDao() {\n    const wot = this;\n    return {\n      get wot() {\n        return wot;\n      },\n      get parentTableOffset() {\n        return wot.cloneSource.wtTable.tableOffset; // TODO rethink: cloneSource exists only in Clone type.\n      },\n\n      get cloneSource() {\n        return wot.cloneSource; // TODO rethink: cloneSource exists only in Clone type.\n      },\n\n      get workspaceWidth() {\n        return wot.wtViewport.getWorkspaceWidth();\n      },\n      get wtViewport() {\n        return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n      },\n\n      get wtOverlays() {\n        return wot.wtOverlays; // TODO refactoring: move outside dao, use IOC\n      },\n\n      get selectionManager() {\n        return wot.selectionManager; // TODO refactoring: move outside dao, use IOC\n      },\n\n      get drawn() {\n        return wot.drawn;\n      },\n      set drawn(v) {\n        // TODO rethink: this breaks assumes of data access object, however it is required until invent better way to handle WOT state.\n        wot.drawn = v;\n      },\n      get wtTable() {\n        return wot.wtTable; // TODO refactoring: it provides itself\n      },\n\n      get startColumnRendered() {\n        return wot.wtViewport.columnsRenderCalculator.startColumn;\n      },\n      get startColumnVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.startColumn;\n      },\n      get endColumnRendered() {\n        return wot.wtViewport.columnsRenderCalculator.endColumn;\n      },\n      get endColumnVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.endColumn;\n      },\n      get countColumnsRendered() {\n        return wot.wtViewport.columnsRenderCalculator.count;\n      },\n      get countColumnsVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.count;\n      },\n      get startRowRendered() {\n        return wot.wtViewport.rowsRenderCalculator.startRow;\n      },\n      get startRowVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.startRow;\n      },\n      get endRowRendered() {\n        return wot.wtViewport.rowsRenderCalculator.endRow;\n      },\n      get endRowVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.endRow;\n      },\n      get countRowsRendered() {\n        return wot.wtViewport.rowsRenderCalculator.count;\n      },\n      get countRowsVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.count;\n      },\n      get columnHeaders() {\n        return wot.wtSettings.getSetting('columnHeaders');\n      },\n      get rowHeaders() {\n        return wot.wtSettings.getSetting('rowHeaders');\n      }\n    };\n  }\n}","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","fastInnerText","randomString","EventManager","Scroll","CellCoords","CellRange","CoreAbstract","eventManager","constructor","table","settings","domBindings","rootTable","rootDocument","ownerDocument","rootWindow","defaultView","wtSettings","wtScroll","createScrollDao","findOriginalHeaders","originalHeaders","wtTable","THEAD","childNodes","length","c","clen","push","innerHTML","getSetting","update","column","TH","createCellCoords","row","createCellRange","highlight","from","to","draw","fastDraw","arguments","undefined","drawInterrupted","isVisible","getCell","coords","topmost","totalRows","fixedRowsTop","fixedRowsBottom","fixedColumnsStart","col","wtOverlays","topInlineStartCornerOverlay","clone","topOverlay","bottomInlineStartCornerOverlay","inlineStartOverlay","bottomOverlay","scrollViewport","snapToTop","snapToRight","snapToBottom","snapToLeft","scrollViewportHorizontally","scrollViewportVertically","getViewport","getFirstVisibleRow","getFirstVisibleColumn","getLastVisibleRow","getLastVisibleColumn","destroy","wtEvent","wot","drawn","wtViewport","totalColumns","getTableDao","parentTableOffset","cloneSource","tableOffset","workspaceWidth","getWorkspaceWidth","selectionManager","v","startColumnRendered","columnsRenderCalculator","startColumn","startColumnVisible","columnsVisibleCalculator","endColumnRendered","endColumn","endColumnVisible","countColumnsRendered","count","countColumnsVisible","startRowRendered","rowsRenderCalculator","startRow","startRowVisible","rowsVisibleCalculator","endRowRendered","endRow","endRowVisible","countRowsRendered","countRowsVisible","columnHeaders","rowHeaders"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/3rdparty/walkontable/src/core/_base.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { fastInnerText } from \"../../../../helpers/dom/element.mjs\";\nimport { randomString } from \"../../../../helpers/string.mjs\";\nimport EventManager from \"../../../../eventManager.mjs\";\nimport Scroll from \"../scroll.mjs\";\nimport CellCoords from \"../cell/coords.mjs\";\nimport CellRange from \"../cell/range.mjs\";\n/**\n * @abstract\n * @class Walkontable\n */\nexport default class CoreAbstract {\n  get eventManager() {\n    return new EventManager(this);\n  }\n\n  /**\n   * @param {HTMLTableElement} table Main table.\n   * @param {Settings} settings The Walkontable settings.\n   */\n  constructor(table, settings) {\n    _defineProperty(this, \"wtTable\", void 0);\n    _defineProperty(this, \"wtScroll\", void 0);\n    _defineProperty(this, \"wtViewport\", void 0);\n    _defineProperty(this, \"wtOverlays\", void 0);\n    _defineProperty(this, \"selectionManager\", void 0);\n    _defineProperty(this, \"wtEvent\", void 0);\n    /**\n     * The walkontable instance id.\n     *\n     * @public\n     * @type {Readonly<string>}\n     */\n    _defineProperty(this, \"guid\", `wt_${randomString()}`);\n    _defineProperty(this, \"drawInterrupted\", false);\n    _defineProperty(this, \"drawn\", false);\n    /**\n     * The DOM bindings.\n     *\n     * @public\n     * @type {DomBindings}\n     */\n    _defineProperty(this, \"domBindings\", void 0);\n    /**\n     * Settings.\n     *\n     * @public\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", void 0);\n    this.domBindings = {\n      rootTable: table,\n      rootDocument: table.ownerDocument,\n      rootWindow: table.ownerDocument.defaultView\n    };\n    this.wtSettings = settings;\n    this.wtScroll = new Scroll(this.createScrollDao());\n  }\n  findOriginalHeaders() {\n    const originalHeaders = [];\n\n    // find original headers\n    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {\n      for (let c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {\n        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);\n      }\n      if (!this.wtSettings.getSetting('columnHeaders').length) {\n        this.wtSettings.update('columnHeaders', [function (column, TH) {\n          fastInnerText(TH, originalHeaders[column]);\n        }]);\n      }\n    }\n  }\n\n  /**\n   * Creates and returns the CellCoords object.\n   *\n   * @param {*} row The row index.\n   * @param {*} column The column index.\n   * @returns {CellCoords}\n   */\n  createCellCoords(row, column) {\n    return new CellCoords(row, column, this.wtSettings.getSetting('rtlMode'));\n  }\n\n  /**\n   * Creates and returns the CellRange object.\n   *\n   * @param {CellCoords} highlight The highlight coordinates.\n   * @param {CellCoords} from The from coordinates.\n   * @param {CellCoords} to The to coordinates.\n   * @returns {CellRange}\n   */\n  createCellRange(highlight, from, to) {\n    return new CellRange(highlight, from, to, this.wtSettings.getSetting('rtlMode'));\n  }\n\n  /**\n   * Force rerender of Walkontable.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   * @returns {Walkontable}\n   */\n  draw() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.drawInterrupted = false;\n    if (!fastDraw && !this.wtTable.isVisible()) {\n      // draw interrupted because TABLE is not visible\n      this.drawInterrupted = true;\n    } else {\n      this.wtTable.draw(fastDraw);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,\n   * if not set or set to false, returns TD from the master table.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   *                                  if the wanted cell is in the range of fixed rows, it will return a TD element\n   *                                  from the top overlay.\n   * @returns {HTMLElement}\n   */\n  getCell(coords) {\n    let topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!topmost) {\n      return this.wtTable.getCell(coords);\n    }\n    const totalRows = this.wtSettings.getSetting('totalRows');\n    const fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');\n    const fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');\n    const fixedColumnsStart = this.wtSettings.getSetting('fixedColumnsStart');\n    if (coords.row < fixedRowsTop && coords.col < fixedColumnsStart) {\n      return this.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.row < fixedRowsTop) {\n      return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.col < fixedColumnsStart && coords.row >= totalRows - fixedRowsBottom) {\n      if (this.wtOverlays.bottomInlineStartCornerOverlay && this.wtOverlays.bottomInlineStartCornerOverlay.clone) {\n        return this.wtOverlays.bottomInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n      }\n    } else if (coords.col < fixedColumnsStart) {\n      return this.wtOverlays.inlineStartOverlay.clone.wtTable.getCell(coords);\n    } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {\n      if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {\n        return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);\n      }\n    }\n    return this.wtTable.getCell(coords);\n  }\n\n  /**\n   * Scrolls the viewport to a cell (rerenders if needed).\n   *\n   * @param {CellCoords} coords The cell coordinates to scroll to.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    if (coords.col < 0 || coords.row < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n  }\n\n  /**\n   * Scrolls the viewport to a column (rerenders if needed).\n   *\n   * @param {number} column Visual column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    if (column < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n  }\n\n  /**\n   * Scrolls the viewport to a row (rerenders if needed).\n   *\n   * @param {number} row Visual row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    if (row < 0) {\n      return false;\n    }\n    return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);\n  }\n\n  /**\n   * @returns {Array}\n   */\n  getViewport() {\n    return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];\n  }\n\n  /**\n   * Destroy instance.\n   */\n  destroy() {\n    this.wtOverlays.destroy();\n    this.wtEvent.destroy();\n  }\n\n  /**\n   * Create data access object for scroll.\n   *\n   * @protected\n   * @returns {ScrollDao}\n   */\n  createScrollDao() {\n    const wot = this;\n    return {\n      get drawn() {\n        return wot.drawn; // TODO refactoring: consider about injecting `isDrawn` function : ()=>return wot.drawn. (it'll enables remove dao layer)\n      },\n      get topOverlay() {\n        return wot.wtOverlays.topOverlay; // TODO refactoring: move outside dao, use IOC\n      },\n      get inlineStartOverlay() {\n        return wot.wtOverlays.inlineStartOverlay; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtTable() {\n        return wot.wtTable; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtViewport() {\n        return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtSettings() {\n        return wot.wtSettings;\n      },\n      get rootWindow() {\n        return wot.domBindings.rootWindow; // TODO refactoring: move outside dao\n      },\n      // TODO refactoring, consider about using injecting wtSettings into scroll (it'll enables remove dao layer)\n      get totalRows() {\n        return wot.wtSettings.getSetting('totalRows');\n      },\n      get totalColumns() {\n        return wot.wtSettings.getSetting('totalColumns');\n      },\n      get fixedRowsTop() {\n        return wot.wtSettings.getSetting('fixedRowsTop');\n      },\n      get fixedRowsBottom() {\n        return wot.wtSettings.getSetting('fixedRowsBottom');\n      },\n      get fixedColumnsStart() {\n        return wot.wtSettings.getSetting('fixedColumnsStart');\n      }\n    };\n  }\n  // TODO refactoring: it will be much better to not use DAO objects. They are needed for now to provide\n  // dynamically access to related objects\n  /**\n   * Create data access object for wtTable.\n   *\n   * @protected\n   * @returns {TableDao}\n   */\n  getTableDao() {\n    const wot = this;\n    return {\n      get wot() {\n        return wot;\n      },\n      get parentTableOffset() {\n        return wot.cloneSource.wtTable.tableOffset; // TODO rethink: cloneSource exists only in Clone type.\n      },\n      get cloneSource() {\n        return wot.cloneSource; // TODO rethink: cloneSource exists only in Clone type.\n      },\n      get workspaceWidth() {\n        return wot.wtViewport.getWorkspaceWidth();\n      },\n      get wtViewport() {\n        return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n      },\n      get wtOverlays() {\n        return wot.wtOverlays; // TODO refactoring: move outside dao, use IOC\n      },\n      get selectionManager() {\n        return wot.selectionManager; // TODO refactoring: move outside dao, use IOC\n      },\n      get drawn() {\n        return wot.drawn;\n      },\n      set drawn(v) {\n        // TODO rethink: this breaks assumes of data access object, however it is required until invent better way to handle WOT state.\n        wot.drawn = v;\n      },\n      get wtTable() {\n        return wot.wtTable; // TODO refactoring: it provides itself\n      },\n      get startColumnRendered() {\n        return wot.wtViewport.columnsRenderCalculator.startColumn;\n      },\n      get startColumnVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.startColumn;\n      },\n      get endColumnRendered() {\n        return wot.wtViewport.columnsRenderCalculator.endColumn;\n      },\n      get endColumnVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.endColumn;\n      },\n      get countColumnsRendered() {\n        return wot.wtViewport.columnsRenderCalculator.count;\n      },\n      get countColumnsVisible() {\n        return wot.wtViewport.columnsVisibleCalculator.count;\n      },\n      get startRowRendered() {\n        return wot.wtViewport.rowsRenderCalculator.startRow;\n      },\n      get startRowVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.startRow;\n      },\n      get endRowRendered() {\n        return wot.wtViewport.rowsRenderCalculator.endRow;\n      },\n      get endRowVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.endRow;\n      },\n      get countRowsRendered() {\n        return wot.wtViewport.rowsRenderCalculator.count;\n      },\n      get countRowsVisible() {\n        return wot.wtViewport.rowsVisibleCalculator.count;\n      },\n      get columnHeaders() {\n        return wot.wtSettings.getSetting('columnHeaders');\n      },\n      get rowHeaders() {\n        return wot.wtSettings.getSetting('rowHeaders');\n      }\n    };\n  }\n}"],"mappings":"AAAA,OAAO,kCAAkC;AACzC,OAAO,mCAAmC;AAC1C,SAASA,eAAe,CAACC,GAAG,EAAEC,GAAG,EAAEC,KAAK,EAAE;EAAED,GAAG,GAAGE,cAAc,CAACF,GAAG,CAAC;EAAE,IAAIA,GAAG,IAAID,GAAG,EAAE;IAAEI,MAAM,CAACC,cAAc,CAACL,GAAG,EAAEC,GAAG,EAAE;MAAEC,KAAK,EAAEA,KAAK;MAAEI,UAAU,EAAE,IAAI;MAAEC,YAAY,EAAE,IAAI;MAAEC,QAAQ,EAAE;IAAK,CAAC,CAAC;EAAE,CAAC,MAAM;IAAER,GAAG,CAACC,GAAG,CAAC,GAAGC,KAAK;EAAE;EAAE,OAAOF,GAAG;AAAE;AAC3O,SAASG,cAAc,CAACM,CAAC,EAAE;EAAE,IAAIC,CAAC,GAAGC,YAAY,CAACF,CAAC,EAAE,QAAQ,CAAC;EAAE,OAAO,QAAQ,IAAI,OAAOC,CAAC,GAAGA,CAAC,GAAGE,MAAM,CAACF,CAAC,CAAC;AAAE;AAC7G,SAASC,YAAY,CAACF,CAAC,EAAEI,CAAC,EAAE;EAAE,IAAI,QAAQ,IAAI,OAAOJ,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EAAE,IAAIK,CAAC,GAAGL,CAAC,CAACM,MAAM,CAACC,WAAW,CAAC;EAAE,IAAI,KAAK,CAAC,KAAKF,CAAC,EAAE;IAAE,IAAIJ,CAAC,GAAGI,CAAC,CAACG,IAAI,CAACR,CAAC,EAAEI,CAAC,IAAI,SAAS,CAAC;IAAE,IAAI,QAAQ,IAAI,OAAOH,CAAC,EAAE,OAAOA,CAAC;IAAE,MAAM,IAAIQ,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAAC,QAAQ,KAAKL,CAAC,GAAGD,MAAM,GAAGO,MAAM,EAAEV,CAAC,CAAC;AAAE;AACvT,SAASW,aAAa,QAAQ,qCAAqC;AACnE,SAASC,YAAY,QAAQ,gCAAgC;AAC7D,OAAOC,YAAY,MAAM,8BAA8B;AACvD,OAAOC,MAAM,MAAM,eAAe;AAClC,OAAOC,UAAU,MAAM,oBAAoB;AAC3C,OAAOC,SAAS,MAAM,mBAAmB;AACzC;AACA;AACA;AACA;AACA,eAAe,MAAMC,YAAY,CAAC;EAChC,IAAIC,YAAY,GAAG;IACjB,OAAO,IAAIL,YAAY,CAAC,IAAI,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;EACEM,WAAW,CAACC,KAAK,EAAEC,QAAQ,EAAE;IAC3B/B,eAAe,CAAC,IAAI,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;IACxCA,eAAe,CAAC,IAAI,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;IACzCA,eAAe,CAAC,IAAI,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;IAC3CA,eAAe,CAAC,IAAI,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;IAC3CA,eAAe,CAAC,IAAI,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC;IACjDA,eAAe,CAAC,IAAI,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;IACxC;AACJ;AACA;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,MAAM,EAAG,MAAKsB,YAAY,EAAG,EAAC,CAAC;IACrDtB,eAAe,CAAC,IAAI,EAAE,iBAAiB,EAAE,KAAK,CAAC;IAC/CA,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC;IACrC;AACJ;AACA;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;IAC5C;AACJ;AACA;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;IAC3C,IAAI,CAACgC,WAAW,GAAG;MACjBC,SAAS,EAAEH,KAAK;MAChBI,YAAY,EAAEJ,KAAK,CAACK,aAAa;MACjCC,UAAU,EAAEN,KAAK,CAACK,aAAa,CAACE;IAClC,CAAC;IACD,IAAI,CAACC,UAAU,GAAGP,QAAQ;IAC1B,IAAI,CAACQ,QAAQ,GAAG,IAAIf,MAAM,CAAC,IAAI,CAACgB,eAAe,EAAE,CAAC;EACpD;EACAC,mBAAmB,GAAG;IACpB,MAAMC,eAAe,GAAG,EAAE;;IAE1B;IACA,IAAI,IAAI,CAACC,OAAO,CAACC,KAAK,CAACC,UAAU,CAACC,MAAM,IAAI,IAAI,CAACH,OAAO,CAACC,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,CAACA,UAAU,CAACC,MAAM,EAAE;MAC9F,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAG,IAAI,CAACL,OAAO,CAACC,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,CAACA,UAAU,CAACC,MAAM,EAAEC,CAAC,GAAGC,IAAI,EAAED,CAAC,EAAE,EAAE;QACxFL,eAAe,CAACO,IAAI,CAAC,IAAI,CAACN,OAAO,CAACC,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,CAACA,UAAU,CAACE,CAAC,CAAC,CAACG,SAAS,CAAC;MAChF;MACA,IAAI,CAAC,IAAI,CAACZ,UAAU,CAACa,UAAU,CAAC,eAAe,CAAC,CAACL,MAAM,EAAE;QACvD,IAAI,CAACR,UAAU,CAACc,MAAM,CAAC,eAAe,EAAE,CAAC,UAAUC,MAAM,EAAEC,EAAE,EAAE;UAC7DjC,aAAa,CAACiC,EAAE,EAAEZ,eAAe,CAACW,MAAM,CAAC,CAAC;QAC5C,CAAC,CAAC,CAAC;MACL;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,gBAAgB,CAACC,GAAG,EAAEH,MAAM,EAAE;IAC5B,OAAO,IAAI5B,UAAU,CAAC+B,GAAG,EAAEH,MAAM,EAAE,IAAI,CAACf,UAAU,CAACa,UAAU,CAAC,SAAS,CAAC,CAAC;EAC3E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,eAAe,CAACC,SAAS,EAAEC,IAAI,EAAEC,EAAE,EAAE;IACnC,OAAO,IAAIlC,SAAS,CAACgC,SAAS,EAAEC,IAAI,EAAEC,EAAE,EAAE,IAAI,CAACtB,UAAU,CAACa,UAAU,CAAC,SAAS,CAAC,CAAC;EAClF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEU,IAAI,GAAG;IACL,IAAIC,QAAQ,GAAGC,SAAS,CAACjB,MAAM,GAAG,CAAC,IAAIiB,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;IACxF,IAAI,CAACE,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACH,QAAQ,IAAI,CAAC,IAAI,CAACnB,OAAO,CAACuB,SAAS,EAAE,EAAE;MAC1C;MACA,IAAI,CAACD,eAAe,GAAG,IAAI;IAC7B,CAAC,MAAM;MACL,IAAI,CAACtB,OAAO,CAACkB,IAAI,CAACC,QAAQ,CAAC;IAC7B;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,OAAO,CAACC,MAAM,EAAE;IACd,IAAIC,OAAO,GAAGN,SAAS,CAACjB,MAAM,GAAG,CAAC,IAAIiB,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;IACvF,IAAI,CAACM,OAAO,EAAE;MACZ,OAAO,IAAI,CAAC1B,OAAO,CAACwB,OAAO,CAACC,MAAM,CAAC;IACrC;IACA,MAAME,SAAS,GAAG,IAAI,CAAChC,UAAU,CAACa,UAAU,CAAC,WAAW,CAAC;IACzD,MAAMoB,YAAY,GAAG,IAAI,CAACjC,UAAU,CAACa,UAAU,CAAC,cAAc,CAAC;IAC/D,MAAMqB,eAAe,GAAG,IAAI,CAAClC,UAAU,CAACa,UAAU,CAAC,iBAAiB,CAAC;IACrE,MAAMsB,iBAAiB,GAAG,IAAI,CAACnC,UAAU,CAACa,UAAU,CAAC,mBAAmB,CAAC;IACzE,IAAIiB,MAAM,CAACZ,GAAG,GAAGe,YAAY,IAAIH,MAAM,CAACM,GAAG,GAAGD,iBAAiB,EAAE;MAC/D,OAAO,IAAI,CAACE,UAAU,CAACC,2BAA2B,CAACC,KAAK,CAAClC,OAAO,CAACwB,OAAO,CAACC,MAAM,CAAC;IAClF,CAAC,MAAM,IAAIA,MAAM,CAACZ,GAAG,GAAGe,YAAY,EAAE;MACpC,OAAO,IAAI,CAACI,UAAU,CAACG,UAAU,CAACD,KAAK,CAAClC,OAAO,CAACwB,OAAO,CAACC,MAAM,CAAC;IACjE,CAAC,MAAM,IAAIA,MAAM,CAACM,GAAG,GAAGD,iBAAiB,IAAIL,MAAM,CAACZ,GAAG,IAAIc,SAAS,GAAGE,eAAe,EAAE;MACtF,IAAI,IAAI,CAACG,UAAU,CAACI,8BAA8B,IAAI,IAAI,CAACJ,UAAU,CAACI,8BAA8B,CAACF,KAAK,EAAE;QAC1G,OAAO,IAAI,CAACF,UAAU,CAACI,8BAA8B,CAACF,KAAK,CAAClC,OAAO,CAACwB,OAAO,CAACC,MAAM,CAAC;MACrF;IACF,CAAC,MAAM,IAAIA,MAAM,CAACM,GAAG,GAAGD,iBAAiB,EAAE;MACzC,OAAO,IAAI,CAACE,UAAU,CAACK,kBAAkB,CAACH,KAAK,CAAClC,OAAO,CAACwB,OAAO,CAACC,MAAM,CAAC;IACzE,CAAC,MAAM,IAAIA,MAAM,CAACZ,GAAG,GAAGc,SAAS,IAAIF,MAAM,CAACZ,GAAG,IAAIc,SAAS,GAAGE,eAAe,EAAE;MAC9E,IAAI,IAAI,CAACG,UAAU,CAACM,aAAa,IAAI,IAAI,CAACN,UAAU,CAACM,aAAa,CAACJ,KAAK,EAAE;QACxE,OAAO,IAAI,CAACF,UAAU,CAACM,aAAa,CAACJ,KAAK,CAAClC,OAAO,CAACwB,OAAO,CAACC,MAAM,CAAC;MACpE;IACF;IACA,OAAO,IAAI,CAACzB,OAAO,CAACwB,OAAO,CAACC,MAAM,CAAC;EACrC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEc,cAAc,CAACd,MAAM,EAAEe,SAAS,EAAEC,WAAW,EAAEC,YAAY,EAAEC,UAAU,EAAE;IACvE,IAAIlB,MAAM,CAACM,GAAG,GAAG,CAAC,IAAIN,MAAM,CAACZ,GAAG,GAAG,CAAC,EAAE;MACpC,OAAO,KAAK;IACd;IACA,OAAO,IAAI,CAACjB,QAAQ,CAAC2C,cAAc,CAACd,MAAM,EAAEe,SAAS,EAAEC,WAAW,EAAEC,YAAY,EAAEC,UAAU,CAAC;EAC/F;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,0BAA0B,CAAClC,MAAM,EAAE+B,WAAW,EAAEE,UAAU,EAAE;IAC1D,IAAIjC,MAAM,GAAG,CAAC,EAAE;MACd,OAAO,KAAK;IACd;IACA,OAAO,IAAI,CAACd,QAAQ,CAACgD,0BAA0B,CAAClC,MAAM,EAAE+B,WAAW,EAAEE,UAAU,CAAC;EAClF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,wBAAwB,CAAChC,GAAG,EAAE2B,SAAS,EAAEE,YAAY,EAAE;IACrD,IAAI7B,GAAG,GAAG,CAAC,EAAE;MACX,OAAO,KAAK;IACd;IACA,OAAO,IAAI,CAACjB,QAAQ,CAACiD,wBAAwB,CAAChC,GAAG,EAAE2B,SAAS,EAAEE,YAAY,CAAC;EAC7E;;EAEA;AACF;AACA;EACEI,WAAW,GAAG;IACZ,OAAO,CAAC,IAAI,CAAC9C,OAAO,CAAC+C,kBAAkB,EAAE,EAAE,IAAI,CAAC/C,OAAO,CAACgD,qBAAqB,EAAE,EAAE,IAAI,CAAChD,OAAO,CAACiD,iBAAiB,EAAE,EAAE,IAAI,CAACjD,OAAO,CAACkD,oBAAoB,EAAE,CAAC;EACzJ;;EAEA;AACF;AACA;EACEC,OAAO,GAAG;IACR,IAAI,CAACnB,UAAU,CAACmB,OAAO,EAAE;IACzB,IAAI,CAACC,OAAO,CAACD,OAAO,EAAE;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEtD,eAAe,GAAG;IAChB,MAAMwD,GAAG,GAAG,IAAI;IAChB,OAAO;MACL,IAAIC,KAAK,GAAG;QACV,OAAOD,GAAG,CAACC,KAAK,CAAC,CAAC;MACpB,CAAC;;MACD,IAAInB,UAAU,GAAG;QACf,OAAOkB,GAAG,CAACrB,UAAU,CAACG,UAAU,CAAC,CAAC;MACpC,CAAC;;MACD,IAAIE,kBAAkB,GAAG;QACvB,OAAOgB,GAAG,CAACrB,UAAU,CAACK,kBAAkB,CAAC,CAAC;MAC5C,CAAC;;MACD,IAAIrC,OAAO,GAAG;QACZ,OAAOqD,GAAG,CAACrD,OAAO,CAAC,CAAC;MACtB,CAAC;;MACD,IAAIuD,UAAU,GAAG;QACf,OAAOF,GAAG,CAACE,UAAU,CAAC,CAAC;MACzB,CAAC;;MACD,IAAI5D,UAAU,GAAG;QACf,OAAO0D,GAAG,CAAC1D,UAAU;MACvB,CAAC;MACD,IAAIF,UAAU,GAAG;QACf,OAAO4D,GAAG,CAAChE,WAAW,CAACI,UAAU,CAAC,CAAC;MACrC,CAAC;;MACD;MACA,IAAIkC,SAAS,GAAG;QACd,OAAO0B,GAAG,CAAC1D,UAAU,CAACa,UAAU,CAAC,WAAW,CAAC;MAC/C,CAAC;MACD,IAAIgD,YAAY,GAAG;QACjB,OAAOH,GAAG,CAAC1D,UAAU,CAACa,UAAU,CAAC,cAAc,CAAC;MAClD,CAAC;MACD,IAAIoB,YAAY,GAAG;QACjB,OAAOyB,GAAG,CAAC1D,UAAU,CAACa,UAAU,CAAC,cAAc,CAAC;MAClD,CAAC;MACD,IAAIqB,eAAe,GAAG;QACpB,OAAOwB,GAAG,CAAC1D,UAAU,CAACa,UAAU,CAAC,iBAAiB,CAAC;MACrD,CAAC;MACD,IAAIsB,iBAAiB,GAAG;QACtB,OAAOuB,GAAG,CAAC1D,UAAU,CAACa,UAAU,CAAC,mBAAmB,CAAC;MACvD;IACF,CAAC;EACH;EACA;EACA;EACA;AACF;AACA;AACA;AACA;AACA;EACEiD,WAAW,GAAG;IACZ,MAAMJ,GAAG,GAAG,IAAI;IAChB,OAAO;MACL,IAAIA,GAAG,GAAG;QACR,OAAOA,GAAG;MACZ,CAAC;MACD,IAAIK,iBAAiB,GAAG;QACtB,OAAOL,GAAG,CAACM,WAAW,CAAC3D,OAAO,CAAC4D,WAAW,CAAC,CAAC;MAC9C,CAAC;;MACD,IAAID,WAAW,GAAG;QAChB,OAAON,GAAG,CAACM,WAAW,CAAC,CAAC;MAC1B,CAAC;;MACD,IAAIE,cAAc,GAAG;QACnB,OAAOR,GAAG,CAACE,UAAU,CAACO,iBAAiB,EAAE;MAC3C,CAAC;MACD,IAAIP,UAAU,GAAG;QACf,OAAOF,GAAG,CAACE,UAAU,CAAC,CAAC;MACzB,CAAC;;MACD,IAAIvB,UAAU,GAAG;QACf,OAAOqB,GAAG,CAACrB,UAAU,CAAC,CAAC;MACzB,CAAC;;MACD,IAAI+B,gBAAgB,GAAG;QACrB,OAAOV,GAAG,CAACU,gBAAgB,CAAC,CAAC;MAC/B,CAAC;;MACD,IAAIT,KAAK,GAAG;QACV,OAAOD,GAAG,CAACC,KAAK;MAClB,CAAC;MACD,IAAIA,KAAK,CAACU,CAAC,EAAE;QACX;QACAX,GAAG,CAACC,KAAK,GAAGU,CAAC;MACf,CAAC;MACD,IAAIhE,OAAO,GAAG;QACZ,OAAOqD,GAAG,CAACrD,OAAO,CAAC,CAAC;MACtB,CAAC;;MACD,IAAIiE,mBAAmB,GAAG;QACxB,OAAOZ,GAAG,CAACE,UAAU,CAACW,uBAAuB,CAACC,WAAW;MAC3D,CAAC;MACD,IAAIC,kBAAkB,GAAG;QACvB,OAAOf,GAAG,CAACE,UAAU,CAACc,wBAAwB,CAACF,WAAW;MAC5D,CAAC;MACD,IAAIG,iBAAiB,GAAG;QACtB,OAAOjB,GAAG,CAACE,UAAU,CAACW,uBAAuB,CAACK,SAAS;MACzD,CAAC;MACD,IAAIC,gBAAgB,GAAG;QACrB,OAAOnB,GAAG,CAACE,UAAU,CAACc,wBAAwB,CAACE,SAAS;MAC1D,CAAC;MACD,IAAIE,oBAAoB,GAAG;QACzB,OAAOpB,GAAG,CAACE,UAAU,CAACW,uBAAuB,CAACQ,KAAK;MACrD,CAAC;MACD,IAAIC,mBAAmB,GAAG;QACxB,OAAOtB,GAAG,CAACE,UAAU,CAACc,wBAAwB,CAACK,KAAK;MACtD,CAAC;MACD,IAAIE,gBAAgB,GAAG;QACrB,OAAOvB,GAAG,CAACE,UAAU,CAACsB,oBAAoB,CAACC,QAAQ;MACrD,CAAC;MACD,IAAIC,eAAe,GAAG;QACpB,OAAO1B,GAAG,CAACE,UAAU,CAACyB,qBAAqB,CAACF,QAAQ;MACtD,CAAC;MACD,IAAIG,cAAc,GAAG;QACnB,OAAO5B,GAAG,CAACE,UAAU,CAACsB,oBAAoB,CAACK,MAAM;MACnD,CAAC;MACD,IAAIC,aAAa,GAAG;QAClB,OAAO9B,GAAG,CAACE,UAAU,CAACyB,qBAAqB,CAACE,MAAM;MACpD,CAAC;MACD,IAAIE,iBAAiB,GAAG;QACtB,OAAO/B,GAAG,CAACE,UAAU,CAACsB,oBAAoB,CAACH,KAAK;MAClD,CAAC;MACD,IAAIW,gBAAgB,GAAG;QACrB,OAAOhC,GAAG,CAACE,UAAU,CAACyB,qBAAqB,CAACN,KAAK;MACnD,CAAC;MACD,IAAIY,aAAa,GAAG;QAClB,OAAOjC,GAAG,CAAC1D,UAAU,CAACa,UAAU,CAAC,eAAe,CAAC;MACnD,CAAC;MACD,IAAI+E,UAAU,GAAG;QACf,OAAOlC,GAAG,CAAC1D,UAAU,CAACa,UAAU,CAAC,YAAY,CAAC;MAChD;IACF,CAAC;EACH;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}