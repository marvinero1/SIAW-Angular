{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport MergedCellsCollection from \"./cellsCollection.mjs\";\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport AutofillCalculations from \"./calculations/autofill.mjs\";\nimport SelectionCalculations from \"./calculations/selection.mjs\";\nimport toggleMergeItem from \"./contextMenuItem/toggleMerge.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { isObject, clone } from \"../../helpers/object.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nimport { getStyle } from \"../../helpers/dom/element.mjs\";\nimport { isChrome } from \"../../helpers/browser.mjs\";\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nexport const PLUGIN_KEY = 'mergeCells';\nexport const PLUGIN_PRIORITY = 150;\nconst SHORTCUTS_GROUP = PLUGIN_KEY;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin MergeCells\n * @class MergeCells\n *\n * @description\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *  data: getData(),\n *  mergeCells: [\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *  ],\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   // enable plugin\n *   mergeCells={[\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *   ]}\n * />\n * ```\n * :::\n */\nvar _lastDesiredCoords = /*#__PURE__*/new WeakMap();\nvar _onAfterInit = /*#__PURE__*/new WeakSet();\nvar _onAfterIsMultipleSelection = /*#__PURE__*/new WeakSet();\nvar _onModifyTransformStart = /*#__PURE__*/new WeakSet();\nvar _onModifyTransformEnd = /*#__PURE__*/new WeakSet();\nvar _onModifyGetCellCoords = /*#__PURE__*/new WeakSet();\nvar _addMergeActionsToContextMenu = /*#__PURE__*/new WeakSet();\nvar _onAfterRenderer = /*#__PURE__*/new WeakSet();\nvar _onBeforeSetRangeStart = /*#__PURE__*/new WeakSet();\nvar _onBeforeSetRangeEnd = /*#__PURE__*/new WeakSet();\nvar _onAfterGetCellMeta = /*#__PURE__*/new WeakSet();\nvar _onAfterViewportRowCalculatorOverride = /*#__PURE__*/new WeakSet();\nvar _onAfterViewportColumnCalculatorOverride = /*#__PURE__*/new WeakSet();\nvar _onModifyAutofillRange = /*#__PURE__*/new WeakSet();\nvar _onAfterCreateCol = /*#__PURE__*/new WeakSet();\nvar _onAfterRemoveCol = /*#__PURE__*/new WeakSet();\nvar _onAfterCreateRow = /*#__PURE__*/new WeakSet();\nvar _onAfterRemoveRow = /*#__PURE__*/new WeakSet();\nvar _onAfterChange = /*#__PURE__*/new WeakSet();\nvar _onBeforeDrawAreaBorders = /*#__PURE__*/new WeakSet();\nvar _onAfterModifyTransformStart = /*#__PURE__*/new WeakSet();\nvar _onAfterDrawSelection = /*#__PURE__*/new WeakSet();\nvar _onBeforeRemoveCellClassNames = /*#__PURE__*/new WeakSet();\nexport class MergeCells extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\n     *\n     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from\n     *   all the cells in the table.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeRemoveCellClassNames);\n    /**\n     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\n     *\n     * @param {number} currentRow Visual row index of the currently processed cell.\n     * @param {number} currentColumn Visual column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow,\n     *   endColumn]`.\n     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently\n     *   processed cell.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterDrawSelection);\n    /**\n     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of\n     * the table with the <kbd>**Enter**</kbd>/<kbd>**Shift**</kbd>+<kbd>**Enter**</kbd>/<kbd>**Tab**</kbd>/<kbd>**Shift**</kbd>+<kbd>**Tab**</kbd> keys.\n     *\n     * @param {CellCoords} coords Coordinates of the to-be-selected cell.\n     * @param {number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value =\n     *   down).\n     * @param {number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value =\n     *   down).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterModifyTransformStart);\n    /**\n     * `beforeDrawAreaBorders` hook callback.\n     *\n     * @param {Array} corners Visual coordinates of the area corners.\n     * @param {string} className Class name for the area.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeDrawAreaBorders);\n    /**\n     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\n     *\n     * @param {Array} changes The changes array.\n     * @param {string} source Determines the source of the change.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterChange);\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @param {number} row Row index.\n     * @param {number} count Number of removed rows.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterRemoveRow);\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @param {number} row Row index.\n     * @param {number} count Number of created rows.\n     * @param {string} source Source of change.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCreateRow);\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @param {number} column Column index.\n     * @param {number} count Number of removed columns.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterRemoveCol);\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @param {number} column Column index.\n     * @param {number} count Number of created columns.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCreateCol);\n    /**\n     * The `modifyAutofillRange` hook callback.\n     *\n     * @param {Array} drag The drag area coordinates.\n     * @param {Array} select The selection information.\n     * @returns {Array} The new drag area.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyAutofillRange);\n    /**\n     * `afterViewportColumnCalculatorOverride` hook callback.\n     *\n     * @param {object} calc The column calculator object.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterViewportColumnCalculatorOverride);\n    /**\n     * `afterViewportRowCalculatorOverride` hook callback.\n     *\n     * @param {object} calc The row calculator object.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterViewportRowCalculatorOverride);\n    /**\n     * The `afterGetCellMeta` hook callback.\n     *\n     * @param {number} row Row index.\n     * @param {number} col Column index.\n     * @param {object} cellProperties The cell properties object.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterGetCellMeta);\n    /**\n     * `beforeSetRangeEnd` hook callback.\n     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the\n     * merged cell.\n     *\n     * Note: Please keep in mind that callback may modify both start and end range coordinates by the reference.\n     *\n     * @param {object} coords Cell coords.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeSetRangeEnd);\n    /**\n     * `beforeSetRangeStart` and `beforeSetRangeStartOnly` hook callback.\n     * A selection within merge area should be rewritten to the start of merge area.\n     *\n     * @param {object} coords Cell coords.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeSetRangeStart);\n    /**\n     * `afterRenderer` hook callback.\n     *\n     * @param {HTMLElement} TD The cell to be modified.\n     * @param {number} row Row index.\n     * @param {number} col Visual column index.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterRenderer);\n    /**\n     * `afterContextMenuDefaultOptions` hook callback.\n     *\n     * @param {object} defaultOptions The default context menu options.\n     */\n    _classPrivateMethodInitSpec(this, _addMergeActionsToContextMenu);\n    /**\n     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Visual column index.\n     * @returns {Array|undefined} Visual coordinates of the merge.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyGetCellCoords);\n    /**\n     * `modifyTransformEnd` hook callback. Needed to handle \"jumping over\" merged merged cells, while selecting.\n     *\n     * @param {object} delta The transformation delta.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyTransformEnd);\n    /**\n     * `modifyTransformStart` hook callback.\n     *\n     * @param {object} delta The transformation delta.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyTransformStart);\n    /**\n     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection`\n     * hook callback.\n     *\n     * @param {boolean} isMultiple Determines whether the current selection contains multiple cells.\n     * @returns {boolean}\n     */\n    _classPrivateMethodInitSpec(this, _onAfterIsMultipleSelection);\n    /**\n     * `afterInit` hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterInit);\n    /**\n     * A container for all the merged cells.\n     *\n     * @private\n     * @type {MergedCellsCollection}\n     */\n    _defineProperty(this, \"mergedCellsCollection\", null);\n    /**\n     * Instance of the class responsible for all the autofill-related calculations.\n     *\n     * @private\n     * @type {AutofillCalculations}\n     */\n    _defineProperty(this, \"autofillCalculations\", null);\n    /**\n     * Instance of the class responsible for the selection-related calculations.\n     *\n     * @private\n     * @type {SelectionCalculations}\n     */\n    _defineProperty(this, \"selectionCalculations\", null);\n    /**\n     * @type {CellCoords}\n     */\n    _classPrivateFieldInitSpec(this, _lastDesiredCoords, {\n      writable: true,\n      value: null\n    });\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link MergeCells#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.mergedCellsCollection = new MergedCellsCollection(this);\n    this.autofillCalculations = new AutofillCalculations(this);\n    this.selectionCalculations = new SelectionCalculations(this);\n    this.addHook('afterInit', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onAfterInit, _onAfterInit2).call(_this, ...args);\n    });\n    this.addHook('modifyTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _classPrivateMethodGet(_this, _onModifyTransformStart, _onModifyTransformStart2).call(_this, ...args);\n    });\n    this.addHook('afterModifyTransformStart', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _classPrivateMethodGet(_this, _onAfterModifyTransformStart, _onAfterModifyTransformStart2).call(_this, ...args);\n    });\n    this.addHook('modifyTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _classPrivateMethodGet(_this, _onModifyTransformEnd, _onModifyTransformEnd2).call(_this, ...args);\n    });\n    this.addHook('modifyGetCellCoords', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _classPrivateMethodGet(_this, _onModifyGetCellCoords, _onModifyGetCellCoords2).call(_this, ...args);\n    });\n    this.addHook('beforeSetRangeStart', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeSetRangeStart, _onBeforeSetRangeStart2).call(_this, ...args);\n    });\n    this.addHook('beforeSetRangeStartOnly', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeSetRangeStart, _onBeforeSetRangeStart2).call(_this, ...args);\n    });\n    this.addHook('beforeSetRangeEnd', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeSetRangeEnd, _onBeforeSetRangeEnd2).call(_this, ...args);\n    });\n    this.addHook('afterIsMultipleSelection', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _classPrivateMethodGet(_this, _onAfterIsMultipleSelection, _onAfterIsMultipleSelection2).call(_this, ...args);\n    });\n    this.addHook('afterRenderer', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _classPrivateMethodGet(_this, _onAfterRenderer, _onAfterRenderer2).call(_this, ...args);\n    });\n    this.addHook('afterContextMenuDefaultOptions', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _classPrivateMethodGet(_this, _addMergeActionsToContextMenu, _addMergeActionsToContextMenu2).call(_this, ...args);\n    });\n    this.addHook('afterGetCellMeta', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _classPrivateMethodGet(_this, _onAfterGetCellMeta, _onAfterGetCellMeta2).call(_this, ...args);\n    });\n    this.addHook('afterViewportRowCalculatorOverride', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _classPrivateMethodGet(_this, _onAfterViewportRowCalculatorOverride, _onAfterViewportRowCalculatorOverride2).call(_this, ...args);\n    });\n    this.addHook('afterViewportColumnCalculatorOverride', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _classPrivateMethodGet(_this, _onAfterViewportColumnCalculatorOverride, _onAfterViewportColumnCalculatorOverride2).call(_this, ...args);\n    });\n    this.addHook('modifyAutofillRange', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _classPrivateMethodGet(_this, _onModifyAutofillRange, _onModifyAutofillRange2).call(_this, ...args);\n    });\n    this.addHook('afterCreateCol', function () {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return _classPrivateMethodGet(_this, _onAfterCreateCol, _onAfterCreateCol2).call(_this, ...args);\n    });\n    this.addHook('afterRemoveCol', function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return _classPrivateMethodGet(_this, _onAfterRemoveCol, _onAfterRemoveCol2).call(_this, ...args);\n    });\n    this.addHook('afterCreateRow', function () {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return _classPrivateMethodGet(_this, _onAfterCreateRow, _onAfterCreateRow2).call(_this, ...args);\n    });\n    this.addHook('afterRemoveRow', function () {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return _classPrivateMethodGet(_this, _onAfterRemoveRow, _onAfterRemoveRow2).call(_this, ...args);\n    });\n    this.addHook('afterChange', function () {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return _classPrivateMethodGet(_this, _onAfterChange, _onAfterChange2).call(_this, ...args);\n    });\n    this.addHook('beforeDrawBorders', function () {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeDrawAreaBorders, _onBeforeDrawAreaBorders2).call(_this, ...args);\n    });\n    this.addHook('afterDrawSelection', function () {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return _classPrivateMethodGet(_this, _onAfterDrawSelection, _onAfterDrawSelection2).call(_this, ...args);\n    });\n    this.addHook('beforeRemoveCellClassNames', function () {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeRemoveCellClassNames, _onBeforeRemoveCellClassNames2).call(_this, ...args);\n    });\n    this.addHook('beforeUndoStackChange', (action, source) => {\n      if (source === 'MergeCells') {\n        return false;\n      }\n    });\n    this.registerShortcuts();\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearCollections();\n    this.unregisterShortcuts();\n    this.hot.render();\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the\n   * following configuration options:\n   *  - [`mergeCells`](@/api/options.md#mergecells)\n   */\n  updatePlugin() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    this.disablePlugin();\n    this.enablePlugin();\n    this.generateFromSettings(settings);\n    super.updatePlugin();\n  }\n\n  /**\n   * If the browser is recognized as Chrome, force an additional repaint to prevent showing the effects of a Chrome bug.\n   *\n   * Issue described in https://github.com/handsontable/dev-handsontable/issues/521.\n   *\n   * @private\n   */\n  ifChromeForceRepaint() {\n    if (!isChrome()) {\n      return;\n    }\n    const rowsToRefresh = [];\n    let rowIndexesToRefresh = [];\n    this.mergedCellsCollection.mergedCells.forEach(mergedCell => {\n      const {\n        row,\n        rowspan\n      } = mergedCell;\n      for (let r = row + 1; r < row + rowspan; r++) {\n        rowIndexesToRefresh.push(r);\n      }\n    });\n\n    // Remove duplicates\n    rowIndexesToRefresh = [...new Set(rowIndexesToRefresh)];\n    rowIndexesToRefresh.forEach(rowIndex => {\n      const renderableRowIndex = this.hot.rowIndexMapper.getRenderableFromVisualIndex(rowIndex);\n      this.hot.view._wt.wtOverlays.getOverlays(true).map(overlay => (overlay === null || overlay === void 0 ? void 0 : overlay.name) === 'master' ? overlay : overlay.clone.wtTable).forEach(wtTableRef => {\n        const rowToRefresh = wtTableRef.getRow(renderableRowIndex);\n        if (rowToRefresh) {\n          // Modify the TR's `background` property to later modify it asynchronously.\n          // The background color is getting modified only with the alpha, so the change should not be visible (and is\n          // covered by the TDs' background color).\n          rowToRefresh.style.background = getStyle(rowToRefresh, 'backgroundColor').replace(')', ', 0.99)');\n          rowsToRefresh.push(rowToRefresh);\n        }\n      });\n    });\n\n    // Asynchronously revert the TRs' `background` property to force a fresh repaint.\n    this.hot._registerTimeout(() => {\n      rowsToRefresh.forEach(rowElement => {\n        rowElement.style.background = getStyle(rowElement, 'backgroundColor').replace(', 0.99)', ')');\n      });\n    }, 1);\n  }\n\n  /**\n   * Validates a single setting object, represented by a single merged cell information object.\n   *\n   * @private\n   * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  validateSetting(setting) {\n    let valid = true;\n    if (!setting) {\n      return false;\n    }\n    if (MergedCellCoords.containsNegativeValues(setting)) {\n      warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n      valid = false;\n    } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n      warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n      valid = false;\n    } else if (MergedCellCoords.isSingleCell(setting)) {\n      warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n      valid = false;\n    } else if (MergedCellCoords.containsZeroSpan(setting)) {\n      warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n      valid = false;\n    }\n    return valid;\n  }\n\n  /**\n   * Generates the merged cells from the settings provided to the plugin.\n   *\n   * @private\n   * @param {Array|boolean} settings The settings provided to the plugin.\n   */\n  generateFromSettings(settings) {\n    if (Array.isArray(settings)) {\n      const populatedNulls = [];\n      arrayEach(settings, setting => {\n        if (!this.validateSetting(setting)) {\n          return;\n        }\n        const highlight = this.hot._createCellCoords(setting.row, setting.col);\n        const rangeEnd = this.hot._createCellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);\n        const mergeRange = this.hot._createCellRange(highlight, highlight, rangeEnd);\n\n        // Merging without data population.\n        this.mergeRange(mergeRange, true, true);\n        rangeEach(setting.row, setting.row + setting.rowspan - 1, rowIndex => {\n          rangeEach(setting.col, setting.col + setting.colspan - 1, columnIndex => {\n            // Not resetting a cell representing a merge area's value.\n            if ((rowIndex === setting.row && columnIndex === setting.col) === false) {\n              populatedNulls.push([rowIndex, columnIndex, null]);\n            }\n          });\n        });\n      });\n\n      // There are no merged cells. Thus, no data population is needed.\n      if (populatedNulls.length === 0) {\n        return;\n      }\n      this.hot.setDataAtCell(populatedNulls);\n    }\n  }\n\n  /**\n   * Clears the merged cells from the merged cell container.\n   */\n  clearCollections() {\n    this.mergedCellsCollection.clear();\n  }\n\n  /**\n   * Returns `true` if a range is mergeable.\n   *\n   * @private\n   * @param {object} newMergedCellInfo Merged cell information object to test.\n   * @param {boolean} [auto=false] `true` if triggered at initialization.\n   * @returns {boolean}\n   */\n  canMergeRange(newMergedCellInfo) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return auto ? true : this.validateSetting(newMergedCellInfo);\n  }\n\n  /**\n   * Merge or unmerge, based on last selected range.\n   *\n   * @private\n   */\n  toggleMergeOnSelection() {\n    const currentRange = this.hot.getSelectedRangeLast();\n    if (!currentRange) {\n      return;\n    }\n    currentRange.setDirection(this.hot.isRtl() ? 'NE-SW' : 'NW-SE');\n    const {\n      from,\n      to\n    } = currentRange;\n    this.toggleMerge(currentRange);\n    this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n\n  /**\n   * Merges the selection provided as a cell range.\n   *\n   * @param {CellRange} [cellRange] Selection cell range.\n   */\n  mergeSelection() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n    if (!cellRange) {\n      return;\n    }\n    cellRange.setDirection(this.hot.isRtl() ? 'NE-SW' : 'NW-SE');\n    const {\n      from,\n      to\n    } = cellRange;\n    this.unmergeRange(cellRange, true);\n    this.mergeRange(cellRange);\n    this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n\n  /**\n   * Unmerges the selection provided as a cell range.\n   *\n   * @param {CellRange} [cellRange] Selection cell range.\n   */\n  unmergeSelection() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n    if (!cellRange) {\n      return;\n    }\n    const {\n      from,\n      to\n    } = cellRange;\n    this.unmergeRange(cellRange, true);\n    this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n\n  /**\n   * Merges cells in the provided cell range.\n   *\n   * @private\n   * @param {CellRange} cellRange Cell range to merge.\n   * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.\n   * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end,\n   *   but rather return its arguments.\n   * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to\n   *   true. If the the merging process went successful, it returns `true`, otherwise - `false`.\n   * @fires Hooks#beforeMergeCells\n   * @fires Hooks#afterMergeCells\n   */\n  mergeRange(cellRange) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const topStart = cellRange.getTopStartCorner();\n    const bottomEnd = cellRange.getBottomEndCorner();\n    const mergeParent = {\n      row: topStart.row,\n      col: topStart.col,\n      rowspan: bottomEnd.row - topStart.row + 1,\n      colspan: bottomEnd.col - topStart.col + 1\n    };\n    const clearedData = [];\n    let populationInfo = null;\n    if (!this.canMergeRange(mergeParent, auto)) {\n      return false;\n    }\n    this.hot.runHooks('beforeMergeCells', cellRange, auto);\n    rangeEach(0, mergeParent.rowspan - 1, i => {\n      rangeEach(0, mergeParent.colspan - 1, j => {\n        let clearedValue = null;\n        if (!clearedData[i]) {\n          clearedData[i] = [];\n        }\n        if (i === 0 && j === 0) {\n          clearedValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(mergeParent.row), this.hot.toPhysicalColumn(mergeParent.col));\n        } else {\n          this.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n        }\n        clearedData[i][j] = clearedValue;\n      });\n    });\n    this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n    const mergedCellAdded = this.mergedCellsCollection.add(mergeParent);\n    if (mergedCellAdded) {\n      if (preventPopulation) {\n        populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n      } else {\n        this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, undefined, undefined, this.pluginName);\n      }\n      if (!auto) {\n        this.ifChromeForceRepaint();\n      }\n      this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n      return populationInfo;\n    }\n    return true;\n  }\n\n  /**\n   * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\n   *\n   * @private\n   * @param {CellRange} cellRange Selection cell range.\n   * @param {boolean} [auto=false] `true` if called automatically by the plugin.\n   *\n   * @fires Hooks#beforeUnmergeCells\n   * @fires Hooks#afterUnmergeCells\n   */\n  unmergeRange(cellRange) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n    if (!mergedCells) {\n      return;\n    }\n    this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n    arrayEach(mergedCells, currentCollection => {\n      this.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n      rangeEach(0, currentCollection.rowspan - 1, i => {\n        rangeEach(0, currentCollection.colspan - 1, j => {\n          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'copyable');\n        });\n      });\n      this.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n    });\n    this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n    this.hot.render();\n  }\n\n  /**\n   * Merges or unmerges, based on the cell range provided as `cellRange`.\n   *\n   * @private\n   * @param {CellRange} cellRange The cell range to merge or unmerged.\n   */\n  toggleMerge(cellRange) {\n    const mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n    const mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n    if (mergedCellCoversWholeRange) {\n      this.unmergeRange(cellRange);\n    } else {\n      this.mergeSelection(cellRange);\n    }\n  }\n\n  /**\n   * Merges the specified range.\n   *\n   * @param {number} startRow Start row of the merged cell.\n   * @param {number} startColumn Start column of the merged cell.\n   * @param {number} endRow End row of the merged cell.\n   * @param {number} endColumn End column of the merged cell.\n   * @fires Hooks#beforeMergeCells\n   * @fires Hooks#afterMergeCells\n   */\n  merge(startRow, startColumn, endRow, endColumn) {\n    const start = this.hot._createCellCoords(startRow, startColumn);\n    const end = this.hot._createCellCoords(endRow, endColumn);\n    this.mergeRange(this.hot._createCellRange(start, start, end));\n  }\n\n  /**\n   * Unmerges the merged cell in the provided range.\n   *\n   * @param {number} startRow Start row of the merged cell.\n   * @param {number} startColumn Start column of the merged cell.\n   * @param {number} endRow End row of the merged cell.\n   * @param {number} endColumn End column of the merged cell.\n   * @fires Hooks#beforeUnmergeCells\n   * @fires Hooks#afterUnmergeCells\n   */\n  unmerge(startRow, startColumn, endRow, endColumn) {\n    const start = this.hot._createCellCoords(startRow, startColumn);\n    const end = this.hot._createCellCoords(endRow, endColumn);\n    this.unmergeRange(this.hot._createCellRange(start, start, end));\n  }\n  /**\n   * Register shortcuts responsible for toggling a merge.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    gridContext.addShortcut({\n      keys: [['Control', 'm']],\n      callback: () => {\n        const range = this.hot.getSelectedRangeLast();\n        if (range && !range.isSingleHeader()) {\n          this.toggleMerge(range);\n          this.hot.render();\n        }\n      },\n      runOnlyIf: event => !event.altKey,\n      // right ALT in some systems triggers ALT+CTRL\n      group: SHORTCUTS_GROUP\n    });\n  }\n\n  /**\n   * Unregister shortcuts responsible for toggling a merge.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n  /**\n   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The row calculator object.\n   * @param {number} nrOfColumns Number of visual columns.\n   */\n  modifyViewportRowStart(calc, nrOfColumns) {\n    const rowMapper = this.hot.rowIndexMapper;\n    const visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);\n    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);\n      if (isObject(mergeParentForViewportStart)) {\n        const renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.row, 1));\n\n        // Merge start is out of the viewport (i.e. when we scrolled to the bottom and we can see just part of a merge).\n        if (renderableIndexAtMergeStart < calc.startRow) {\n          // We extend viewport when some rows have been merged.\n          calc.startRow = renderableIndexAtMergeStart;\n          // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n          this.modifyViewportRowStart(calc, nrOfColumns); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The row calculator object.\n   * @param {number} nrOfColumns Number of visual columns.\n   */\n  modifyViewportRowEnd(calc, nrOfColumns) {\n    const rowMapper = this.hot.rowIndexMapper;\n    const visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);\n    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);\n      if (isObject(mergeParentForViewportEnd)) {\n        const mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;\n        const renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeEnd, -1));\n\n        // Merge end is out of the viewport.\n        if (renderableIndexAtMergeEnd > calc.endRow) {\n          // We extend the viewport when some rows have been merged.\n          calc.endRow = renderableIndexAtMergeEnd;\n          // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n          this.modifyViewportRowEnd(calc, nrOfColumns); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n  /**\n   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The column calculator object.\n   * @param {number} nrOfRows Number of visual rows.\n   */\n  modifyViewportColumnStart(calc, nrOfRows) {\n    const columnMapper = this.hot.columnIndexMapper;\n    const visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);\n    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);\n      if (isObject(mergeParentForViewportStart)) {\n        const renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.col, 1));\n\n        // Merge start is out of the viewport (i.e. when we scrolled to the right and we can see just part of a merge).\n        if (renderableIndexAtMergeStart < calc.startColumn) {\n          // We extend viewport when some columns have been merged.\n          calc.startColumn = renderableIndexAtMergeStart;\n          // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n          this.modifyViewportColumnStart(calc, nrOfRows); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The column calculator object.\n   * @param {number} nrOfRows Number of visual rows.\n   */\n  modifyViewportColumnEnd(calc, nrOfRows) {\n    const columnMapper = this.hot.columnIndexMapper;\n    const visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);\n    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);\n      if (isObject(mergeParentForViewportEnd)) {\n        const mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;\n        const renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeEnd, -1));\n\n        // Merge end is out of the viewport.\n        if (renderableIndexAtMergeEnd > calc.endColumn) {\n          // We extend the viewport when some columns have been merged.\n          calc.endColumn = renderableIndexAtMergeEnd;\n          // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n          this.modifyViewportColumnEnd(calc, nrOfRows); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   * Translates merged cell coordinates to renderable indexes.\n   *\n   * @private\n   * @param {number} parentRow Visual row index.\n   * @param {number} rowspan Rowspan which describes shift which will be applied to parent row\n   *                         to calculate renderable index which points to the most bottom\n   *                         index position. Pass rowspan as `0` to calculate the most top\n   *                         index position.\n   * @param {number} parentColumn Visual column index.\n   * @param {number} colspan Colspan which describes shift which will be applied to parent column\n   *                         to calculate renderable index which points to the most right\n   *                         index position. Pass colspan as `0` to calculate the most left\n   *                         index position.\n   * @returns {number[]}\n   */\n  translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {\n    const {\n      rowIndexMapper: rowMapper,\n      columnIndexMapper: columnMapper\n    } = this.hot;\n    let firstNonHiddenRow;\n    let firstNonHiddenColumn;\n    if (rowspan === 0) {\n      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow, 1);\n    } else {\n      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow + rowspan - 1, -1);\n    }\n    if (colspan === 0) {\n      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn, 1);\n    } else {\n      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn + colspan - 1, -1);\n    }\n    const renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;\n    const renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;\n    return [renderableRow, renderableColumn];\n  }\n}\nfunction _onAfterInit2() {\n  this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY]);\n  this.hot.render();\n}\nfunction _onAfterIsMultipleSelection2(isMultiple) {\n  if (isMultiple) {\n    const mergedCells = this.mergedCellsCollection.mergedCells;\n    const selectionRange = this.hot.getSelectedRangeLast();\n    for (let group = 0; group < mergedCells.length; group += 1) {\n      if (selectionRange.from.row === mergedCells[group].row && selectionRange.from.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n        return false;\n      }\n    }\n  }\n  return isMultiple;\n}\nfunction _onModifyTransformStart2(delta) {\n  const currentlySelectedRange = this.hot.getSelectedRangeLast();\n  let newDelta = {\n    row: delta.row,\n    col: delta.col\n  };\n  let nextPosition = null;\n  const currentPosition = this.hot._createCellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);\n  const mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\n  if (!_classPrivateFieldGet(this, _lastDesiredCoords)) {\n    _classPrivateFieldSet(this, _lastDesiredCoords, this.hot._createCellCoords(null, null));\n  }\n  if (mergedParent) {\n    // only merge selected\n    const mergeTopLeft = this.hot._createCellCoords(mergedParent.row, mergedParent.col);\n    const mergeBottomRight = this.hot._createCellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);\n    const mergeRange = this.hot._createCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n    if (!mergeRange.includes(_classPrivateFieldGet(this, _lastDesiredCoords))) {\n      _classPrivateFieldSet(this, _lastDesiredCoords, this.hot._createCellCoords(null, null)); // reset outdated version of lastDesiredCoords\n    }\n\n    newDelta.row = _classPrivateFieldGet(this, _lastDesiredCoords).row ? _classPrivateFieldGet(this, _lastDesiredCoords).row - currentPosition.row : newDelta.row;\n    newDelta.col = _classPrivateFieldGet(this, _lastDesiredCoords).col ? _classPrivateFieldGet(this, _lastDesiredCoords).col - currentPosition.col : newDelta.col;\n    if (delta.row > 0) {\n      // moving down\n      newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\n    } else if (delta.row < 0) {\n      // moving up\n      newDelta.row = currentPosition.row - mergedParent.row + delta.row;\n    }\n    if (delta.col > 0) {\n      // moving right\n      newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\n    } else if (delta.col < 0) {\n      // moving left\n      newDelta.col = currentPosition.col - mergedParent.col + delta.col;\n    }\n  }\n  nextPosition = this.hot._createCellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\n  const nextPositionMergedCell = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\n  if (nextPositionMergedCell) {\n    // skipping the invisible cells in the merge range\n    const firstRenderableCoords = this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.row, nextPositionMergedCell.col);\n    _classPrivateFieldSet(this, _lastDesiredCoords, nextPosition);\n    newDelta = {\n      row: firstRenderableCoords.row - currentPosition.row,\n      col: firstRenderableCoords.col - currentPosition.col\n    };\n  }\n  if (newDelta.row !== 0) {\n    delta.row = newDelta.row;\n  }\n  if (newDelta.col !== 0) {\n    delta.col = newDelta.col;\n  }\n}\nfunction _onModifyTransformEnd2(delta) {\n  const currentSelectionRange = this.hot.getSelectedRangeLast();\n  const newDelta = clone(delta);\n  const newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);\n  let tempDelta = clone(newDelta);\n  const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\n  do {\n    tempDelta = clone(newDelta);\n    this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);\n    arrayEach(mergedCellsWithinRange, mergedCell => {\n      this.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);\n    });\n  } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);\n  delta.row = newDelta.row;\n  delta.col = newDelta.col;\n}\nfunction _onModifyGetCellCoords2(row, column) {\n  if (row < 0 || column < 0) {\n    return;\n  }\n  const mergeParent = this.mergedCellsCollection.get(row, column);\n  if (!mergeParent) {\n    return;\n  }\n  const {\n    row: mergeRow,\n    col: mergeColumn,\n    colspan,\n    rowspan\n  } = mergeParent;\n  return [\n  // Most top-left merged cell coords.\n  mergeRow, mergeColumn,\n  // Most bottom-right merged cell coords.\n  mergeRow + rowspan - 1, mergeColumn + colspan - 1];\n}\nfunction _addMergeActionsToContextMenu2(defaultOptions) {\n  defaultOptions.items.push({\n    name: '---------'\n  }, toggleMergeItem(this));\n}\nfunction _onAfterRenderer2(TD, row, col) {\n  const mergedCell = this.mergedCellsCollection.get(row, col);\n  // We shouldn't override data in the collection.\n  const mergedCellCopy = isObject(mergedCell) ? clone(mergedCell) : undefined;\n  if (isObject(mergedCellCopy)) {\n    const {\n      rowIndexMapper: rowMapper,\n      columnIndexMapper: columnMapper\n    } = this.hot;\n    const {\n      row: mergeRow,\n      col: mergeColumn,\n      colspan,\n      rowspan\n    } = mergedCellCopy;\n    const [lastMergedRowIndex, lastMergedColumnIndex] = this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, colspan);\n    const renderedRowIndex = rowMapper.getRenderableFromVisualIndex(row);\n    const renderedColumnIndex = columnMapper.getRenderableFromVisualIndex(col);\n    const maxRowSpan = lastMergedRowIndex - renderedRowIndex + 1; // Number of rendered columns.\n    const maxColSpan = lastMergedColumnIndex - renderedColumnIndex + 1; // Number of rendered columns.\n\n    // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\n    mergedCellCopy.row = rowMapper.getNearestNotHiddenIndex(mergedCellCopy.row, 1);\n    // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\n    mergedCellCopy.col = columnMapper.getNearestNotHiddenIndex(mergedCellCopy.col, 1);\n    // The `rowSpan` property for a `TD` element should be at most equal to number of rendered rows in the merge area.\n    mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan);\n    // The `colSpan` property for a `TD` element should be at most equal to number of rendered columns in the merge area.\n    mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);\n  }\n  applySpanProperties(TD, mergedCellCopy, row, col);\n}\nfunction _onBeforeSetRangeStart2(coords) {\n  // TODO: It is a workaround, but probably this hook may be needed. Every selection on the merge area\n  // could set start point of the selection to the start of the merge area. However, logic inside `expandByRange` need\n  // an initial start point. Click on the merge cell when there are some hidden indexes break the logic in some cases.\n  // Please take a look at #7010 for more information. I'm not sure if selection directions are calculated properly\n  // and what was idea for flipping direction inside `expandByRange` method.\n  if (this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, coords.col)) {\n    const mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);\n    [coords.row, coords.col] = [mergeParent.row, mergeParent.col];\n  }\n}\nfunction _onBeforeSetRangeEnd2(coords) {\n  const selRange = this.hot.getSelectedRangeLast();\n  selRange.highlight = this.hot._createCellCoords(selRange.highlight.row, selRange.highlight.col); // clone in case we will modify its reference\n  selRange.to = coords;\n  let rangeExpanded = false;\n  if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n    return;\n  }\n  do {\n    rangeExpanded = false;\n    for (let i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n      const cellInfo = this.mergedCellsCollection.mergedCells[i];\n      const mergedCellRange = cellInfo.getRange();\n      if (selRange.expandByRange(mergedCellRange)) {\n        coords.row = selRange.to.row;\n        coords.col = selRange.to.col;\n        rangeExpanded = true;\n      }\n    }\n  } while (rangeExpanded);\n}\nfunction _onAfterGetCellMeta2(row, col, cellProperties) {\n  const mergeParent = this.mergedCellsCollection.get(row, col);\n  if (mergeParent) {\n    if (mergeParent.row !== row || mergeParent.col !== col) {\n      cellProperties.copyable = false;\n    } else {\n      cellProperties.rowspan = mergeParent.rowspan;\n      cellProperties.colspan = mergeParent.colspan;\n    }\n  }\n}\nfunction _onAfterViewportRowCalculatorOverride2(calc) {\n  const nrOfColumns = this.hot.countCols();\n  this.modifyViewportRowStart(calc, nrOfColumns);\n  this.modifyViewportRowEnd(calc, nrOfColumns);\n}\nfunction _onAfterViewportColumnCalculatorOverride2(calc) {\n  const nrOfRows = this.hot.countRows();\n  this.modifyViewportColumnStart(calc, nrOfRows);\n  this.modifyViewportColumnEnd(calc, nrOfRows);\n}\nfunction _onModifyAutofillRange2(drag, select) {\n  this.autofillCalculations.correctSelectionAreaSize(select);\n  const dragDirection = this.autofillCalculations.getDirection(select, drag);\n  let dragArea = drag;\n  if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n    dragArea = select;\n    return dragArea;\n  }\n  const mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({\n    from: {\n      row: select[0],\n      col: select[1]\n    },\n    to: {\n      row: select[2],\n      col: select[3]\n    }\n  });\n  if (!mergedCellsWithinSelectionArea) {\n    return dragArea;\n  }\n  dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n  return dragArea;\n}\nfunction _onAfterCreateCol2(column, count) {\n  this.mergedCellsCollection.shiftCollections('right', column, count);\n}\nfunction _onAfterRemoveCol2(column, count) {\n  this.mergedCellsCollection.shiftCollections('left', column, count);\n}\nfunction _onAfterCreateRow2(row, count, source) {\n  if (source === 'auto') {\n    return;\n  }\n  this.mergedCellsCollection.shiftCollections('down', row, count);\n}\nfunction _onAfterRemoveRow2(row, count) {\n  this.mergedCellsCollection.shiftCollections('up', row, count);\n}\nfunction _onAfterChange2(changes, source) {\n  if (source !== 'Autofill.fill') {\n    return;\n  }\n  this.autofillCalculations.recreateAfterDataPopulation(changes);\n}\nfunction _onBeforeDrawAreaBorders2(corners, className) {\n  if (className && className === 'area') {\n    const selectedRange = this.hot.getSelectedRangeLast();\n    const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n    arrayEach(mergedCellsWithinRange, mergedCell => {\n      if (selectedRange.getBottomEndCorner().row === mergedCell.getLastRow() && selectedRange.getBottomEndCorner().col === mergedCell.getLastColumn()) {\n        corners[2] = mergedCell.row;\n        corners[3] = mergedCell.col;\n      }\n    });\n  }\n}\nfunction _onAfterModifyTransformStart2(coords, rowTransformDir, colTransformDir) {\n  if (!this.enabled) {\n    return;\n  }\n  const mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);\n  if (!mergedCellAtCoords) {\n    return;\n  }\n  const goingDown = rowTransformDir > 0;\n  const goingUp = rowTransformDir < 0;\n  const goingLeft = colTransformDir < 0;\n  const goingRight = colTransformDir > 0;\n  const mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\n  const mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\n  const mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;\n  const mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;\n  if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {\n    coords.row = mergedCellAtCoords.row;\n    coords.col = mergedCellAtCoords.col;\n  }\n}\nfunction _onAfterDrawSelection2(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n  // Nothing's selected (hook might be triggered by the custom borders)\n  if (!cornersOfSelection) {\n    return;\n  }\n  return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n}\nfunction _onBeforeRemoveCellClassNames2() {\n  return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","privateMap","value","set","privateCollection","has","TypeError","_defineProperty","key","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateFieldSet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorSet","_classPrivateFieldGet","_classApplyDescriptorGet","action","get","_classPrivateMethodGet","fn","BasePlugin","Hooks","MergedCellsCollection","MergedCellCoords","AutofillCalculations","SelectionCalculations","toggleMergeItem","arrayEach","isObject","clone","warn","rangeEach","applySpanProperties","getStyle","isChrome","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","SHORTCUTS_GROUP","_lastDesiredCoords","WeakMap","_onAfterInit","WeakSet","_onAfterIsMultipleSelection","_onModifyTransformStart","_onModifyTransformEnd","_onModifyGetCellCoords","_addMergeActionsToContextMenu","_onAfterRenderer","_onBeforeSetRangeStart","_onBeforeSetRangeEnd","_onAfterGetCellMeta","_onAfterViewportRowCalculatorOverride","_onAfterViewportColumnCalculatorOverride","_onModifyAutofillRange","_onAfterCreateCol","_onAfterRemoveCol","_onAfterCreateRow","_onAfterRemoveRow","_onAfterChange","_onBeforeDrawAreaBorders","_onAfterModifyTransformStart","_onAfterDrawSelection","_onBeforeRemoveCellClassNames","MergeCells","constructor","arguments","isEnabled","hot","getSettings","enablePlugin","_this","enabled","mergedCellsCollection","autofillCalculations","selectionCalculations","addHook","_len","length","args","Array","_key","_onAfterInit2","_len2","_key2","_onModifyTransformStart2","_len3","_key3","_onAfterModifyTransformStart2","_len4","_key4","_onModifyTransformEnd2","_len5","_key5","_onModifyGetCellCoords2","_len6","_key6","_onBeforeSetRangeStart2","_len7","_key7","_len8","_key8","_onBeforeSetRangeEnd2","_len9","_key9","_onAfterIsMultipleSelection2","_len10","_key10","_onAfterRenderer2","_len11","_key11","_addMergeActionsToContextMenu2","_len12","_key12","_onAfterGetCellMeta2","_len13","_key13","_onAfterViewportRowCalculatorOverride2","_len14","_key14","_onAfterViewportColumnCalculatorOverride2","_len15","_key15","_onModifyAutofillRange2","_len16","_key16","_onAfterCreateCol2","_len17","_key17","_onAfterRemoveCol2","_len18","_key18","_onAfterCreateRow2","_len19","_key19","_onAfterRemoveRow2","_len20","_key20","_onAfterChange2","_len21","_key21","_onBeforeDrawAreaBorders2","_len22","_key22","_onAfterDrawSelection2","_len23","_key23","_onBeforeRemoveCellClassNames2","source","registerShortcuts","disablePlugin","clearCollections","unregisterShortcuts","render","updatePlugin","settings","generateFromSettings","ifChromeForceRepaint","rowsToRefresh","rowIndexesToRefresh","mergedCells","forEach","mergedCell","row","rowspan","push","Set","rowIndex","renderableRowIndex","rowIndexMapper","getRenderableFromVisualIndex","view","_wt","wtOverlays","getOverlays","map","overlay","name","wtTable","wtTableRef","rowToRefresh","getRow","style","background","replace","_registerTimeout","rowElement","validateSetting","setting","valid","containsNegativeValues","NEGATIVE_VALUES_WARNING","isOutOfBounds","countRows","countCols","IS_OUT_OF_BOUNDS_WARNING","isSingleCell","IS_SINGLE_CELL","containsZeroSpan","ZERO_SPAN_WARNING","isArray","populatedNulls","highlight","_createCellCoords","col","rangeEnd","colspan","mergeRange","_createCellRange","columnIndex","setDataAtCell","clear","canMergeRange","newMergedCellInfo","auto","undefined","toggleMergeOnSelection","currentRange","getSelectedRangeLast","setDirection","isRtl","from","to","toggleMerge","selectCell","mergeSelection","cellRange","unmergeRange","unmergeSelection","preventPopulation","topStart","getTopStartCorner","bottomEnd","getBottomEndCorner","mergeParent","clearedData","populationInfo","runHooks","j","clearedValue","getSourceDataAtCell","toPhysicalRow","toPhysicalColumn","setCellMeta","mergedCellAdded","populateFromArray","pluginName","getWithinRange","currentCollection","remove","removeCellMeta","mergedCellCoversWholeRange","merge","startRow","startColumn","endRow","endColumn","start","end","unmerge","shortcutManager","getShortcutManager","gridContext","getContext","addShortcut","keys","callback","range","isSingleHeader","runOnlyIf","event","altKey","group","removeShortcutsByGroup","modifyViewportRowStart","calc","nrOfColumns","rowMapper","visualStartRow","getVisualFromRenderableIndex","visualColumnIndex","mergeParentForViewportStart","renderableIndexAtMergeStart","getNearestNotHiddenIndex","modifyViewportRowEnd","visualEndRow","mergeParentForViewportEnd","mergeEnd","renderableIndexAtMergeEnd","modifyViewportColumnStart","nrOfRows","columnMapper","columnIndexMapper","visualStartCol","visualRowIndex","modifyViewportColumnEnd","visualEndCol","translateMergedCellToRenderable","parentRow","parentColumn","firstNonHiddenRow","firstNonHiddenColumn","renderableRow","renderableColumn","isMultiple","selectionRange","delta","currentlySelectedRange","newDelta","nextPosition","currentPosition","mergedParent","mergeTopLeft","mergeBottomRight","includes","nextPositionMergedCell","firstRenderableCoords","getFirstRenderableCoords","currentSelectionRange","newSelectionRange","getUpdatedSelectionRange","tempDelta","mergedCellsWithinRange","snapDelta","column","mergeRow","mergeColumn","defaultOptions","items","TD","mergedCellCopy","lastMergedRowIndex","lastMergedColumnIndex","renderedRowIndex","renderedColumnIndex","maxRowSpan","maxColSpan","Math","min","coords","isFirstRenderableMergedCell","selRange","rangeExpanded","selection","isSelectedByColumnHeader","isSelectedByRowHeader","cellInfo","mergedCellRange","getRange","expandByRange","cellProperties","copyable","drag","select","correctSelectionAreaSize","dragDirection","getDirection","dragArea","dragAreaOverlapsCollections","mergedCellsWithinSelectionArea","snapDragArea","count","shiftCollections","changes","recreateAfterDataPopulation","corners","className","selectedRange","getLastRow","getLastColumn","rowTransformDir","colTransformDir","mergedCellAtCoords","goingDown","goingUp","goingLeft","goingRight","mergedCellOnBottomEdge","mergedCellOnTopEdge","mergedCellOnRightEdge","mergedCellOnLeftEdge","currentRow","currentColumn","cornersOfSelection","layerLevel","getSelectedMergedCellClassName","getSelectedMergedCellClassNameToRemove"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/mergeCells/mergeCells.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport MergedCellsCollection from \"./cellsCollection.mjs\";\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport AutofillCalculations from \"./calculations/autofill.mjs\";\nimport SelectionCalculations from \"./calculations/selection.mjs\";\nimport toggleMergeItem from \"./contextMenuItem/toggleMerge.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { isObject, clone } from \"../../helpers/object.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nimport { getStyle } from \"../../helpers/dom/element.mjs\";\nimport { isChrome } from \"../../helpers/browser.mjs\";\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nexport const PLUGIN_KEY = 'mergeCells';\nexport const PLUGIN_PRIORITY = 150;\nconst SHORTCUTS_GROUP = PLUGIN_KEY;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin MergeCells\n * @class MergeCells\n *\n * @description\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *  data: getData(),\n *  mergeCells: [\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *  ],\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   // enable plugin\n *   mergeCells={[\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *   ]}\n * />\n * ```\n * :::\n */\nvar _lastDesiredCoords = /*#__PURE__*/new WeakMap();\nvar _onAfterInit = /*#__PURE__*/new WeakSet();\nvar _onAfterIsMultipleSelection = /*#__PURE__*/new WeakSet();\nvar _onModifyTransformStart = /*#__PURE__*/new WeakSet();\nvar _onModifyTransformEnd = /*#__PURE__*/new WeakSet();\nvar _onModifyGetCellCoords = /*#__PURE__*/new WeakSet();\nvar _addMergeActionsToContextMenu = /*#__PURE__*/new WeakSet();\nvar _onAfterRenderer = /*#__PURE__*/new WeakSet();\nvar _onBeforeSetRangeStart = /*#__PURE__*/new WeakSet();\nvar _onBeforeSetRangeEnd = /*#__PURE__*/new WeakSet();\nvar _onAfterGetCellMeta = /*#__PURE__*/new WeakSet();\nvar _onAfterViewportRowCalculatorOverride = /*#__PURE__*/new WeakSet();\nvar _onAfterViewportColumnCalculatorOverride = /*#__PURE__*/new WeakSet();\nvar _onModifyAutofillRange = /*#__PURE__*/new WeakSet();\nvar _onAfterCreateCol = /*#__PURE__*/new WeakSet();\nvar _onAfterRemoveCol = /*#__PURE__*/new WeakSet();\nvar _onAfterCreateRow = /*#__PURE__*/new WeakSet();\nvar _onAfterRemoveRow = /*#__PURE__*/new WeakSet();\nvar _onAfterChange = /*#__PURE__*/new WeakSet();\nvar _onBeforeDrawAreaBorders = /*#__PURE__*/new WeakSet();\nvar _onAfterModifyTransformStart = /*#__PURE__*/new WeakSet();\nvar _onAfterDrawSelection = /*#__PURE__*/new WeakSet();\nvar _onBeforeRemoveCellClassNames = /*#__PURE__*/new WeakSet();\nexport class MergeCells extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\n     *\n     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from\n     *   all the cells in the table.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeRemoveCellClassNames);\n    /**\n     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\n     *\n     * @param {number} currentRow Visual row index of the currently processed cell.\n     * @param {number} currentColumn Visual column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow,\n     *   endColumn]`.\n     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently\n     *   processed cell.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterDrawSelection);\n    /**\n     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of\n     * the table with the <kbd>**Enter**</kbd>/<kbd>**Shift**</kbd>+<kbd>**Enter**</kbd>/<kbd>**Tab**</kbd>/<kbd>**Shift**</kbd>+<kbd>**Tab**</kbd> keys.\n     *\n     * @param {CellCoords} coords Coordinates of the to-be-selected cell.\n     * @param {number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value =\n     *   down).\n     * @param {number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value =\n     *   down).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterModifyTransformStart);\n    /**\n     * `beforeDrawAreaBorders` hook callback.\n     *\n     * @param {Array} corners Visual coordinates of the area corners.\n     * @param {string} className Class name for the area.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeDrawAreaBorders);\n    /**\n     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\n     *\n     * @param {Array} changes The changes array.\n     * @param {string} source Determines the source of the change.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterChange);\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @param {number} row Row index.\n     * @param {number} count Number of removed rows.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterRemoveRow);\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @param {number} row Row index.\n     * @param {number} count Number of created rows.\n     * @param {string} source Source of change.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCreateRow);\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @param {number} column Column index.\n     * @param {number} count Number of removed columns.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterRemoveCol);\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @param {number} column Column index.\n     * @param {number} count Number of created columns.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCreateCol);\n    /**\n     * The `modifyAutofillRange` hook callback.\n     *\n     * @param {Array} drag The drag area coordinates.\n     * @param {Array} select The selection information.\n     * @returns {Array} The new drag area.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyAutofillRange);\n    /**\n     * `afterViewportColumnCalculatorOverride` hook callback.\n     *\n     * @param {object} calc The column calculator object.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterViewportColumnCalculatorOverride);\n    /**\n     * `afterViewportRowCalculatorOverride` hook callback.\n     *\n     * @param {object} calc The row calculator object.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterViewportRowCalculatorOverride);\n    /**\n     * The `afterGetCellMeta` hook callback.\n     *\n     * @param {number} row Row index.\n     * @param {number} col Column index.\n     * @param {object} cellProperties The cell properties object.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterGetCellMeta);\n    /**\n     * `beforeSetRangeEnd` hook callback.\n     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the\n     * merged cell.\n     *\n     * Note: Please keep in mind that callback may modify both start and end range coordinates by the reference.\n     *\n     * @param {object} coords Cell coords.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeSetRangeEnd);\n    /**\n     * `beforeSetRangeStart` and `beforeSetRangeStartOnly` hook callback.\n     * A selection within merge area should be rewritten to the start of merge area.\n     *\n     * @param {object} coords Cell coords.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeSetRangeStart);\n    /**\n     * `afterRenderer` hook callback.\n     *\n     * @param {HTMLElement} TD The cell to be modified.\n     * @param {number} row Row index.\n     * @param {number} col Visual column index.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterRenderer);\n    /**\n     * `afterContextMenuDefaultOptions` hook callback.\n     *\n     * @param {object} defaultOptions The default context menu options.\n     */\n    _classPrivateMethodInitSpec(this, _addMergeActionsToContextMenu);\n    /**\n     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Visual column index.\n     * @returns {Array|undefined} Visual coordinates of the merge.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyGetCellCoords);\n    /**\n     * `modifyTransformEnd` hook callback. Needed to handle \"jumping over\" merged merged cells, while selecting.\n     *\n     * @param {object} delta The transformation delta.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyTransformEnd);\n    /**\n     * `modifyTransformStart` hook callback.\n     *\n     * @param {object} delta The transformation delta.\n     */\n    _classPrivateMethodInitSpec(this, _onModifyTransformStart);\n    /**\n     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection`\n     * hook callback.\n     *\n     * @param {boolean} isMultiple Determines whether the current selection contains multiple cells.\n     * @returns {boolean}\n     */\n    _classPrivateMethodInitSpec(this, _onAfterIsMultipleSelection);\n    /**\n     * `afterInit` hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterInit);\n    /**\n     * A container for all the merged cells.\n     *\n     * @private\n     * @type {MergedCellsCollection}\n     */\n    _defineProperty(this, \"mergedCellsCollection\", null);\n    /**\n     * Instance of the class responsible for all the autofill-related calculations.\n     *\n     * @private\n     * @type {AutofillCalculations}\n     */\n    _defineProperty(this, \"autofillCalculations\", null);\n    /**\n     * Instance of the class responsible for the selection-related calculations.\n     *\n     * @private\n     * @type {SelectionCalculations}\n     */\n    _defineProperty(this, \"selectionCalculations\", null);\n    /**\n     * @type {CellCoords}\n     */\n    _classPrivateFieldInitSpec(this, _lastDesiredCoords, {\n      writable: true,\n      value: null\n    });\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link MergeCells#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.mergedCellsCollection = new MergedCellsCollection(this);\n    this.autofillCalculations = new AutofillCalculations(this);\n    this.selectionCalculations = new SelectionCalculations(this);\n    this.addHook('afterInit', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onAfterInit, _onAfterInit2).call(_this, ...args);\n    });\n    this.addHook('modifyTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _classPrivateMethodGet(_this, _onModifyTransformStart, _onModifyTransformStart2).call(_this, ...args);\n    });\n    this.addHook('afterModifyTransformStart', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _classPrivateMethodGet(_this, _onAfterModifyTransformStart, _onAfterModifyTransformStart2).call(_this, ...args);\n    });\n    this.addHook('modifyTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _classPrivateMethodGet(_this, _onModifyTransformEnd, _onModifyTransformEnd2).call(_this, ...args);\n    });\n    this.addHook('modifyGetCellCoords', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _classPrivateMethodGet(_this, _onModifyGetCellCoords, _onModifyGetCellCoords2).call(_this, ...args);\n    });\n    this.addHook('beforeSetRangeStart', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeSetRangeStart, _onBeforeSetRangeStart2).call(_this, ...args);\n    });\n    this.addHook('beforeSetRangeStartOnly', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeSetRangeStart, _onBeforeSetRangeStart2).call(_this, ...args);\n    });\n    this.addHook('beforeSetRangeEnd', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeSetRangeEnd, _onBeforeSetRangeEnd2).call(_this, ...args);\n    });\n    this.addHook('afterIsMultipleSelection', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _classPrivateMethodGet(_this, _onAfterIsMultipleSelection, _onAfterIsMultipleSelection2).call(_this, ...args);\n    });\n    this.addHook('afterRenderer', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _classPrivateMethodGet(_this, _onAfterRenderer, _onAfterRenderer2).call(_this, ...args);\n    });\n    this.addHook('afterContextMenuDefaultOptions', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _classPrivateMethodGet(_this, _addMergeActionsToContextMenu, _addMergeActionsToContextMenu2).call(_this, ...args);\n    });\n    this.addHook('afterGetCellMeta', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _classPrivateMethodGet(_this, _onAfterGetCellMeta, _onAfterGetCellMeta2).call(_this, ...args);\n    });\n    this.addHook('afterViewportRowCalculatorOverride', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _classPrivateMethodGet(_this, _onAfterViewportRowCalculatorOverride, _onAfterViewportRowCalculatorOverride2).call(_this, ...args);\n    });\n    this.addHook('afterViewportColumnCalculatorOverride', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _classPrivateMethodGet(_this, _onAfterViewportColumnCalculatorOverride, _onAfterViewportColumnCalculatorOverride2).call(_this, ...args);\n    });\n    this.addHook('modifyAutofillRange', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _classPrivateMethodGet(_this, _onModifyAutofillRange, _onModifyAutofillRange2).call(_this, ...args);\n    });\n    this.addHook('afterCreateCol', function () {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return _classPrivateMethodGet(_this, _onAfterCreateCol, _onAfterCreateCol2).call(_this, ...args);\n    });\n    this.addHook('afterRemoveCol', function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return _classPrivateMethodGet(_this, _onAfterRemoveCol, _onAfterRemoveCol2).call(_this, ...args);\n    });\n    this.addHook('afterCreateRow', function () {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return _classPrivateMethodGet(_this, _onAfterCreateRow, _onAfterCreateRow2).call(_this, ...args);\n    });\n    this.addHook('afterRemoveRow', function () {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return _classPrivateMethodGet(_this, _onAfterRemoveRow, _onAfterRemoveRow2).call(_this, ...args);\n    });\n    this.addHook('afterChange', function () {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return _classPrivateMethodGet(_this, _onAfterChange, _onAfterChange2).call(_this, ...args);\n    });\n    this.addHook('beforeDrawBorders', function () {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeDrawAreaBorders, _onBeforeDrawAreaBorders2).call(_this, ...args);\n    });\n    this.addHook('afterDrawSelection', function () {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return _classPrivateMethodGet(_this, _onAfterDrawSelection, _onAfterDrawSelection2).call(_this, ...args);\n    });\n    this.addHook('beforeRemoveCellClassNames', function () {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeRemoveCellClassNames, _onBeforeRemoveCellClassNames2).call(_this, ...args);\n    });\n    this.addHook('beforeUndoStackChange', (action, source) => {\n      if (source === 'MergeCells') {\n        return false;\n      }\n    });\n    this.registerShortcuts();\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearCollections();\n    this.unregisterShortcuts();\n    this.hot.render();\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the\n   * following configuration options:\n   *  - [`mergeCells`](@/api/options.md#mergecells)\n   */\n  updatePlugin() {\n    const settings = this.hot.getSettings()[PLUGIN_KEY];\n    this.disablePlugin();\n    this.enablePlugin();\n    this.generateFromSettings(settings);\n    super.updatePlugin();\n  }\n\n  /**\n   * If the browser is recognized as Chrome, force an additional repaint to prevent showing the effects of a Chrome bug.\n   *\n   * Issue described in https://github.com/handsontable/dev-handsontable/issues/521.\n   *\n   * @private\n   */\n  ifChromeForceRepaint() {\n    if (!isChrome()) {\n      return;\n    }\n    const rowsToRefresh = [];\n    let rowIndexesToRefresh = [];\n    this.mergedCellsCollection.mergedCells.forEach(mergedCell => {\n      const {\n        row,\n        rowspan\n      } = mergedCell;\n      for (let r = row + 1; r < row + rowspan; r++) {\n        rowIndexesToRefresh.push(r);\n      }\n    });\n\n    // Remove duplicates\n    rowIndexesToRefresh = [...new Set(rowIndexesToRefresh)];\n    rowIndexesToRefresh.forEach(rowIndex => {\n      const renderableRowIndex = this.hot.rowIndexMapper.getRenderableFromVisualIndex(rowIndex);\n      this.hot.view._wt.wtOverlays.getOverlays(true).map(overlay => (overlay === null || overlay === void 0 ? void 0 : overlay.name) === 'master' ? overlay : overlay.clone.wtTable).forEach(wtTableRef => {\n        const rowToRefresh = wtTableRef.getRow(renderableRowIndex);\n        if (rowToRefresh) {\n          // Modify the TR's `background` property to later modify it asynchronously.\n          // The background color is getting modified only with the alpha, so the change should not be visible (and is\n          // covered by the TDs' background color).\n          rowToRefresh.style.background = getStyle(rowToRefresh, 'backgroundColor').replace(')', ', 0.99)');\n          rowsToRefresh.push(rowToRefresh);\n        }\n      });\n    });\n\n    // Asynchronously revert the TRs' `background` property to force a fresh repaint.\n    this.hot._registerTimeout(() => {\n      rowsToRefresh.forEach(rowElement => {\n        rowElement.style.background = getStyle(rowElement, 'backgroundColor').replace(', 0.99)', ')');\n      });\n    }, 1);\n  }\n\n  /**\n   * Validates a single setting object, represented by a single merged cell information object.\n   *\n   * @private\n   * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n   * @returns {boolean}\n   */\n  validateSetting(setting) {\n    let valid = true;\n    if (!setting) {\n      return false;\n    }\n    if (MergedCellCoords.containsNegativeValues(setting)) {\n      warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n      valid = false;\n    } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n      warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n      valid = false;\n    } else if (MergedCellCoords.isSingleCell(setting)) {\n      warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n      valid = false;\n    } else if (MergedCellCoords.containsZeroSpan(setting)) {\n      warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n      valid = false;\n    }\n    return valid;\n  }\n\n  /**\n   * Generates the merged cells from the settings provided to the plugin.\n   *\n   * @private\n   * @param {Array|boolean} settings The settings provided to the plugin.\n   */\n  generateFromSettings(settings) {\n    if (Array.isArray(settings)) {\n      const populatedNulls = [];\n      arrayEach(settings, setting => {\n        if (!this.validateSetting(setting)) {\n          return;\n        }\n        const highlight = this.hot._createCellCoords(setting.row, setting.col);\n        const rangeEnd = this.hot._createCellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);\n        const mergeRange = this.hot._createCellRange(highlight, highlight, rangeEnd);\n\n        // Merging without data population.\n        this.mergeRange(mergeRange, true, true);\n        rangeEach(setting.row, setting.row + setting.rowspan - 1, rowIndex => {\n          rangeEach(setting.col, setting.col + setting.colspan - 1, columnIndex => {\n            // Not resetting a cell representing a merge area's value.\n            if ((rowIndex === setting.row && columnIndex === setting.col) === false) {\n              populatedNulls.push([rowIndex, columnIndex, null]);\n            }\n          });\n        });\n      });\n\n      // There are no merged cells. Thus, no data population is needed.\n      if (populatedNulls.length === 0) {\n        return;\n      }\n      this.hot.setDataAtCell(populatedNulls);\n    }\n  }\n\n  /**\n   * Clears the merged cells from the merged cell container.\n   */\n  clearCollections() {\n    this.mergedCellsCollection.clear();\n  }\n\n  /**\n   * Returns `true` if a range is mergeable.\n   *\n   * @private\n   * @param {object} newMergedCellInfo Merged cell information object to test.\n   * @param {boolean} [auto=false] `true` if triggered at initialization.\n   * @returns {boolean}\n   */\n  canMergeRange(newMergedCellInfo) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return auto ? true : this.validateSetting(newMergedCellInfo);\n  }\n\n  /**\n   * Merge or unmerge, based on last selected range.\n   *\n   * @private\n   */\n  toggleMergeOnSelection() {\n    const currentRange = this.hot.getSelectedRangeLast();\n    if (!currentRange) {\n      return;\n    }\n    currentRange.setDirection(this.hot.isRtl() ? 'NE-SW' : 'NW-SE');\n    const {\n      from,\n      to\n    } = currentRange;\n    this.toggleMerge(currentRange);\n    this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n\n  /**\n   * Merges the selection provided as a cell range.\n   *\n   * @param {CellRange} [cellRange] Selection cell range.\n   */\n  mergeSelection() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n    if (!cellRange) {\n      return;\n    }\n    cellRange.setDirection(this.hot.isRtl() ? 'NE-SW' : 'NW-SE');\n    const {\n      from,\n      to\n    } = cellRange;\n    this.unmergeRange(cellRange, true);\n    this.mergeRange(cellRange);\n    this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n\n  /**\n   * Unmerges the selection provided as a cell range.\n   *\n   * @param {CellRange} [cellRange] Selection cell range.\n   */\n  unmergeSelection() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n    if (!cellRange) {\n      return;\n    }\n    const {\n      from,\n      to\n    } = cellRange;\n    this.unmergeRange(cellRange, true);\n    this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n  }\n\n  /**\n   * Merges cells in the provided cell range.\n   *\n   * @private\n   * @param {CellRange} cellRange Cell range to merge.\n   * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.\n   * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end,\n   *   but rather return its arguments.\n   * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to\n   *   true. If the the merging process went successful, it returns `true`, otherwise - `false`.\n   * @fires Hooks#beforeMergeCells\n   * @fires Hooks#afterMergeCells\n   */\n  mergeRange(cellRange) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const topStart = cellRange.getTopStartCorner();\n    const bottomEnd = cellRange.getBottomEndCorner();\n    const mergeParent = {\n      row: topStart.row,\n      col: topStart.col,\n      rowspan: bottomEnd.row - topStart.row + 1,\n      colspan: bottomEnd.col - topStart.col + 1\n    };\n    const clearedData = [];\n    let populationInfo = null;\n    if (!this.canMergeRange(mergeParent, auto)) {\n      return false;\n    }\n    this.hot.runHooks('beforeMergeCells', cellRange, auto);\n    rangeEach(0, mergeParent.rowspan - 1, i => {\n      rangeEach(0, mergeParent.colspan - 1, j => {\n        let clearedValue = null;\n        if (!clearedData[i]) {\n          clearedData[i] = [];\n        }\n        if (i === 0 && j === 0) {\n          clearedValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(mergeParent.row), this.hot.toPhysicalColumn(mergeParent.col));\n        } else {\n          this.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n        }\n        clearedData[i][j] = clearedValue;\n      });\n    });\n    this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n    const mergedCellAdded = this.mergedCellsCollection.add(mergeParent);\n    if (mergedCellAdded) {\n      if (preventPopulation) {\n        populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n      } else {\n        this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, undefined, undefined, this.pluginName);\n      }\n      if (!auto) {\n        this.ifChromeForceRepaint();\n      }\n      this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n      return populationInfo;\n    }\n    return true;\n  }\n\n  /**\n   * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\n   *\n   * @private\n   * @param {CellRange} cellRange Selection cell range.\n   * @param {boolean} [auto=false] `true` if called automatically by the plugin.\n   *\n   * @fires Hooks#beforeUnmergeCells\n   * @fires Hooks#afterUnmergeCells\n   */\n  unmergeRange(cellRange) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n    if (!mergedCells) {\n      return;\n    }\n    this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n    arrayEach(mergedCells, currentCollection => {\n      this.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n      rangeEach(0, currentCollection.rowspan - 1, i => {\n        rangeEach(0, currentCollection.colspan - 1, j => {\n          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'copyable');\n        });\n      });\n      this.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n    });\n    this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n    this.hot.render();\n  }\n\n  /**\n   * Merges or unmerges, based on the cell range provided as `cellRange`.\n   *\n   * @private\n   * @param {CellRange} cellRange The cell range to merge or unmerged.\n   */\n  toggleMerge(cellRange) {\n    const mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n    const mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n    if (mergedCellCoversWholeRange) {\n      this.unmergeRange(cellRange);\n    } else {\n      this.mergeSelection(cellRange);\n    }\n  }\n\n  /**\n   * Merges the specified range.\n   *\n   * @param {number} startRow Start row of the merged cell.\n   * @param {number} startColumn Start column of the merged cell.\n   * @param {number} endRow End row of the merged cell.\n   * @param {number} endColumn End column of the merged cell.\n   * @fires Hooks#beforeMergeCells\n   * @fires Hooks#afterMergeCells\n   */\n  merge(startRow, startColumn, endRow, endColumn) {\n    const start = this.hot._createCellCoords(startRow, startColumn);\n    const end = this.hot._createCellCoords(endRow, endColumn);\n    this.mergeRange(this.hot._createCellRange(start, start, end));\n  }\n\n  /**\n   * Unmerges the merged cell in the provided range.\n   *\n   * @param {number} startRow Start row of the merged cell.\n   * @param {number} startColumn Start column of the merged cell.\n   * @param {number} endRow End row of the merged cell.\n   * @param {number} endColumn End column of the merged cell.\n   * @fires Hooks#beforeUnmergeCells\n   * @fires Hooks#afterUnmergeCells\n   */\n  unmerge(startRow, startColumn, endRow, endColumn) {\n    const start = this.hot._createCellCoords(startRow, startColumn);\n    const end = this.hot._createCellCoords(endRow, endColumn);\n    this.unmergeRange(this.hot._createCellRange(start, start, end));\n  }\n  /**\n   * Register shortcuts responsible for toggling a merge.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    gridContext.addShortcut({\n      keys: [['Control', 'm']],\n      callback: () => {\n        const range = this.hot.getSelectedRangeLast();\n        if (range && !range.isSingleHeader()) {\n          this.toggleMerge(range);\n          this.hot.render();\n        }\n      },\n      runOnlyIf: event => !event.altKey,\n      // right ALT in some systems triggers ALT+CTRL\n      group: SHORTCUTS_GROUP\n    });\n  }\n\n  /**\n   * Unregister shortcuts responsible for toggling a merge.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n  /**\n   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The row calculator object.\n   * @param {number} nrOfColumns Number of visual columns.\n   */\n  modifyViewportRowStart(calc, nrOfColumns) {\n    const rowMapper = this.hot.rowIndexMapper;\n    const visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);\n    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);\n      if (isObject(mergeParentForViewportStart)) {\n        const renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.row, 1));\n\n        // Merge start is out of the viewport (i.e. when we scrolled to the bottom and we can see just part of a merge).\n        if (renderableIndexAtMergeStart < calc.startRow) {\n          // We extend viewport when some rows have been merged.\n          calc.startRow = renderableIndexAtMergeStart;\n          // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n          this.modifyViewportRowStart(calc, nrOfColumns); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The row calculator object.\n   * @param {number} nrOfColumns Number of visual columns.\n   */\n  modifyViewportRowEnd(calc, nrOfColumns) {\n    const rowMapper = this.hot.rowIndexMapper;\n    const visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);\n    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);\n      if (isObject(mergeParentForViewportEnd)) {\n        const mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;\n        const renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeEnd, -1));\n\n        // Merge end is out of the viewport.\n        if (renderableIndexAtMergeEnd > calc.endRow) {\n          // We extend the viewport when some rows have been merged.\n          calc.endRow = renderableIndexAtMergeEnd;\n          // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n          this.modifyViewportRowEnd(calc, nrOfColumns); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n  /**\n   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The column calculator object.\n   * @param {number} nrOfRows Number of visual rows.\n   */\n  modifyViewportColumnStart(calc, nrOfRows) {\n    const columnMapper = this.hot.columnIndexMapper;\n    const visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);\n    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);\n      if (isObject(mergeParentForViewportStart)) {\n        const renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.col, 1));\n\n        // Merge start is out of the viewport (i.e. when we scrolled to the right and we can see just part of a merge).\n        if (renderableIndexAtMergeStart < calc.startColumn) {\n          // We extend viewport when some columns have been merged.\n          calc.startColumn = renderableIndexAtMergeStart;\n          // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n          this.modifyViewportColumnStart(calc, nrOfRows); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n   *\n   * @private\n   * @param {object} calc The column calculator object.\n   * @param {number} nrOfRows Number of visual rows.\n   */\n  modifyViewportColumnEnd(calc, nrOfRows) {\n    const columnMapper = this.hot.columnIndexMapper;\n    const visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);\n    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);\n      if (isObject(mergeParentForViewportEnd)) {\n        const mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;\n        const renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeEnd, -1));\n\n        // Merge end is out of the viewport.\n        if (renderableIndexAtMergeEnd > calc.endColumn) {\n          // We extend the viewport when some columns have been merged.\n          calc.endColumn = renderableIndexAtMergeEnd;\n          // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n          this.modifyViewportColumnEnd(calc, nrOfRows); // recursively search upwards\n\n          return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n        }\n      }\n    }\n  }\n\n  /**\n   * Translates merged cell coordinates to renderable indexes.\n   *\n   * @private\n   * @param {number} parentRow Visual row index.\n   * @param {number} rowspan Rowspan which describes shift which will be applied to parent row\n   *                         to calculate renderable index which points to the most bottom\n   *                         index position. Pass rowspan as `0` to calculate the most top\n   *                         index position.\n   * @param {number} parentColumn Visual column index.\n   * @param {number} colspan Colspan which describes shift which will be applied to parent column\n   *                         to calculate renderable index which points to the most right\n   *                         index position. Pass colspan as `0` to calculate the most left\n   *                         index position.\n   * @returns {number[]}\n   */\n  translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {\n    const {\n      rowIndexMapper: rowMapper,\n      columnIndexMapper: columnMapper\n    } = this.hot;\n    let firstNonHiddenRow;\n    let firstNonHiddenColumn;\n    if (rowspan === 0) {\n      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow, 1);\n    } else {\n      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow + rowspan - 1, -1);\n    }\n    if (colspan === 0) {\n      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn, 1);\n    } else {\n      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn + colspan - 1, -1);\n    }\n    const renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;\n    const renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;\n    return [renderableRow, renderableColumn];\n  }\n}\nfunction _onAfterInit2() {\n  this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY]);\n  this.hot.render();\n}\nfunction _onAfterIsMultipleSelection2(isMultiple) {\n  if (isMultiple) {\n    const mergedCells = this.mergedCellsCollection.mergedCells;\n    const selectionRange = this.hot.getSelectedRangeLast();\n    for (let group = 0; group < mergedCells.length; group += 1) {\n      if (selectionRange.from.row === mergedCells[group].row && selectionRange.from.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n        return false;\n      }\n    }\n  }\n  return isMultiple;\n}\nfunction _onModifyTransformStart2(delta) {\n  const currentlySelectedRange = this.hot.getSelectedRangeLast();\n  let newDelta = {\n    row: delta.row,\n    col: delta.col\n  };\n  let nextPosition = null;\n  const currentPosition = this.hot._createCellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);\n  const mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\n  if (!_classPrivateFieldGet(this, _lastDesiredCoords)) {\n    _classPrivateFieldSet(this, _lastDesiredCoords, this.hot._createCellCoords(null, null));\n  }\n  if (mergedParent) {\n    // only merge selected\n    const mergeTopLeft = this.hot._createCellCoords(mergedParent.row, mergedParent.col);\n    const mergeBottomRight = this.hot._createCellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);\n    const mergeRange = this.hot._createCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n    if (!mergeRange.includes(_classPrivateFieldGet(this, _lastDesiredCoords))) {\n      _classPrivateFieldSet(this, _lastDesiredCoords, this.hot._createCellCoords(null, null)); // reset outdated version of lastDesiredCoords\n    }\n    newDelta.row = _classPrivateFieldGet(this, _lastDesiredCoords).row ? _classPrivateFieldGet(this, _lastDesiredCoords).row - currentPosition.row : newDelta.row;\n    newDelta.col = _classPrivateFieldGet(this, _lastDesiredCoords).col ? _classPrivateFieldGet(this, _lastDesiredCoords).col - currentPosition.col : newDelta.col;\n    if (delta.row > 0) {\n      // moving down\n      newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\n    } else if (delta.row < 0) {\n      // moving up\n      newDelta.row = currentPosition.row - mergedParent.row + delta.row;\n    }\n    if (delta.col > 0) {\n      // moving right\n      newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\n    } else if (delta.col < 0) {\n      // moving left\n      newDelta.col = currentPosition.col - mergedParent.col + delta.col;\n    }\n  }\n  nextPosition = this.hot._createCellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\n  const nextPositionMergedCell = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\n  if (nextPositionMergedCell) {\n    // skipping the invisible cells in the merge range\n    const firstRenderableCoords = this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.row, nextPositionMergedCell.col);\n    _classPrivateFieldSet(this, _lastDesiredCoords, nextPosition);\n    newDelta = {\n      row: firstRenderableCoords.row - currentPosition.row,\n      col: firstRenderableCoords.col - currentPosition.col\n    };\n  }\n  if (newDelta.row !== 0) {\n    delta.row = newDelta.row;\n  }\n  if (newDelta.col !== 0) {\n    delta.col = newDelta.col;\n  }\n}\nfunction _onModifyTransformEnd2(delta) {\n  const currentSelectionRange = this.hot.getSelectedRangeLast();\n  const newDelta = clone(delta);\n  const newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);\n  let tempDelta = clone(newDelta);\n  const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\n  do {\n    tempDelta = clone(newDelta);\n    this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);\n    arrayEach(mergedCellsWithinRange, mergedCell => {\n      this.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);\n    });\n  } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);\n  delta.row = newDelta.row;\n  delta.col = newDelta.col;\n}\nfunction _onModifyGetCellCoords2(row, column) {\n  if (row < 0 || column < 0) {\n    return;\n  }\n  const mergeParent = this.mergedCellsCollection.get(row, column);\n  if (!mergeParent) {\n    return;\n  }\n  const {\n    row: mergeRow,\n    col: mergeColumn,\n    colspan,\n    rowspan\n  } = mergeParent;\n  return [\n  // Most top-left merged cell coords.\n  mergeRow, mergeColumn,\n  // Most bottom-right merged cell coords.\n  mergeRow + rowspan - 1, mergeColumn + colspan - 1];\n}\nfunction _addMergeActionsToContextMenu2(defaultOptions) {\n  defaultOptions.items.push({\n    name: '---------'\n  }, toggleMergeItem(this));\n}\nfunction _onAfterRenderer2(TD, row, col) {\n  const mergedCell = this.mergedCellsCollection.get(row, col);\n  // We shouldn't override data in the collection.\n  const mergedCellCopy = isObject(mergedCell) ? clone(mergedCell) : undefined;\n  if (isObject(mergedCellCopy)) {\n    const {\n      rowIndexMapper: rowMapper,\n      columnIndexMapper: columnMapper\n    } = this.hot;\n    const {\n      row: mergeRow,\n      col: mergeColumn,\n      colspan,\n      rowspan\n    } = mergedCellCopy;\n    const [lastMergedRowIndex, lastMergedColumnIndex] = this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, colspan);\n    const renderedRowIndex = rowMapper.getRenderableFromVisualIndex(row);\n    const renderedColumnIndex = columnMapper.getRenderableFromVisualIndex(col);\n    const maxRowSpan = lastMergedRowIndex - renderedRowIndex + 1; // Number of rendered columns.\n    const maxColSpan = lastMergedColumnIndex - renderedColumnIndex + 1; // Number of rendered columns.\n\n    // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\n    mergedCellCopy.row = rowMapper.getNearestNotHiddenIndex(mergedCellCopy.row, 1);\n    // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\n    mergedCellCopy.col = columnMapper.getNearestNotHiddenIndex(mergedCellCopy.col, 1);\n    // The `rowSpan` property for a `TD` element should be at most equal to number of rendered rows in the merge area.\n    mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan);\n    // The `colSpan` property for a `TD` element should be at most equal to number of rendered columns in the merge area.\n    mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);\n  }\n  applySpanProperties(TD, mergedCellCopy, row, col);\n}\nfunction _onBeforeSetRangeStart2(coords) {\n  // TODO: It is a workaround, but probably this hook may be needed. Every selection on the merge area\n  // could set start point of the selection to the start of the merge area. However, logic inside `expandByRange` need\n  // an initial start point. Click on the merge cell when there are some hidden indexes break the logic in some cases.\n  // Please take a look at #7010 for more information. I'm not sure if selection directions are calculated properly\n  // and what was idea for flipping direction inside `expandByRange` method.\n  if (this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, coords.col)) {\n    const mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);\n    [coords.row, coords.col] = [mergeParent.row, mergeParent.col];\n  }\n}\nfunction _onBeforeSetRangeEnd2(coords) {\n  const selRange = this.hot.getSelectedRangeLast();\n  selRange.highlight = this.hot._createCellCoords(selRange.highlight.row, selRange.highlight.col); // clone in case we will modify its reference\n  selRange.to = coords;\n  let rangeExpanded = false;\n  if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n    return;\n  }\n  do {\n    rangeExpanded = false;\n    for (let i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n      const cellInfo = this.mergedCellsCollection.mergedCells[i];\n      const mergedCellRange = cellInfo.getRange();\n      if (selRange.expandByRange(mergedCellRange)) {\n        coords.row = selRange.to.row;\n        coords.col = selRange.to.col;\n        rangeExpanded = true;\n      }\n    }\n  } while (rangeExpanded);\n}\nfunction _onAfterGetCellMeta2(row, col, cellProperties) {\n  const mergeParent = this.mergedCellsCollection.get(row, col);\n  if (mergeParent) {\n    if (mergeParent.row !== row || mergeParent.col !== col) {\n      cellProperties.copyable = false;\n    } else {\n      cellProperties.rowspan = mergeParent.rowspan;\n      cellProperties.colspan = mergeParent.colspan;\n    }\n  }\n}\nfunction _onAfterViewportRowCalculatorOverride2(calc) {\n  const nrOfColumns = this.hot.countCols();\n  this.modifyViewportRowStart(calc, nrOfColumns);\n  this.modifyViewportRowEnd(calc, nrOfColumns);\n}\nfunction _onAfterViewportColumnCalculatorOverride2(calc) {\n  const nrOfRows = this.hot.countRows();\n  this.modifyViewportColumnStart(calc, nrOfRows);\n  this.modifyViewportColumnEnd(calc, nrOfRows);\n}\nfunction _onModifyAutofillRange2(drag, select) {\n  this.autofillCalculations.correctSelectionAreaSize(select);\n  const dragDirection = this.autofillCalculations.getDirection(select, drag);\n  let dragArea = drag;\n  if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n    dragArea = select;\n    return dragArea;\n  }\n  const mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({\n    from: {\n      row: select[0],\n      col: select[1]\n    },\n    to: {\n      row: select[2],\n      col: select[3]\n    }\n  });\n  if (!mergedCellsWithinSelectionArea) {\n    return dragArea;\n  }\n  dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n  return dragArea;\n}\nfunction _onAfterCreateCol2(column, count) {\n  this.mergedCellsCollection.shiftCollections('right', column, count);\n}\nfunction _onAfterRemoveCol2(column, count) {\n  this.mergedCellsCollection.shiftCollections('left', column, count);\n}\nfunction _onAfterCreateRow2(row, count, source) {\n  if (source === 'auto') {\n    return;\n  }\n  this.mergedCellsCollection.shiftCollections('down', row, count);\n}\nfunction _onAfterRemoveRow2(row, count) {\n  this.mergedCellsCollection.shiftCollections('up', row, count);\n}\nfunction _onAfterChange2(changes, source) {\n  if (source !== 'Autofill.fill') {\n    return;\n  }\n  this.autofillCalculations.recreateAfterDataPopulation(changes);\n}\nfunction _onBeforeDrawAreaBorders2(corners, className) {\n  if (className && className === 'area') {\n    const selectedRange = this.hot.getSelectedRangeLast();\n    const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n    arrayEach(mergedCellsWithinRange, mergedCell => {\n      if (selectedRange.getBottomEndCorner().row === mergedCell.getLastRow() && selectedRange.getBottomEndCorner().col === mergedCell.getLastColumn()) {\n        corners[2] = mergedCell.row;\n        corners[3] = mergedCell.col;\n      }\n    });\n  }\n}\nfunction _onAfterModifyTransformStart2(coords, rowTransformDir, colTransformDir) {\n  if (!this.enabled) {\n    return;\n  }\n  const mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);\n  if (!mergedCellAtCoords) {\n    return;\n  }\n  const goingDown = rowTransformDir > 0;\n  const goingUp = rowTransformDir < 0;\n  const goingLeft = colTransformDir < 0;\n  const goingRight = colTransformDir > 0;\n  const mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\n  const mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\n  const mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;\n  const mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;\n  if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {\n    coords.row = mergedCellAtCoords.row;\n    coords.col = mergedCellAtCoords.col;\n  }\n}\nfunction _onAfterDrawSelection2(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n  // Nothing's selected (hook might be triggered by the custom borders)\n  if (!cornersOfSelection) {\n    return;\n  }\n  return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n}\nfunction _onBeforeRemoveCellClassNames2() {\n  return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}