{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE } from \"./constants.mjs\";\n/**\n * @typedef {object} ViewportRowsCalculatorOptions\n * @property {number} viewportHeight Height of the viewport.\n * @property {number} scrollOffset Current vertical scroll position of the viewport.\n * @property {number} totalRows Total number of rows.\n * @property {Function} rowHeightFn Function that returns the height of the row at a given index (in px).\n * @property {Function} overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin).\n * @property {string} calculationType String which describes types of calculation which will be performed.\n * @property {number} horizontalScrollbarHeight The scrollbar height.\n */\n/**\n * Calculates indexes of rows to render OR rows that are visible.\n * To redo the calculation, you need to create a new calculator.\n *\n * @class ViewportRowsCalculator\n */\nvar _options = /*#__PURE__*/new WeakMap();\nexport class ViewportRowsCalculator {\n  /**\n   * Default row height.\n   *\n   * @type {number}\n   */\n  static get DEFAULT_HEIGHT() {\n    return 23;\n  }\n\n  /**\n   * Number of rendered/visible rows.\n   *\n   * @type {number}\n   */\n\n  /**\n   * @param {ViewportRowsCalculatorOptions} options Object with all options specified for row viewport calculation.\n   */\n  constructor(options) {\n    _defineProperty(this, \"count\", 0);\n    /**\n     * Index of the first rendered/visible row (can be overwritten using overrideFn).\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startRow\", null);\n    /**\n     * Index of the last rendered/visible row (can be overwritten using overrideFn).\n     *\n     * @type {null}\n     */\n    _defineProperty(this, \"endRow\", null);\n    /**\n     * Position of the first rendered/visible row (in px).\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startPosition\", null);\n    /**\n     * Determines if the viewport is visible in the trimming container.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isVisibleInTrimmingContainer\", false);\n    /**\n     * The calculator options.\n     *\n     * @type {ViewportRowsCalculatorOptions}\n     */\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _options, options);\n    this.calculate();\n  }\n\n  /**\n   * Calculates viewport.\n   */\n  calculate() {\n    const {\n      calculationType,\n      overrideFn,\n      rowHeightFn,\n      scrollOffset,\n      totalRows,\n      viewportHeight\n    } = _classPrivateFieldGet(this, _options);\n    const zeroBasedScrollOffset = Math.max(_classPrivateFieldGet(this, _options).scrollOffset, 0);\n    const horizontalScrollbarHeight = _classPrivateFieldGet(this, _options).horizontalScrollbarHeight || 0;\n    let sum = 0;\n    let needReverse = true;\n    const startPositions = [];\n    let rowHeight;\n    let firstVisibleRowHeight = 0;\n    let lastVisibleRowHeight = 0;\n\n    // Calculate the number (start and end index) of rows needed\n    for (let i = 0; i < totalRows; i++) {\n      rowHeight = rowHeightFn(i);\n      if (isNaN(rowHeight)) {\n        rowHeight = ViewportRowsCalculator.DEFAULT_HEIGHT;\n      }\n      if (sum <= zeroBasedScrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {\n        this.startRow = i;\n        firstVisibleRowHeight = rowHeight;\n      }\n      if (sum >= zeroBasedScrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? rowHeight : 0) <= zeroBasedScrollOffset + viewportHeight - horizontalScrollbarHeight) {\n        // eslint-disable-line max-len\n        if (this.startRow === null) {\n          this.startRow = i;\n          firstVisibleRowHeight = rowHeight;\n        }\n        this.endRow = i;\n      }\n      startPositions.push(sum);\n      sum += rowHeight;\n      lastVisibleRowHeight = rowHeight;\n      if (calculationType !== FULLY_VISIBLE_TYPE) {\n        this.endRow = i;\n      }\n      if (sum >= zeroBasedScrollOffset + viewportHeight - horizontalScrollbarHeight) {\n        needReverse = false;\n        break;\n      }\n    }\n    const mostBottomScrollOffset = scrollOffset + viewportHeight - horizontalScrollbarHeight;\n    const topRowOffset = calculationType === FULLY_VISIBLE_TYPE ? firstVisibleRowHeight : 0;\n    const bottomRowOffset = calculationType === FULLY_VISIBLE_TYPE ? 0 : lastVisibleRowHeight;\n    if (mostBottomScrollOffset < topRowOffset || scrollOffset > startPositions.at(-1) + bottomRowOffset) {\n      this.isVisibleInTrimmingContainer = false;\n    } else {\n      this.isVisibleInTrimmingContainer = true;\n    }\n\n    // If the estimation has reached the last row and there is still some space available in the viewport,\n    // we need to render in reverse in order to fill the whole viewport with rows\n    if (this.endRow === totalRows - 1 && needReverse) {\n      this.startRow = this.endRow;\n      while (this.startRow > 0) {\n        // rowHeight is the height of the last row\n        const viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];\n        if (viewportSum <= viewportHeight - horizontalScrollbarHeight || calculationType !== FULLY_VISIBLE_TYPE) {\n          this.startRow -= 1;\n        }\n        if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {\n          break;\n        }\n      }\n    }\n    if (calculationType === RENDER_TYPE && this.startRow !== null && overrideFn) {\n      overrideFn(this);\n    }\n    this.startPosition = startPositions[this.startRow];\n    if (this.startPosition === undefined) {\n      this.startPosition = null;\n    }\n\n    // If totalRows exceeded its total rows size set endRow to the latest item\n    if (totalRows < this.endRow) {\n      this.endRow = totalRows - 1;\n    }\n    if (this.startRow !== null) {\n      this.count = this.endRow - this.startRow + 1;\n    }\n  }\n}","map":{"version":3,"names":["_classPrivateFieldInitSpec","obj","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","TypeError","_defineProperty","key","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","_classPrivateFieldSet","_classApplyDescriptorSet","action","RENDER_TYPE","FULLY_VISIBLE_TYPE","_options","WeakMap","ViewportRowsCalculator","DEFAULT_HEIGHT","constructor","options","calculate","calculationType","overrideFn","rowHeightFn","scrollOffset","totalRows","viewportHeight","zeroBasedScrollOffset","Math","max","horizontalScrollbarHeight","sum","needReverse","startPositions","rowHeight","firstVisibleRowHeight","lastVisibleRowHeight","isNaN","startRow","endRow","push","mostBottomScrollOffset","topRowOffset","bottomRowOffset","at","isVisibleInTrimmingContainer","viewportSum","startPosition","undefined","count"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/3rdparty/walkontable/src/calculator/viewportRows.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE } from \"./constants.mjs\";\n/**\n * @typedef {object} ViewportRowsCalculatorOptions\n * @property {number} viewportHeight Height of the viewport.\n * @property {number} scrollOffset Current vertical scroll position of the viewport.\n * @property {number} totalRows Total number of rows.\n * @property {Function} rowHeightFn Function that returns the height of the row at a given index (in px).\n * @property {Function} overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin).\n * @property {string} calculationType String which describes types of calculation which will be performed.\n * @property {number} horizontalScrollbarHeight The scrollbar height.\n */\n/**\n * Calculates indexes of rows to render OR rows that are visible.\n * To redo the calculation, you need to create a new calculator.\n *\n * @class ViewportRowsCalculator\n */\nvar _options = /*#__PURE__*/new WeakMap();\nexport class ViewportRowsCalculator {\n  /**\n   * Default row height.\n   *\n   * @type {number}\n   */\n  static get DEFAULT_HEIGHT() {\n    return 23;\n  }\n\n  /**\n   * Number of rendered/visible rows.\n   *\n   * @type {number}\n   */\n\n  /**\n   * @param {ViewportRowsCalculatorOptions} options Object with all options specified for row viewport calculation.\n   */\n  constructor(options) {\n    _defineProperty(this, \"count\", 0);\n    /**\n     * Index of the first rendered/visible row (can be overwritten using overrideFn).\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startRow\", null);\n    /**\n     * Index of the last rendered/visible row (can be overwritten using overrideFn).\n     *\n     * @type {null}\n     */\n    _defineProperty(this, \"endRow\", null);\n    /**\n     * Position of the first rendered/visible row (in px).\n     *\n     * @type {number|null}\n     */\n    _defineProperty(this, \"startPosition\", null);\n    /**\n     * Determines if the viewport is visible in the trimming container.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isVisibleInTrimmingContainer\", false);\n    /**\n     * The calculator options.\n     *\n     * @type {ViewportRowsCalculatorOptions}\n     */\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _options, options);\n    this.calculate();\n  }\n\n  /**\n   * Calculates viewport.\n   */\n  calculate() {\n    const {\n      calculationType,\n      overrideFn,\n      rowHeightFn,\n      scrollOffset,\n      totalRows,\n      viewportHeight\n    } = _classPrivateFieldGet(this, _options);\n    const zeroBasedScrollOffset = Math.max(_classPrivateFieldGet(this, _options).scrollOffset, 0);\n    const horizontalScrollbarHeight = _classPrivateFieldGet(this, _options).horizontalScrollbarHeight || 0;\n    let sum = 0;\n    let needReverse = true;\n    const startPositions = [];\n    let rowHeight;\n    let firstVisibleRowHeight = 0;\n    let lastVisibleRowHeight = 0;\n\n    // Calculate the number (start and end index) of rows needed\n    for (let i = 0; i < totalRows; i++) {\n      rowHeight = rowHeightFn(i);\n      if (isNaN(rowHeight)) {\n        rowHeight = ViewportRowsCalculator.DEFAULT_HEIGHT;\n      }\n      if (sum <= zeroBasedScrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {\n        this.startRow = i;\n        firstVisibleRowHeight = rowHeight;\n      }\n      if (sum >= zeroBasedScrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? rowHeight : 0) <= zeroBasedScrollOffset + viewportHeight - horizontalScrollbarHeight) {\n        // eslint-disable-line max-len\n        if (this.startRow === null) {\n          this.startRow = i;\n          firstVisibleRowHeight = rowHeight;\n        }\n        this.endRow = i;\n      }\n      startPositions.push(sum);\n      sum += rowHeight;\n      lastVisibleRowHeight = rowHeight;\n      if (calculationType !== FULLY_VISIBLE_TYPE) {\n        this.endRow = i;\n      }\n      if (sum >= zeroBasedScrollOffset + viewportHeight - horizontalScrollbarHeight) {\n        needReverse = false;\n        break;\n      }\n    }\n    const mostBottomScrollOffset = scrollOffset + viewportHeight - horizontalScrollbarHeight;\n    const topRowOffset = calculationType === FULLY_VISIBLE_TYPE ? firstVisibleRowHeight : 0;\n    const bottomRowOffset = calculationType === FULLY_VISIBLE_TYPE ? 0 : lastVisibleRowHeight;\n    if (mostBottomScrollOffset < topRowOffset || scrollOffset > startPositions.at(-1) + bottomRowOffset) {\n      this.isVisibleInTrimmingContainer = false;\n    } else {\n      this.isVisibleInTrimmingContainer = true;\n    }\n\n    // If the estimation has reached the last row and there is still some space available in the viewport,\n    // we need to render in reverse in order to fill the whole viewport with rows\n    if (this.endRow === totalRows - 1 && needReverse) {\n      this.startRow = this.endRow;\n      while (this.startRow > 0) {\n        // rowHeight is the height of the last row\n        const viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];\n        if (viewportSum <= viewportHeight - horizontalScrollbarHeight || calculationType !== FULLY_VISIBLE_TYPE) {\n          this.startRow -= 1;\n        }\n        if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {\n          break;\n        }\n      }\n    }\n    if (calculationType === RENDER_TYPE && this.startRow !== null && overrideFn) {\n      overrideFn(this);\n    }\n    this.startPosition = startPositions[this.startRow];\n    if (this.startPosition === undefined) {\n      this.startPosition = null;\n    }\n\n    // If totalRows exceeded its total rows size set endRow to the latest item\n    if (totalRows < this.endRow) {\n      this.endRow = totalRows - 1;\n    }\n    if (this.startRow !== null) {\n      this.count = this.endRow - this.startRow + 1;\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}