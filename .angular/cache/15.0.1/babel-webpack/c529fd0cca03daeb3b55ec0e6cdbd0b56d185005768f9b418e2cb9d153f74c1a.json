{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nlet _Symbol$iterator;\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n_Symbol$iterator = Symbol.iterator;\n/**\n * The SelectionRange class is a simple CellRanges collection designed for easy manipulation of the multiple\n * consecutive and non-consecutive selections.\n *\n * @class SelectionRange\n * @util\n */\nclass SelectionRange {\n  constructor(createCellRange) {\n    /**\n     * List of all CellRanges added to the class instance.\n     *\n     * @type {CellRange[]}\n     */\n    _defineProperty(this, \"ranges\", []);\n    /**\n     * @type {function(CellCoords): CellRange}\n     */\n    _defineProperty(this, \"createCellRange\", void 0);\n    this.createCellRange = createCellRange;\n  }\n\n  /**\n   * Check if selected range is empty.\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * Set coordinates to the class instance. It clears all previously added coordinates and push `coords`\n   * to the collection.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {SelectionRange}\n   */\n  set(coords) {\n    this.clear();\n    this.ranges.push(this.createCellRange(coords));\n    return this;\n  }\n\n  /**\n   * Add coordinates to the class instance. The new coordinates are added to the end of the range collection.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {SelectionRange}\n   */\n  add(coords) {\n    this.ranges.push(this.createCellRange(coords));\n    return this;\n  }\n\n  /**\n   * Removes from the stack the last added coordinates.\n   *\n   * @returns {SelectionRange}\n   */\n  pop() {\n    this.ranges.pop();\n    return this;\n  }\n\n  /**\n   * Get last added coordinates from ranges, it returns a CellRange instance.\n   *\n   * @returns {CellRange|undefined}\n   */\n  current() {\n    return this.peekByIndex(this.size() - 1);\n  }\n\n  /**\n   * Get previously added coordinates from ranges, it returns a CellRange instance.\n   *\n   * @returns {CellRange|undefined}\n   */\n  previous() {\n    return this.peekByIndex(this.size() - 2);\n  }\n\n  /**\n   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n   * the coords object is within selection range.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {boolean}\n   */\n  includes(coords) {\n    return this.ranges.some(cellRange => cellRange.includes(coords));\n  }\n\n  /**\n   * Clear collection.\n   *\n   * @returns {SelectionRange}\n   */\n  clear() {\n    this.ranges.length = 0;\n    return this;\n  }\n\n  /**\n   * Get count of added all coordinates added to the selection.\n   *\n   * @returns {number}\n   */\n  size() {\n    return this.ranges.length;\n  }\n\n  /**\n   * Peek the coordinates based on the index where that coordinate resides in the collection.\n   *\n   * @param {number} [index=0] An index where the coordinate will be retrieved from. The index '0' gets the\n   * latest range.\n   * @returns {CellRange|undefined}\n   */\n  peekByIndex() {\n    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let cellRange;\n    if (index >= 0 && index < this.size()) {\n      cellRange = this.ranges[index];\n    }\n    return cellRange;\n  }\n  [_Symbol$iterator]() {\n    return this.ranges[Symbol.iterator]();\n  }\n}\nexport default SelectionRange;","map":{"version":3,"names":["_Symbol$iterator","_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","iterator","SelectionRange","constructor","createCellRange","isEmpty","size","set","coords","clear","ranges","push","add","pop","current","peekByIndex","previous","includes","some","cellRange","length","index","arguments","undefined"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/selection/range.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nlet _Symbol$iterator;\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n_Symbol$iterator = Symbol.iterator;\n/**\n * The SelectionRange class is a simple CellRanges collection designed for easy manipulation of the multiple\n * consecutive and non-consecutive selections.\n *\n * @class SelectionRange\n * @util\n */\nclass SelectionRange {\n  constructor(createCellRange) {\n    /**\n     * List of all CellRanges added to the class instance.\n     *\n     * @type {CellRange[]}\n     */\n    _defineProperty(this, \"ranges\", []);\n    /**\n     * @type {function(CellCoords): CellRange}\n     */\n    _defineProperty(this, \"createCellRange\", void 0);\n    this.createCellRange = createCellRange;\n  }\n\n  /**\n   * Check if selected range is empty.\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * Set coordinates to the class instance. It clears all previously added coordinates and push `coords`\n   * to the collection.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {SelectionRange}\n   */\n  set(coords) {\n    this.clear();\n    this.ranges.push(this.createCellRange(coords));\n    return this;\n  }\n\n  /**\n   * Add coordinates to the class instance. The new coordinates are added to the end of the range collection.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {SelectionRange}\n   */\n  add(coords) {\n    this.ranges.push(this.createCellRange(coords));\n    return this;\n  }\n\n  /**\n   * Removes from the stack the last added coordinates.\n   *\n   * @returns {SelectionRange}\n   */\n  pop() {\n    this.ranges.pop();\n    return this;\n  }\n\n  /**\n   * Get last added coordinates from ranges, it returns a CellRange instance.\n   *\n   * @returns {CellRange|undefined}\n   */\n  current() {\n    return this.peekByIndex(this.size() - 1);\n  }\n\n  /**\n   * Get previously added coordinates from ranges, it returns a CellRange instance.\n   *\n   * @returns {CellRange|undefined}\n   */\n  previous() {\n    return this.peekByIndex(this.size() - 2);\n  }\n\n  /**\n   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n   * the coords object is within selection range.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {boolean}\n   */\n  includes(coords) {\n    return this.ranges.some(cellRange => cellRange.includes(coords));\n  }\n\n  /**\n   * Clear collection.\n   *\n   * @returns {SelectionRange}\n   */\n  clear() {\n    this.ranges.length = 0;\n    return this;\n  }\n\n  /**\n   * Get count of added all coordinates added to the selection.\n   *\n   * @returns {number}\n   */\n  size() {\n    return this.ranges.length;\n  }\n\n  /**\n   * Peek the coordinates based on the index where that coordinate resides in the collection.\n   *\n   * @param {number} [index=0] An index where the coordinate will be retrieved from. The index '0' gets the\n   * latest range.\n   * @returns {CellRange|undefined}\n   */\n  peekByIndex() {\n    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let cellRange;\n    if (index >= 0 && index < this.size()) {\n      cellRange = this.ranges[index];\n    }\n    return cellRange;\n  }\n  [_Symbol$iterator]() {\n    return this.ranges[Symbol.iterator]();\n  }\n}\nexport default SelectionRange;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}