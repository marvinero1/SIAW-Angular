{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\n/**\n * Class responsible for making data operations.\n *\n * @private\n */\nclass DataManager {\n  constructor(nestedRowsPlugin, hotInstance) {\n    /**\n     * Main Handsontable instance reference.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to the source data object.\n     *\n     * @type {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n    _defineProperty(this, \"data\", null);\n    /**\n     * Reference to the NestedRows plugin.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Map of row object parents.\n     *\n     * @type {WeakMap}\n     */\n    _defineProperty(this, \"parentReference\", new WeakMap());\n    /**\n     * Nested structure cache.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cache\", {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    });\n    this.hot = hotInstance;\n    this.plugin = nestedRowsPlugin;\n  }\n\n  /**\n   * Set the data for the manager.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n  setData(data) {\n    this.data = data;\n  }\n\n  /**\n   * Get the data cached in the manager.\n   *\n   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n   */\n  getData() {\n    return this.data;\n  }\n\n  /**\n   * Load the \"raw\" source data, without NestedRows' modifications.\n   *\n   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n   */\n  getRawSourceData() {\n    let rawSourceData = null;\n    this.plugin.disableCoreAPIModifiers();\n    rawSourceData = this.hot.getSourceData();\n    this.plugin.enableCoreAPIModifiers();\n    return rawSourceData;\n  }\n\n  /**\n   * Update the Data Manager with new data and refresh cache.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n  updateWithData(data) {\n    this.setData(data);\n    this.rewriteCache();\n  }\n\n  /**\n   * Rewrite the nested structure cache.\n   *\n   * @private\n   */\n  rewriteCache() {\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    };\n    rangeEach(0, this.data.length - 1, i => {\n      this.cacheNode(this.data[i], 0, null);\n    });\n  }\n\n  /**\n   * Cache a data node.\n   *\n   * @private\n   * @param {object} node Node to cache.\n   * @param {number} level Level of the node.\n   * @param {object} parent Parent of the node.\n   */\n  cacheNode(node, level, parent) {\n    if (!this.cache.levels[level]) {\n      this.cache.levels[level] = [];\n      this.cache.levelCount += 1;\n    }\n    this.cache.levels[level].push(node);\n    this.cache.rows.push(node);\n    this.cache.nodeInfo.set(node, {\n      parent,\n      row: this.cache.rows.length - 1,\n      level\n    });\n    if (this.hasChildren(node)) {\n      arrayEach(node.__children, elem => {\n        this.cacheNode(elem, level + 1, node);\n      });\n    }\n  }\n\n  /**\n   * Get the date for the provided visual row number.\n   *\n   * @param {number} row Row index.\n   * @returns {object}\n   */\n  getDataObject(row) {\n    return row === null || row === undefined ? null : this.cache.rows[row];\n  }\n\n  /**\n   * Read the row tree in search for a specific row index or row object.\n   *\n   * @private\n   * @param {object} parent The initial parent object.\n   * @param {number} readCount Number of read nodes.\n   * @param {number} neededIndex The row index we search for.\n   * @param {object} neededObject The row object we search for.\n   * @returns {number|object}\n   */\n  readTreeNodes(parent, readCount, neededIndex, neededObject) {\n    let rootLevel = false;\n    let readNodesCount = readCount;\n    if (isNaN(readNodesCount) && readNodesCount.end) {\n      return readNodesCount;\n    }\n    let parentObj = parent;\n    if (!parentObj) {\n      parentObj = {\n        __children: this.data\n      };\n      rootLevel = true;\n      readNodesCount -= 1;\n    }\n    if (neededIndex !== null && neededIndex !== undefined && readNodesCount === neededIndex) {\n      return {\n        result: parentObj,\n        end: true\n      };\n    }\n    if (neededObject !== null && neededObject !== undefined && parentObj === neededObject) {\n      return {\n        result: readNodesCount,\n        end: true\n      };\n    }\n    readNodesCount += 1;\n    if (parentObj.__children) {\n      arrayEach(parentObj.__children, val => {\n        this.parentReference.set(val, rootLevel ? null : parentObj);\n        readNodesCount = this.readTreeNodes(val, readNodesCount, neededIndex, neededObject);\n        if (isNaN(readNodesCount) && readNodesCount.end) {\n          return false;\n        }\n      });\n    }\n    return readNodesCount;\n  }\n\n  /**\n   * Mock a parent node.\n   *\n   * @private\n   * @returns {*}\n   */\n  mockParent() {\n    const fakeParent = this.mockNode();\n    fakeParent.__children = this.data;\n    return fakeParent;\n  }\n\n  /**\n   * Mock a data node.\n   *\n   * @private\n   * @returns {{}}\n   */\n  mockNode() {\n    const fakeNode = {};\n    objectEach(this.data[0], (val, key) => {\n      fakeNode[key] = null;\n    });\n    return fakeNode;\n  }\n\n  /**\n   * Get the row index for the provided row object.\n   *\n   * @param {object} rowObj The row object.\n   * @returns {number} Row index.\n   */\n  getRowIndex(rowObj) {\n    return rowObj === null || rowObj === undefined ? null : this.cache.nodeInfo.get(rowObj).row;\n  }\n\n  /**\n   * Get the index of the provided row index/row object within its parent.\n   *\n   * @param {number|object} row Row index / row object.\n   * @returns {number}\n   */\n  getRowIndexWithinParent(row) {\n    let rowObj = null;\n    if (isNaN(row)) {\n      rowObj = row;\n    } else {\n      rowObj = this.getDataObject(row);\n    }\n    const parent = this.getRowParent(row);\n    if (parent === null || parent === undefined) {\n      return this.data.indexOf(rowObj);\n    }\n    return parent.__children.indexOf(rowObj);\n  }\n\n  /**\n   * Count all rows (including all parents and children).\n   *\n   * @returns {number}\n   */\n  countAllRows() {\n    const rootNodeMock = {\n      __children: this.data\n    };\n    return this.countChildren(rootNodeMock);\n  }\n\n  /**\n   * Count children of the provided parent.\n   *\n   * @param {object|number} parent Parent node.\n   * @returns {number} Children count.\n   */\n  countChildren(parent) {\n    let rowCount = 0;\n    let parentNode = parent;\n    if (!isNaN(parentNode)) {\n      parentNode = this.getDataObject(parentNode);\n    }\n    if (!parentNode || !parentNode.__children) {\n      return 0;\n    }\n    arrayEach(parentNode.__children, elem => {\n      rowCount += 1;\n      if (elem.__children) {\n        rowCount += this.countChildren(elem);\n      }\n    });\n    return rowCount;\n  }\n\n  /**\n   * Get the parent of the row at the provided index.\n   *\n   * @param {number|object} row Physical row index.\n   * @returns {object}\n   */\n  getRowParent(row) {\n    let rowObject;\n    if (isNaN(row)) {\n      rowObject = row;\n    } else {\n      rowObject = this.getDataObject(row);\n    }\n    return this.getRowObjectParent(rowObject);\n  }\n\n  /**\n   * Get the parent of the provided row object.\n   *\n   * @private\n   * @param {object} rowObject The row object (tree node).\n   * @returns {object|null}\n   */\n  getRowObjectParent(rowObject) {\n    if (!rowObject || typeof rowObject !== 'object') {\n      return null;\n    }\n    return this.cache.nodeInfo.get(rowObject).parent;\n  }\n\n  /**\n   * Get the nesting level for the row with the provided row index.\n   *\n   * @param {number} row Row index.\n   * @returns {number|null} Row level or null, when row doesn't exist.\n   */\n  getRowLevel(row) {\n    let rowObject = null;\n    if (isNaN(row)) {\n      rowObject = row;\n    } else {\n      rowObject = this.getDataObject(row);\n    }\n    return rowObject ? this.getRowObjectLevel(rowObject) : null;\n  }\n\n  /**\n   * Get the nesting level for the row with the provided row index.\n   *\n   * @private\n   * @param {object} rowObject Row object.\n   * @returns {number} Row level.\n   */\n  getRowObjectLevel(rowObject) {\n    return rowObject === null || rowObject === undefined ? null : this.cache.nodeInfo.get(rowObject).level;\n  }\n\n  /**\n   * Check if the provided row/row element has children.\n   *\n   * @param {number|object} row Row number or row element.\n   * @returns {boolean}\n   */\n  hasChildren(row) {\n    let rowObj = row;\n    if (!isNaN(rowObj)) {\n      rowObj = this.getDataObject(rowObj);\n    }\n    return !!(rowObj.__children && rowObj.__children.length);\n  }\n\n  /**\n   * Returns `true` if the row at the provided index has a parent.\n   *\n   * @param {number} index Row index.\n   * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.\n   */\n  isChild(index) {\n    return this.getRowParent(index) !== null;\n  }\n\n  /**\n   * Get child at a provided index from the parent element.\n   *\n   * @param {object} parent The parent row object.\n   * @param {number} index Index of the child element to be retrieved.\n   * @returns {object|null} The child element or `null` if the child doesn't exist.\n   */\n  getChild(parent, index) {\n    var _parent$__children;\n    return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index]) || null;\n  }\n\n  /**\n   * Return `true` of the row at the provided index is located at the topmost level.\n   *\n   * @param {number} index Row index.\n   * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.\n   */\n  isRowHighestLevel(index) {\n    return !this.isChild(index);\n  }\n\n  /**\n   * Return `true` if the provided row index / row object represents a parent in the nested structure.\n   *\n   * @param {number|object} row Row index / row object.\n   * @returns {boolean} `true` if the row is a parent, `false` otherwise.\n   */\n  isParent(row) {\n    var _rowObj$__children;\n    let rowObj = row;\n    if (!isNaN(rowObj)) {\n      rowObj = this.getDataObject(rowObj);\n    }\n    return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;\n  }\n\n  /**\n   * Add a child to the provided parent. It's optional to add a row object as the \"element\".\n   *\n   * @param {object} parent The parent row object.\n   * @param {object} [element] The element to add as a child.\n   */\n  addChild(parent, element) {\n    let childElement = element;\n    this.hot.runHooks('beforeAddChild', parent, childElement);\n    let parentIndex = null;\n    if (parent) {\n      parentIndex = this.getRowIndex(parent);\n    }\n    this.hot.runHooks('beforeCreateRow', parentIndex + this.countChildren(parent) + 1, 1);\n    let functionalParent = parent;\n    if (!parent) {\n      functionalParent = this.mockParent();\n    }\n    if (!functionalParent.__children) {\n      functionalParent.__children = [];\n    }\n    if (!childElement) {\n      childElement = this.mockNode();\n    }\n    functionalParent.__children.push(childElement);\n    this.rewriteCache();\n    const newRowIndex = this.getRowIndex(childElement);\n    this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);\n    this.hot.runHooks('afterCreateRow', newRowIndex, 1);\n    this.hot.runHooks('afterAddChild', parent, childElement);\n  }\n\n  /**\n   * Add a child node to the provided parent at a specified index.\n   *\n   * @param {object} parent Parent node.\n   * @param {number} index Index to insert the child element at.\n   * @param {object} [element] Element (node) to insert.\n   */\n  addChildAtIndex(parent, index, element) {\n    let childElement = element;\n    let flattenedIndex;\n    if (!childElement) {\n      childElement = this.mockNode();\n    }\n    this.hot.runHooks('beforeAddChild', parent, childElement, index);\n    if (parent) {\n      const parentIndex = this.getRowIndex(parent);\n      const finalChildIndex = parentIndex + index + 1;\n      this.hot.runHooks('beforeCreateRow', finalChildIndex, 1);\n      parent.__children.splice(index, null, childElement);\n      this.rewriteCache();\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), '__children', parent.__children, 'NestedRows.addChildAtIndex');\n      this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);\n      this.plugin.enableCoreAPIModifiers();\n      this.hot.runHooks('afterCreateRow', finalChildIndex, 1);\n      flattenedIndex = finalChildIndex;\n    } else {\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.alter('insert_row_above', index, 1, 'NestedRows.addChildAtIndex');\n      this.plugin.enableCoreAPIModifiers();\n      flattenedIndex = this.getRowIndex(this.data[index]);\n    }\n\n    // Workaround for refreshing cache losing the reference to the mocked row.\n    childElement = this.getDataObject(flattenedIndex);\n    this.hot.runHooks('afterAddChild', parent, childElement, index);\n  }\n\n  /**\n   * Add a sibling element at the specified index.\n   *\n   * @param {number} index New element sibling's index.\n   * @param {('above'|'below')} where Direction in which the sibling is to be created.\n   */\n  addSibling(index) {\n    let where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'below';\n    const translatedIndex = this.translateTrimmedRow(index);\n    const parent = this.getRowParent(translatedIndex);\n    const indexWithinParent = this.getRowIndexWithinParent(translatedIndex);\n    switch (where) {\n      case 'below':\n        this.addChildAtIndex(parent, indexWithinParent + 1, null);\n        break;\n      case 'above':\n        this.addChildAtIndex(parent, indexWithinParent, null);\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Detach the provided element from its parent and add it right after it.\n   *\n   * @param {object|Array} elements Row object or an array of selected coordinates.\n   * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.\n   */\n  detachFromParent(elements) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let element = null;\n    const rowObjects = [];\n    if (Array.isArray(elements)) {\n      rangeEach(elements[0], elements[2], i => {\n        const translatedIndex = this.translateTrimmedRow(i);\n        rowObjects.push(this.getDataObject(translatedIndex));\n      });\n      rangeEach(0, rowObjects.length - 2, i => {\n        this.detachFromParent(rowObjects[i], false);\n      });\n      element = rowObjects[rowObjects.length - 1];\n    } else {\n      element = elements;\n    }\n    const childRowIndex = this.getRowIndex(element);\n    const childCount = this.countChildren(element);\n    const indexWithinParent = this.getRowIndexWithinParent(element);\n    const parent = this.getRowParent(element);\n    const grandparent = this.getRowParent(parent);\n    const grandparentRowIndex = this.getRowIndex(grandparent);\n    let movedElementRowIndex = null;\n    this.hot.runHooks('beforeDetachChild', parent, element);\n    if (indexWithinParent !== null && indexWithinParent !== undefined) {\n      const removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));\n      this.hot.runHooks('beforeRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n      parent.__children.splice(indexWithinParent, 1);\n      this.rewriteCache();\n      this.hot.runHooks('afterRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n      if (grandparent) {\n        movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);\n        const lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);\n        const lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);\n        this.hot.runHooks('beforeCreateRow', lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);\n        grandparent.__children.push(element);\n      } else {\n        movedElementRowIndex = this.hot.countRows() + 1;\n        this.hot.runHooks('beforeCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n        this.data.push(element);\n      }\n    }\n    this.rewriteCache();\n    this.hot.runHooks('afterCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n    this.hot.runHooks('afterDetachChild', parent, element, this.getRowIndex(element));\n    if (forceRender) {\n      this.hot.render();\n    }\n  }\n\n  /**\n   * Filter the data by the `logicRows` array.\n   *\n   * @private\n   * @param {number} index Index of the first row to remove.\n   * @param {number} amount Number of elements to remove.\n   * @param {Array} logicRows Array of indexes to remove.\n   */\n  filterData(index, amount, logicRows) {\n    // TODO: why are the first 2 arguments not used?\n\n    const elementsToRemove = [];\n    arrayEach(logicRows, elem => {\n      elementsToRemove.push(this.getDataObject(elem));\n    });\n    arrayEach(elementsToRemove, elem => {\n      const indexWithinParent = this.getRowIndexWithinParent(elem);\n      const tempParent = this.getRowParent(elem);\n      if (tempParent === null) {\n        this.data.splice(indexWithinParent, 1);\n      } else {\n        tempParent.__children.splice(indexWithinParent, 1);\n      }\n    });\n    this.rewriteCache();\n  }\n\n  /**\n   * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the\n   * default script.\n   *\n   * @private\n   * @param {number} index Physical index of the element at the splice beginning.\n   * @param {number} amount Number of elements to be removed.\n   * @param {object[]} elements Array of row objects to add.\n   */\n  spliceData(index, amount, elements) {\n    const previousElement = this.getDataObject(index - 1);\n    let newRowParent = null;\n    let indexWithinParent = index;\n    if (previousElement && previousElement.__children && previousElement.__children.length === 0) {\n      newRowParent = previousElement;\n      indexWithinParent = 0;\n    } else if (index < this.countAllRows()) {\n      newRowParent = this.getRowParent(index);\n      indexWithinParent = this.getRowIndexWithinParent(index);\n    }\n    if (newRowParent) {\n      if (elements) {\n        newRowParent.__children.splice(indexWithinParent, amount, ...elements);\n      } else {\n        newRowParent.__children.splice(indexWithinParent, amount);\n      }\n    } else if (elements) {\n      this.data.splice(indexWithinParent, amount, ...elements);\n    } else {\n      this.data.splice(indexWithinParent, amount);\n    }\n    this.rewriteCache();\n  }\n\n  /**\n   * Update the `__children` key of the upmost parent of the provided row object.\n   *\n   * @private\n   * @param {object} rowElement Row object.\n   */\n  syncRowWithRawSource(rowElement) {\n    let upmostParent = rowElement;\n    let tempParent = null;\n    do {\n      tempParent = this.getRowParent(tempParent);\n      if (tempParent !== null) {\n        upmostParent = tempParent;\n      }\n    } while (tempParent !== null);\n    this.plugin.disableCoreAPIModifiers();\n    this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), '__children', upmostParent.__children, 'NestedRows.syncRowWithRawSource');\n    this.plugin.enableCoreAPIModifiers();\n  }\n\n  /* eslint-disable jsdoc/require-param */\n  /**\n   * Move a single row.\n   *\n   * @param {number} fromIndex Index of the row to be moved.\n   * @param {number} toIndex Index of the destination.\n   * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.\n   * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.\n   */\n\n  /* eslint-enable jsdoc/require-param */\n  moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {\n    const moveToLastRow = toIndex === this.hot.countRows();\n    const fromParent = this.getRowParent(fromIndex);\n    const indexInFromParent = this.getRowIndexWithinParent(fromIndex);\n    const elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n    const movingUp = fromIndex > toIndex;\n    let toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);\n    if (toParent === null || toParent === undefined) {\n      toParent = this.getRowParent(toIndex - 1);\n    }\n    if (toParent === null || toParent === undefined) {\n      toParent = this.getDataObject(toIndex - 1);\n    }\n    if (!toParent) {\n      toParent = this.getDataObject(toIndex);\n      toParent.__children = [];\n    } else if (!toParent.__children) {\n      toParent.__children = [];\n    }\n    const indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);\n    const sameParent = fromParent === toParent;\n    toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);\n    fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1);\n\n    // Sync the changes in the cached data with the actual data stored in HOT.\n    this.syncRowWithRawSource(fromParent);\n    if (!sameParent) {\n      this.syncRowWithRawSource(toParent);\n    }\n  }\n\n  /**\n   * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number}\n   */\n  translateTrimmedRow(row) {\n    if (this.plugin.collapsingUI) {\n      return this.plugin.collapsingUI.translateTrimmedRow(row);\n    }\n    return row;\n  }\n\n  /**\n   * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number}\n   */\n  untranslateTrimmedRow(row) {\n    if (this.plugin.collapsingUI) {\n      return this.plugin.collapsingUI.untranslateTrimmedRow(row);\n    }\n    return row;\n  }\n}\nexport default DataManager;","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","rangeEach","objectEach","arrayEach","DataManager","constructor","nestedRowsPlugin","hotInstance","WeakMap","levels","levelCount","rows","nodeInfo","hot","plugin","setData","data","getData","getRawSourceData","rawSourceData","disableCoreAPIModifiers","getSourceData","enableCoreAPIModifiers","updateWithData","rewriteCache","cache","length","cacheNode","node","level","parent","push","set","row","hasChildren","__children","elem","getDataObject","undefined","readTreeNodes","readCount","neededIndex","neededObject","rootLevel","readNodesCount","isNaN","end","parentObj","result","val","parentReference","mockParent","fakeParent","mockNode","fakeNode","getRowIndex","rowObj","get","getRowIndexWithinParent","getRowParent","indexOf","countAllRows","rootNodeMock","countChildren","rowCount","parentNode","rowObject","getRowObjectParent","getRowLevel","getRowObjectLevel","isChild","index","getChild","_parent$__children","isRowHighestLevel","isParent","_rowObj$__children","addChild","element","childElement","runHooks","parentIndex","functionalParent","newRowIndex","rowIndexMapper","insertIndexes","addChildAtIndex","flattenedIndex","finalChildIndex","splice","setSourceDataAtCell","alter","addSibling","where","arguments","translatedIndex","translateTrimmedRow","indexWithinParent","detachFromParent","elements","forceRender","rowObjects","Array","isArray","childRowIndex","childCount","grandparent","grandparentRowIndex","movedElementRowIndex","removedRowIndexes","from","keys","pluginName","lastGrandparentChild","lastGrandparentChildIndex","countRows","render","filterData","amount","logicRows","elementsToRemove","tempParent","spliceData","previousElement","newRowParent","syncRowWithRawSource","rowElement","upmostParent","moveRow","fromIndex","toIndex","moveToCollapsed","moveToLastChild","moveToLastRow","fromParent","indexInFromParent","elemToMove","slice","movingUp","toParent","indexInTargetParent","sameParent","collapsingUI","untranslateTrimmedRow"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/nestedRows/data/dataManager.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\n/**\n * Class responsible for making data operations.\n *\n * @private\n */\nclass DataManager {\n  constructor(nestedRowsPlugin, hotInstance) {\n    /**\n     * Main Handsontable instance reference.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to the source data object.\n     *\n     * @type {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n    _defineProperty(this, \"data\", null);\n    /**\n     * Reference to the NestedRows plugin.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Map of row object parents.\n     *\n     * @type {WeakMap}\n     */\n    _defineProperty(this, \"parentReference\", new WeakMap());\n    /**\n     * Nested structure cache.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cache\", {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    });\n    this.hot = hotInstance;\n    this.plugin = nestedRowsPlugin;\n  }\n\n  /**\n   * Set the data for the manager.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n  setData(data) {\n    this.data = data;\n  }\n\n  /**\n   * Get the data cached in the manager.\n   *\n   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n   */\n  getData() {\n    return this.data;\n  }\n\n  /**\n   * Load the \"raw\" source data, without NestedRows' modifications.\n   *\n   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n   */\n  getRawSourceData() {\n    let rawSourceData = null;\n    this.plugin.disableCoreAPIModifiers();\n    rawSourceData = this.hot.getSourceData();\n    this.plugin.enableCoreAPIModifiers();\n    return rawSourceData;\n  }\n\n  /**\n   * Update the Data Manager with new data and refresh cache.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n  updateWithData(data) {\n    this.setData(data);\n    this.rewriteCache();\n  }\n\n  /**\n   * Rewrite the nested structure cache.\n   *\n   * @private\n   */\n  rewriteCache() {\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    };\n    rangeEach(0, this.data.length - 1, i => {\n      this.cacheNode(this.data[i], 0, null);\n    });\n  }\n\n  /**\n   * Cache a data node.\n   *\n   * @private\n   * @param {object} node Node to cache.\n   * @param {number} level Level of the node.\n   * @param {object} parent Parent of the node.\n   */\n  cacheNode(node, level, parent) {\n    if (!this.cache.levels[level]) {\n      this.cache.levels[level] = [];\n      this.cache.levelCount += 1;\n    }\n    this.cache.levels[level].push(node);\n    this.cache.rows.push(node);\n    this.cache.nodeInfo.set(node, {\n      parent,\n      row: this.cache.rows.length - 1,\n      level\n    });\n    if (this.hasChildren(node)) {\n      arrayEach(node.__children, elem => {\n        this.cacheNode(elem, level + 1, node);\n      });\n    }\n  }\n\n  /**\n   * Get the date for the provided visual row number.\n   *\n   * @param {number} row Row index.\n   * @returns {object}\n   */\n  getDataObject(row) {\n    return row === null || row === undefined ? null : this.cache.rows[row];\n  }\n\n  /**\n   * Read the row tree in search for a specific row index or row object.\n   *\n   * @private\n   * @param {object} parent The initial parent object.\n   * @param {number} readCount Number of read nodes.\n   * @param {number} neededIndex The row index we search for.\n   * @param {object} neededObject The row object we search for.\n   * @returns {number|object}\n   */\n  readTreeNodes(parent, readCount, neededIndex, neededObject) {\n    let rootLevel = false;\n    let readNodesCount = readCount;\n    if (isNaN(readNodesCount) && readNodesCount.end) {\n      return readNodesCount;\n    }\n    let parentObj = parent;\n    if (!parentObj) {\n      parentObj = {\n        __children: this.data\n      };\n      rootLevel = true;\n      readNodesCount -= 1;\n    }\n    if (neededIndex !== null && neededIndex !== undefined && readNodesCount === neededIndex) {\n      return {\n        result: parentObj,\n        end: true\n      };\n    }\n    if (neededObject !== null && neededObject !== undefined && parentObj === neededObject) {\n      return {\n        result: readNodesCount,\n        end: true\n      };\n    }\n    readNodesCount += 1;\n    if (parentObj.__children) {\n      arrayEach(parentObj.__children, val => {\n        this.parentReference.set(val, rootLevel ? null : parentObj);\n        readNodesCount = this.readTreeNodes(val, readNodesCount, neededIndex, neededObject);\n        if (isNaN(readNodesCount) && readNodesCount.end) {\n          return false;\n        }\n      });\n    }\n    return readNodesCount;\n  }\n\n  /**\n   * Mock a parent node.\n   *\n   * @private\n   * @returns {*}\n   */\n  mockParent() {\n    const fakeParent = this.mockNode();\n    fakeParent.__children = this.data;\n    return fakeParent;\n  }\n\n  /**\n   * Mock a data node.\n   *\n   * @private\n   * @returns {{}}\n   */\n  mockNode() {\n    const fakeNode = {};\n    objectEach(this.data[0], (val, key) => {\n      fakeNode[key] = null;\n    });\n    return fakeNode;\n  }\n\n  /**\n   * Get the row index for the provided row object.\n   *\n   * @param {object} rowObj The row object.\n   * @returns {number} Row index.\n   */\n  getRowIndex(rowObj) {\n    return rowObj === null || rowObj === undefined ? null : this.cache.nodeInfo.get(rowObj).row;\n  }\n\n  /**\n   * Get the index of the provided row index/row object within its parent.\n   *\n   * @param {number|object} row Row index / row object.\n   * @returns {number}\n   */\n  getRowIndexWithinParent(row) {\n    let rowObj = null;\n    if (isNaN(row)) {\n      rowObj = row;\n    } else {\n      rowObj = this.getDataObject(row);\n    }\n    const parent = this.getRowParent(row);\n    if (parent === null || parent === undefined) {\n      return this.data.indexOf(rowObj);\n    }\n    return parent.__children.indexOf(rowObj);\n  }\n\n  /**\n   * Count all rows (including all parents and children).\n   *\n   * @returns {number}\n   */\n  countAllRows() {\n    const rootNodeMock = {\n      __children: this.data\n    };\n    return this.countChildren(rootNodeMock);\n  }\n\n  /**\n   * Count children of the provided parent.\n   *\n   * @param {object|number} parent Parent node.\n   * @returns {number} Children count.\n   */\n  countChildren(parent) {\n    let rowCount = 0;\n    let parentNode = parent;\n    if (!isNaN(parentNode)) {\n      parentNode = this.getDataObject(parentNode);\n    }\n    if (!parentNode || !parentNode.__children) {\n      return 0;\n    }\n    arrayEach(parentNode.__children, elem => {\n      rowCount += 1;\n      if (elem.__children) {\n        rowCount += this.countChildren(elem);\n      }\n    });\n    return rowCount;\n  }\n\n  /**\n   * Get the parent of the row at the provided index.\n   *\n   * @param {number|object} row Physical row index.\n   * @returns {object}\n   */\n  getRowParent(row) {\n    let rowObject;\n    if (isNaN(row)) {\n      rowObject = row;\n    } else {\n      rowObject = this.getDataObject(row);\n    }\n    return this.getRowObjectParent(rowObject);\n  }\n\n  /**\n   * Get the parent of the provided row object.\n   *\n   * @private\n   * @param {object} rowObject The row object (tree node).\n   * @returns {object|null}\n   */\n  getRowObjectParent(rowObject) {\n    if (!rowObject || typeof rowObject !== 'object') {\n      return null;\n    }\n    return this.cache.nodeInfo.get(rowObject).parent;\n  }\n\n  /**\n   * Get the nesting level for the row with the provided row index.\n   *\n   * @param {number} row Row index.\n   * @returns {number|null} Row level or null, when row doesn't exist.\n   */\n  getRowLevel(row) {\n    let rowObject = null;\n    if (isNaN(row)) {\n      rowObject = row;\n    } else {\n      rowObject = this.getDataObject(row);\n    }\n    return rowObject ? this.getRowObjectLevel(rowObject) : null;\n  }\n\n  /**\n   * Get the nesting level for the row with the provided row index.\n   *\n   * @private\n   * @param {object} rowObject Row object.\n   * @returns {number} Row level.\n   */\n  getRowObjectLevel(rowObject) {\n    return rowObject === null || rowObject === undefined ? null : this.cache.nodeInfo.get(rowObject).level;\n  }\n\n  /**\n   * Check if the provided row/row element has children.\n   *\n   * @param {number|object} row Row number or row element.\n   * @returns {boolean}\n   */\n  hasChildren(row) {\n    let rowObj = row;\n    if (!isNaN(rowObj)) {\n      rowObj = this.getDataObject(rowObj);\n    }\n    return !!(rowObj.__children && rowObj.__children.length);\n  }\n\n  /**\n   * Returns `true` if the row at the provided index has a parent.\n   *\n   * @param {number} index Row index.\n   * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.\n   */\n  isChild(index) {\n    return this.getRowParent(index) !== null;\n  }\n\n  /**\n   * Get child at a provided index from the parent element.\n   *\n   * @param {object} parent The parent row object.\n   * @param {number} index Index of the child element to be retrieved.\n   * @returns {object|null} The child element or `null` if the child doesn't exist.\n   */\n  getChild(parent, index) {\n    var _parent$__children;\n    return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index]) || null;\n  }\n\n  /**\n   * Return `true` of the row at the provided index is located at the topmost level.\n   *\n   * @param {number} index Row index.\n   * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.\n   */\n  isRowHighestLevel(index) {\n    return !this.isChild(index);\n  }\n\n  /**\n   * Return `true` if the provided row index / row object represents a parent in the nested structure.\n   *\n   * @param {number|object} row Row index / row object.\n   * @returns {boolean} `true` if the row is a parent, `false` otherwise.\n   */\n  isParent(row) {\n    var _rowObj$__children;\n    let rowObj = row;\n    if (!isNaN(rowObj)) {\n      rowObj = this.getDataObject(rowObj);\n    }\n    return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;\n  }\n\n  /**\n   * Add a child to the provided parent. It's optional to add a row object as the \"element\".\n   *\n   * @param {object} parent The parent row object.\n   * @param {object} [element] The element to add as a child.\n   */\n  addChild(parent, element) {\n    let childElement = element;\n    this.hot.runHooks('beforeAddChild', parent, childElement);\n    let parentIndex = null;\n    if (parent) {\n      parentIndex = this.getRowIndex(parent);\n    }\n    this.hot.runHooks('beforeCreateRow', parentIndex + this.countChildren(parent) + 1, 1);\n    let functionalParent = parent;\n    if (!parent) {\n      functionalParent = this.mockParent();\n    }\n    if (!functionalParent.__children) {\n      functionalParent.__children = [];\n    }\n    if (!childElement) {\n      childElement = this.mockNode();\n    }\n    functionalParent.__children.push(childElement);\n    this.rewriteCache();\n    const newRowIndex = this.getRowIndex(childElement);\n    this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);\n    this.hot.runHooks('afterCreateRow', newRowIndex, 1);\n    this.hot.runHooks('afterAddChild', parent, childElement);\n  }\n\n  /**\n   * Add a child node to the provided parent at a specified index.\n   *\n   * @param {object} parent Parent node.\n   * @param {number} index Index to insert the child element at.\n   * @param {object} [element] Element (node) to insert.\n   */\n  addChildAtIndex(parent, index, element) {\n    let childElement = element;\n    let flattenedIndex;\n    if (!childElement) {\n      childElement = this.mockNode();\n    }\n    this.hot.runHooks('beforeAddChild', parent, childElement, index);\n    if (parent) {\n      const parentIndex = this.getRowIndex(parent);\n      const finalChildIndex = parentIndex + index + 1;\n      this.hot.runHooks('beforeCreateRow', finalChildIndex, 1);\n      parent.__children.splice(index, null, childElement);\n      this.rewriteCache();\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), '__children', parent.__children, 'NestedRows.addChildAtIndex');\n      this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);\n      this.plugin.enableCoreAPIModifiers();\n      this.hot.runHooks('afterCreateRow', finalChildIndex, 1);\n      flattenedIndex = finalChildIndex;\n    } else {\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.alter('insert_row_above', index, 1, 'NestedRows.addChildAtIndex');\n      this.plugin.enableCoreAPIModifiers();\n      flattenedIndex = this.getRowIndex(this.data[index]);\n    }\n\n    // Workaround for refreshing cache losing the reference to the mocked row.\n    childElement = this.getDataObject(flattenedIndex);\n    this.hot.runHooks('afterAddChild', parent, childElement, index);\n  }\n\n  /**\n   * Add a sibling element at the specified index.\n   *\n   * @param {number} index New element sibling's index.\n   * @param {('above'|'below')} where Direction in which the sibling is to be created.\n   */\n  addSibling(index) {\n    let where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'below';\n    const translatedIndex = this.translateTrimmedRow(index);\n    const parent = this.getRowParent(translatedIndex);\n    const indexWithinParent = this.getRowIndexWithinParent(translatedIndex);\n    switch (where) {\n      case 'below':\n        this.addChildAtIndex(parent, indexWithinParent + 1, null);\n        break;\n      case 'above':\n        this.addChildAtIndex(parent, indexWithinParent, null);\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Detach the provided element from its parent and add it right after it.\n   *\n   * @param {object|Array} elements Row object or an array of selected coordinates.\n   * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.\n   */\n  detachFromParent(elements) {\n    let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let element = null;\n    const rowObjects = [];\n    if (Array.isArray(elements)) {\n      rangeEach(elements[0], elements[2], i => {\n        const translatedIndex = this.translateTrimmedRow(i);\n        rowObjects.push(this.getDataObject(translatedIndex));\n      });\n      rangeEach(0, rowObjects.length - 2, i => {\n        this.detachFromParent(rowObjects[i], false);\n      });\n      element = rowObjects[rowObjects.length - 1];\n    } else {\n      element = elements;\n    }\n    const childRowIndex = this.getRowIndex(element);\n    const childCount = this.countChildren(element);\n    const indexWithinParent = this.getRowIndexWithinParent(element);\n    const parent = this.getRowParent(element);\n    const grandparent = this.getRowParent(parent);\n    const grandparentRowIndex = this.getRowIndex(grandparent);\n    let movedElementRowIndex = null;\n    this.hot.runHooks('beforeDetachChild', parent, element);\n    if (indexWithinParent !== null && indexWithinParent !== undefined) {\n      const removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));\n      this.hot.runHooks('beforeRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n      parent.__children.splice(indexWithinParent, 1);\n      this.rewriteCache();\n      this.hot.runHooks('afterRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n      if (grandparent) {\n        movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);\n        const lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);\n        const lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);\n        this.hot.runHooks('beforeCreateRow', lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);\n        grandparent.__children.push(element);\n      } else {\n        movedElementRowIndex = this.hot.countRows() + 1;\n        this.hot.runHooks('beforeCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n        this.data.push(element);\n      }\n    }\n    this.rewriteCache();\n    this.hot.runHooks('afterCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n    this.hot.runHooks('afterDetachChild', parent, element, this.getRowIndex(element));\n    if (forceRender) {\n      this.hot.render();\n    }\n  }\n\n  /**\n   * Filter the data by the `logicRows` array.\n   *\n   * @private\n   * @param {number} index Index of the first row to remove.\n   * @param {number} amount Number of elements to remove.\n   * @param {Array} logicRows Array of indexes to remove.\n   */\n  filterData(index, amount, logicRows) {\n    // TODO: why are the first 2 arguments not used?\n\n    const elementsToRemove = [];\n    arrayEach(logicRows, elem => {\n      elementsToRemove.push(this.getDataObject(elem));\n    });\n    arrayEach(elementsToRemove, elem => {\n      const indexWithinParent = this.getRowIndexWithinParent(elem);\n      const tempParent = this.getRowParent(elem);\n      if (tempParent === null) {\n        this.data.splice(indexWithinParent, 1);\n      } else {\n        tempParent.__children.splice(indexWithinParent, 1);\n      }\n    });\n    this.rewriteCache();\n  }\n\n  /**\n   * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the\n   * default script.\n   *\n   * @private\n   * @param {number} index Physical index of the element at the splice beginning.\n   * @param {number} amount Number of elements to be removed.\n   * @param {object[]} elements Array of row objects to add.\n   */\n  spliceData(index, amount, elements) {\n    const previousElement = this.getDataObject(index - 1);\n    let newRowParent = null;\n    let indexWithinParent = index;\n    if (previousElement && previousElement.__children && previousElement.__children.length === 0) {\n      newRowParent = previousElement;\n      indexWithinParent = 0;\n    } else if (index < this.countAllRows()) {\n      newRowParent = this.getRowParent(index);\n      indexWithinParent = this.getRowIndexWithinParent(index);\n    }\n    if (newRowParent) {\n      if (elements) {\n        newRowParent.__children.splice(indexWithinParent, amount, ...elements);\n      } else {\n        newRowParent.__children.splice(indexWithinParent, amount);\n      }\n    } else if (elements) {\n      this.data.splice(indexWithinParent, amount, ...elements);\n    } else {\n      this.data.splice(indexWithinParent, amount);\n    }\n    this.rewriteCache();\n  }\n\n  /**\n   * Update the `__children` key of the upmost parent of the provided row object.\n   *\n   * @private\n   * @param {object} rowElement Row object.\n   */\n  syncRowWithRawSource(rowElement) {\n    let upmostParent = rowElement;\n    let tempParent = null;\n    do {\n      tempParent = this.getRowParent(tempParent);\n      if (tempParent !== null) {\n        upmostParent = tempParent;\n      }\n    } while (tempParent !== null);\n    this.plugin.disableCoreAPIModifiers();\n    this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), '__children', upmostParent.__children, 'NestedRows.syncRowWithRawSource');\n    this.plugin.enableCoreAPIModifiers();\n  }\n\n  /* eslint-disable jsdoc/require-param */\n  /**\n   * Move a single row.\n   *\n   * @param {number} fromIndex Index of the row to be moved.\n   * @param {number} toIndex Index of the destination.\n   * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.\n   * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.\n   */\n\n  /* eslint-enable jsdoc/require-param */\n  moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {\n    const moveToLastRow = toIndex === this.hot.countRows();\n    const fromParent = this.getRowParent(fromIndex);\n    const indexInFromParent = this.getRowIndexWithinParent(fromIndex);\n    const elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n    const movingUp = fromIndex > toIndex;\n    let toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);\n    if (toParent === null || toParent === undefined) {\n      toParent = this.getRowParent(toIndex - 1);\n    }\n    if (toParent === null || toParent === undefined) {\n      toParent = this.getDataObject(toIndex - 1);\n    }\n    if (!toParent) {\n      toParent = this.getDataObject(toIndex);\n      toParent.__children = [];\n    } else if (!toParent.__children) {\n      toParent.__children = [];\n    }\n    const indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);\n    const sameParent = fromParent === toParent;\n    toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);\n    fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1);\n\n    // Sync the changes in the cached data with the actual data stored in HOT.\n    this.syncRowWithRawSource(fromParent);\n    if (!sameParent) {\n      this.syncRowWithRawSource(toParent);\n    }\n  }\n\n  /**\n   * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number}\n   */\n  translateTrimmedRow(row) {\n    if (this.plugin.collapsingUI) {\n      return this.plugin.collapsingUI.translateTrimmedRow(row);\n    }\n    return row;\n  }\n\n  /**\n   * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @returns {number}\n   */\n  untranslateTrimmedRow(row) {\n    if (this.plugin.collapsingUI) {\n      return this.plugin.collapsingUI.untranslateTrimmedRow(row);\n    }\n    return row;\n  }\n}\nexport default DataManager;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}