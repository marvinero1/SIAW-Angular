{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { isFunctionKey, isCtrlMetaKey } from \"./helpers/unicode.mjs\";\nimport { isImmediatePropagationStopped } from \"./helpers/dom/event.mjs\";\nimport { getEditorInstance } from \"./editors/registry.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { isDefined } from \"./helpers/mixed.mjs\";\nexport const SHORTCUTS_GROUP_NAVIGATION = 'editorManager.navigation';\nvar _onAfterDocumentKeyDown = /*#__PURE__*/new WeakSet();\nvar _onCellDblClick = /*#__PURE__*/new WeakSet();\nclass EditorManager {\n  /**\n   * @param {Core} hotInstance The Handsontable instance.\n   * @param {TableMeta} tableMeta The table meta instance.\n   * @param {Selection} selection The selection instance.\n   */\n  constructor(hotInstance, tableMeta, _selection) {\n    /**\n     * OnCellDblClick callback.\n     *\n     * @param {MouseEvent} event The mouse event object.\n     * @param {object} coords The cell coordinates.\n     * @param {HTMLTableCellElement|HTMLTableHeaderCellElement} elem The element which triggers the action.\n     */\n    _classPrivateMethodInitSpec(this, _onCellDblClick);\n    /**\n     * OnAfterDocumentKeyDown callback.\n     *\n     * @param {KeyboardEvent} event The keyboard event object.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterDocumentKeyDown);\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to an instance's private GridSettings object.\n     *\n     * @private\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"tableMeta\", void 0);\n    /**\n     * Instance of {@link Selection}.\n     *\n     * @private\n     * @type {Selection}\n     */\n    _defineProperty(this, \"selection\", void 0);\n    /**\n     * Instance of {@link EventManager}.\n     *\n     * @private\n     * @type {EventManager}\n     */\n    _defineProperty(this, \"eventManager\", void 0);\n    /**\n     * Determines if EditorManager is destroyed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"destroyed\", false);\n    /**\n     * Determines if EditorManager is locked.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"lock\", false);\n    /**\n     * A reference to an instance of the activeEditor.\n     *\n     * @private\n     * @type {BaseEditor}\n     */\n    _defineProperty(this, \"activeEditor\", void 0);\n    /**\n     * Keeps a reference to the cell's properties object.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cellProperties\", void 0);\n    this.hot = hotInstance;\n    this.tableMeta = tableMeta;\n    this.selection = _selection;\n    this.eventManager = new EventManager(hotInstance);\n    this.hot.addHook('afterDocumentKeyDown', event => _classPrivateMethodGet(this, _onAfterDocumentKeyDown, _onAfterDocumentKeyDown2).call(this, event));\n\n    // Open editor when text composition is started (IME editor)\n    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'compositionstart', event => {\n      if (!this.destroyed && this.hot.isListening()) {\n        this.openEditor('', event);\n      }\n    });\n    this.hot.view._wt.update('onCellDblClick', (event, coords, elem) => _classPrivateMethodGet(this, _onCellDblClick, _onCellDblClick2).call(this, event, coords, elem));\n  }\n\n  /**\n   * Lock the editor from being prepared and closed. Locking the editor prevents its closing and\n   * reinitialized after selecting the new cell. This feature is necessary for a mobile editor.\n   */\n  lockEditor() {\n    this.lock = true;\n  }\n\n  /**\n   * Unlock the editor from being prepared and closed. This method restores the original behavior of\n   * the editors where for every new selection its instances are closed.\n   */\n  unlockEditor() {\n    this.lock = false;\n  }\n\n  /**\n   * Destroy current editor, if exists.\n   *\n   * @param {boolean} revertOriginal If `false` and the cell using allowInvalid option,\n   *                                 then an editor won't be closed until validation is passed.\n   */\n  destroyEditor(revertOriginal) {\n    if (!this.lock) {\n      this.closeEditor(revertOriginal);\n    }\n  }\n\n  /**\n   * Get active editor.\n   *\n   * @returns {BaseEditor}\n   */\n  getActiveEditor() {\n    return this.activeEditor;\n  }\n\n  /**\n   * Prepare text input to be displayed at given grid cell.\n   */\n  prepareEditor() {\n    var _this$hot$getSelected;\n    if (this.lock) {\n      return;\n    }\n    if (this.activeEditor && this.activeEditor.isWaiting()) {\n      this.closeEditor(false, false, dataSaved => {\n        if (dataSaved) {\n          this.prepareEditor();\n        }\n      });\n      return;\n    }\n    const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;\n    if (!highlight || highlight.isHeader()) {\n      return;\n    }\n    const {\n      row,\n      col\n    } = highlight;\n    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', row, col);\n    let visualRowToCheck = row;\n    let visualColumnToCheck = col;\n    if (Array.isArray(modifiedCellCoords)) {\n      [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;\n    }\n\n    // Getting values using the modified coordinates.\n    this.cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);\n    if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      return;\n    }\n    const td = this.hot.getCell(row, col, true);\n\n    // Skip the preparation when the cell is not rendered in the DOM. The cell is scrolled out of\n    // the table's viewport.\n    if (td) {\n      const editorClass = this.hot.getCellEditor(this.cellProperties);\n      const prop = this.hot.colToProp(visualColumnToCheck);\n      const originalValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(visualRowToCheck), visualColumnToCheck);\n      this.activeEditor = getEditorInstance(editorClass, this.hot);\n      // Using not modified coordinates, as we need to get the table element using selection coordinates.\n      // There is an extra translation in the editor for saving value.\n      this.activeEditor.prepare(row, col, prop, td, originalValue, this.cellProperties);\n    }\n  }\n\n  /**\n   * Check is editor is opened/showed.\n   *\n   * @returns {boolean}\n   */\n  isEditorOpened() {\n    return this.activeEditor && this.activeEditor.isOpened();\n  }\n\n  /**\n   * Open editor with initial value.\n   *\n   * @param {null|string} newInitialValue New value from which editor will start if handled property it's not the `null`.\n   * @param {Event} event The event object.\n   * @param {boolean} [enableFullEditMode=false] When true, an editor works in full editing mode. Mode disallows closing an editor\n   *                                             when arrow keys are pressed.\n   */\n  openEditor(newInitialValue, event) {\n    let enableFullEditMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      return;\n    }\n    if (!this.activeEditor) {\n      this.hot.scrollToFocusedCell();\n      this.prepareEditor();\n    }\n    if (this.activeEditor) {\n      if (enableFullEditMode) {\n        this.activeEditor.enableFullEditMode();\n      }\n      this.activeEditor.beginEditing(newInitialValue, event);\n    }\n  }\n\n  /**\n   * Close editor, finish editing cell.\n   *\n   * @param {boolean} restoreOriginalValue If `true`, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  closeEditor(restoreOriginalValue, isCtrlPressed, callback) {\n    if (this.activeEditor) {\n      this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, callback);\n    } else if (callback) {\n      callback(false);\n    }\n  }\n\n  /**\n   * Close editor and save changes.\n   *\n   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.\n   */\n  closeEditorAndSaveChanges(isCtrlPressed) {\n    this.closeEditor(false, isCtrlPressed);\n  }\n\n  /**\n   * Close editor and restore original value.\n   *\n   * @param {boolean} isCtrlPressed Indication of whether the CTRL button is pressed.\n   */\n  closeEditorAndRestoreOriginalValue(isCtrlPressed) {\n    this.closeEditor(true, isCtrlPressed);\n  }\n\n  /**\n   * Clears reference to an instance of the active editor.\n   *\n   * @private\n   */\n  clearActiveEditor() {\n    this.activeEditor = undefined;\n  }\n\n  /**\n   * Checks if the currently selected cell (pointed by selection highlight coords) is editable.\n   * Editable cell is when:\n   *   - the cell has defined an editor type;\n   *   - the cell is not marked as read-only;\n   *   - the cell is not hidden.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isCellEditable() {\n    const selection = this.hot.getSelectedRangeLast();\n    if (!selection) {\n      return false;\n    }\n    const editorClass = this.hot.getCellEditor(this.cellProperties);\n    const {\n      row,\n      col\n    } = selection.highlight;\n    const {\n      rowIndexMapper,\n      columnIndexMapper\n    } = this.hot;\n    const isCellHidden = rowIndexMapper.isHidden(this.hot.toPhysicalRow(row)) || columnIndexMapper.isHidden(this.hot.toPhysicalColumn(col));\n    if (this.cellProperties.readOnly || !editorClass || isCellHidden) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Controls selection's behaviour after clicking `Enter`.\n   *\n   * @private\n   * @param {boolean} isShiftPressed If `true`, then the selection will move up after hit enter.\n   */\n  moveSelectionAfterEnter(isShiftPressed) {\n    const enterMoves = typeof this.tableMeta.enterMoves === 'function' ? this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves;\n    if (isShiftPressed) {\n      // move selection up\n      this.selection.transformStart(-enterMoves.row, -enterMoves.col);\n    } else {\n      // move selection down (add a new row if needed)\n      this.selection.transformStart(enterMoves.row, enterMoves.col, true);\n    }\n  }\n  /**\n   * Destroy the instance.\n   */\n  destroy() {\n    this.destroyed = true;\n    this.eventManager.destroy();\n  }\n}\nfunction _onAfterDocumentKeyDown2(event) {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!this.hot.isListening() || !selection || selection.highlight.isHeader() || isImmediatePropagationStopped(event)) {\n    return;\n  }\n  const {\n    keyCode\n  } = event;\n\n  // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n  const isCtrlPressed = (event.ctrlKey || event.metaKey) && !event.altKey;\n  if (!this.activeEditor || this.activeEditor && !this.activeEditor.isWaiting()) {\n    if (!isFunctionKey(keyCode) && !isCtrlMetaKey(keyCode) && !isCtrlPressed && !this.isEditorOpened()) {\n      const shortcutManager = this.hot.getShortcutManager();\n      const editorContext = shortcutManager.getContext('editor');\n      const runOnlySelectedConfig = {\n        runOnlyIf: () => isDefined(this.hot.getSelected()),\n        group: SHORTCUTS_GROUP_NAVIGATION\n      };\n      editorContext.addShortcuts([{\n        keys: [['ArrowUp']],\n        callback: () => {\n          this.hot.selection.transformStart(-1, 0);\n        }\n      }, {\n        keys: [['ArrowDown']],\n        callback: () => {\n          this.hot.selection.transformStart(1, 0);\n        }\n      }, {\n        keys: [['ArrowLeft']],\n        callback: () => {\n          this.hot.selection.transformStart(0, -1 * this.hot.getDirectionFactor());\n        }\n      }, {\n        keys: [['ArrowRight']],\n        callback: () => {\n          this.hot.selection.transformStart(0, this.hot.getDirectionFactor());\n        }\n      }], runOnlySelectedConfig);\n      this.openEditor('', event);\n    }\n  }\n}\nfunction _onCellDblClick2(event, coords, elem) {\n  // may be TD or TH\n  if (elem.nodeName === 'TD') {\n    this.openEditor(null, event, true);\n  }\n}\nconst instances = new WeakMap();\n\n/**\n * @param {Core} hotInstance The Handsontable instance.\n * @param {TableMeta} tableMeta The table meta class instance.\n * @param {Selection} selection The selection instance.\n * @returns {EditorManager}\n */\nEditorManager.getInstance = function (hotInstance, tableMeta, selection) {\n  let editorManager = instances.get(hotInstance);\n  if (!editorManager) {\n    editorManager = new EditorManager(hotInstance, tableMeta, selection);\n    instances.set(hotInstance, editorManager);\n  }\n  return editorManager;\n};\nexport default EditorManager;","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","privateCollection","has","TypeError","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateMethodGet","receiver","fn","isFunctionKey","isCtrlMetaKey","isImmediatePropagationStopped","getEditorInstance","EventManager","isDefined","SHORTCUTS_GROUP_NAVIGATION","_onAfterDocumentKeyDown","WeakSet","_onCellDblClick","EditorManager","constructor","hotInstance","tableMeta","_selection","hot","selection","eventManager","addHook","event","_onAfterDocumentKeyDown2","addEventListener","rootDocument","documentElement","destroyed","isListening","openEditor","view","_wt","update","coords","elem","_onCellDblClick2","lockEditor","lock","unlockEditor","destroyEditor","revertOriginal","closeEditor","getActiveEditor","activeEditor","prepareEditor","_this$hot$getSelected","isWaiting","dataSaved","highlight","getSelectedRangeLast","isHeader","row","col","modifiedCellCoords","runHooks","visualRowToCheck","visualColumnToCheck","Array","isArray","cellProperties","getCellMeta","isCellEditable","clearActiveEditor","td","getCell","editorClass","getCellEditor","prop","colToProp","originalValue","getSourceDataAtCell","toPhysicalRow","prepare","isEditorOpened","isOpened","newInitialValue","enableFullEditMode","arguments","length","undefined","scrollToFocusedCell","beginEditing","restoreOriginalValue","isCtrlPressed","callback","finishEditing","closeEditorAndSaveChanges","closeEditorAndRestoreOriginalValue","rowIndexMapper","columnIndexMapper","isCellHidden","isHidden","toPhysicalColumn","readOnly","moveSelectionAfterEnter","isShiftPressed","enterMoves","transformStart","destroy","keyCode","ctrlKey","metaKey","altKey","shortcutManager","getShortcutManager","editorContext","getContext","runOnlySelectedConfig","runOnlyIf","getSelected","group","addShortcuts","keys","getDirectionFactor","nodeName","instances","WeakMap","getInstance","editorManager","get","set"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/editorManager.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { isFunctionKey, isCtrlMetaKey } from \"./helpers/unicode.mjs\";\nimport { isImmediatePropagationStopped } from \"./helpers/dom/event.mjs\";\nimport { getEditorInstance } from \"./editors/registry.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { isDefined } from \"./helpers/mixed.mjs\";\nexport const SHORTCUTS_GROUP_NAVIGATION = 'editorManager.navigation';\nvar _onAfterDocumentKeyDown = /*#__PURE__*/new WeakSet();\nvar _onCellDblClick = /*#__PURE__*/new WeakSet();\nclass EditorManager {\n  /**\n   * @param {Core} hotInstance The Handsontable instance.\n   * @param {TableMeta} tableMeta The table meta instance.\n   * @param {Selection} selection The selection instance.\n   */\n  constructor(hotInstance, tableMeta, _selection) {\n    /**\n     * OnCellDblClick callback.\n     *\n     * @param {MouseEvent} event The mouse event object.\n     * @param {object} coords The cell coordinates.\n     * @param {HTMLTableCellElement|HTMLTableHeaderCellElement} elem The element which triggers the action.\n     */\n    _classPrivateMethodInitSpec(this, _onCellDblClick);\n    /**\n     * OnAfterDocumentKeyDown callback.\n     *\n     * @param {KeyboardEvent} event The keyboard event object.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterDocumentKeyDown);\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to an instance's private GridSettings object.\n     *\n     * @private\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"tableMeta\", void 0);\n    /**\n     * Instance of {@link Selection}.\n     *\n     * @private\n     * @type {Selection}\n     */\n    _defineProperty(this, \"selection\", void 0);\n    /**\n     * Instance of {@link EventManager}.\n     *\n     * @private\n     * @type {EventManager}\n     */\n    _defineProperty(this, \"eventManager\", void 0);\n    /**\n     * Determines if EditorManager is destroyed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"destroyed\", false);\n    /**\n     * Determines if EditorManager is locked.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"lock\", false);\n    /**\n     * A reference to an instance of the activeEditor.\n     *\n     * @private\n     * @type {BaseEditor}\n     */\n    _defineProperty(this, \"activeEditor\", void 0);\n    /**\n     * Keeps a reference to the cell's properties object.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cellProperties\", void 0);\n    this.hot = hotInstance;\n    this.tableMeta = tableMeta;\n    this.selection = _selection;\n    this.eventManager = new EventManager(hotInstance);\n    this.hot.addHook('afterDocumentKeyDown', event => _classPrivateMethodGet(this, _onAfterDocumentKeyDown, _onAfterDocumentKeyDown2).call(this, event));\n\n    // Open editor when text composition is started (IME editor)\n    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'compositionstart', event => {\n      if (!this.destroyed && this.hot.isListening()) {\n        this.openEditor('', event);\n      }\n    });\n    this.hot.view._wt.update('onCellDblClick', (event, coords, elem) => _classPrivateMethodGet(this, _onCellDblClick, _onCellDblClick2).call(this, event, coords, elem));\n  }\n\n  /**\n   * Lock the editor from being prepared and closed. Locking the editor prevents its closing and\n   * reinitialized after selecting the new cell. This feature is necessary for a mobile editor.\n   */\n  lockEditor() {\n    this.lock = true;\n  }\n\n  /**\n   * Unlock the editor from being prepared and closed. This method restores the original behavior of\n   * the editors where for every new selection its instances are closed.\n   */\n  unlockEditor() {\n    this.lock = false;\n  }\n\n  /**\n   * Destroy current editor, if exists.\n   *\n   * @param {boolean} revertOriginal If `false` and the cell using allowInvalid option,\n   *                                 then an editor won't be closed until validation is passed.\n   */\n  destroyEditor(revertOriginal) {\n    if (!this.lock) {\n      this.closeEditor(revertOriginal);\n    }\n  }\n\n  /**\n   * Get active editor.\n   *\n   * @returns {BaseEditor}\n   */\n  getActiveEditor() {\n    return this.activeEditor;\n  }\n\n  /**\n   * Prepare text input to be displayed at given grid cell.\n   */\n  prepareEditor() {\n    var _this$hot$getSelected;\n    if (this.lock) {\n      return;\n    }\n    if (this.activeEditor && this.activeEditor.isWaiting()) {\n      this.closeEditor(false, false, dataSaved => {\n        if (dataSaved) {\n          this.prepareEditor();\n        }\n      });\n      return;\n    }\n    const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;\n    if (!highlight || highlight.isHeader()) {\n      return;\n    }\n    const {\n      row,\n      col\n    } = highlight;\n    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', row, col);\n    let visualRowToCheck = row;\n    let visualColumnToCheck = col;\n    if (Array.isArray(modifiedCellCoords)) {\n      [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;\n    }\n\n    // Getting values using the modified coordinates.\n    this.cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);\n    if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      return;\n    }\n    const td = this.hot.getCell(row, col, true);\n\n    // Skip the preparation when the cell is not rendered in the DOM. The cell is scrolled out of\n    // the table's viewport.\n    if (td) {\n      const editorClass = this.hot.getCellEditor(this.cellProperties);\n      const prop = this.hot.colToProp(visualColumnToCheck);\n      const originalValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(visualRowToCheck), visualColumnToCheck);\n      this.activeEditor = getEditorInstance(editorClass, this.hot);\n      // Using not modified coordinates, as we need to get the table element using selection coordinates.\n      // There is an extra translation in the editor for saving value.\n      this.activeEditor.prepare(row, col, prop, td, originalValue, this.cellProperties);\n    }\n  }\n\n  /**\n   * Check is editor is opened/showed.\n   *\n   * @returns {boolean}\n   */\n  isEditorOpened() {\n    return this.activeEditor && this.activeEditor.isOpened();\n  }\n\n  /**\n   * Open editor with initial value.\n   *\n   * @param {null|string} newInitialValue New value from which editor will start if handled property it's not the `null`.\n   * @param {Event} event The event object.\n   * @param {boolean} [enableFullEditMode=false] When true, an editor works in full editing mode. Mode disallows closing an editor\n   *                                             when arrow keys are pressed.\n   */\n  openEditor(newInitialValue, event) {\n    let enableFullEditMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      return;\n    }\n    if (!this.activeEditor) {\n      this.hot.scrollToFocusedCell();\n      this.prepareEditor();\n    }\n    if (this.activeEditor) {\n      if (enableFullEditMode) {\n        this.activeEditor.enableFullEditMode();\n      }\n      this.activeEditor.beginEditing(newInitialValue, event);\n    }\n  }\n\n  /**\n   * Close editor, finish editing cell.\n   *\n   * @param {boolean} restoreOriginalValue If `true`, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  closeEditor(restoreOriginalValue, isCtrlPressed, callback) {\n    if (this.activeEditor) {\n      this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, callback);\n    } else if (callback) {\n      callback(false);\n    }\n  }\n\n  /**\n   * Close editor and save changes.\n   *\n   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.\n   */\n  closeEditorAndSaveChanges(isCtrlPressed) {\n    this.closeEditor(false, isCtrlPressed);\n  }\n\n  /**\n   * Close editor and restore original value.\n   *\n   * @param {boolean} isCtrlPressed Indication of whether the CTRL button is pressed.\n   */\n  closeEditorAndRestoreOriginalValue(isCtrlPressed) {\n    this.closeEditor(true, isCtrlPressed);\n  }\n\n  /**\n   * Clears reference to an instance of the active editor.\n   *\n   * @private\n   */\n  clearActiveEditor() {\n    this.activeEditor = undefined;\n  }\n\n  /**\n   * Checks if the currently selected cell (pointed by selection highlight coords) is editable.\n   * Editable cell is when:\n   *   - the cell has defined an editor type;\n   *   - the cell is not marked as read-only;\n   *   - the cell is not hidden.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isCellEditable() {\n    const selection = this.hot.getSelectedRangeLast();\n    if (!selection) {\n      return false;\n    }\n    const editorClass = this.hot.getCellEditor(this.cellProperties);\n    const {\n      row,\n      col\n    } = selection.highlight;\n    const {\n      rowIndexMapper,\n      columnIndexMapper\n    } = this.hot;\n    const isCellHidden = rowIndexMapper.isHidden(this.hot.toPhysicalRow(row)) || columnIndexMapper.isHidden(this.hot.toPhysicalColumn(col));\n    if (this.cellProperties.readOnly || !editorClass || isCellHidden) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Controls selection's behaviour after clicking `Enter`.\n   *\n   * @private\n   * @param {boolean} isShiftPressed If `true`, then the selection will move up after hit enter.\n   */\n  moveSelectionAfterEnter(isShiftPressed) {\n    const enterMoves = typeof this.tableMeta.enterMoves === 'function' ? this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves;\n    if (isShiftPressed) {\n      // move selection up\n      this.selection.transformStart(-enterMoves.row, -enterMoves.col);\n    } else {\n      // move selection down (add a new row if needed)\n      this.selection.transformStart(enterMoves.row, enterMoves.col, true);\n    }\n  }\n  /**\n   * Destroy the instance.\n   */\n  destroy() {\n    this.destroyed = true;\n    this.eventManager.destroy();\n  }\n}\nfunction _onAfterDocumentKeyDown2(event) {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!this.hot.isListening() || !selection || selection.highlight.isHeader() || isImmediatePropagationStopped(event)) {\n    return;\n  }\n  const {\n    keyCode\n  } = event;\n\n  // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n  const isCtrlPressed = (event.ctrlKey || event.metaKey) && !event.altKey;\n  if (!this.activeEditor || this.activeEditor && !this.activeEditor.isWaiting()) {\n    if (!isFunctionKey(keyCode) && !isCtrlMetaKey(keyCode) && !isCtrlPressed && !this.isEditorOpened()) {\n      const shortcutManager = this.hot.getShortcutManager();\n      const editorContext = shortcutManager.getContext('editor');\n      const runOnlySelectedConfig = {\n        runOnlyIf: () => isDefined(this.hot.getSelected()),\n        group: SHORTCUTS_GROUP_NAVIGATION\n      };\n      editorContext.addShortcuts([{\n        keys: [['ArrowUp']],\n        callback: () => {\n          this.hot.selection.transformStart(-1, 0);\n        }\n      }, {\n        keys: [['ArrowDown']],\n        callback: () => {\n          this.hot.selection.transformStart(1, 0);\n        }\n      }, {\n        keys: [['ArrowLeft']],\n        callback: () => {\n          this.hot.selection.transformStart(0, -1 * this.hot.getDirectionFactor());\n        }\n      }, {\n        keys: [['ArrowRight']],\n        callback: () => {\n          this.hot.selection.transformStart(0, this.hot.getDirectionFactor());\n        }\n      }], runOnlySelectedConfig);\n      this.openEditor('', event);\n    }\n  }\n}\nfunction _onCellDblClick2(event, coords, elem) {\n  // may be TD or TH\n  if (elem.nodeName === 'TD') {\n    this.openEditor(null, event, true);\n  }\n}\nconst instances = new WeakMap();\n\n/**\n * @param {Core} hotInstance The Handsontable instance.\n * @param {TableMeta} tableMeta The table meta class instance.\n * @param {Selection} selection The selection instance.\n * @returns {EditorManager}\n */\nEditorManager.getInstance = function (hotInstance, tableMeta, selection) {\n  let editorManager = instances.get(hotInstance);\n  if (!editorManager) {\n    editorManager = new EditorManager(hotInstance, tableMeta, selection);\n    instances.set(hotInstance, editorManager);\n  }\n  return editorManager;\n};\nexport default EditorManager;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}