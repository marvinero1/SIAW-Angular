{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { BaseEditor, EDITOR_STATE } from \"../baseEditor/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { isEdge, isIOS } from \"../../helpers/browser.mjs\";\nimport { addClass, getComputedStyle, isThisHotChild, setCaretPosition, hasClass, removeClass, setAttribute } from \"../../helpers/dom/element.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { createInputElementResizer } from \"../../utils/autoResize.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nimport { SHORTCUTS_GROUP_NAVIGATION } from \"../../editorManager.mjs\";\nimport { SHORTCUTS_GROUP_EDITOR } from \"../baseEditor/baseEditor.mjs\";\nimport { updateCaretPosition } from \"./caretPositioner.mjs\";\nimport { A11Y_HIDDEN, A11Y_TABINDEX } from \"../../helpers/a11y.mjs\";\nconst EDITOR_VISIBLE_CLASS_NAME = 'ht_editor_visible';\nconst EDITOR_HIDDEN_CLASS_NAME = 'ht_editor_hidden';\nconst SHORTCUTS_GROUP = 'textEditor';\nexport const EDITOR_TYPE = 'text';\n\n/**\n * @private\n * @class TextEditor\n */\nexport class TextEditor extends BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * Instance of {@link EventManager}.\n   *\n   * @private\n   * @type {EventManager}\n   */\n\n  /**\n   * @param {Core} hotInstance The Handsontable instance.\n   */\n  constructor(hotInstance) {\n    super(hotInstance);\n    _defineProperty(this, \"eventManager\", new EventManager(this));\n    /**\n     * Autoresize instance. Automagically resizes editor after changes.\n     *\n     * @private\n     * @type {Function}\n     */\n    _defineProperty(this, \"autoResize\", createInputElementResizer(this.hot.rootDocument));\n    /**\n     * An TEXTAREA element.\n     *\n     * @private\n     * @type {HTMLTextAreaElement}\n     */\n    _defineProperty(this, \"TEXTAREA\", void 0);\n    /**\n     * Style declaration object of the TEXTAREA element.\n     *\n     * @private\n     * @type {CSSStyleDeclaration}\n     */\n    _defineProperty(this, \"textareaStyle\", void 0);\n    /**\n     * Parent element of the TEXTAREA.\n     *\n     * @private\n     * @type {HTMLDivElement}\n     */\n    _defineProperty(this, \"TEXTAREA_PARENT\", void 0);\n    /**\n     * Style declaration object of the TEXTAREA_PARENT element.\n     *\n     * @private\n     * @type {CSSStyleDeclaration}\n     */\n    _defineProperty(this, \"textareaParentStyle\", void 0);\n    /**\n     * Z-index class style for the editor.\n     *\n     * @private\n     * @type {string}\n     */\n    _defineProperty(this, \"layerClass\", void 0);\n    this.eventManager = new EventManager(this);\n    this.createElements();\n    this.bindEvents();\n    this.hot.addHookOnce('afterDestroy', () => this.destroy());\n  }\n\n  /**\n   * Gets current value from editable element.\n   *\n   * @returns {number}\n   */\n  getValue() {\n    return this.TEXTAREA.value;\n  }\n\n  /**\n   * Sets new value into editable element.\n   *\n   * @param {*} newValue The editor value.\n   */\n  setValue(newValue) {\n    this.TEXTAREA.value = newValue;\n  }\n\n  /**\n   * Opens the editor and adjust its size.\n   */\n  open() {\n    this.refreshDimensions(); // need it instantly, to prevent https://github.com/handsontable/handsontable/issues/348\n    this.showEditableElement();\n    this.hot.getShortcutManager().setActiveContextName('editor');\n    this.registerShortcuts();\n  }\n\n  /**\n   * Closes the editor.\n   */\n  close() {\n    this.autoResize.unObserve();\n    if (isThisHotChild(this.hot.rootDocument.activeElement, this.hot.rootElement)) {\n      this.hot.listen(); // don't refocus the table if user focused some cell outside of HT on purpose\n    }\n\n    this.hideEditableElement();\n    this.unregisterShortcuts();\n  }\n\n  /**\n   * Prepares editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    const previousState = this.state;\n    super.prepare(row, col, prop, td, value, cellProperties);\n    if (!cellProperties.readOnly) {\n      this.refreshDimensions(true);\n      const {\n        allowInvalid\n      } = cellProperties;\n      if (allowInvalid) {\n        // Remove an empty space from textarea (added by copyPaste plugin to make copy/paste\n        // functionality work with IME)\n        this.TEXTAREA.value = '';\n      }\n      if (previousState !== EDITOR_STATE.FINISHED) {\n        this.hideEditableElement();\n      }\n    }\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The editor initial value.\n   * @param {Event} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    }\n    this.TEXTAREA.value = ''; // Remove an empty space from textarea (added by copyPaste plugin to make copy/paste functionality work with IME).\n    super.beginEditing(newInitialValue, event);\n  }\n\n  /**\n   * Sets focus state on the select element.\n   */\n  focus() {\n    // For IME editor textarea element must be focused using \".select\" method.\n    // Using \".focus\" browser automatically scroll into the focused element which\n    // is undesired effect.\n    this.TEXTAREA.select();\n    setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);\n  }\n\n  /**\n   * Creates an editor's elements and adds necessary CSS classnames.\n   */\n  createElements() {\n    const {\n      rootDocument\n    } = this.hot;\n    this.TEXTAREA = rootDocument.createElement('TEXTAREA');\n\n    // Makes the element recognizable by Hot as its own\n    // component's element.\n    setAttribute(this.TEXTAREA, [['data-hot-input', ''], A11Y_TABINDEX(-1)]);\n    if (this.hot.getSettings().ariaTags) {\n      setAttribute(this.TEXTAREA, [A11Y_HIDDEN()]);\n    }\n    addClass(this.TEXTAREA, 'handsontableInput');\n    this.textareaStyle = this.TEXTAREA.style;\n    this.textareaStyle.width = 0;\n    this.textareaStyle.height = 0;\n    this.textareaStyle.overflowY = 'visible';\n    this.TEXTAREA_PARENT = rootDocument.createElement('DIV');\n    addClass(this.TEXTAREA_PARENT, 'handsontableInputHolder');\n    if (hasClass(this.TEXTAREA_PARENT, this.layerClass)) {\n      removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    }\n    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    this.textareaParentStyle = this.TEXTAREA_PARENT.style;\n    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);\n    this.hot.rootElement.appendChild(this.TEXTAREA_PARENT);\n  }\n\n  /**\n   * Moves an editable element out of the viewport, but element must be able to hold focus for IME support.\n   *\n   * @private\n   */\n  hideEditableElement() {\n    if (isEdge()) {\n      this.textareaStyle.textIndent = '-99999px';\n    }\n    this.textareaStyle.overflowY = 'visible';\n    this.textareaParentStyle.opacity = '0';\n    this.textareaParentStyle.height = '1px';\n    removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n  }\n\n  /**\n   * Resets an editable element position.\n   *\n   * @private\n   */\n  showEditableElement() {\n    this.textareaParentStyle.height = '';\n    this.textareaParentStyle.overflow = '';\n    this.textareaParentStyle.position = '';\n    this.textareaParentStyle[this.hot.isRtl() ? 'left' : 'right'] = 'auto';\n    this.textareaParentStyle.opacity = '1';\n    this.textareaStyle.textIndent = '';\n    this.textareaStyle.overflowY = 'hidden';\n    const childNodes = this.TEXTAREA_PARENT.childNodes;\n    let hasClassHandsontableEditor = false;\n    rangeEach(childNodes.length - 1, index => {\n      const childNode = childNodes[index];\n      if (hasClass(childNode, 'handsontableEditor')) {\n        hasClassHandsontableEditor = true;\n        return false;\n      }\n    });\n    if (hasClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME)) {\n      removeClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    }\n    if (hasClassHandsontableEditor) {\n      this.layerClass = EDITOR_VISIBLE_CLASS_NAME;\n      addClass(this.TEXTAREA_PARENT, this.layerClass);\n    } else {\n      this.layerClass = this.getEditedCellsLayerClass();\n      addClass(this.TEXTAREA_PARENT, this.layerClass);\n    }\n  }\n\n  /**\n   * Refreshes editor's value using source data.\n   *\n   * @private\n   */\n  refreshValue() {\n    const physicalRow = this.hot.toPhysicalRow(this.row);\n    const sourceData = this.hot.getSourceDataAtCell(physicalRow, this.col);\n    this.originalValue = sourceData;\n    this.setValue(sourceData);\n    this.refreshDimensions();\n  }\n\n  /**\n   * Refreshes editor's size and position.\n   *\n   * @private\n   * @param {boolean} force Indicates if the refreshing editor dimensions should be triggered.\n   */\n  refreshDimensions() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.state !== EDITOR_STATE.EDITING && !force) {\n      return;\n    }\n    this.TD = this.getEditedCell();\n\n    // TD is outside of the viewport.\n    if (!this.TD) {\n      if (!force) {\n        this.close(); // TODO shouldn't it be this.finishEditing() ?\n      }\n\n      return;\n    }\n    const {\n      top,\n      start,\n      width,\n      maxWidth,\n      height,\n      maxHeight\n    } = this.getEditedCellRect();\n    this.textareaParentStyle.top = `${top}px`;\n    this.textareaParentStyle[this.hot.isRtl() ? 'right' : 'left'] = `${start}px`;\n    this.showEditableElement();\n    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;\n    this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;\n    this.TEXTAREA.style.backgroundColor = this.TD.style.backgroundColor;\n    const textareaComputedStyle = getComputedStyle(this.TEXTAREA);\n    const horizontalPadding = parseInt(textareaComputedStyle.paddingLeft, 10) + parseInt(textareaComputedStyle.paddingRight, 10);\n    const verticalPadding = parseInt(textareaComputedStyle.paddingTop, 10) + parseInt(textareaComputedStyle.paddingBottom, 10);\n    const finalWidth = width - horizontalPadding;\n    const finalHeight = height - verticalPadding;\n    const finalMaxWidth = maxWidth - horizontalPadding;\n    const finalMaxHeight = maxHeight - verticalPadding;\n    this.autoResize.init(this.TEXTAREA, {\n      minWidth: Math.min(finalWidth, finalMaxWidth),\n      minHeight: Math.min(finalHeight, finalMaxHeight),\n      // TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)\n      maxWidth: finalMaxWidth,\n      maxHeight: finalMaxHeight\n    }, true);\n  }\n\n  /**\n   * Binds events and hooks.\n   *\n   * @private\n   */\n  bindEvents() {\n    if (isIOS()) {\n      // on iOS after click \"Done\" the edit isn't hidden by default, so we need to handle it manually.\n      this.eventManager.addEventListener(this.TEXTAREA, 'focusout', () => this.finishEditing(false));\n    }\n    this.addHook('afterScrollHorizontally', () => this.refreshDimensions());\n    this.addHook('afterScrollVertically', () => this.refreshDimensions());\n    this.addHook('afterColumnResize', () => {\n      this.refreshDimensions();\n      if (this.state === EDITOR_STATE.EDITING) {\n        this.focus();\n      }\n    });\n    this.addHook('afterRowResize', () => {\n      this.refreshDimensions();\n      if (this.state === EDITOR_STATE.EDITING) {\n        this.focus();\n      }\n    });\n  }\n\n  /**\n   * Ugly hack for autocompleteEditor.\n   *\n   * @private\n   */\n  allowKeyEventPropagation() {}\n\n  /**\n   * Destroys the internal event manager and clears attached hooks.\n   *\n   * @private\n   */\n  destroy() {\n    this.eventManager.destroy();\n    this.clearHooks();\n  }\n\n  /**\n   * Register shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    const gridContext = shortcutManager.getContext('grid');\n    const contextConfig = {\n      runOnlyIf: () => isDefined(this.hot.getSelected()),\n      group: SHORTCUTS_GROUP\n    };\n    const insertNewLine = () => {\n      this.hot.rootDocument.execCommand('insertText', false, '\\n');\n    };\n    editorContext.addShortcuts([{\n      keys: [['Tab'], ['Shift', 'Tab'], ['PageUp'], ['PageDown']],\n      forwardToContext: gridContext,\n      callback: () => {}\n    }, {\n      keys: [['Control', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      },\n\n      runOnlyIf: event => !this.hot.selection.isMultiple() &&\n      // We trigger a data population for multiple selection.\n      // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n      !event.altKey\n    }, {\n      keys: [['Meta', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      },\n\n      runOnlyIf: () => !this.hot.selection.isMultiple() // We trigger a data population for multiple selection.\n    }, {\n      keys: [['Alt', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      }\n    }, {\n      keys: [['Home']],\n      callback: (event, _ref) => {\n        let [keyName] = _ref;\n        updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }, {\n      keys: [['End']],\n      callback: (event, _ref2) => {\n        let [keyName] = _ref2;\n        updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }], contextConfig);\n  }\n\n  /**\n   * Unregister shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR);\n  }\n}","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","BaseEditor","EDITOR_STATE","EventManager","isEdge","isIOS","addClass","getComputedStyle","isThisHotChild","setCaretPosition","hasClass","removeClass","setAttribute","rangeEach","createInputElementResizer","isDefined","SHORTCUTS_GROUP_NAVIGATION","SHORTCUTS_GROUP_EDITOR","updateCaretPosition","A11Y_HIDDEN","A11Y_TABINDEX","EDITOR_VISIBLE_CLASS_NAME","EDITOR_HIDDEN_CLASS_NAME","SHORTCUTS_GROUP","EDITOR_TYPE","TextEditor","constructor","hotInstance","hot","rootDocument","eventManager","createElements","bindEvents","addHookOnce","destroy","getValue","TEXTAREA","setValue","newValue","open","refreshDimensions","showEditableElement","getShortcutManager","setActiveContextName","registerShortcuts","close","autoResize","unObserve","activeElement","rootElement","listen","hideEditableElement","unregisterShortcuts","prepare","row","col","prop","td","cellProperties","previousState","state","readOnly","allowInvalid","FINISHED","beginEditing","newInitialValue","event","VIRGIN","focus","select","length","createElement","getSettings","ariaTags","textareaStyle","style","width","height","overflowY","TEXTAREA_PARENT","layerClass","textareaParentStyle","appendChild","textIndent","opacity","overflow","position","isRtl","childNodes","hasClassHandsontableEditor","index","childNode","getEditedCellsLayerClass","refreshValue","physicalRow","toPhysicalRow","sourceData","getSourceDataAtCell","originalValue","force","arguments","undefined","EDITING","TD","getEditedCell","top","start","maxWidth","maxHeight","getEditedCellRect","cellComputedStyle","rootWindow","fontSize","fontFamily","backgroundColor","textareaComputedStyle","horizontalPadding","parseInt","paddingLeft","paddingRight","verticalPadding","paddingTop","paddingBottom","finalWidth","finalHeight","finalMaxWidth","finalMaxHeight","init","minWidth","Math","min","minHeight","addEventListener","finishEditing","addHook","allowKeyEventPropagation","clearHooks","shortcutManager","editorContext","getContext","gridContext","contextConfig","runOnlyIf","getSelected","group","insertNewLine","execCommand","addShortcuts","keys","forwardToContext","callback","selection","isMultiple","altKey","_ref","keyName","_ref2","removeShortcutsByGroup"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/editors/textEditor/textEditor.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { BaseEditor, EDITOR_STATE } from \"../baseEditor/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { isEdge, isIOS } from \"../../helpers/browser.mjs\";\nimport { addClass, getComputedStyle, isThisHotChild, setCaretPosition, hasClass, removeClass, setAttribute } from \"../../helpers/dom/element.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { createInputElementResizer } from \"../../utils/autoResize.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nimport { SHORTCUTS_GROUP_NAVIGATION } from \"../../editorManager.mjs\";\nimport { SHORTCUTS_GROUP_EDITOR } from \"../baseEditor/baseEditor.mjs\";\nimport { updateCaretPosition } from \"./caretPositioner.mjs\";\nimport { A11Y_HIDDEN, A11Y_TABINDEX } from \"../../helpers/a11y.mjs\";\nconst EDITOR_VISIBLE_CLASS_NAME = 'ht_editor_visible';\nconst EDITOR_HIDDEN_CLASS_NAME = 'ht_editor_hidden';\nconst SHORTCUTS_GROUP = 'textEditor';\nexport const EDITOR_TYPE = 'text';\n\n/**\n * @private\n * @class TextEditor\n */\nexport class TextEditor extends BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * Instance of {@link EventManager}.\n   *\n   * @private\n   * @type {EventManager}\n   */\n\n  /**\n   * @param {Core} hotInstance The Handsontable instance.\n   */\n  constructor(hotInstance) {\n    super(hotInstance);\n    _defineProperty(this, \"eventManager\", new EventManager(this));\n    /**\n     * Autoresize instance. Automagically resizes editor after changes.\n     *\n     * @private\n     * @type {Function}\n     */\n    _defineProperty(this, \"autoResize\", createInputElementResizer(this.hot.rootDocument));\n    /**\n     * An TEXTAREA element.\n     *\n     * @private\n     * @type {HTMLTextAreaElement}\n     */\n    _defineProperty(this, \"TEXTAREA\", void 0);\n    /**\n     * Style declaration object of the TEXTAREA element.\n     *\n     * @private\n     * @type {CSSStyleDeclaration}\n     */\n    _defineProperty(this, \"textareaStyle\", void 0);\n    /**\n     * Parent element of the TEXTAREA.\n     *\n     * @private\n     * @type {HTMLDivElement}\n     */\n    _defineProperty(this, \"TEXTAREA_PARENT\", void 0);\n    /**\n     * Style declaration object of the TEXTAREA_PARENT element.\n     *\n     * @private\n     * @type {CSSStyleDeclaration}\n     */\n    _defineProperty(this, \"textareaParentStyle\", void 0);\n    /**\n     * Z-index class style for the editor.\n     *\n     * @private\n     * @type {string}\n     */\n    _defineProperty(this, \"layerClass\", void 0);\n    this.eventManager = new EventManager(this);\n    this.createElements();\n    this.bindEvents();\n    this.hot.addHookOnce('afterDestroy', () => this.destroy());\n  }\n\n  /**\n   * Gets current value from editable element.\n   *\n   * @returns {number}\n   */\n  getValue() {\n    return this.TEXTAREA.value;\n  }\n\n  /**\n   * Sets new value into editable element.\n   *\n   * @param {*} newValue The editor value.\n   */\n  setValue(newValue) {\n    this.TEXTAREA.value = newValue;\n  }\n\n  /**\n   * Opens the editor and adjust its size.\n   */\n  open() {\n    this.refreshDimensions(); // need it instantly, to prevent https://github.com/handsontable/handsontable/issues/348\n    this.showEditableElement();\n    this.hot.getShortcutManager().setActiveContextName('editor');\n    this.registerShortcuts();\n  }\n\n  /**\n   * Closes the editor.\n   */\n  close() {\n    this.autoResize.unObserve();\n    if (isThisHotChild(this.hot.rootDocument.activeElement, this.hot.rootElement)) {\n      this.hot.listen(); // don't refocus the table if user focused some cell outside of HT on purpose\n    }\n    this.hideEditableElement();\n    this.unregisterShortcuts();\n  }\n\n  /**\n   * Prepares editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    const previousState = this.state;\n    super.prepare(row, col, prop, td, value, cellProperties);\n    if (!cellProperties.readOnly) {\n      this.refreshDimensions(true);\n      const {\n        allowInvalid\n      } = cellProperties;\n      if (allowInvalid) {\n        // Remove an empty space from textarea (added by copyPaste plugin to make copy/paste\n        // functionality work with IME)\n        this.TEXTAREA.value = '';\n      }\n      if (previousState !== EDITOR_STATE.FINISHED) {\n        this.hideEditableElement();\n      }\n    }\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The editor initial value.\n   * @param {Event} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    }\n    this.TEXTAREA.value = ''; // Remove an empty space from textarea (added by copyPaste plugin to make copy/paste functionality work with IME).\n    super.beginEditing(newInitialValue, event);\n  }\n\n  /**\n   * Sets focus state on the select element.\n   */\n  focus() {\n    // For IME editor textarea element must be focused using \".select\" method.\n    // Using \".focus\" browser automatically scroll into the focused element which\n    // is undesired effect.\n    this.TEXTAREA.select();\n    setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);\n  }\n\n  /**\n   * Creates an editor's elements and adds necessary CSS classnames.\n   */\n  createElements() {\n    const {\n      rootDocument\n    } = this.hot;\n    this.TEXTAREA = rootDocument.createElement('TEXTAREA');\n\n    // Makes the element recognizable by Hot as its own\n    // component's element.\n    setAttribute(this.TEXTAREA, [['data-hot-input', ''], A11Y_TABINDEX(-1)]);\n    if (this.hot.getSettings().ariaTags) {\n      setAttribute(this.TEXTAREA, [A11Y_HIDDEN()]);\n    }\n    addClass(this.TEXTAREA, 'handsontableInput');\n    this.textareaStyle = this.TEXTAREA.style;\n    this.textareaStyle.width = 0;\n    this.textareaStyle.height = 0;\n    this.textareaStyle.overflowY = 'visible';\n    this.TEXTAREA_PARENT = rootDocument.createElement('DIV');\n    addClass(this.TEXTAREA_PARENT, 'handsontableInputHolder');\n    if (hasClass(this.TEXTAREA_PARENT, this.layerClass)) {\n      removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    }\n    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    this.textareaParentStyle = this.TEXTAREA_PARENT.style;\n    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);\n    this.hot.rootElement.appendChild(this.TEXTAREA_PARENT);\n  }\n\n  /**\n   * Moves an editable element out of the viewport, but element must be able to hold focus for IME support.\n   *\n   * @private\n   */\n  hideEditableElement() {\n    if (isEdge()) {\n      this.textareaStyle.textIndent = '-99999px';\n    }\n    this.textareaStyle.overflowY = 'visible';\n    this.textareaParentStyle.opacity = '0';\n    this.textareaParentStyle.height = '1px';\n    removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n  }\n\n  /**\n   * Resets an editable element position.\n   *\n   * @private\n   */\n  showEditableElement() {\n    this.textareaParentStyle.height = '';\n    this.textareaParentStyle.overflow = '';\n    this.textareaParentStyle.position = '';\n    this.textareaParentStyle[this.hot.isRtl() ? 'left' : 'right'] = 'auto';\n    this.textareaParentStyle.opacity = '1';\n    this.textareaStyle.textIndent = '';\n    this.textareaStyle.overflowY = 'hidden';\n    const childNodes = this.TEXTAREA_PARENT.childNodes;\n    let hasClassHandsontableEditor = false;\n    rangeEach(childNodes.length - 1, index => {\n      const childNode = childNodes[index];\n      if (hasClass(childNode, 'handsontableEditor')) {\n        hasClassHandsontableEditor = true;\n        return false;\n      }\n    });\n    if (hasClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME)) {\n      removeClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    }\n    if (hasClassHandsontableEditor) {\n      this.layerClass = EDITOR_VISIBLE_CLASS_NAME;\n      addClass(this.TEXTAREA_PARENT, this.layerClass);\n    } else {\n      this.layerClass = this.getEditedCellsLayerClass();\n      addClass(this.TEXTAREA_PARENT, this.layerClass);\n    }\n  }\n\n  /**\n   * Refreshes editor's value using source data.\n   *\n   * @private\n   */\n  refreshValue() {\n    const physicalRow = this.hot.toPhysicalRow(this.row);\n    const sourceData = this.hot.getSourceDataAtCell(physicalRow, this.col);\n    this.originalValue = sourceData;\n    this.setValue(sourceData);\n    this.refreshDimensions();\n  }\n\n  /**\n   * Refreshes editor's size and position.\n   *\n   * @private\n   * @param {boolean} force Indicates if the refreshing editor dimensions should be triggered.\n   */\n  refreshDimensions() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.state !== EDITOR_STATE.EDITING && !force) {\n      return;\n    }\n    this.TD = this.getEditedCell();\n\n    // TD is outside of the viewport.\n    if (!this.TD) {\n      if (!force) {\n        this.close(); // TODO shouldn't it be this.finishEditing() ?\n      }\n      return;\n    }\n    const {\n      top,\n      start,\n      width,\n      maxWidth,\n      height,\n      maxHeight\n    } = this.getEditedCellRect();\n    this.textareaParentStyle.top = `${top}px`;\n    this.textareaParentStyle[this.hot.isRtl() ? 'right' : 'left'] = `${start}px`;\n    this.showEditableElement();\n    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;\n    this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;\n    this.TEXTAREA.style.backgroundColor = this.TD.style.backgroundColor;\n    const textareaComputedStyle = getComputedStyle(this.TEXTAREA);\n    const horizontalPadding = parseInt(textareaComputedStyle.paddingLeft, 10) + parseInt(textareaComputedStyle.paddingRight, 10);\n    const verticalPadding = parseInt(textareaComputedStyle.paddingTop, 10) + parseInt(textareaComputedStyle.paddingBottom, 10);\n    const finalWidth = width - horizontalPadding;\n    const finalHeight = height - verticalPadding;\n    const finalMaxWidth = maxWidth - horizontalPadding;\n    const finalMaxHeight = maxHeight - verticalPadding;\n    this.autoResize.init(this.TEXTAREA, {\n      minWidth: Math.min(finalWidth, finalMaxWidth),\n      minHeight: Math.min(finalHeight, finalMaxHeight),\n      // TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)\n      maxWidth: finalMaxWidth,\n      maxHeight: finalMaxHeight\n    }, true);\n  }\n\n  /**\n   * Binds events and hooks.\n   *\n   * @private\n   */\n  bindEvents() {\n    if (isIOS()) {\n      // on iOS after click \"Done\" the edit isn't hidden by default, so we need to handle it manually.\n      this.eventManager.addEventListener(this.TEXTAREA, 'focusout', () => this.finishEditing(false));\n    }\n    this.addHook('afterScrollHorizontally', () => this.refreshDimensions());\n    this.addHook('afterScrollVertically', () => this.refreshDimensions());\n    this.addHook('afterColumnResize', () => {\n      this.refreshDimensions();\n      if (this.state === EDITOR_STATE.EDITING) {\n        this.focus();\n      }\n    });\n    this.addHook('afterRowResize', () => {\n      this.refreshDimensions();\n      if (this.state === EDITOR_STATE.EDITING) {\n        this.focus();\n      }\n    });\n  }\n\n  /**\n   * Ugly hack for autocompleteEditor.\n   *\n   * @private\n   */\n  allowKeyEventPropagation() {}\n\n  /**\n   * Destroys the internal event manager and clears attached hooks.\n   *\n   * @private\n   */\n  destroy() {\n    this.eventManager.destroy();\n    this.clearHooks();\n  }\n\n  /**\n   * Register shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    const gridContext = shortcutManager.getContext('grid');\n    const contextConfig = {\n      runOnlyIf: () => isDefined(this.hot.getSelected()),\n      group: SHORTCUTS_GROUP\n    };\n    const insertNewLine = () => {\n      this.hot.rootDocument.execCommand('insertText', false, '\\n');\n    };\n    editorContext.addShortcuts([{\n      keys: [['Tab'], ['Shift', 'Tab'], ['PageUp'], ['PageDown']],\n      forwardToContext: gridContext,\n      callback: () => {}\n    }, {\n      keys: [['Control', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      },\n      runOnlyIf: event => !this.hot.selection.isMultiple() &&\n      // We trigger a data population for multiple selection.\n      // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n      !event.altKey\n    }, {\n      keys: [['Meta', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      },\n      runOnlyIf: () => !this.hot.selection.isMultiple() // We trigger a data population for multiple selection.\n    }, {\n      keys: [['Alt', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      }\n    }, {\n      keys: [['Home']],\n      callback: (event, _ref) => {\n        let [keyName] = _ref;\n        updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }, {\n      keys: [['End']],\n      callback: (event, _ref2) => {\n        let [keyName] = _ref2;\n        updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }], contextConfig);\n  }\n\n  /**\n   * Unregister shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}