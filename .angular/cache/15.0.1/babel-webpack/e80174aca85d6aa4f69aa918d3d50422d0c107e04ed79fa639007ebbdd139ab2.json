{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { baseRenderer } from \"../baseRenderer/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { empty, addClass, setAttribute } from \"../../helpers/dom/element.mjs\";\nimport { isEmpty, stringify } from \"../../helpers/mixed.mjs\";\nimport { EDITOR_EDIT_GROUP as SHORTCUTS_GROUP_EDITOR } from \"../../shortcutContexts/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { A11Y_CHECKBOX, A11Y_CHECKED, A11Y_LABEL } from \"../../helpers/a11y.mjs\";\nimport { CHECKBOX_CHECKED, CHECKBOX_UNCHECKED } from \"../../i18n/constants.mjs\";\nconst isListeningKeyDownEvent = new WeakMap();\nconst isCheckboxListenerAdded = new WeakMap();\nconst BAD_VALUE_CLASS = 'htBadValue';\nconst ATTR_ROW = 'data-row';\nconst ATTR_COLUMN = 'data-col';\nconst SHORTCUTS_GROUP = 'checkboxRenderer';\nexport const RENDERER_TYPE = 'checkbox';\nHooks.getSingleton().add('modifyAutoColumnSizeSeed', function (bundleSeed, cellMeta, cellValue) {\n  const {\n    label,\n    type,\n    row,\n    column,\n    prop\n  } = cellMeta;\n  if (type !== RENDERER_TYPE) {\n    return;\n  }\n  if (label) {\n    const {\n      value: labelValue,\n      property: labelProperty\n    } = label;\n    let labelText = cellValue;\n    if (labelValue) {\n      labelText = typeof labelValue === 'function' ? labelValue(row, column, prop, cellValue) : labelValue;\n    } else if (labelProperty) {\n      const labelData = this.getDataAtRowProp(row, labelProperty);\n      labelText = labelData !== null ? labelData : cellValue;\n    }\n    bundleSeed = labelText;\n  }\n  return bundleSeed;\n});\n/**\n * Checkbox renderer.\n *\n * @private\n * @param {Core} hotInstance The Handsontable instance.\n * @param {HTMLTableCellElement} TD The rendered cell element.\n * @param {number} row The visual row index.\n * @param {number} col The visual column index.\n * @param {number|string} prop The column property (passed when datasource is an array of objects).\n * @param {*} value The rendered value.\n * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).\n */\nexport function checkboxRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {\n  const {\n    rootDocument\n  } = hotInstance;\n  const ariaEnabled = hotInstance.getSettings().ariaTags;\n  baseRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);\n  registerEvents(hotInstance);\n  let input = createInput(rootDocument);\n  const labelOptions = cellProperties.label;\n  let badValue = false;\n  if (typeof cellProperties.checkedTemplate === 'undefined') {\n    cellProperties.checkedTemplate = true;\n  }\n  if (typeof cellProperties.uncheckedTemplate === 'undefined') {\n    cellProperties.uncheckedTemplate = false;\n  }\n  empty(TD); // TODO identify under what circumstances this line can be removed\n\n  if (value === cellProperties.checkedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.checkedTemplate).toLocaleLowerCase(cellProperties.locale)) {\n    input.checked = true;\n  } else if (value === cellProperties.uncheckedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.uncheckedTemplate).toLocaleLowerCase(cellProperties.locale)) {\n    input.checked = false;\n  } else if (isEmpty(value)) {\n    // default value\n    addClass(input, 'noValue');\n  } else {\n    input.style.display = 'none';\n    addClass(input, BAD_VALUE_CLASS);\n    badValue = true;\n  }\n  setAttribute(input, [[ATTR_ROW, row], [ATTR_COLUMN, col]]);\n  if (ariaEnabled) {\n    setAttribute(input, [A11Y_LABEL(input.checked ? hotInstance.getTranslatedPhrase(CHECKBOX_CHECKED) : hotInstance.getTranslatedPhrase(CHECKBOX_UNCHECKED)), A11Y_CHECKED(input.checked), A11Y_CHECKBOX()]);\n  }\n  if (!badValue && labelOptions) {\n    let labelText = '';\n    if (labelOptions.value) {\n      labelText = typeof labelOptions.value === 'function' ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;\n    } else if (labelOptions.property) {\n      const labelValue = hotInstance.getDataAtRowProp(row, labelOptions.property);\n      labelText = labelValue !== null ? labelValue : '';\n    }\n    const label = createLabel(rootDocument, labelText, labelOptions.separated !== true);\n    if (labelOptions.position === 'before') {\n      if (labelOptions.separated) {\n        TD.appendChild(label);\n        TD.appendChild(input);\n      } else {\n        label.appendChild(input);\n        input = label;\n      }\n    } else if (!labelOptions.position || labelOptions.position === 'after') {\n      if (labelOptions.separated) {\n        TD.appendChild(input);\n        TD.appendChild(label);\n      } else {\n        label.insertBefore(input, label.firstChild);\n        input = label;\n      }\n    }\n  }\n  if (!labelOptions || labelOptions && !labelOptions.separated) {\n    TD.appendChild(input);\n  }\n  if (badValue) {\n    TD.appendChild(rootDocument.createTextNode('#bad-value#'));\n  }\n  if (!isListeningKeyDownEvent.has(hotInstance)) {\n    isListeningKeyDownEvent.set(hotInstance, true);\n    registerShortcuts();\n  }\n\n  /**\n   * Register shortcuts responsible for toggling checkbox state.\n   *\n   * @private\n   */\n  function registerShortcuts() {\n    const shortcutManager = hotInstance.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    const config = {\n      group: SHORTCUTS_GROUP\n    };\n    gridContext.addShortcuts([{\n      keys: [['space']],\n      callback: () => {\n        changeSelectedCheckboxesState();\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      }\n    }, {\n      keys: [['enter']],\n      callback: () => {\n        changeSelectedCheckboxesState();\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      },\n\n      runOnlyIf: () => hotInstance.getSettings().enterBeginsEditing\n    }, {\n      keys: [['delete'], ['backspace']],\n      callback: () => {\n        changeSelectedCheckboxesState(true);\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      },\n\n      relativeToGroup: SHORTCUTS_GROUP_EDITOR,\n      position: 'before'\n    }], config);\n  }\n\n  /**\n   * Change checkbox checked property.\n   *\n   * @private\n   * @param {boolean} [uncheckCheckbox=false] The new \"checked\" state for the checkbox elements.\n   */\n  function changeSelectedCheckboxesState() {\n    let uncheckCheckbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const selRange = hotInstance.getSelectedRange();\n    if (!selRange) {\n      return;\n    }\n    for (let key = 0; key < selRange.length; key++) {\n      const {\n        row: startRow,\n        col: startColumn\n      } = selRange[key].getTopStartCorner();\n      const {\n        row: endRow,\n        col: endColumn\n      } = selRange[key].getBottomEndCorner();\n      const changes = [];\n      for (let visualRow = startRow; visualRow <= endRow; visualRow += 1) {\n        for (let visualColumn = startColumn; visualColumn <= endColumn; visualColumn += 1) {\n          const cachedCellProperties = hotInstance.getCellMeta(visualRow, visualColumn);\n          if (cachedCellProperties.type !== 'checkbox') {\n            return;\n          }\n\n          /* eslint-disable no-continue */\n          if (cachedCellProperties.readOnly === true) {\n            continue;\n          }\n          if (typeof cachedCellProperties.checkedTemplate === 'undefined') {\n            cachedCellProperties.checkedTemplate = true;\n          }\n          if (typeof cachedCellProperties.uncheckedTemplate === 'undefined') {\n            cachedCellProperties.uncheckedTemplate = false;\n          }\n          const dataAtCell = hotInstance.getDataAtCell(visualRow, visualColumn);\n          if (uncheckCheckbox === false) {\n            if ([cachedCellProperties.checkedTemplate, cachedCellProperties.checkedTemplate.toString()].includes(dataAtCell)) {\n              // eslint-disable-line max-len\n              changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);\n            } else if ([cachedCellProperties.uncheckedTemplate, cachedCellProperties.uncheckedTemplate.toString(), null, undefined].includes(dataAtCell)) {\n              // eslint-disable-line max-len\n              changes.push([visualRow, visualColumn, cachedCellProperties.checkedTemplate]);\n            }\n          } else {\n            changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);\n          }\n        }\n      }\n      if (changes.length > 0) {\n        hotInstance.setDataAtCell(changes);\n      }\n    }\n  }\n\n  /**\n   * Check whether all selected cells are with checkbox type.\n   *\n   * @returns {boolean}\n   * @private\n   */\n  function areSelectedCheckboxCells() {\n    const selRange = hotInstance.getSelectedRange();\n    if (!selRange) {\n      return;\n    }\n    for (let key = 0; key < selRange.length; key++) {\n      const topLeft = selRange[key].getTopStartCorner();\n      const bottomRight = selRange[key].getBottomEndCorner();\n      for (let visualRow = topLeft.row; visualRow <= bottomRight.row; visualRow++) {\n        for (let visualColumn = topLeft.col; visualColumn <= bottomRight.col; visualColumn++) {\n          const cachedCellProperties = hotInstance.getCellMeta(visualRow, visualColumn);\n          if (cachedCellProperties.type !== 'checkbox') {\n            return false;\n          }\n          const cell = hotInstance.getCell(visualRow, visualColumn);\n          if (cell === null || cell === undefined) {\n            return true;\n          } else {\n            const checkboxes = cell.querySelectorAll('input[type=checkbox]');\n            if (checkboxes.length > 0 && !cachedCellProperties.readOnly) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n}\ncheckboxRenderer.RENDERER_TYPE = RENDERER_TYPE;\n\n/**\n * Register checkbox listeners.\n *\n * @param {Core} instance The Handsontable instance.\n * @returns {EventManager}\n */\nfunction registerEvents(instance) {\n  let eventManager = isCheckboxListenerAdded.get(instance);\n  if (!eventManager) {\n    const {\n      rootElement\n    } = instance;\n    eventManager = new EventManager(instance);\n    eventManager.addEventListener(rootElement, 'click', event => onClick(event, instance));\n    eventManager.addEventListener(rootElement, 'mouseup', event => onMouseUp(event, instance));\n    eventManager.addEventListener(rootElement, 'change', event => onChange(event, instance));\n    isCheckboxListenerAdded.set(instance, eventManager);\n  }\n  return eventManager;\n}\n\n/**\n * Create input element.\n *\n * @param {Document} rootDocument The document owner.\n * @returns {Node}\n */\nfunction createInput(rootDocument) {\n  const input = rootDocument.createElement('input');\n  input.className = 'htCheckboxRendererInput';\n  input.type = 'checkbox';\n  input.setAttribute('tabindex', '-1');\n  return input.cloneNode(false);\n}\n\n/**\n * Create label element.\n *\n * @param {Document} rootDocument The document owner.\n * @param {string} text The label text.\n * @param {boolean} fullWidth Determines whether label should have full width.\n * @returns {Node}\n */\nfunction createLabel(rootDocument, text, fullWidth) {\n  const label = rootDocument.createElement('label');\n  label.className = `htCheckboxRendererLabel ${fullWidth ? 'fullWidth' : ''}`;\n  label.appendChild(rootDocument.createTextNode(text));\n  return label.cloneNode(true);\n}\n\n/**\n * `mouseup` callback.\n *\n * @private\n * @param {Event} event `mouseup` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onMouseUp(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  setTimeout(instance.listen, 10);\n}\n\n/**\n * `click` callback.\n *\n * @private\n * @param {MouseEvent} event `click` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onClick(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  const row = parseInt(target.getAttribute(ATTR_ROW), 10);\n  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);\n  const cellProperties = instance.getCellMeta(row, col);\n  if (cellProperties.readOnly) {\n    event.preventDefault();\n  }\n}\n\n/**\n * `change` callback.\n *\n * @param {Event} event `change` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onChange(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  const row = parseInt(target.getAttribute(ATTR_ROW), 10);\n  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);\n  const cellProperties = instance.getCellMeta(row, col);\n  if (!cellProperties.readOnly) {\n    let newCheckboxValue = null;\n    if (event.target.checked) {\n      newCheckboxValue = cellProperties.uncheckedTemplate === undefined ? true : cellProperties.checkedTemplate;\n    } else {\n      newCheckboxValue = cellProperties.uncheckedTemplate === undefined ? false : cellProperties.uncheckedTemplate;\n    }\n    instance.setDataAtCell(row, col, newCheckboxValue);\n  }\n}\n\n/**\n * Check if the provided element is the checkbox input.\n *\n * @private\n * @param {HTMLElement} element The element in question.\n * @returns {boolean}\n */\nfunction isCheckboxInput(element) {\n  return element.tagName === 'INPUT' && element.getAttribute('type') === 'checkbox';\n}","map":{"version":3,"names":["baseRenderer","EventManager","empty","addClass","setAttribute","isEmpty","stringify","EDITOR_EDIT_GROUP","SHORTCUTS_GROUP_EDITOR","Hooks","A11Y_CHECKBOX","A11Y_CHECKED","A11Y_LABEL","CHECKBOX_CHECKED","CHECKBOX_UNCHECKED","isListeningKeyDownEvent","WeakMap","isCheckboxListenerAdded","BAD_VALUE_CLASS","ATTR_ROW","ATTR_COLUMN","SHORTCUTS_GROUP","RENDERER_TYPE","getSingleton","add","bundleSeed","cellMeta","cellValue","label","type","row","column","prop","value","labelValue","property","labelProperty","labelText","labelData","getDataAtRowProp","checkboxRenderer","hotInstance","TD","col","cellProperties","rootDocument","ariaEnabled","getSettings","ariaTags","apply","registerEvents","input","createInput","labelOptions","badValue","checkedTemplate","uncheckedTemplate","toLocaleLowerCase","locale","checked","style","display","getTranslatedPhrase","call","createLabel","separated","position","appendChild","insertBefore","firstChild","createTextNode","has","set","registerShortcuts","shortcutManager","getShortcutManager","gridContext","getContext","config","group","addShortcuts","keys","callback","changeSelectedCheckboxesState","areSelectedCheckboxCells","runOnlyIf","enterBeginsEditing","relativeToGroup","uncheckCheckbox","arguments","length","undefined","selRange","getSelectedRange","key","startRow","startColumn","getTopStartCorner","endRow","endColumn","getBottomEndCorner","changes","visualRow","visualColumn","cachedCellProperties","getCellMeta","readOnly","dataAtCell","getDataAtCell","toString","includes","push","setDataAtCell","topLeft","bottomRight","cell","getCell","checkboxes","querySelectorAll","instance","eventManager","get","rootElement","addEventListener","event","onClick","onMouseUp","onChange","createElement","className","cloneNode","text","fullWidth","target","isCheckboxInput","hasAttribute","setTimeout","listen","parseInt","getAttribute","preventDefault","newCheckboxValue","element","tagName"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/renderers/checkboxRenderer/checkboxRenderer.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport { baseRenderer } from \"../baseRenderer/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { empty, addClass, setAttribute } from \"../../helpers/dom/element.mjs\";\nimport { isEmpty, stringify } from \"../../helpers/mixed.mjs\";\nimport { EDITOR_EDIT_GROUP as SHORTCUTS_GROUP_EDITOR } from \"../../shortcutContexts/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { A11Y_CHECKBOX, A11Y_CHECKED, A11Y_LABEL } from \"../../helpers/a11y.mjs\";\nimport { CHECKBOX_CHECKED, CHECKBOX_UNCHECKED } from \"../../i18n/constants.mjs\";\nconst isListeningKeyDownEvent = new WeakMap();\nconst isCheckboxListenerAdded = new WeakMap();\nconst BAD_VALUE_CLASS = 'htBadValue';\nconst ATTR_ROW = 'data-row';\nconst ATTR_COLUMN = 'data-col';\nconst SHORTCUTS_GROUP = 'checkboxRenderer';\nexport const RENDERER_TYPE = 'checkbox';\nHooks.getSingleton().add('modifyAutoColumnSizeSeed', function (bundleSeed, cellMeta, cellValue) {\n  const {\n    label,\n    type,\n    row,\n    column,\n    prop\n  } = cellMeta;\n  if (type !== RENDERER_TYPE) {\n    return;\n  }\n  if (label) {\n    const {\n      value: labelValue,\n      property: labelProperty\n    } = label;\n    let labelText = cellValue;\n    if (labelValue) {\n      labelText = typeof labelValue === 'function' ? labelValue(row, column, prop, cellValue) : labelValue;\n    } else if (labelProperty) {\n      const labelData = this.getDataAtRowProp(row, labelProperty);\n      labelText = labelData !== null ? labelData : cellValue;\n    }\n    bundleSeed = labelText;\n  }\n  return bundleSeed;\n});\n/**\n * Checkbox renderer.\n *\n * @private\n * @param {Core} hotInstance The Handsontable instance.\n * @param {HTMLTableCellElement} TD The rendered cell element.\n * @param {number} row The visual row index.\n * @param {number} col The visual column index.\n * @param {number|string} prop The column property (passed when datasource is an array of objects).\n * @param {*} value The rendered value.\n * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).\n */\nexport function checkboxRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {\n  const {\n    rootDocument\n  } = hotInstance;\n  const ariaEnabled = hotInstance.getSettings().ariaTags;\n  baseRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);\n  registerEvents(hotInstance);\n  let input = createInput(rootDocument);\n  const labelOptions = cellProperties.label;\n  let badValue = false;\n  if (typeof cellProperties.checkedTemplate === 'undefined') {\n    cellProperties.checkedTemplate = true;\n  }\n  if (typeof cellProperties.uncheckedTemplate === 'undefined') {\n    cellProperties.uncheckedTemplate = false;\n  }\n  empty(TD); // TODO identify under what circumstances this line can be removed\n\n  if (value === cellProperties.checkedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.checkedTemplate).toLocaleLowerCase(cellProperties.locale)) {\n    input.checked = true;\n  } else if (value === cellProperties.uncheckedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.uncheckedTemplate).toLocaleLowerCase(cellProperties.locale)) {\n    input.checked = false;\n  } else if (isEmpty(value)) {\n    // default value\n    addClass(input, 'noValue');\n  } else {\n    input.style.display = 'none';\n    addClass(input, BAD_VALUE_CLASS);\n    badValue = true;\n  }\n  setAttribute(input, [[ATTR_ROW, row], [ATTR_COLUMN, col]]);\n  if (ariaEnabled) {\n    setAttribute(input, [A11Y_LABEL(input.checked ? hotInstance.getTranslatedPhrase(CHECKBOX_CHECKED) : hotInstance.getTranslatedPhrase(CHECKBOX_UNCHECKED)), A11Y_CHECKED(input.checked), A11Y_CHECKBOX()]);\n  }\n  if (!badValue && labelOptions) {\n    let labelText = '';\n    if (labelOptions.value) {\n      labelText = typeof labelOptions.value === 'function' ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;\n    } else if (labelOptions.property) {\n      const labelValue = hotInstance.getDataAtRowProp(row, labelOptions.property);\n      labelText = labelValue !== null ? labelValue : '';\n    }\n    const label = createLabel(rootDocument, labelText, labelOptions.separated !== true);\n    if (labelOptions.position === 'before') {\n      if (labelOptions.separated) {\n        TD.appendChild(label);\n        TD.appendChild(input);\n      } else {\n        label.appendChild(input);\n        input = label;\n      }\n    } else if (!labelOptions.position || labelOptions.position === 'after') {\n      if (labelOptions.separated) {\n        TD.appendChild(input);\n        TD.appendChild(label);\n      } else {\n        label.insertBefore(input, label.firstChild);\n        input = label;\n      }\n    }\n  }\n  if (!labelOptions || labelOptions && !labelOptions.separated) {\n    TD.appendChild(input);\n  }\n  if (badValue) {\n    TD.appendChild(rootDocument.createTextNode('#bad-value#'));\n  }\n  if (!isListeningKeyDownEvent.has(hotInstance)) {\n    isListeningKeyDownEvent.set(hotInstance, true);\n    registerShortcuts();\n  }\n\n  /**\n   * Register shortcuts responsible for toggling checkbox state.\n   *\n   * @private\n   */\n  function registerShortcuts() {\n    const shortcutManager = hotInstance.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    const config = {\n      group: SHORTCUTS_GROUP\n    };\n    gridContext.addShortcuts([{\n      keys: [['space']],\n      callback: () => {\n        changeSelectedCheckboxesState();\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      }\n    }, {\n      keys: [['enter']],\n      callback: () => {\n        changeSelectedCheckboxesState();\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      },\n      runOnlyIf: () => hotInstance.getSettings().enterBeginsEditing\n    }, {\n      keys: [['delete'], ['backspace']],\n      callback: () => {\n        changeSelectedCheckboxesState(true);\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      },\n      relativeToGroup: SHORTCUTS_GROUP_EDITOR,\n      position: 'before'\n    }], config);\n  }\n\n  /**\n   * Change checkbox checked property.\n   *\n   * @private\n   * @param {boolean} [uncheckCheckbox=false] The new \"checked\" state for the checkbox elements.\n   */\n  function changeSelectedCheckboxesState() {\n    let uncheckCheckbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const selRange = hotInstance.getSelectedRange();\n    if (!selRange) {\n      return;\n    }\n    for (let key = 0; key < selRange.length; key++) {\n      const {\n        row: startRow,\n        col: startColumn\n      } = selRange[key].getTopStartCorner();\n      const {\n        row: endRow,\n        col: endColumn\n      } = selRange[key].getBottomEndCorner();\n      const changes = [];\n      for (let visualRow = startRow; visualRow <= endRow; visualRow += 1) {\n        for (let visualColumn = startColumn; visualColumn <= endColumn; visualColumn += 1) {\n          const cachedCellProperties = hotInstance.getCellMeta(visualRow, visualColumn);\n          if (cachedCellProperties.type !== 'checkbox') {\n            return;\n          }\n\n          /* eslint-disable no-continue */\n          if (cachedCellProperties.readOnly === true) {\n            continue;\n          }\n          if (typeof cachedCellProperties.checkedTemplate === 'undefined') {\n            cachedCellProperties.checkedTemplate = true;\n          }\n          if (typeof cachedCellProperties.uncheckedTemplate === 'undefined') {\n            cachedCellProperties.uncheckedTemplate = false;\n          }\n          const dataAtCell = hotInstance.getDataAtCell(visualRow, visualColumn);\n          if (uncheckCheckbox === false) {\n            if ([cachedCellProperties.checkedTemplate, cachedCellProperties.checkedTemplate.toString()].includes(dataAtCell)) {\n              // eslint-disable-line max-len\n              changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);\n            } else if ([cachedCellProperties.uncheckedTemplate, cachedCellProperties.uncheckedTemplate.toString(), null, undefined].includes(dataAtCell)) {\n              // eslint-disable-line max-len\n              changes.push([visualRow, visualColumn, cachedCellProperties.checkedTemplate]);\n            }\n          } else {\n            changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);\n          }\n        }\n      }\n      if (changes.length > 0) {\n        hotInstance.setDataAtCell(changes);\n      }\n    }\n  }\n\n  /**\n   * Check whether all selected cells are with checkbox type.\n   *\n   * @returns {boolean}\n   * @private\n   */\n  function areSelectedCheckboxCells() {\n    const selRange = hotInstance.getSelectedRange();\n    if (!selRange) {\n      return;\n    }\n    for (let key = 0; key < selRange.length; key++) {\n      const topLeft = selRange[key].getTopStartCorner();\n      const bottomRight = selRange[key].getBottomEndCorner();\n      for (let visualRow = topLeft.row; visualRow <= bottomRight.row; visualRow++) {\n        for (let visualColumn = topLeft.col; visualColumn <= bottomRight.col; visualColumn++) {\n          const cachedCellProperties = hotInstance.getCellMeta(visualRow, visualColumn);\n          if (cachedCellProperties.type !== 'checkbox') {\n            return false;\n          }\n          const cell = hotInstance.getCell(visualRow, visualColumn);\n          if (cell === null || cell === undefined) {\n            return true;\n          } else {\n            const checkboxes = cell.querySelectorAll('input[type=checkbox]');\n            if (checkboxes.length > 0 && !cachedCellProperties.readOnly) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n}\ncheckboxRenderer.RENDERER_TYPE = RENDERER_TYPE;\n\n/**\n * Register checkbox listeners.\n *\n * @param {Core} instance The Handsontable instance.\n * @returns {EventManager}\n */\nfunction registerEvents(instance) {\n  let eventManager = isCheckboxListenerAdded.get(instance);\n  if (!eventManager) {\n    const {\n      rootElement\n    } = instance;\n    eventManager = new EventManager(instance);\n    eventManager.addEventListener(rootElement, 'click', event => onClick(event, instance));\n    eventManager.addEventListener(rootElement, 'mouseup', event => onMouseUp(event, instance));\n    eventManager.addEventListener(rootElement, 'change', event => onChange(event, instance));\n    isCheckboxListenerAdded.set(instance, eventManager);\n  }\n  return eventManager;\n}\n\n/**\n * Create input element.\n *\n * @param {Document} rootDocument The document owner.\n * @returns {Node}\n */\nfunction createInput(rootDocument) {\n  const input = rootDocument.createElement('input');\n  input.className = 'htCheckboxRendererInput';\n  input.type = 'checkbox';\n  input.setAttribute('tabindex', '-1');\n  return input.cloneNode(false);\n}\n\n/**\n * Create label element.\n *\n * @param {Document} rootDocument The document owner.\n * @param {string} text The label text.\n * @param {boolean} fullWidth Determines whether label should have full width.\n * @returns {Node}\n */\nfunction createLabel(rootDocument, text, fullWidth) {\n  const label = rootDocument.createElement('label');\n  label.className = `htCheckboxRendererLabel ${fullWidth ? 'fullWidth' : ''}`;\n  label.appendChild(rootDocument.createTextNode(text));\n  return label.cloneNode(true);\n}\n\n/**\n * `mouseup` callback.\n *\n * @private\n * @param {Event} event `mouseup` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onMouseUp(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  setTimeout(instance.listen, 10);\n}\n\n/**\n * `click` callback.\n *\n * @private\n * @param {MouseEvent} event `click` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onClick(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  const row = parseInt(target.getAttribute(ATTR_ROW), 10);\n  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);\n  const cellProperties = instance.getCellMeta(row, col);\n  if (cellProperties.readOnly) {\n    event.preventDefault();\n  }\n}\n\n/**\n * `change` callback.\n *\n * @param {Event} event `change` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onChange(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  const row = parseInt(target.getAttribute(ATTR_ROW), 10);\n  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);\n  const cellProperties = instance.getCellMeta(row, col);\n  if (!cellProperties.readOnly) {\n    let newCheckboxValue = null;\n    if (event.target.checked) {\n      newCheckboxValue = cellProperties.uncheckedTemplate === undefined ? true : cellProperties.checkedTemplate;\n    } else {\n      newCheckboxValue = cellProperties.uncheckedTemplate === undefined ? false : cellProperties.uncheckedTemplate;\n    }\n    instance.setDataAtCell(row, col, newCheckboxValue);\n  }\n}\n\n/**\n * Check if the provided element is the checkbox input.\n *\n * @private\n * @param {HTMLElement} element The element in question.\n * @returns {boolean}\n */\nfunction isCheckboxInput(element) {\n  return element.tagName === 'INPUT' && element.getAttribute('type') === 'checkbox';\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}