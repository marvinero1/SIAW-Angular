{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { isDefined, stringify } from \"../../helpers/mixed.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\nimport { SHORTCUTS_GROUP_NAVIGATION } from \"../../editorManager.mjs\";\nimport hooksRefRegisterer from \"../../mixins/hooksRefRegisterer.mjs\";\nimport { getScrollbarWidth, offset, hasVerticalScrollbar, hasHorizontalScrollbar, outerWidth, outerHeight, getComputedStyle } from \"../../helpers/dom/element.mjs\";\nexport const EDITOR_TYPE = 'base';\nexport const EDITOR_STATE = Object.freeze({\n  VIRGIN: 'STATE_VIRGIN',\n  // before editing\n  EDITING: 'STATE_EDITING',\n  WAITING: 'STATE_WAITING',\n  // waiting for async validation\n  FINISHED: 'STATE_FINISHED'\n});\nexport const SHORTCUTS_GROUP_EDITOR = 'baseEditor';\n\n/**\n * @class BaseEditor\n */\nexport class BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * A reference to the source instance of the Handsontable.\n   *\n   * @type {Handsontable}\n   */\n\n  /**\n   * @param {Handsontable} hotInstance A reference to the source instance of the Handsontable.\n   */\n  constructor(hotInstance) {\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Editor's state.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"state\", EDITOR_STATE.VIRGIN);\n    /**\n     * Flag to store information about editor's opening status.\n     *\n     * @private\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"_opened\", false);\n    /**\n     * Defines the editor's editing mode. When false, then an editor works in fast editing mode.\n     *\n     * @private\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"_fullEditMode\", false);\n    /**\n     * Callback to call after closing editor.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"_closeCallback\", null);\n    /**\n     * Currently rendered cell's TD element.\n     *\n     * @type {HTMLTableCellElement}\n     */\n    _defineProperty(this, \"TD\", null);\n    /**\n     * Visual row index.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"row\", null);\n    /**\n     * Visual column index.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"col\", null);\n    /**\n     * Column property name or a column index, if datasource is an array of arrays.\n     *\n     * @type {number|string}\n     */\n    _defineProperty(this, \"prop\", null);\n    /**\n     * Original cell's value.\n     *\n     * @type {*}\n     */\n    _defineProperty(this, \"originalValue\", null);\n    /**\n     * Object containing the cell's properties.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cellProperties\", null);\n    this.hot = hotInstance;\n    this.init();\n  }\n\n  /**\n   * Fires callback after closing editor.\n   *\n   * @private\n   * @param {boolean} result The editor value.\n   */\n  _fireCallbacks(result) {\n    if (this._closeCallback) {\n      this._closeCallback(result);\n      this._closeCallback = null;\n    }\n  }\n\n  /**\n   * Initializes an editor's intance.\n   */\n  init() {}\n\n  /**\n   * Required method to get current value from editable element.\n   */\n  getValue() {\n    throw Error('Editor getValue() method unimplemented');\n  }\n\n  /**\n   * Required method to set new value into editable element.\n   */\n  setValue() {\n    throw Error('Editor setValue() method unimplemented');\n  }\n\n  /**\n   * Required method to open editor.\n   */\n  open() {\n    throw Error('Editor open() method unimplemented');\n  }\n\n  /**\n   * Required method to close editor.\n   */\n  close() {\n    throw Error('Editor close() method unimplemented');\n  }\n\n  /**\n   * Prepares editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    this.TD = td;\n    this.row = row;\n    this.col = col;\n    this.prop = prop;\n    this.originalValue = value;\n    this.cellProperties = cellProperties;\n    this.state = EDITOR_STATE.VIRGIN;\n  }\n\n  /**\n   * Fallback method to provide extendable editors in ES5.\n   *\n   * @returns {Function}\n   */\n  extend() {\n    return class Editor extends this.constructor {};\n  }\n\n  /**\n   * Saves value from editor into data storage.\n   *\n   * @param {*} value The editor value.\n   * @param {boolean} ctrlDown If `true`, applies value to each cell in the last selected range.\n   */\n  saveValue(value, ctrlDown) {\n    let visualRowFrom;\n    let visualColumnFrom;\n    let visualRowTo;\n    let visualColumnTo;\n\n    // if ctrl+enter and multiple cells selected, behave like Excel (finish editing and apply to all cells)\n    if (ctrlDown) {\n      const selectedLast = this.hot.getSelectedLast();\n      visualRowFrom = Math.max(Math.min(selectedLast[0], selectedLast[2]), 0); // Math.max eliminate headers coords.\n      visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0); // Math.max eliminate headers coords.\n      visualRowTo = Math.max(selectedLast[0], selectedLast[2]);\n      visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);\n    } else {\n      [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = [this.row, this.col, null, null];\n    }\n    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowFrom, visualColumnFrom);\n    if (Array.isArray(modifiedCellCoords)) {\n      [visualRowFrom, visualColumnFrom] = modifiedCellCoords;\n    }\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    const contextConfig = {\n      runOnlyIf: () => isDefined(this.hot.getSelected()),\n      group: SHORTCUTS_GROUP_EDITOR\n    };\n    if (this.isInFullEditMode()) {\n      editorContext.addShortcuts([{\n        keys: [['ArrowUp']],\n        callback: () => {\n          this.hot.selection.transformStart(-1, 0);\n        }\n      }, {\n        keys: [['ArrowDown']],\n        callback: () => {\n          this.hot.selection.transformStart(1, 0);\n        }\n      }, {\n        keys: [['ArrowLeft']],\n        callback: () => {\n          this.hot.selection.transformStart(0, -1 * this.hot.getDirectionFactor());\n        }\n      }, {\n        keys: [['ArrowRight']],\n        callback: () => {\n          this.hot.selection.transformStart(0, this.hot.getDirectionFactor());\n        }\n      }], contextConfig);\n    }\n\n    // Saving values using the modified coordinates.\n    this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, visualRowTo, visualColumnTo, 'edit');\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The initial editor value.\n   * @param {Event} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    }\n    const hotInstance = this.hot;\n    // We have to convert visual indexes into renderable indexes\n    // due to hidden columns don't participate in the rendering process\n    const renderableRowIndex = hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const renderableColumnIndex = hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    hotInstance.view.scrollViewport(hotInstance._createCellCoords(renderableRowIndex, renderableColumnIndex));\n    this.state = EDITOR_STATE.EDITING;\n\n    // Set the editor value only in the full edit mode. In other mode the focusable element has to be empty,\n    // otherwise IME (editor for Asia users) doesn't work.\n    if (this.isInFullEditMode()) {\n      const stringifiedInitialValue = typeof newInitialValue === 'string' ? newInitialValue : stringify(this.originalValue);\n      this.setValue(stringifiedInitialValue);\n    }\n    this.open(event);\n    this._opened = true;\n    this.focus();\n\n    // only rerender the selections (FillHandle should disappear when beginEditing is triggered)\n    hotInstance.view.render();\n    hotInstance.runHooks('afterBeginEditing', this.row, this.col);\n  }\n\n  /**\n   * Finishes editing and start saving or restoring process for editing cell or last selected range.\n   *\n   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  finishEditing(restoreOriginalValue, ctrlDown, callback) {\n    let val;\n    if (callback) {\n      const previousCloseCallback = this._closeCallback;\n      this._closeCallback = result => {\n        if (previousCloseCallback) {\n          previousCloseCallback(result);\n        }\n        callback(result);\n        this.hot.view.render();\n      };\n    }\n    if (this.isWaiting()) {\n      return;\n    }\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR);\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);\n    if (this.state === EDITOR_STATE.VIRGIN) {\n      this.hot._registerTimeout(() => {\n        this._fireCallbacks(true);\n      });\n      return;\n    }\n    if (this.state === EDITOR_STATE.EDITING) {\n      if (restoreOriginalValue) {\n        this.cancelChanges();\n        this.hot.view.render();\n        return;\n      }\n      const value = this.getValue();\n      if (this.cellProperties.trimWhitespace) {\n        // We trim only string values\n        val = [[typeof value === 'string' ? String.prototype.trim.call(value || '') : value]];\n      } else {\n        val = [[value]];\n      }\n      this.state = EDITOR_STATE.WAITING;\n      this.saveValue(val, ctrlDown);\n      if (this.hot.getCellValidator(this.cellProperties)) {\n        this.hot.addHookOnce('postAfterValidate', result => {\n          this.state = EDITOR_STATE.FINISHED;\n          this.discardEditor(result);\n        });\n      } else {\n        this.state = EDITOR_STATE.FINISHED;\n        this.discardEditor(true);\n      }\n    }\n  }\n\n  /**\n   * Finishes editing without singout saving value.\n   */\n  cancelChanges() {\n    this.state = EDITOR_STATE.FINISHED;\n    this.discardEditor();\n  }\n\n  /**\n   * Verifies result of validation or closes editor if user's cancelled changes.\n   *\n   * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,\n   *                                   then an editor won't be closed until validation is passed.\n   */\n  discardEditor(result) {\n    if (this.state !== EDITOR_STATE.FINISHED) {\n      return;\n    }\n\n    // validator was defined and failed\n    if (result === false && this.cellProperties.allowInvalid !== true) {\n      this.hot.selectCell(this.row, this.col);\n      this.focus();\n      this.state = EDITOR_STATE.EDITING;\n      this._fireCallbacks(false);\n    } else {\n      this.close();\n      this._opened = false;\n      this._fullEditMode = false;\n      this.state = EDITOR_STATE.VIRGIN;\n      this._fireCallbacks(true);\n      const shortcutManager = this.hot.getShortcutManager();\n      shortcutManager.setActiveContextName('grid');\n    }\n  }\n\n  /**\n   * Switch editor into full edit mode. In this state navigation keys don't close editor. This mode is activated\n   * automatically after hit ENTER or F2 key on the cell or while editing cell press F2 key.\n   */\n  enableFullEditMode() {\n    this._fullEditMode = true;\n  }\n\n  /**\n   * Checks if editor is in full edit mode.\n   *\n   * @returns {boolean}\n   */\n  isInFullEditMode() {\n    return this._fullEditMode;\n  }\n\n  /**\n   * Returns information whether the editor is open.\n   *\n   * @returns {boolean}\n   */\n  isOpened() {\n    return this._opened;\n  }\n\n  /**\n   * Returns information whether the editor is waiting, eg.: for async validation.\n   *\n   * @returns {boolean}\n   */\n  isWaiting() {\n    return this.state === EDITOR_STATE.WAITING;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Gets the object that provides information about the edited cell size and its position\n   * relative to the table viewport.\n   *\n   * The rectangle has six integer properties:\n   *  - `top` The top position relative to the table viewport\n   *  - `start` The left (or right in RTL) position relative to the table viewport\n   *  - `width` The cell's current width;\n   *  - `maxWidth` The maximum cell's width after which the editor goes out of the table viewport\n   *  - `height` The cell's current height;\n   *  - `maxHeight` The maximum cell's height after which the editor goes out of the table viewport\n   *\n   * @returns {{top: number, start: number, width: number, maxWidth: number, height: number, maxHeight: number} | undefined}\n   */\n  getEditedCellRect() {\n    var _wtOverlays$getParent;\n    const TD = this.getEditedCell();\n\n    // TD is outside of the viewport.\n    if (!TD) {\n      return;\n    }\n    const {\n      wtOverlays,\n      wtViewport\n    } = this.hot.view._wt;\n    const rootWindow = this.hot.rootWindow;\n    const currentOffset = offset(TD);\n    const cellWidth = outerWidth(TD);\n    const containerOffset = offset(this.hot.rootElement);\n    const containerWidth = outerWidth(this.hot.rootElement);\n    const scrollableContainerTop = wtOverlays.topOverlay.holder;\n    const scrollableContainerLeft = wtOverlays.inlineStartOverlay.holder;\n    const containerScrollTop = scrollableContainerTop !== rootWindow ? scrollableContainerTop.scrollTop : 0;\n    const containerScrollLeft = scrollableContainerLeft !== rootWindow ? scrollableContainerLeft.scrollLeft : 0;\n    const gridMostRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;\n    const {\n      wtTable: overlayTable\n    } = (_wtOverlays$getParent = wtOverlays.getParentOverlay(TD)) !== null && _wtOverlays$getParent !== void 0 ? _wtOverlays$getParent : this.hot.view._wt;\n    const overlayName = overlayTable.name;\n    const scrollTop = ['master', 'inline_start'].includes(overlayName) ? containerScrollTop : 0;\n    const scrollLeft = ['master', 'top', 'bottom'].includes(overlayName) ? containerScrollLeft : 0;\n\n    // If colHeaders is disabled, cells in the first row have border-top\n    const editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;\n    let topPos = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;\n    let inlineStartPos = 0;\n    if (this.hot.isRtl()) {\n      inlineStartPos = rootWindow.innerWidth - currentOffset.left - cellWidth - gridMostRightPos - 1 + scrollLeft;\n    } else {\n      inlineStartPos = currentOffset.left - containerOffset.left - 1 - scrollLeft;\n    }\n\n    // When the scrollable element is Window object then the editor position needs to be compensated\n    // by the overlays' position (position relative to the table viewport). In other cases, the overlay's\n    // position always returns 0.\n    if (['top', 'top_inline_start_corner'].includes(overlayName)) {\n      topPos += wtOverlays.topOverlay.getOverlayOffset();\n    }\n    if (['inline_start', 'top_inline_start_corner'].includes(overlayName)) {\n      inlineStartPos += Math.abs(wtOverlays.inlineStartOverlay.getOverlayOffset());\n    }\n    const hasColumnHeaders = this.hot.hasColHeaders();\n    const renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    const nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();\n    const firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view._wt.getSetting('fixedRowsBottom');\n    if (hasColumnHeaders && renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {\n      topPos += 1;\n    }\n    if (renderableColumn <= 0) {\n      inlineStartPos += 1;\n    }\n    const firstRowOffset = wtViewport.rowsRenderCalculator.startPosition;\n    const firstColumnOffset = wtViewport.columnsRenderCalculator.startPosition;\n    const horizontalScrollPosition = Math.abs(wtOverlays.inlineStartOverlay.getScrollPosition());\n    const verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();\n    const scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);\n    let cellTopOffset = TD.offsetTop;\n    if (['inline_start', 'master'].includes(overlayName)) {\n      cellTopOffset += firstRowOffset - verticalScrollPosition;\n    }\n    if (['bottom', 'bottom_inline_start_corner'].includes(overlayName)) {\n      const {\n        wtViewport: bottomWtViewport,\n        wtTable: bottomWtTable\n      } = wtOverlays.bottomOverlay.clone;\n      cellTopOffset += bottomWtViewport.getWorkspaceHeight() - bottomWtTable.getHeight() - scrollbarWidth;\n    }\n    let cellStartOffset = TD.offsetLeft;\n    if (this.hot.isRtl()) {\n      if (cellStartOffset >= 0) {\n        cellStartOffset = overlayTable.getWidth() - TD.offsetLeft;\n      } else {\n        // The `offsetLeft` returns negative values when the parent offset element has position relative\n        // (it happens when on the cell the selection is applied - the `area` CSS class).\n        // When it happens the `offsetLeft` value is calculated from the right edge of the parent element.\n        cellStartOffset = Math.abs(cellStartOffset);\n      }\n      cellStartOffset += firstColumnOffset - horizontalScrollPosition - cellWidth;\n    } else if (['top', 'master', 'bottom'].includes(overlayName)) {\n      cellStartOffset += firstColumnOffset - horizontalScrollPosition;\n    }\n    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    const borderPhysicalWidthProp = this.hot.isRtl() ? 'borderRightWidth' : 'borderLeftWidth';\n    const inlineStartBorderCompensation = parseInt(cellComputedStyle[borderPhysicalWidthProp], 10) > 0 ? 0 : 1;\n    const topBorderCompensation = parseInt(cellComputedStyle.borderTopWidth, 10) > 0 ? 0 : 1;\n    const width = outerWidth(TD) + inlineStartBorderCompensation;\n    const height = outerHeight(TD) + topBorderCompensation;\n    const actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;\n    const actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;\n    const maxWidth = this.hot.view.maximumVisibleElementWidth(cellStartOffset) - actualVerticalScrollbarWidth + inlineStartBorderCompensation;\n    const maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth + topBorderCompensation, 23);\n    return {\n      top: topPos,\n      start: inlineStartPos,\n      height,\n      maxHeight,\n      width,\n      maxWidth\n    };\n  }\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  /**\n   * Gets className of the edited cell if exist.\n   *\n   * @returns {string}\n   */\n  getEditedCellsLayerClass() {\n    const editorSection = this.checkEditorSection();\n    switch (editorSection) {\n      case 'inline-start':\n        return 'ht_clone_left ht_clone_inline_start';\n      case 'bottom':\n        return 'ht_clone_bottom';\n      case 'bottom-inline-start-corner':\n        return 'ht_clone_bottom_left_corner ht_clone_bottom_inline_start_corner';\n      case 'top':\n        return 'ht_clone_top';\n      case 'top-inline-start-corner':\n        return 'ht_clone_top_left_corner ht_clone_top_inline_start_corner';\n      default:\n        return 'ht_clone_master';\n    }\n  }\n\n  /**\n   * Gets HTMLTableCellElement of the edited cell if exist.\n   *\n   * @returns {HTMLTableCellElement|null}\n   */\n  getEditedCell() {\n    return this.hot.getCell(this.row, this.col, true);\n  }\n\n  /**\n   * Returns name of the overlay, where editor is placed.\n   *\n   * @private\n   * @returns {string}\n   */\n  checkEditorSection() {\n    const totalRows = this.hot.countRows();\n    let section = '';\n    if (this.row < this.hot.getSettings().fixedRowsTop) {\n      if (this.col < this.hot.getSettings().fixedColumnsStart) {\n        section = 'top-inline-start-corner';\n      } else {\n        section = 'top';\n      }\n    } else if (this.hot.getSettings().fixedRowsBottom && this.row >= totalRows - this.hot.getSettings().fixedRowsBottom) {\n      if (this.col < this.hot.getSettings().fixedColumnsStart) {\n        section = 'bottom-inline-start-corner';\n      } else {\n        section = 'bottom';\n      }\n    } else if (this.col < this.hot.getSettings().fixedColumnsStart) {\n      section = 'inline-start';\n    }\n    return section;\n  }\n}\nmixin(BaseEditor, hooksRefRegisterer);","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","isDefined","stringify","mixin","SHORTCUTS_GROUP_NAVIGATION","hooksRefRegisterer","getScrollbarWidth","offset","hasVerticalScrollbar","hasHorizontalScrollbar","outerWidth","outerHeight","getComputedStyle","EDITOR_TYPE","EDITOR_STATE","freeze","VIRGIN","EDITING","WAITING","FINISHED","SHORTCUTS_GROUP_EDITOR","BaseEditor","constructor","hotInstance","hot","init","_fireCallbacks","result","_closeCallback","getValue","Error","setValue","open","close","prepare","row","col","prop","td","cellProperties","TD","originalValue","state","extend","Editor","saveValue","ctrlDown","visualRowFrom","visualColumnFrom","visualRowTo","visualColumnTo","selectedLast","getSelectedLast","Math","max","min","modifiedCellCoords","runHooks","Array","isArray","shortcutManager","getShortcutManager","editorContext","getContext","contextConfig","runOnlyIf","getSelected","group","isInFullEditMode","addShortcuts","keys","callback","selection","transformStart","getDirectionFactor","populateFromArray","beginEditing","newInitialValue","event","renderableRowIndex","rowIndexMapper","getRenderableFromVisualIndex","renderableColumnIndex","columnIndexMapper","view","scrollViewport","_createCellCoords","stringifiedInitialValue","_opened","focus","render","finishEditing","restoreOriginalValue","val","previousCloseCallback","isWaiting","removeShortcutsByGroup","_registerTimeout","cancelChanges","trimWhitespace","prototype","trim","getCellValidator","addHookOnce","discardEditor","allowInvalid","selectCell","_fullEditMode","setActiveContextName","enableFullEditMode","isOpened","getEditedCellRect","_wtOverlays$getParent","getEditedCell","wtOverlays","wtViewport","_wt","rootWindow","currentOffset","cellWidth","containerOffset","rootElement","containerWidth","scrollableContainerTop","topOverlay","holder","scrollableContainerLeft","inlineStartOverlay","containerScrollTop","scrollTop","containerScrollLeft","scrollLeft","gridMostRightPos","innerWidth","left","wtTable","overlayTable","getParentOverlay","overlayName","name","includes","editTopModifier","top","topPos","inlineStartPos","isRtl","getOverlayOffset","abs","hasColumnHeaders","hasColHeaders","renderableRow","renderableColumn","nrOfRenderableRowIndexes","getRenderableIndexesLength","firstRowIndexOfTheBottomOverlay","getSetting","firstRowOffset","rowsRenderCalculator","startPosition","firstColumnOffset","columnsRenderCalculator","horizontalScrollPosition","getScrollPosition","verticalScrollPosition","scrollbarWidth","rootDocument","cellTopOffset","offsetTop","bottomWtViewport","bottomWtTable","bottomOverlay","clone","getWorkspaceHeight","getHeight","cellStartOffset","offsetLeft","getWidth","cellComputedStyle","borderPhysicalWidthProp","inlineStartBorderCompensation","parseInt","topBorderCompensation","borderTopWidth","width","height","actualVerticalScrollbarWidth","actualHorizontalScrollbarWidth","maxWidth","maximumVisibleElementWidth","maxHeight","maximumVisibleElementHeight","start","getEditedCellsLayerClass","editorSection","checkEditorSection","getCell","totalRows","countRows","section","getSettings","fixedRowsTop","fixedColumnsStart","fixedRowsBottom"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/editors/baseEditor/baseEditor.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { isDefined, stringify } from \"../../helpers/mixed.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\nimport { SHORTCUTS_GROUP_NAVIGATION } from \"../../editorManager.mjs\";\nimport hooksRefRegisterer from \"../../mixins/hooksRefRegisterer.mjs\";\nimport { getScrollbarWidth, offset, hasVerticalScrollbar, hasHorizontalScrollbar, outerWidth, outerHeight, getComputedStyle } from \"../../helpers/dom/element.mjs\";\nexport const EDITOR_TYPE = 'base';\nexport const EDITOR_STATE = Object.freeze({\n  VIRGIN: 'STATE_VIRGIN',\n  // before editing\n  EDITING: 'STATE_EDITING',\n  WAITING: 'STATE_WAITING',\n  // waiting for async validation\n  FINISHED: 'STATE_FINISHED'\n});\nexport const SHORTCUTS_GROUP_EDITOR = 'baseEditor';\n\n/**\n * @class BaseEditor\n */\nexport class BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * A reference to the source instance of the Handsontable.\n   *\n   * @type {Handsontable}\n   */\n\n  /**\n   * @param {Handsontable} hotInstance A reference to the source instance of the Handsontable.\n   */\n  constructor(hotInstance) {\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Editor's state.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"state\", EDITOR_STATE.VIRGIN);\n    /**\n     * Flag to store information about editor's opening status.\n     *\n     * @private\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"_opened\", false);\n    /**\n     * Defines the editor's editing mode. When false, then an editor works in fast editing mode.\n     *\n     * @private\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"_fullEditMode\", false);\n    /**\n     * Callback to call after closing editor.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"_closeCallback\", null);\n    /**\n     * Currently rendered cell's TD element.\n     *\n     * @type {HTMLTableCellElement}\n     */\n    _defineProperty(this, \"TD\", null);\n    /**\n     * Visual row index.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"row\", null);\n    /**\n     * Visual column index.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"col\", null);\n    /**\n     * Column property name or a column index, if datasource is an array of arrays.\n     *\n     * @type {number|string}\n     */\n    _defineProperty(this, \"prop\", null);\n    /**\n     * Original cell's value.\n     *\n     * @type {*}\n     */\n    _defineProperty(this, \"originalValue\", null);\n    /**\n     * Object containing the cell's properties.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cellProperties\", null);\n    this.hot = hotInstance;\n    this.init();\n  }\n\n  /**\n   * Fires callback after closing editor.\n   *\n   * @private\n   * @param {boolean} result The editor value.\n   */\n  _fireCallbacks(result) {\n    if (this._closeCallback) {\n      this._closeCallback(result);\n      this._closeCallback = null;\n    }\n  }\n\n  /**\n   * Initializes an editor's intance.\n   */\n  init() {}\n\n  /**\n   * Required method to get current value from editable element.\n   */\n  getValue() {\n    throw Error('Editor getValue() method unimplemented');\n  }\n\n  /**\n   * Required method to set new value into editable element.\n   */\n  setValue() {\n    throw Error('Editor setValue() method unimplemented');\n  }\n\n  /**\n   * Required method to open editor.\n   */\n  open() {\n    throw Error('Editor open() method unimplemented');\n  }\n\n  /**\n   * Required method to close editor.\n   */\n  close() {\n    throw Error('Editor close() method unimplemented');\n  }\n\n  /**\n   * Prepares editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    this.TD = td;\n    this.row = row;\n    this.col = col;\n    this.prop = prop;\n    this.originalValue = value;\n    this.cellProperties = cellProperties;\n    this.state = EDITOR_STATE.VIRGIN;\n  }\n\n  /**\n   * Fallback method to provide extendable editors in ES5.\n   *\n   * @returns {Function}\n   */\n  extend() {\n    return class Editor extends this.constructor {};\n  }\n\n  /**\n   * Saves value from editor into data storage.\n   *\n   * @param {*} value The editor value.\n   * @param {boolean} ctrlDown If `true`, applies value to each cell in the last selected range.\n   */\n  saveValue(value, ctrlDown) {\n    let visualRowFrom;\n    let visualColumnFrom;\n    let visualRowTo;\n    let visualColumnTo;\n\n    // if ctrl+enter and multiple cells selected, behave like Excel (finish editing and apply to all cells)\n    if (ctrlDown) {\n      const selectedLast = this.hot.getSelectedLast();\n      visualRowFrom = Math.max(Math.min(selectedLast[0], selectedLast[2]), 0); // Math.max eliminate headers coords.\n      visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0); // Math.max eliminate headers coords.\n      visualRowTo = Math.max(selectedLast[0], selectedLast[2]);\n      visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);\n    } else {\n      [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = [this.row, this.col, null, null];\n    }\n    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowFrom, visualColumnFrom);\n    if (Array.isArray(modifiedCellCoords)) {\n      [visualRowFrom, visualColumnFrom] = modifiedCellCoords;\n    }\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    const contextConfig = {\n      runOnlyIf: () => isDefined(this.hot.getSelected()),\n      group: SHORTCUTS_GROUP_EDITOR\n    };\n    if (this.isInFullEditMode()) {\n      editorContext.addShortcuts([{\n        keys: [['ArrowUp']],\n        callback: () => {\n          this.hot.selection.transformStart(-1, 0);\n        }\n      }, {\n        keys: [['ArrowDown']],\n        callback: () => {\n          this.hot.selection.transformStart(1, 0);\n        }\n      }, {\n        keys: [['ArrowLeft']],\n        callback: () => {\n          this.hot.selection.transformStart(0, -1 * this.hot.getDirectionFactor());\n        }\n      }, {\n        keys: [['ArrowRight']],\n        callback: () => {\n          this.hot.selection.transformStart(0, this.hot.getDirectionFactor());\n        }\n      }], contextConfig);\n    }\n\n    // Saving values using the modified coordinates.\n    this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, visualRowTo, visualColumnTo, 'edit');\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The initial editor value.\n   * @param {Event} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    }\n    const hotInstance = this.hot;\n    // We have to convert visual indexes into renderable indexes\n    // due to hidden columns don't participate in the rendering process\n    const renderableRowIndex = hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const renderableColumnIndex = hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    hotInstance.view.scrollViewport(hotInstance._createCellCoords(renderableRowIndex, renderableColumnIndex));\n    this.state = EDITOR_STATE.EDITING;\n\n    // Set the editor value only in the full edit mode. In other mode the focusable element has to be empty,\n    // otherwise IME (editor for Asia users) doesn't work.\n    if (this.isInFullEditMode()) {\n      const stringifiedInitialValue = typeof newInitialValue === 'string' ? newInitialValue : stringify(this.originalValue);\n      this.setValue(stringifiedInitialValue);\n    }\n    this.open(event);\n    this._opened = true;\n    this.focus();\n\n    // only rerender the selections (FillHandle should disappear when beginEditing is triggered)\n    hotInstance.view.render();\n    hotInstance.runHooks('afterBeginEditing', this.row, this.col);\n  }\n\n  /**\n   * Finishes editing and start saving or restoring process for editing cell or last selected range.\n   *\n   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  finishEditing(restoreOriginalValue, ctrlDown, callback) {\n    let val;\n    if (callback) {\n      const previousCloseCallback = this._closeCallback;\n      this._closeCallback = result => {\n        if (previousCloseCallback) {\n          previousCloseCallback(result);\n        }\n        callback(result);\n        this.hot.view.render();\n      };\n    }\n    if (this.isWaiting()) {\n      return;\n    }\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR);\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);\n    if (this.state === EDITOR_STATE.VIRGIN) {\n      this.hot._registerTimeout(() => {\n        this._fireCallbacks(true);\n      });\n      return;\n    }\n    if (this.state === EDITOR_STATE.EDITING) {\n      if (restoreOriginalValue) {\n        this.cancelChanges();\n        this.hot.view.render();\n        return;\n      }\n      const value = this.getValue();\n      if (this.cellProperties.trimWhitespace) {\n        // We trim only string values\n        val = [[typeof value === 'string' ? String.prototype.trim.call(value || '') : value]];\n      } else {\n        val = [[value]];\n      }\n      this.state = EDITOR_STATE.WAITING;\n      this.saveValue(val, ctrlDown);\n      if (this.hot.getCellValidator(this.cellProperties)) {\n        this.hot.addHookOnce('postAfterValidate', result => {\n          this.state = EDITOR_STATE.FINISHED;\n          this.discardEditor(result);\n        });\n      } else {\n        this.state = EDITOR_STATE.FINISHED;\n        this.discardEditor(true);\n      }\n    }\n  }\n\n  /**\n   * Finishes editing without singout saving value.\n   */\n  cancelChanges() {\n    this.state = EDITOR_STATE.FINISHED;\n    this.discardEditor();\n  }\n\n  /**\n   * Verifies result of validation or closes editor if user's cancelled changes.\n   *\n   * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,\n   *                                   then an editor won't be closed until validation is passed.\n   */\n  discardEditor(result) {\n    if (this.state !== EDITOR_STATE.FINISHED) {\n      return;\n    }\n\n    // validator was defined and failed\n    if (result === false && this.cellProperties.allowInvalid !== true) {\n      this.hot.selectCell(this.row, this.col);\n      this.focus();\n      this.state = EDITOR_STATE.EDITING;\n      this._fireCallbacks(false);\n    } else {\n      this.close();\n      this._opened = false;\n      this._fullEditMode = false;\n      this.state = EDITOR_STATE.VIRGIN;\n      this._fireCallbacks(true);\n      const shortcutManager = this.hot.getShortcutManager();\n      shortcutManager.setActiveContextName('grid');\n    }\n  }\n\n  /**\n   * Switch editor into full edit mode. In this state navigation keys don't close editor. This mode is activated\n   * automatically after hit ENTER or F2 key on the cell or while editing cell press F2 key.\n   */\n  enableFullEditMode() {\n    this._fullEditMode = true;\n  }\n\n  /**\n   * Checks if editor is in full edit mode.\n   *\n   * @returns {boolean}\n   */\n  isInFullEditMode() {\n    return this._fullEditMode;\n  }\n\n  /**\n   * Returns information whether the editor is open.\n   *\n   * @returns {boolean}\n   */\n  isOpened() {\n    return this._opened;\n  }\n\n  /**\n   * Returns information whether the editor is waiting, eg.: for async validation.\n   *\n   * @returns {boolean}\n   */\n  isWaiting() {\n    return this.state === EDITOR_STATE.WAITING;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Gets the object that provides information about the edited cell size and its position\n   * relative to the table viewport.\n   *\n   * The rectangle has six integer properties:\n   *  - `top` The top position relative to the table viewport\n   *  - `start` The left (or right in RTL) position relative to the table viewport\n   *  - `width` The cell's current width;\n   *  - `maxWidth` The maximum cell's width after which the editor goes out of the table viewport\n   *  - `height` The cell's current height;\n   *  - `maxHeight` The maximum cell's height after which the editor goes out of the table viewport\n   *\n   * @returns {{top: number, start: number, width: number, maxWidth: number, height: number, maxHeight: number} | undefined}\n   */\n  getEditedCellRect() {\n    var _wtOverlays$getParent;\n    const TD = this.getEditedCell();\n\n    // TD is outside of the viewport.\n    if (!TD) {\n      return;\n    }\n    const {\n      wtOverlays,\n      wtViewport\n    } = this.hot.view._wt;\n    const rootWindow = this.hot.rootWindow;\n    const currentOffset = offset(TD);\n    const cellWidth = outerWidth(TD);\n    const containerOffset = offset(this.hot.rootElement);\n    const containerWidth = outerWidth(this.hot.rootElement);\n    const scrollableContainerTop = wtOverlays.topOverlay.holder;\n    const scrollableContainerLeft = wtOverlays.inlineStartOverlay.holder;\n    const containerScrollTop = scrollableContainerTop !== rootWindow ? scrollableContainerTop.scrollTop : 0;\n    const containerScrollLeft = scrollableContainerLeft !== rootWindow ? scrollableContainerLeft.scrollLeft : 0;\n    const gridMostRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;\n    const {\n      wtTable: overlayTable\n    } = (_wtOverlays$getParent = wtOverlays.getParentOverlay(TD)) !== null && _wtOverlays$getParent !== void 0 ? _wtOverlays$getParent : this.hot.view._wt;\n    const overlayName = overlayTable.name;\n    const scrollTop = ['master', 'inline_start'].includes(overlayName) ? containerScrollTop : 0;\n    const scrollLeft = ['master', 'top', 'bottom'].includes(overlayName) ? containerScrollLeft : 0;\n\n    // If colHeaders is disabled, cells in the first row have border-top\n    const editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;\n    let topPos = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;\n    let inlineStartPos = 0;\n    if (this.hot.isRtl()) {\n      inlineStartPos = rootWindow.innerWidth - currentOffset.left - cellWidth - gridMostRightPos - 1 + scrollLeft;\n    } else {\n      inlineStartPos = currentOffset.left - containerOffset.left - 1 - scrollLeft;\n    }\n\n    // When the scrollable element is Window object then the editor position needs to be compensated\n    // by the overlays' position (position relative to the table viewport). In other cases, the overlay's\n    // position always returns 0.\n    if (['top', 'top_inline_start_corner'].includes(overlayName)) {\n      topPos += wtOverlays.topOverlay.getOverlayOffset();\n    }\n    if (['inline_start', 'top_inline_start_corner'].includes(overlayName)) {\n      inlineStartPos += Math.abs(wtOverlays.inlineStartOverlay.getOverlayOffset());\n    }\n    const hasColumnHeaders = this.hot.hasColHeaders();\n    const renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    const nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();\n    const firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view._wt.getSetting('fixedRowsBottom');\n    if (hasColumnHeaders && renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {\n      topPos += 1;\n    }\n    if (renderableColumn <= 0) {\n      inlineStartPos += 1;\n    }\n    const firstRowOffset = wtViewport.rowsRenderCalculator.startPosition;\n    const firstColumnOffset = wtViewport.columnsRenderCalculator.startPosition;\n    const horizontalScrollPosition = Math.abs(wtOverlays.inlineStartOverlay.getScrollPosition());\n    const verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();\n    const scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);\n    let cellTopOffset = TD.offsetTop;\n    if (['inline_start', 'master'].includes(overlayName)) {\n      cellTopOffset += firstRowOffset - verticalScrollPosition;\n    }\n    if (['bottom', 'bottom_inline_start_corner'].includes(overlayName)) {\n      const {\n        wtViewport: bottomWtViewport,\n        wtTable: bottomWtTable\n      } = wtOverlays.bottomOverlay.clone;\n      cellTopOffset += bottomWtViewport.getWorkspaceHeight() - bottomWtTable.getHeight() - scrollbarWidth;\n    }\n    let cellStartOffset = TD.offsetLeft;\n    if (this.hot.isRtl()) {\n      if (cellStartOffset >= 0) {\n        cellStartOffset = overlayTable.getWidth() - TD.offsetLeft;\n      } else {\n        // The `offsetLeft` returns negative values when the parent offset element has position relative\n        // (it happens when on the cell the selection is applied - the `area` CSS class).\n        // When it happens the `offsetLeft` value is calculated from the right edge of the parent element.\n        cellStartOffset = Math.abs(cellStartOffset);\n      }\n      cellStartOffset += firstColumnOffset - horizontalScrollPosition - cellWidth;\n    } else if (['top', 'master', 'bottom'].includes(overlayName)) {\n      cellStartOffset += firstColumnOffset - horizontalScrollPosition;\n    }\n    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    const borderPhysicalWidthProp = this.hot.isRtl() ? 'borderRightWidth' : 'borderLeftWidth';\n    const inlineStartBorderCompensation = parseInt(cellComputedStyle[borderPhysicalWidthProp], 10) > 0 ? 0 : 1;\n    const topBorderCompensation = parseInt(cellComputedStyle.borderTopWidth, 10) > 0 ? 0 : 1;\n    const width = outerWidth(TD) + inlineStartBorderCompensation;\n    const height = outerHeight(TD) + topBorderCompensation;\n    const actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;\n    const actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;\n    const maxWidth = this.hot.view.maximumVisibleElementWidth(cellStartOffset) - actualVerticalScrollbarWidth + inlineStartBorderCompensation;\n    const maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth + topBorderCompensation, 23);\n    return {\n      top: topPos,\n      start: inlineStartPos,\n      height,\n      maxHeight,\n      width,\n      maxWidth\n    };\n  }\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  /**\n   * Gets className of the edited cell if exist.\n   *\n   * @returns {string}\n   */\n  getEditedCellsLayerClass() {\n    const editorSection = this.checkEditorSection();\n    switch (editorSection) {\n      case 'inline-start':\n        return 'ht_clone_left ht_clone_inline_start';\n      case 'bottom':\n        return 'ht_clone_bottom';\n      case 'bottom-inline-start-corner':\n        return 'ht_clone_bottom_left_corner ht_clone_bottom_inline_start_corner';\n      case 'top':\n        return 'ht_clone_top';\n      case 'top-inline-start-corner':\n        return 'ht_clone_top_left_corner ht_clone_top_inline_start_corner';\n      default:\n        return 'ht_clone_master';\n    }\n  }\n\n  /**\n   * Gets HTMLTableCellElement of the edited cell if exist.\n   *\n   * @returns {HTMLTableCellElement|null}\n   */\n  getEditedCell() {\n    return this.hot.getCell(this.row, this.col, true);\n  }\n\n  /**\n   * Returns name of the overlay, where editor is placed.\n   *\n   * @private\n   * @returns {string}\n   */\n  checkEditorSection() {\n    const totalRows = this.hot.countRows();\n    let section = '';\n    if (this.row < this.hot.getSettings().fixedRowsTop) {\n      if (this.col < this.hot.getSettings().fixedColumnsStart) {\n        section = 'top-inline-start-corner';\n      } else {\n        section = 'top';\n      }\n    } else if (this.hot.getSettings().fixedRowsBottom && this.row >= totalRows - this.hot.getSettings().fixedRowsBottom) {\n      if (this.col < this.hot.getSettings().fixedColumnsStart) {\n        section = 'bottom-inline-start-corner';\n      } else {\n        section = 'bottom';\n      }\n    } else if (this.col < this.hot.getSettings().fixedColumnsStart) {\n      section = 'inline-start';\n    }\n    return section;\n  }\n}\nmixin(BaseEditor, hooksRefRegisterer);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}