{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { stringify, parse } from \"../../3rdparty/SheetClip/index.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { sanitize } from \"../../helpers/string.mjs\";\nimport { removeContentEditableFromElementAndDeselect, runWithSelectedContendEditableElement, makeElementContentEditableAndSelectItsContent } from \"../../helpers/dom/element.mjs\";\nimport { isSafari } from \"../../helpers/browser.mjs\";\nimport copyItem from \"./contextMenuItem/copy.mjs\";\nimport copyColumnHeadersOnlyItem from \"./contextMenuItem/copyColumnHeadersOnly.mjs\";\nimport copyWithColumnGroupHeadersItem from \"./contextMenuItem/copyWithColumnGroupHeaders.mjs\";\nimport copyWithColumnHeadersItem from \"./contextMenuItem/copyWithColumnHeaders.mjs\";\nimport cutItem from \"./contextMenuItem/cut.mjs\";\nimport PasteEvent from \"./pasteEvent.mjs\";\nimport { CopyableRangesFactory, normalizeRanges } from \"./copyableRanges.mjs\";\nimport { _dataToHTML, htmlToGridSettings } from \"../../utils/parseTable.mjs\";\nHooks.getSingleton().register('afterCopyLimit');\nHooks.getSingleton().register('modifyCopyableRange');\nHooks.getSingleton().register('beforeCut');\nHooks.getSingleton().register('afterCut');\nHooks.getSingleton().register('beforePaste');\nHooks.getSingleton().register('afterPaste');\nHooks.getSingleton().register('beforeCopy');\nHooks.getSingleton().register('afterCopy');\nexport const PLUGIN_KEY = 'copyPaste';\nexport const PLUGIN_PRIORITY = 80;\nconst SETTING_KEYS = ['fragmentSelection'];\nconst META_HEAD = ['<meta name=\"generator\" content=\"Handsontable\"/>', '<style type=\"text/css\">td{white-space:normal}br{mso-data-placement:same-cell}</style>'].join('');\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n * Copy, cut, and paste data by using the `CopyPaste` plugin.\n *\n * Control the `CopyPaste` plugin programmatically through its [API methods](#methods).\n *\n * The user can access the copy-paste features through:\n * - The [context menu](@/guides/cell-features/clipboard.md#context-menu).\n * - The [keyboard shortcuts](@/guides/cell-features/clipboard.md#related-keyboard-shortcuts).\n * - The browser's menu bar.\n *\n * Read more:\n * - [Guides: Clipboard](@/guides/cell-features/clipboard.md)\n * - [Configuration options: `copyPaste`](@/api/options.md#copypaste)\n *\n * @example\n * ```js\n * // enable the plugin with the default configuration\n * copyPaste: true,\n *\n * // or, enable the plugin with a custom configuration\n * copyPaste: {\n *   columnsLimit: 25,\n *   rowsLimit: 50,\n *   pasteMode: 'shift_down',\n *   copyColumnHeaders: true,\n *   copyColumnGroupHeaders: true,\n *   copyColumnHeadersOnly: true,\n *   uiContainer: document.body,\n * },\n * ```\n * @class CopyPaste\n * @plugin CopyPaste\n */\nvar _enableCopyColumnHeaders = /*#__PURE__*/new WeakMap();\nvar _enableCopyColumnGroupHeaders = /*#__PURE__*/new WeakMap();\nvar _enableCopyColumnHeadersOnly = /*#__PURE__*/new WeakMap();\nvar _copyMode = /*#__PURE__*/new WeakMap();\nvar _isTriggeredByCopy = /*#__PURE__*/new WeakMap();\nvar _isTriggeredByCut = /*#__PURE__*/new WeakMap();\nvar _copyableRangesFactory = /*#__PURE__*/new WeakMap();\nvar _preventViewportScrollOnPaste = /*#__PURE__*/new WeakMap();\nvar _ensureClipboardEventsGetTriggered = /*#__PURE__*/new WeakSet();\nvar _countCopiedHeaders = /*#__PURE__*/new WeakSet();\nvar _addContentEditableToHighlightedCell = /*#__PURE__*/new WeakSet();\nvar _removeContentEditableFromHighlightedCell = /*#__PURE__*/new WeakSet();\nvar _onAfterContextMenuDefaultOptions = /*#__PURE__*/new WeakSet();\nvar _onAfterSelection = /*#__PURE__*/new WeakSet();\nvar _onAfterSelectionEnd = /*#__PURE__*/new WeakSet();\nvar _onSafariMouseEnter = /*#__PURE__*/new WeakSet();\nvar _onSafariMouseLeave = /*#__PURE__*/new WeakSet();\nvar _onSafariAfterSelection = /*#__PURE__*/new WeakSet();\nexport class CopyPaste extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `afterSelection` hook callback triggered only on Safari.\n     */\n    _classPrivateMethodInitSpec(this, _onSafariAfterSelection);\n    /**\n     * `document.body` `mouseleave` callback used to work around a Safari's problem with copying/cutting from the\n     * browser's menu.\n     */\n    _classPrivateMethodInitSpec(this, _onSafariMouseLeave);\n    /**\n     * `document.body` `mouseenter` callback used to work around a Safari's problem with copying/cutting from the\n     * browser's menu.\n     */\n    _classPrivateMethodInitSpec(this, _onSafariMouseEnter);\n    /**\n     * Force focus on focusableElement after end of the selection.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterSelectionEnd);\n    /**\n     * Disables the viewport scroll after pasting the data.\n     *\n     * @param {number} fromRow Selection start row visual index.\n     * @param {number} fromColumn Selection start column visual index.\n     * @param {number} toRow Selection end row visual index.\n     * @param {number} toColumn Selection end column visual index.\n     * @param {object} preventScrolling Object with `value` property. If `true`, the viewport scroll will be prevented.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterSelection);\n    /**\n     * Add copy and cut options to the Context Menu.\n     *\n     * @param {object} options Contains default added options of the Context Menu.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterContextMenuDefaultOptions);\n    /**\n     * Remove the `contenteditable` attribute from the highlighted cell and deselect its content.\n     */\n    _classPrivateMethodInitSpec(this, _removeContentEditableFromHighlightedCell);\n    /**\n     * Add the `contenteditable` attribute to the highlighted cell and select its content.\n     */\n    _classPrivateMethodInitSpec(this, _addContentEditableToHighlightedCell);\n    /**\n     * Counts how many column headers will be copied based on the passed range.\n     *\n     * @private\n     * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n     * @returns {{ columnHeadersCount: number }} Returns an object with keys that holds\n     *                                           information with the number of copied headers.\n     */\n    _classPrivateMethodInitSpec(this, _countCopiedHeaders);\n    /**\n     * Ensure that the `copy`/`cut` events get triggered properly in Safari.\n     *\n     * @param {string} eventName Name of the event to get triggered.\n     */\n    _classPrivateMethodInitSpec(this, _ensureClipboardEventsGetTriggered);\n    /**\n     * The maximum number of columns than can be copied to the clipboard.\n     *\n     * @type {number}\n     * @default Infinity\n     */\n    _defineProperty(this, \"columnsLimit\", Infinity);\n    /**\n     * The maximum number of rows than can be copied to the clipboard.\n     *\n     * @type {number}\n     * @default Infinity\n     */\n    _defineProperty(this, \"rowsLimit\", Infinity);\n    /**\n     * When pasting:\n     * - `'overwrite'`: overwrite the currently-selected cells\n     * - `'shift_down'`: move currently-selected cells down\n     * - `'shift_right'`: move currently-selected cells to the right\n     *\n     * @type {string}\n     * @default 'overwrite'\n     */\n    _defineProperty(this, \"pasteMode\", 'overwrite');\n    /**\n     * The UI container for the secondary focusable element.\n     *\n     * @type {HTMLElement}\n     */\n    _defineProperty(this, \"uiContainer\", this.hot.rootDocument.body);\n    /**\n     * Shows the \"Copy with headers\" item in the context menu and extends the context menu with the\n     * `'copy_with_column_headers'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnHeaders, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Shows the \"Copy with group headers\" item in the context menu and extends the context menu with the\n     * `'copy_with_column_group headers'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnGroupHeaders, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Shows the \"Copy headers only\" item in the context menu and extends the context menu with the\n     * `'copy_column_headers_only'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnHeadersOnly, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Defines the data range to copy. Possible values:\n     *  * `'cells-only'` Copy selected cells only;\n     *  * `'column-headers-only'` Copy column headers only;\n     *  * `'with-column-group-headers'` Copy cells with all column headers;\n     *  * `'with-column-headers'` Copy cells with column headers;\n     *\n     * @type {'cells-only' | 'column-headers-only' | 'with-column-group-headers' | 'with-column-headers'}\n     */\n    _classPrivateFieldInitSpec(this, _copyMode, {\n      writable: true,\n      value: 'cells-only'\n    });\n    /**\n     * Flag that is used to prevent copying when the native shortcut was not pressed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isTriggeredByCopy, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Flag that is used to prevent cutting when the native shortcut was not pressed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isTriggeredByCut, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Class that helps generate copyable ranges based on the current selection for different copy mode\n     * types.\n     *\n     * @type {CopyableRangesFactory}\n     */\n    _classPrivateFieldInitSpec(this, _copyableRangesFactory, {\n      writable: true,\n      value: new CopyableRangesFactory({\n        countRows: () => this.hot.countRows(),\n        countColumns: () => this.hot.countCols(),\n        rowsLimit: () => this.rowsLimit,\n        columnsLimit: () => this.columnsLimit,\n        countColumnHeaders: () => this.hot.view.getColumnHeadersCount()\n      })\n    });\n    /**\n     * Flag that indicates if the viewport scroll should be prevented after pasting the data.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _preventViewportScrollOnPaste, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Ranges of the cells coordinates, which should be used to copy/cut/paste actions.\n     *\n     * @private\n     * @type {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>}\n     */\n    _defineProperty(this, \"copyableRanges\", []);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the [`CopyPaste`](#copypaste) plugin is enabled.\n   *\n   * This method gets called by Handsontable's [`beforeInit`](@/api/hooks.md#beforeinit) hook.\n   * If it returns `true`, the [`enablePlugin()`](#enableplugin) method gets called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const {\n      [PLUGIN_KEY]: settings\n    } = this.hot.getSettings();\n    if (typeof settings === 'object') {\n      var _settings$pasteMode, _settings$uiContainer;\n      this.pasteMode = (_settings$pasteMode = settings.pasteMode) !== null && _settings$pasteMode !== void 0 ? _settings$pasteMode : this.pasteMode;\n      this.rowsLimit = isNaN(settings.rowsLimit) ? this.rowsLimit : settings.rowsLimit;\n      this.columnsLimit = isNaN(settings.columnsLimit) ? this.columnsLimit : settings.columnsLimit;\n      _classPrivateFieldSet(this, _enableCopyColumnHeaders, !!settings.copyColumnHeaders);\n      _classPrivateFieldSet(this, _enableCopyColumnGroupHeaders, !!settings.copyColumnGroupHeaders);\n      _classPrivateFieldSet(this, _enableCopyColumnHeadersOnly, !!settings.copyColumnHeadersOnly);\n      this.uiContainer = (_settings$uiContainer = settings.uiContainer) !== null && _settings$uiContainer !== void 0 ? _settings$uiContainer : this.uiContainer;\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => _classPrivateMethodGet(this, _onAfterContextMenuDefaultOptions, _onAfterContextMenuDefaultOptions2).call(this, options));\n    this.addHook('afterSelection', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onAfterSelection, _onAfterSelection2).call(_this, ...args);\n    });\n    this.addHook('afterSelectionEnd', () => _classPrivateMethodGet(this, _onAfterSelectionEnd, _onAfterSelectionEnd2).call(this));\n    this.eventManager.addEventListener(this.hot.rootDocument, 'copy', function () {\n      return _this.onCopy(...arguments);\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument, 'cut', function () {\n      return _this.onCut(...arguments);\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument, 'paste', function () {\n      return _this.onPaste(...arguments);\n    });\n\n    // Without this workaround Safari (tested on Safari@16.5.2) does allow copying/cutting from the browser menu.\n    if (isSafari()) {\n      this.eventManager.addEventListener(this.hot.rootDocument.body, 'mouseenter', function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return _classPrivateMethodGet(_this, _onSafariMouseEnter, _onSafariMouseEnter2).call(_this, ...args);\n      });\n      this.eventManager.addEventListener(this.hot.rootDocument.body, 'mouseleave', function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        return _classPrivateMethodGet(_this, _onSafariMouseLeave, _onSafariMouseLeave2).call(_this, ...args);\n      });\n      this.addHook('afterSelection', () => _classPrivateMethodGet(this, _onSafariAfterSelection, _onSafariAfterSelection2).call(this));\n    }\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the state of the [`CopyPaste`](#copypaste) plugin.\n   *\n   * Gets called when [`updateSettings()`](@/api/core.md#updatesettings)\n   * is invoked with any of the following configuration options:\n   *  - [`copyPaste`](@/api/options.md#copypaste)\n   *  - [`fragmentSelection`](@/api/options.md#fragmentselection)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.\n   */\n  disablePlugin() {\n    super.disablePlugin();\n  }\n\n  /**\n   * Copies the contents of the selected cells (and/or their related column headers) to the system clipboard.\n   *\n   * Takes an optional parameter (`copyMode`) that defines the scope of copying:\n   *\n   * | `copyMode` value              | Description                                                     |\n   * | ----------------------------- | --------------------------------------------------------------- |\n   * | `'cells-only'` (default)      | Copy the selected cells                                         |\n   * | `'with-column-headers'`       | - Copy the selected cells<br>- Copy the nearest column headers  |\n   * | `'with-column-group-headers'` | - Copy the selected cells<br>- Copy all related columns headers |\n   * | `'column-headers-only'`       | Copy the nearest column headers (without copying cells)         |\n   *\n   * @param {string} [copyMode='cells-only'] Copy mode.\n   */\n  copy() {\n    let copyMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cells-only';\n    _classPrivateFieldSet(this, _copyMode, copyMode);\n    _classPrivateFieldSet(this, _isTriggeredByCopy, true);\n    _classPrivateMethodGet(this, _ensureClipboardEventsGetTriggered, _ensureClipboardEventsGetTriggered2).call(this, 'copy');\n  }\n\n  /**\n   * Copies the contents of the selected cells.\n   */\n  copyCellsOnly() {\n    this.copy('cells-only');\n  }\n  /**\n   * Copies the contents of column headers that are nearest to the selected cells.\n   */\n  copyColumnHeadersOnly() {\n    this.copy('column-headers-only');\n  }\n  /**\n   * Copies the contents of the selected cells and all their related column headers.\n   */\n  copyWithAllColumnHeaders() {\n    this.copy('with-column-group-headers');\n  }\n  /**\n   * Copies the contents of the selected cells and their nearest column headers.\n   */\n  copyWithColumnHeaders() {\n    this.copy('with-column-headers');\n  }\n\n  /**\n   * Cuts the contents of the selected cells to the system clipboard.\n   */\n  cut() {\n    _classPrivateFieldSet(this, _isTriggeredByCut, true);\n    _classPrivateMethodGet(this, _ensureClipboardEventsGetTriggered, _ensureClipboardEventsGetTriggered2).call(this, 'cut');\n  }\n\n  /**\n   * Converts the contents of multiple ranges (`ranges`) into a single string.\n   *\n   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `endRow`, `startCol` and `endCol`.\n   * @returns {string} A string that will be copied to the clipboard.\n   */\n  getRangedCopyableData(ranges) {\n    return stringify(this.getRangedData(ranges));\n  }\n\n  /**\n   * Converts the contents of multiple ranges (`ranges`) into an array of arrays.\n   *\n   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n   * @returns {Array[]} An array of arrays that will be copied to the clipboard.\n   */\n  getRangedData(ranges) {\n    const data = [];\n    const {\n      rows,\n      columns\n    } = normalizeRanges(ranges);\n\n    // concatenate all rows and columns data defined in ranges into one copyable string\n    arrayEach(rows, row => {\n      const rowSet = [];\n      arrayEach(columns, column => {\n        if (row < 0) {\n          // `row` as the second argument acts here as the `headerLevel` argument\n          rowSet.push(this.hot.getColHeader(column, row));\n        } else {\n          rowSet.push(this.hot.getCopyableData(row, column));\n        }\n      });\n      data.push(rowSet);\n    });\n    return data;\n  }\n\n  /**\n   * Simulates the paste action.\n   *\n   * For security reasons, modern browsers don't allow reading from the system clipboard.\n   *\n   * @param {string} pastableText The value to paste, as a raw string.\n   * @param {string} [pastableHtml=''] The value to paste, as HTML.\n   */\n  paste() {\n    let pastableText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let pastableHtml = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pastableText;\n    if (!pastableText && !pastableHtml) {\n      return;\n    }\n    const pasteData = new PasteEvent();\n    if (pastableText) {\n      pasteData.clipboardData.setData('text/plain', pastableText);\n    }\n    if (pastableHtml) {\n      pasteData.clipboardData.setData('text/html', pastableHtml);\n    }\n    this.onPaste(pasteData);\n  }\n\n  /**\n   * Prepares copyable text from the cells selection in the invisible textarea.\n   */\n  setCopyableText() {\n    const selectionRange = this.hot.getSelectedRangeLast();\n    if (!selectionRange) {\n      return;\n    }\n    if (selectionRange.isSingleHeader()) {\n      this.copyableRanges = [];\n      return;\n    }\n    _classPrivateFieldGet(this, _copyableRangesFactory).setSelectedRange(selectionRange);\n    const groupedRanges = new Map([['headers', null], ['cells', null]]);\n    if (_classPrivateFieldGet(this, _copyMode) === 'column-headers-only') {\n      groupedRanges.set('headers', _classPrivateFieldGet(this, _copyableRangesFactory).getMostBottomColumnHeadersRange());\n    } else {\n      if (_classPrivateFieldGet(this, _copyMode) === 'with-column-headers') {\n        groupedRanges.set('headers', _classPrivateFieldGet(this, _copyableRangesFactory).getMostBottomColumnHeadersRange());\n      } else if (_classPrivateFieldGet(this, _copyMode) === 'with-column-group-headers') {\n        groupedRanges.set('headers', _classPrivateFieldGet(this, _copyableRangesFactory).getAllColumnHeadersRange());\n      }\n      groupedRanges.set('cells', _classPrivateFieldGet(this, _copyableRangesFactory).getCellsRange());\n    }\n    this.copyableRanges = Array.from(groupedRanges.values()).filter(range => range !== null).map(_ref => {\n      let {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      } = _ref;\n      return {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      };\n    });\n    this.copyableRanges = this.hot.runHooks('modifyCopyableRange', this.copyableRanges);\n    const cellsRange = groupedRanges.get('cells');\n    if (cellsRange !== null && cellsRange.isRangeTrimmed) {\n      const {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      } = cellsRange;\n      this.hot.runHooks('afterCopyLimit', endRow - startRow + 1, endCol - startCol + 1, this.rowsLimit, this.columnsLimit);\n    }\n  }\n\n  /**\n   * Verifies if editor exists and is open.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isEditorOpened() {\n    var _this$hot$getActiveEd;\n    return (_this$hot$getActiveEd = this.hot.getActiveEditor()) === null || _this$hot$getActiveEd === void 0 ? void 0 : _this$hot$getActiveEd.isOpened();\n  }\n  /**\n   * Prepares new values to populate them into datasource.\n   *\n   * @private\n   * @param {Array} inputArray An array of the data to populate.\n   * @param {Array} [selection] The selection which indicates from what position the data will be populated.\n   * @returns {Array} Range coordinates after populate data.\n   */\n  populateValues(inputArray) {\n    let selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.hot.getSelectedRangeLast();\n    if (!inputArray.length) {\n      return;\n    }\n    const populatedRowsLength = inputArray.length;\n    const populatedColumnsLength = inputArray[0].length;\n    const newRows = [];\n    const {\n      row: startRow,\n      col: startColumn\n    } = selection.getTopStartCorner();\n    const {\n      row: endRowFromSelection,\n      col: endColumnFromSelection\n    } = selection.getBottomEndCorner();\n    let visualRowForPopulatedData = startRow;\n    let visualColumnForPopulatedData = startColumn;\n    let lastVisualRow = startRow;\n    let lastVisualColumn = startColumn;\n\n    // We try to populate just all copied data or repeat copied data within a selection. Please keep in mind that we\n    // don't know whether populated data is bigger than selection on start as there are some cells for which values\n    // should be not inserted (it's known right after getting cell meta).\n    while (newRows.length < populatedRowsLength || visualRowForPopulatedData <= endRowFromSelection) {\n      const {\n        skipRowOnPaste,\n        visualRow\n      } = this.hot.getCellMeta(visualRowForPopulatedData, startColumn);\n      visualRowForPopulatedData = visualRow + 1;\n      if (skipRowOnPaste === true) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      lastVisualRow = visualRow;\n      visualColumnForPopulatedData = startColumn;\n      const newRow = [];\n      const insertedRow = newRows.length % populatedRowsLength;\n      while (newRow.length < populatedColumnsLength || visualColumnForPopulatedData <= endColumnFromSelection) {\n        const {\n          skipColumnOnPaste,\n          visualCol\n        } = this.hot.getCellMeta(startRow, visualColumnForPopulatedData);\n        visualColumnForPopulatedData = visualCol + 1;\n        if (skipColumnOnPaste === true) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        lastVisualColumn = visualCol;\n        const insertedColumn = newRow.length % populatedColumnsLength;\n        newRow.push(inputArray[insertedRow][insertedColumn]);\n      }\n      newRows.push(newRow);\n    }\n    _classPrivateFieldSet(this, _preventViewportScrollOnPaste, true);\n    this.hot.populateFromArray(startRow, startColumn, newRows, undefined, undefined, 'CopyPaste.paste', this.pasteMode);\n    return [startRow, startColumn, lastVisualRow, lastVisualColumn];\n  }\n  /**\n   * `copy` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent.\n   * @private\n   */\n  onCopy(event) {\n    if (!this.hot.isListening() && !_classPrivateFieldGet(this, _isTriggeredByCopy) || this.isEditorOpened()) {\n      return;\n    }\n    this.setCopyableText();\n    _classPrivateFieldSet(this, _isTriggeredByCopy, false);\n    const data = this.getRangedData(this.copyableRanges);\n    const copiedHeadersCount = _classPrivateMethodGet(this, _countCopiedHeaders, _countCopiedHeaders2).call(this, this.copyableRanges);\n    const allowCopying = !!this.hot.runHooks('beforeCopy', data, this.copyableRanges, copiedHeadersCount);\n    if (allowCopying) {\n      const textPlain = stringify(data);\n      if (event && event.clipboardData) {\n        const textHTML = _dataToHTML(data, this.hot.rootDocument);\n        event.clipboardData.setData('text/plain', textPlain);\n        event.clipboardData.setData('text/html', [META_HEAD, textHTML].join(''));\n      } else if (typeof ClipboardEvent === 'undefined') {\n        this.hot.rootWindow.clipboardData.setData('Text', textPlain);\n      }\n      this.hot.runHooks('afterCopy', data, this.copyableRanges, copiedHeadersCount);\n    }\n    _classPrivateFieldSet(this, _copyMode, 'cells-only');\n    event.preventDefault();\n  }\n\n  /**\n   * `cut` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent.\n   * @private\n   */\n  onCut(event) {\n    if (!this.hot.isListening() && !_classPrivateFieldGet(this, _isTriggeredByCut) || this.isEditorOpened()) {\n      return;\n    }\n    this.setCopyableText();\n    _classPrivateFieldSet(this, _isTriggeredByCut, false);\n    const rangedData = this.getRangedData(this.copyableRanges);\n    const allowCuttingOut = !!this.hot.runHooks('beforeCut', rangedData, this.copyableRanges);\n    if (allowCuttingOut) {\n      const textPlain = stringify(rangedData);\n      if (event && event.clipboardData) {\n        const textHTML = _dataToHTML(rangedData, this.hot.rootDocument);\n        event.clipboardData.setData('text/plain', textPlain);\n        event.clipboardData.setData('text/html', [META_HEAD, textHTML].join(''));\n      } else if (typeof ClipboardEvent === 'undefined') {\n        this.hot.rootWindow.clipboardData.setData('Text', textPlain);\n      }\n      this.hot.emptySelectedCells('CopyPaste.cut');\n      this.hot.runHooks('afterCut', rangedData, this.copyableRanges);\n    }\n    event.preventDefault();\n  }\n\n  /**\n   * `paste` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent or pseudo ClipboardEvent, if paste was called manually.\n   * @private\n   */\n  onPaste(event) {\n    if (!this.hot.isListening() || this.isEditorOpened() || !this.hot.getSelected()) {\n      return;\n    }\n    if (event && event.preventDefault) {\n      event.preventDefault();\n    }\n    let pastedData;\n    if (event && typeof event.clipboardData !== 'undefined') {\n      const textHTML = sanitize(event.clipboardData.getData('text/html'), {\n        ADD_TAGS: ['meta'],\n        ADD_ATTR: ['content'],\n        FORCE_BODY: true\n      });\n      if (textHTML && /(<table)|(<TABLE)/g.test(textHTML)) {\n        const parsedConfig = htmlToGridSettings(textHTML, this.hot.rootDocument);\n        pastedData = parsedConfig.data;\n      } else {\n        pastedData = event.clipboardData.getData('text/plain');\n      }\n    } else if (typeof ClipboardEvent === 'undefined' && typeof this.hot.rootWindow.clipboardData !== 'undefined') {\n      pastedData = this.hot.rootWindow.clipboardData.getData('Text');\n    }\n    if (typeof pastedData === 'string') {\n      pastedData = parse(pastedData);\n    }\n    if (pastedData === void 0 || pastedData && pastedData.length === 0) {\n      return;\n    }\n    if (this.hot.runHooks('beforePaste', pastedData, this.copyableRanges) === false) {\n      return;\n    }\n    const [startRow, startColumn, endRow, endColumn] = this.populateValues(pastedData);\n    this.hot.selectCell(startRow, startColumn, Math.min(this.hot.countRows() - 1, endRow), Math.min(this.hot.countCols() - 1, endColumn));\n    this.hot.runHooks('afterPaste', pastedData, this.copyableRanges);\n  }\n  /**\n   * Destroys the `CopyPaste` plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _ensureClipboardEventsGetTriggered2(eventName) {\n  // Without this workaround Safari (tested on Safari@16.5.2) does not trigger the 'copy' event.\n  if (isSafari()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell) {\n        runWithSelectedContendEditableElement(currentlySelectedCell, () => {\n          this.hot.rootDocument.execCommand(eventName);\n        });\n      }\n    }\n  } else {\n    this.hot.rootDocument.execCommand(eventName);\n  }\n}\nfunction _countCopiedHeaders2(ranges) {\n  const {\n    rows\n  } = normalizeRanges(ranges);\n  let columnHeadersCount = 0;\n  for (let row = 0; row < rows.length; row++) {\n    if (rows[row] >= 0) {\n      break;\n    }\n    columnHeadersCount += 1;\n  }\n  return {\n    columnHeadersCount\n  };\n}\nfunction _addContentEditableToHighlightedCell2() {\n  if (this.hot.isListening()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell) {\n        makeElementContentEditableAndSelectItsContent(currentlySelectedCell);\n      }\n    }\n  }\n}\nfunction _removeContentEditableFromHighlightedCell2() {\n  // If the instance is not listening, the workaround is not needed.\n  if (this.hot.isListening()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell !== null && currentlySelectedCell !== void 0 && currentlySelectedCell.hasAttribute('contenteditable')) {\n        removeContentEditableFromElementAndDeselect(currentlySelectedCell);\n      }\n    }\n  }\n}\nfunction _onAfterContextMenuDefaultOptions2(options) {\n  options.items.push({\n    name: '---------'\n  }, copyItem(this));\n  if (_classPrivateFieldGet(this, _enableCopyColumnHeaders)) {\n    options.items.push(copyWithColumnHeadersItem(this));\n  }\n  if (_classPrivateFieldGet(this, _enableCopyColumnGroupHeaders)) {\n    options.items.push(copyWithColumnGroupHeadersItem(this));\n  }\n  if (_classPrivateFieldGet(this, _enableCopyColumnHeadersOnly)) {\n    options.items.push(copyColumnHeadersOnlyItem(this));\n  }\n  options.items.push(cutItem(this));\n}\nfunction _onAfterSelection2(fromRow, fromColumn, toRow, toColumn, preventScrolling) {\n  if (_classPrivateFieldGet(this, _preventViewportScrollOnPaste)) {\n    preventScrolling.value = true;\n  }\n  _classPrivateFieldSet(this, _preventViewportScrollOnPaste, false);\n}\nfunction _onAfterSelectionEnd2() {\n  if (this.isEditorOpened()) {\n    return;\n  }\n  if (this.hot.getSettings().fragmentSelection) {\n    return;\n  }\n  this.setCopyableText();\n}\nfunction _onSafariMouseEnter2() {\n  _classPrivateMethodGet(this, _removeContentEditableFromHighlightedCell, _removeContentEditableFromHighlightedCell2).call(this);\n}\nfunction _onSafariMouseLeave2() {\n  _classPrivateMethodGet(this, _addContentEditableToHighlightedCell, _addContentEditableToHighlightedCell2).call(this);\n}\nfunction _onSafariAfterSelection2() {\n  _classPrivateMethodGet(this, _removeContentEditableFromHighlightedCell, _removeContentEditableFromHighlightedCell2).call(this);\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","privateMap","value","set","privateCollection","has","TypeError","_defineProperty","key","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","_classPrivateMethodGet","fn","_classPrivateFieldSet","_classApplyDescriptorSet","action","BasePlugin","Hooks","stringify","parse","arrayEach","sanitize","removeContentEditableFromElementAndDeselect","runWithSelectedContendEditableElement","makeElementContentEditableAndSelectItsContent","isSafari","copyItem","copyColumnHeadersOnlyItem","copyWithColumnGroupHeadersItem","copyWithColumnHeadersItem","cutItem","PasteEvent","CopyableRangesFactory","normalizeRanges","_dataToHTML","htmlToGridSettings","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","SETTING_KEYS","META_HEAD","join","_enableCopyColumnHeaders","WeakMap","_enableCopyColumnGroupHeaders","_enableCopyColumnHeadersOnly","_copyMode","_isTriggeredByCopy","_isTriggeredByCut","_copyableRangesFactory","_preventViewportScrollOnPaste","_ensureClipboardEventsGetTriggered","WeakSet","_countCopiedHeaders","_addContentEditableToHighlightedCell","_removeContentEditableFromHighlightedCell","_onAfterContextMenuDefaultOptions","_onAfterSelection","_onAfterSelectionEnd","_onSafariMouseEnter","_onSafariMouseLeave","_onSafariAfterSelection","CopyPaste","constructor","arguments","Infinity","hot","rootDocument","body","countRows","countColumns","countCols","rowsLimit","columnsLimit","countColumnHeaders","view","getColumnHeadersCount","isEnabled","getSettings","enablePlugin","_this","enabled","settings","_settings$pasteMode","_settings$uiContainer","pasteMode","isNaN","copyColumnHeaders","copyColumnGroupHeaders","copyColumnHeadersOnly","uiContainer","addHook","options","_onAfterContextMenuDefaultOptions2","_len","length","args","Array","_key","_onAfterSelection2","_onAfterSelectionEnd2","eventManager","addEventListener","onCopy","onCut","onPaste","_len2","_key2","_onSafariMouseEnter2","_len3","_key3","_onSafariMouseLeave2","_onSafariAfterSelection2","updatePlugin","disablePlugin","copy","copyMode","undefined","_ensureClipboardEventsGetTriggered2","copyCellsOnly","copyWithAllColumnHeaders","copyWithColumnHeaders","cut","getRangedCopyableData","ranges","getRangedData","data","rows","columns","row","rowSet","column","push","getColHeader","getCopyableData","paste","pastableText","pastableHtml","pasteData","clipboardData","setData","setCopyableText","selectionRange","getSelectedRangeLast","isSingleHeader","copyableRanges","setSelectedRange","groupedRanges","Map","getMostBottomColumnHeadersRange","getAllColumnHeadersRange","getCellsRange","from","values","filter","range","map","_ref","startRow","startCol","endRow","endCol","runHooks","cellsRange","isRangeTrimmed","isEditorOpened","_this$hot$getActiveEd","getActiveEditor","isOpened","populateValues","inputArray","selection","populatedRowsLength","populatedColumnsLength","newRows","col","startColumn","getTopStartCorner","endRowFromSelection","endColumnFromSelection","getBottomEndCorner","visualRowForPopulatedData","visualColumnForPopulatedData","lastVisualRow","lastVisualColumn","skipRowOnPaste","visualRow","getCellMeta","newRow","insertedRow","skipColumnOnPaste","visualCol","insertedColumn","populateFromArray","event","isListening","copiedHeadersCount","_countCopiedHeaders2","allowCopying","textPlain","textHTML","ClipboardEvent","rootWindow","preventDefault","rangedData","allowCuttingOut","emptySelectedCells","getSelected","pastedData","getData","ADD_TAGS","ADD_ATTR","FORCE_BODY","test","parsedConfig","endColumn","selectCell","Math","min","destroy","eventName","lastSelectedRange","highlightRow","highlightColumn","highlight","currentlySelectedCell","getCell","execCommand","columnHeadersCount","_addContentEditableToHighlightedCell2","_removeContentEditableFromHighlightedCell2","hasAttribute","items","name","fromRow","fromColumn","toRow","toColumn","preventScrolling","fragmentSelection"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/copyPaste/copyPaste.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { stringify, parse } from \"../../3rdparty/SheetClip/index.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { sanitize } from \"../../helpers/string.mjs\";\nimport { removeContentEditableFromElementAndDeselect, runWithSelectedContendEditableElement, makeElementContentEditableAndSelectItsContent } from \"../../helpers/dom/element.mjs\";\nimport { isSafari } from \"../../helpers/browser.mjs\";\nimport copyItem from \"./contextMenuItem/copy.mjs\";\nimport copyColumnHeadersOnlyItem from \"./contextMenuItem/copyColumnHeadersOnly.mjs\";\nimport copyWithColumnGroupHeadersItem from \"./contextMenuItem/copyWithColumnGroupHeaders.mjs\";\nimport copyWithColumnHeadersItem from \"./contextMenuItem/copyWithColumnHeaders.mjs\";\nimport cutItem from \"./contextMenuItem/cut.mjs\";\nimport PasteEvent from \"./pasteEvent.mjs\";\nimport { CopyableRangesFactory, normalizeRanges } from \"./copyableRanges.mjs\";\nimport { _dataToHTML, htmlToGridSettings } from \"../../utils/parseTable.mjs\";\nHooks.getSingleton().register('afterCopyLimit');\nHooks.getSingleton().register('modifyCopyableRange');\nHooks.getSingleton().register('beforeCut');\nHooks.getSingleton().register('afterCut');\nHooks.getSingleton().register('beforePaste');\nHooks.getSingleton().register('afterPaste');\nHooks.getSingleton().register('beforeCopy');\nHooks.getSingleton().register('afterCopy');\nexport const PLUGIN_KEY = 'copyPaste';\nexport const PLUGIN_PRIORITY = 80;\nconst SETTING_KEYS = ['fragmentSelection'];\nconst META_HEAD = ['<meta name=\"generator\" content=\"Handsontable\"/>', '<style type=\"text/css\">td{white-space:normal}br{mso-data-placement:same-cell}</style>'].join('');\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n * Copy, cut, and paste data by using the `CopyPaste` plugin.\n *\n * Control the `CopyPaste` plugin programmatically through its [API methods](#methods).\n *\n * The user can access the copy-paste features through:\n * - The [context menu](@/guides/cell-features/clipboard.md#context-menu).\n * - The [keyboard shortcuts](@/guides/cell-features/clipboard.md#related-keyboard-shortcuts).\n * - The browser's menu bar.\n *\n * Read more:\n * - [Guides: Clipboard](@/guides/cell-features/clipboard.md)\n * - [Configuration options: `copyPaste`](@/api/options.md#copypaste)\n *\n * @example\n * ```js\n * // enable the plugin with the default configuration\n * copyPaste: true,\n *\n * // or, enable the plugin with a custom configuration\n * copyPaste: {\n *   columnsLimit: 25,\n *   rowsLimit: 50,\n *   pasteMode: 'shift_down',\n *   copyColumnHeaders: true,\n *   copyColumnGroupHeaders: true,\n *   copyColumnHeadersOnly: true,\n *   uiContainer: document.body,\n * },\n * ```\n * @class CopyPaste\n * @plugin CopyPaste\n */\nvar _enableCopyColumnHeaders = /*#__PURE__*/new WeakMap();\nvar _enableCopyColumnGroupHeaders = /*#__PURE__*/new WeakMap();\nvar _enableCopyColumnHeadersOnly = /*#__PURE__*/new WeakMap();\nvar _copyMode = /*#__PURE__*/new WeakMap();\nvar _isTriggeredByCopy = /*#__PURE__*/new WeakMap();\nvar _isTriggeredByCut = /*#__PURE__*/new WeakMap();\nvar _copyableRangesFactory = /*#__PURE__*/new WeakMap();\nvar _preventViewportScrollOnPaste = /*#__PURE__*/new WeakMap();\nvar _ensureClipboardEventsGetTriggered = /*#__PURE__*/new WeakSet();\nvar _countCopiedHeaders = /*#__PURE__*/new WeakSet();\nvar _addContentEditableToHighlightedCell = /*#__PURE__*/new WeakSet();\nvar _removeContentEditableFromHighlightedCell = /*#__PURE__*/new WeakSet();\nvar _onAfterContextMenuDefaultOptions = /*#__PURE__*/new WeakSet();\nvar _onAfterSelection = /*#__PURE__*/new WeakSet();\nvar _onAfterSelectionEnd = /*#__PURE__*/new WeakSet();\nvar _onSafariMouseEnter = /*#__PURE__*/new WeakSet();\nvar _onSafariMouseLeave = /*#__PURE__*/new WeakSet();\nvar _onSafariAfterSelection = /*#__PURE__*/new WeakSet();\nexport class CopyPaste extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `afterSelection` hook callback triggered only on Safari.\n     */\n    _classPrivateMethodInitSpec(this, _onSafariAfterSelection);\n    /**\n     * `document.body` `mouseleave` callback used to work around a Safari's problem with copying/cutting from the\n     * browser's menu.\n     */\n    _classPrivateMethodInitSpec(this, _onSafariMouseLeave);\n    /**\n     * `document.body` `mouseenter` callback used to work around a Safari's problem with copying/cutting from the\n     * browser's menu.\n     */\n    _classPrivateMethodInitSpec(this, _onSafariMouseEnter);\n    /**\n     * Force focus on focusableElement after end of the selection.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterSelectionEnd);\n    /**\n     * Disables the viewport scroll after pasting the data.\n     *\n     * @param {number} fromRow Selection start row visual index.\n     * @param {number} fromColumn Selection start column visual index.\n     * @param {number} toRow Selection end row visual index.\n     * @param {number} toColumn Selection end column visual index.\n     * @param {object} preventScrolling Object with `value` property. If `true`, the viewport scroll will be prevented.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterSelection);\n    /**\n     * Add copy and cut options to the Context Menu.\n     *\n     * @param {object} options Contains default added options of the Context Menu.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterContextMenuDefaultOptions);\n    /**\n     * Remove the `contenteditable` attribute from the highlighted cell and deselect its content.\n     */\n    _classPrivateMethodInitSpec(this, _removeContentEditableFromHighlightedCell);\n    /**\n     * Add the `contenteditable` attribute to the highlighted cell and select its content.\n     */\n    _classPrivateMethodInitSpec(this, _addContentEditableToHighlightedCell);\n    /**\n     * Counts how many column headers will be copied based on the passed range.\n     *\n     * @private\n     * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n     * @returns {{ columnHeadersCount: number }} Returns an object with keys that holds\n     *                                           information with the number of copied headers.\n     */\n    _classPrivateMethodInitSpec(this, _countCopiedHeaders);\n    /**\n     * Ensure that the `copy`/`cut` events get triggered properly in Safari.\n     *\n     * @param {string} eventName Name of the event to get triggered.\n     */\n    _classPrivateMethodInitSpec(this, _ensureClipboardEventsGetTriggered);\n    /**\n     * The maximum number of columns than can be copied to the clipboard.\n     *\n     * @type {number}\n     * @default Infinity\n     */\n    _defineProperty(this, \"columnsLimit\", Infinity);\n    /**\n     * The maximum number of rows than can be copied to the clipboard.\n     *\n     * @type {number}\n     * @default Infinity\n     */\n    _defineProperty(this, \"rowsLimit\", Infinity);\n    /**\n     * When pasting:\n     * - `'overwrite'`: overwrite the currently-selected cells\n     * - `'shift_down'`: move currently-selected cells down\n     * - `'shift_right'`: move currently-selected cells to the right\n     *\n     * @type {string}\n     * @default 'overwrite'\n     */\n    _defineProperty(this, \"pasteMode\", 'overwrite');\n    /**\n     * The UI container for the secondary focusable element.\n     *\n     * @type {HTMLElement}\n     */\n    _defineProperty(this, \"uiContainer\", this.hot.rootDocument.body);\n    /**\n     * Shows the \"Copy with headers\" item in the context menu and extends the context menu with the\n     * `'copy_with_column_headers'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnHeaders, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Shows the \"Copy with group headers\" item in the context menu and extends the context menu with the\n     * `'copy_with_column_group headers'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnGroupHeaders, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Shows the \"Copy headers only\" item in the context menu and extends the context menu with the\n     * `'copy_column_headers_only'` option that can be used for creating custom menus arrangements.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    _classPrivateFieldInitSpec(this, _enableCopyColumnHeadersOnly, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Defines the data range to copy. Possible values:\n     *  * `'cells-only'` Copy selected cells only;\n     *  * `'column-headers-only'` Copy column headers only;\n     *  * `'with-column-group-headers'` Copy cells with all column headers;\n     *  * `'with-column-headers'` Copy cells with column headers;\n     *\n     * @type {'cells-only' | 'column-headers-only' | 'with-column-group-headers' | 'with-column-headers'}\n     */\n    _classPrivateFieldInitSpec(this, _copyMode, {\n      writable: true,\n      value: 'cells-only'\n    });\n    /**\n     * Flag that is used to prevent copying when the native shortcut was not pressed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isTriggeredByCopy, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Flag that is used to prevent cutting when the native shortcut was not pressed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isTriggeredByCut, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Class that helps generate copyable ranges based on the current selection for different copy mode\n     * types.\n     *\n     * @type {CopyableRangesFactory}\n     */\n    _classPrivateFieldInitSpec(this, _copyableRangesFactory, {\n      writable: true,\n      value: new CopyableRangesFactory({\n        countRows: () => this.hot.countRows(),\n        countColumns: () => this.hot.countCols(),\n        rowsLimit: () => this.rowsLimit,\n        columnsLimit: () => this.columnsLimit,\n        countColumnHeaders: () => this.hot.view.getColumnHeadersCount()\n      })\n    });\n    /**\n     * Flag that indicates if the viewport scroll should be prevented after pasting the data.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _preventViewportScrollOnPaste, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Ranges of the cells coordinates, which should be used to copy/cut/paste actions.\n     *\n     * @private\n     * @type {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>}\n     */\n    _defineProperty(this, \"copyableRanges\", []);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the [`CopyPaste`](#copypaste) plugin is enabled.\n   *\n   * This method gets called by Handsontable's [`beforeInit`](@/api/hooks.md#beforeinit) hook.\n   * If it returns `true`, the [`enablePlugin()`](#enableplugin) method gets called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const {\n      [PLUGIN_KEY]: settings\n    } = this.hot.getSettings();\n    if (typeof settings === 'object') {\n      var _settings$pasteMode, _settings$uiContainer;\n      this.pasteMode = (_settings$pasteMode = settings.pasteMode) !== null && _settings$pasteMode !== void 0 ? _settings$pasteMode : this.pasteMode;\n      this.rowsLimit = isNaN(settings.rowsLimit) ? this.rowsLimit : settings.rowsLimit;\n      this.columnsLimit = isNaN(settings.columnsLimit) ? this.columnsLimit : settings.columnsLimit;\n      _classPrivateFieldSet(this, _enableCopyColumnHeaders, !!settings.copyColumnHeaders);\n      _classPrivateFieldSet(this, _enableCopyColumnGroupHeaders, !!settings.copyColumnGroupHeaders);\n      _classPrivateFieldSet(this, _enableCopyColumnHeadersOnly, !!settings.copyColumnHeadersOnly);\n      this.uiContainer = (_settings$uiContainer = settings.uiContainer) !== null && _settings$uiContainer !== void 0 ? _settings$uiContainer : this.uiContainer;\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => _classPrivateMethodGet(this, _onAfterContextMenuDefaultOptions, _onAfterContextMenuDefaultOptions2).call(this, options));\n    this.addHook('afterSelection', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onAfterSelection, _onAfterSelection2).call(_this, ...args);\n    });\n    this.addHook('afterSelectionEnd', () => _classPrivateMethodGet(this, _onAfterSelectionEnd, _onAfterSelectionEnd2).call(this));\n    this.eventManager.addEventListener(this.hot.rootDocument, 'copy', function () {\n      return _this.onCopy(...arguments);\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument, 'cut', function () {\n      return _this.onCut(...arguments);\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument, 'paste', function () {\n      return _this.onPaste(...arguments);\n    });\n\n    // Without this workaround Safari (tested on Safari@16.5.2) does allow copying/cutting from the browser menu.\n    if (isSafari()) {\n      this.eventManager.addEventListener(this.hot.rootDocument.body, 'mouseenter', function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return _classPrivateMethodGet(_this, _onSafariMouseEnter, _onSafariMouseEnter2).call(_this, ...args);\n      });\n      this.eventManager.addEventListener(this.hot.rootDocument.body, 'mouseleave', function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        return _classPrivateMethodGet(_this, _onSafariMouseLeave, _onSafariMouseLeave2).call(_this, ...args);\n      });\n      this.addHook('afterSelection', () => _classPrivateMethodGet(this, _onSafariAfterSelection, _onSafariAfterSelection2).call(this));\n    }\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the state of the [`CopyPaste`](#copypaste) plugin.\n   *\n   * Gets called when [`updateSettings()`](@/api/core.md#updatesettings)\n   * is invoked with any of the following configuration options:\n   *  - [`copyPaste`](@/api/options.md#copypaste)\n   *  - [`fragmentSelection`](@/api/options.md#fragmentselection)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.\n   */\n  disablePlugin() {\n    super.disablePlugin();\n  }\n\n  /**\n   * Copies the contents of the selected cells (and/or their related column headers) to the system clipboard.\n   *\n   * Takes an optional parameter (`copyMode`) that defines the scope of copying:\n   *\n   * | `copyMode` value              | Description                                                     |\n   * | ----------------------------- | --------------------------------------------------------------- |\n   * | `'cells-only'` (default)      | Copy the selected cells                                         |\n   * | `'with-column-headers'`       | - Copy the selected cells<br>- Copy the nearest column headers  |\n   * | `'with-column-group-headers'` | - Copy the selected cells<br>- Copy all related columns headers |\n   * | `'column-headers-only'`       | Copy the nearest column headers (without copying cells)         |\n   *\n   * @param {string} [copyMode='cells-only'] Copy mode.\n   */\n  copy() {\n    let copyMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cells-only';\n    _classPrivateFieldSet(this, _copyMode, copyMode);\n    _classPrivateFieldSet(this, _isTriggeredByCopy, true);\n    _classPrivateMethodGet(this, _ensureClipboardEventsGetTriggered, _ensureClipboardEventsGetTriggered2).call(this, 'copy');\n  }\n\n  /**\n   * Copies the contents of the selected cells.\n   */\n  copyCellsOnly() {\n    this.copy('cells-only');\n  }\n  /**\n   * Copies the contents of column headers that are nearest to the selected cells.\n   */\n  copyColumnHeadersOnly() {\n    this.copy('column-headers-only');\n  }\n  /**\n   * Copies the contents of the selected cells and all their related column headers.\n   */\n  copyWithAllColumnHeaders() {\n    this.copy('with-column-group-headers');\n  }\n  /**\n   * Copies the contents of the selected cells and their nearest column headers.\n   */\n  copyWithColumnHeaders() {\n    this.copy('with-column-headers');\n  }\n\n  /**\n   * Cuts the contents of the selected cells to the system clipboard.\n   */\n  cut() {\n    _classPrivateFieldSet(this, _isTriggeredByCut, true);\n    _classPrivateMethodGet(this, _ensureClipboardEventsGetTriggered, _ensureClipboardEventsGetTriggered2).call(this, 'cut');\n  }\n\n  /**\n   * Converts the contents of multiple ranges (`ranges`) into a single string.\n   *\n   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `endRow`, `startCol` and `endCol`.\n   * @returns {string} A string that will be copied to the clipboard.\n   */\n  getRangedCopyableData(ranges) {\n    return stringify(this.getRangedData(ranges));\n  }\n\n  /**\n   * Converts the contents of multiple ranges (`ranges`) into an array of arrays.\n   *\n   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n   * @returns {Array[]} An array of arrays that will be copied to the clipboard.\n   */\n  getRangedData(ranges) {\n    const data = [];\n    const {\n      rows,\n      columns\n    } = normalizeRanges(ranges);\n\n    // concatenate all rows and columns data defined in ranges into one copyable string\n    arrayEach(rows, row => {\n      const rowSet = [];\n      arrayEach(columns, column => {\n        if (row < 0) {\n          // `row` as the second argument acts here as the `headerLevel` argument\n          rowSet.push(this.hot.getColHeader(column, row));\n        } else {\n          rowSet.push(this.hot.getCopyableData(row, column));\n        }\n      });\n      data.push(rowSet);\n    });\n    return data;\n  }\n\n  /**\n   * Simulates the paste action.\n   *\n   * For security reasons, modern browsers don't allow reading from the system clipboard.\n   *\n   * @param {string} pastableText The value to paste, as a raw string.\n   * @param {string} [pastableHtml=''] The value to paste, as HTML.\n   */\n  paste() {\n    let pastableText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let pastableHtml = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pastableText;\n    if (!pastableText && !pastableHtml) {\n      return;\n    }\n    const pasteData = new PasteEvent();\n    if (pastableText) {\n      pasteData.clipboardData.setData('text/plain', pastableText);\n    }\n    if (pastableHtml) {\n      pasteData.clipboardData.setData('text/html', pastableHtml);\n    }\n    this.onPaste(pasteData);\n  }\n\n  /**\n   * Prepares copyable text from the cells selection in the invisible textarea.\n   */\n  setCopyableText() {\n    const selectionRange = this.hot.getSelectedRangeLast();\n    if (!selectionRange) {\n      return;\n    }\n    if (selectionRange.isSingleHeader()) {\n      this.copyableRanges = [];\n      return;\n    }\n    _classPrivateFieldGet(this, _copyableRangesFactory).setSelectedRange(selectionRange);\n    const groupedRanges = new Map([['headers', null], ['cells', null]]);\n    if (_classPrivateFieldGet(this, _copyMode) === 'column-headers-only') {\n      groupedRanges.set('headers', _classPrivateFieldGet(this, _copyableRangesFactory).getMostBottomColumnHeadersRange());\n    } else {\n      if (_classPrivateFieldGet(this, _copyMode) === 'with-column-headers') {\n        groupedRanges.set('headers', _classPrivateFieldGet(this, _copyableRangesFactory).getMostBottomColumnHeadersRange());\n      } else if (_classPrivateFieldGet(this, _copyMode) === 'with-column-group-headers') {\n        groupedRanges.set('headers', _classPrivateFieldGet(this, _copyableRangesFactory).getAllColumnHeadersRange());\n      }\n      groupedRanges.set('cells', _classPrivateFieldGet(this, _copyableRangesFactory).getCellsRange());\n    }\n    this.copyableRanges = Array.from(groupedRanges.values()).filter(range => range !== null).map(_ref => {\n      let {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      } = _ref;\n      return {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      };\n    });\n    this.copyableRanges = this.hot.runHooks('modifyCopyableRange', this.copyableRanges);\n    const cellsRange = groupedRanges.get('cells');\n    if (cellsRange !== null && cellsRange.isRangeTrimmed) {\n      const {\n        startRow,\n        startCol,\n        endRow,\n        endCol\n      } = cellsRange;\n      this.hot.runHooks('afterCopyLimit', endRow - startRow + 1, endCol - startCol + 1, this.rowsLimit, this.columnsLimit);\n    }\n  }\n\n  /**\n   * Verifies if editor exists and is open.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isEditorOpened() {\n    var _this$hot$getActiveEd;\n    return (_this$hot$getActiveEd = this.hot.getActiveEditor()) === null || _this$hot$getActiveEd === void 0 ? void 0 : _this$hot$getActiveEd.isOpened();\n  }\n  /**\n   * Prepares new values to populate them into datasource.\n   *\n   * @private\n   * @param {Array} inputArray An array of the data to populate.\n   * @param {Array} [selection] The selection which indicates from what position the data will be populated.\n   * @returns {Array} Range coordinates after populate data.\n   */\n  populateValues(inputArray) {\n    let selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.hot.getSelectedRangeLast();\n    if (!inputArray.length) {\n      return;\n    }\n    const populatedRowsLength = inputArray.length;\n    const populatedColumnsLength = inputArray[0].length;\n    const newRows = [];\n    const {\n      row: startRow,\n      col: startColumn\n    } = selection.getTopStartCorner();\n    const {\n      row: endRowFromSelection,\n      col: endColumnFromSelection\n    } = selection.getBottomEndCorner();\n    let visualRowForPopulatedData = startRow;\n    let visualColumnForPopulatedData = startColumn;\n    let lastVisualRow = startRow;\n    let lastVisualColumn = startColumn;\n\n    // We try to populate just all copied data or repeat copied data within a selection. Please keep in mind that we\n    // don't know whether populated data is bigger than selection on start as there are some cells for which values\n    // should be not inserted (it's known right after getting cell meta).\n    while (newRows.length < populatedRowsLength || visualRowForPopulatedData <= endRowFromSelection) {\n      const {\n        skipRowOnPaste,\n        visualRow\n      } = this.hot.getCellMeta(visualRowForPopulatedData, startColumn);\n      visualRowForPopulatedData = visualRow + 1;\n      if (skipRowOnPaste === true) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      lastVisualRow = visualRow;\n      visualColumnForPopulatedData = startColumn;\n      const newRow = [];\n      const insertedRow = newRows.length % populatedRowsLength;\n      while (newRow.length < populatedColumnsLength || visualColumnForPopulatedData <= endColumnFromSelection) {\n        const {\n          skipColumnOnPaste,\n          visualCol\n        } = this.hot.getCellMeta(startRow, visualColumnForPopulatedData);\n        visualColumnForPopulatedData = visualCol + 1;\n        if (skipColumnOnPaste === true) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        lastVisualColumn = visualCol;\n        const insertedColumn = newRow.length % populatedColumnsLength;\n        newRow.push(inputArray[insertedRow][insertedColumn]);\n      }\n      newRows.push(newRow);\n    }\n    _classPrivateFieldSet(this, _preventViewportScrollOnPaste, true);\n    this.hot.populateFromArray(startRow, startColumn, newRows, undefined, undefined, 'CopyPaste.paste', this.pasteMode);\n    return [startRow, startColumn, lastVisualRow, lastVisualColumn];\n  }\n  /**\n   * `copy` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent.\n   * @private\n   */\n  onCopy(event) {\n    if (!this.hot.isListening() && !_classPrivateFieldGet(this, _isTriggeredByCopy) || this.isEditorOpened()) {\n      return;\n    }\n    this.setCopyableText();\n    _classPrivateFieldSet(this, _isTriggeredByCopy, false);\n    const data = this.getRangedData(this.copyableRanges);\n    const copiedHeadersCount = _classPrivateMethodGet(this, _countCopiedHeaders, _countCopiedHeaders2).call(this, this.copyableRanges);\n    const allowCopying = !!this.hot.runHooks('beforeCopy', data, this.copyableRanges, copiedHeadersCount);\n    if (allowCopying) {\n      const textPlain = stringify(data);\n      if (event && event.clipboardData) {\n        const textHTML = _dataToHTML(data, this.hot.rootDocument);\n        event.clipboardData.setData('text/plain', textPlain);\n        event.clipboardData.setData('text/html', [META_HEAD, textHTML].join(''));\n      } else if (typeof ClipboardEvent === 'undefined') {\n        this.hot.rootWindow.clipboardData.setData('Text', textPlain);\n      }\n      this.hot.runHooks('afterCopy', data, this.copyableRanges, copiedHeadersCount);\n    }\n    _classPrivateFieldSet(this, _copyMode, 'cells-only');\n    event.preventDefault();\n  }\n\n  /**\n   * `cut` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent.\n   * @private\n   */\n  onCut(event) {\n    if (!this.hot.isListening() && !_classPrivateFieldGet(this, _isTriggeredByCut) || this.isEditorOpened()) {\n      return;\n    }\n    this.setCopyableText();\n    _classPrivateFieldSet(this, _isTriggeredByCut, false);\n    const rangedData = this.getRangedData(this.copyableRanges);\n    const allowCuttingOut = !!this.hot.runHooks('beforeCut', rangedData, this.copyableRanges);\n    if (allowCuttingOut) {\n      const textPlain = stringify(rangedData);\n      if (event && event.clipboardData) {\n        const textHTML = _dataToHTML(rangedData, this.hot.rootDocument);\n        event.clipboardData.setData('text/plain', textPlain);\n        event.clipboardData.setData('text/html', [META_HEAD, textHTML].join(''));\n      } else if (typeof ClipboardEvent === 'undefined') {\n        this.hot.rootWindow.clipboardData.setData('Text', textPlain);\n      }\n      this.hot.emptySelectedCells('CopyPaste.cut');\n      this.hot.runHooks('afterCut', rangedData, this.copyableRanges);\n    }\n    event.preventDefault();\n  }\n\n  /**\n   * `paste` event callback on textarea element.\n   *\n   * @param {Event} event ClipboardEvent or pseudo ClipboardEvent, if paste was called manually.\n   * @private\n   */\n  onPaste(event) {\n    if (!this.hot.isListening() || this.isEditorOpened() || !this.hot.getSelected()) {\n      return;\n    }\n    if (event && event.preventDefault) {\n      event.preventDefault();\n    }\n    let pastedData;\n    if (event && typeof event.clipboardData !== 'undefined') {\n      const textHTML = sanitize(event.clipboardData.getData('text/html'), {\n        ADD_TAGS: ['meta'],\n        ADD_ATTR: ['content'],\n        FORCE_BODY: true\n      });\n      if (textHTML && /(<table)|(<TABLE)/g.test(textHTML)) {\n        const parsedConfig = htmlToGridSettings(textHTML, this.hot.rootDocument);\n        pastedData = parsedConfig.data;\n      } else {\n        pastedData = event.clipboardData.getData('text/plain');\n      }\n    } else if (typeof ClipboardEvent === 'undefined' && typeof this.hot.rootWindow.clipboardData !== 'undefined') {\n      pastedData = this.hot.rootWindow.clipboardData.getData('Text');\n    }\n    if (typeof pastedData === 'string') {\n      pastedData = parse(pastedData);\n    }\n    if (pastedData === void 0 || pastedData && pastedData.length === 0) {\n      return;\n    }\n    if (this.hot.runHooks('beforePaste', pastedData, this.copyableRanges) === false) {\n      return;\n    }\n    const [startRow, startColumn, endRow, endColumn] = this.populateValues(pastedData);\n    this.hot.selectCell(startRow, startColumn, Math.min(this.hot.countRows() - 1, endRow), Math.min(this.hot.countCols() - 1, endColumn));\n    this.hot.runHooks('afterPaste', pastedData, this.copyableRanges);\n  }\n  /**\n   * Destroys the `CopyPaste` plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _ensureClipboardEventsGetTriggered2(eventName) {\n  // Without this workaround Safari (tested on Safari@16.5.2) does not trigger the 'copy' event.\n  if (isSafari()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell) {\n        runWithSelectedContendEditableElement(currentlySelectedCell, () => {\n          this.hot.rootDocument.execCommand(eventName);\n        });\n      }\n    }\n  } else {\n    this.hot.rootDocument.execCommand(eventName);\n  }\n}\nfunction _countCopiedHeaders2(ranges) {\n  const {\n    rows\n  } = normalizeRanges(ranges);\n  let columnHeadersCount = 0;\n  for (let row = 0; row < rows.length; row++) {\n    if (rows[row] >= 0) {\n      break;\n    }\n    columnHeadersCount += 1;\n  }\n  return {\n    columnHeadersCount\n  };\n}\nfunction _addContentEditableToHighlightedCell2() {\n  if (this.hot.isListening()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell) {\n        makeElementContentEditableAndSelectItsContent(currentlySelectedCell);\n      }\n    }\n  }\n}\nfunction _removeContentEditableFromHighlightedCell2() {\n  // If the instance is not listening, the workaround is not needed.\n  if (this.hot.isListening()) {\n    const lastSelectedRange = this.hot.getSelectedRangeLast();\n    if (lastSelectedRange) {\n      const {\n        row: highlightRow,\n        col: highlightColumn\n      } = lastSelectedRange.highlight;\n      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);\n      if (currentlySelectedCell !== null && currentlySelectedCell !== void 0 && currentlySelectedCell.hasAttribute('contenteditable')) {\n        removeContentEditableFromElementAndDeselect(currentlySelectedCell);\n      }\n    }\n  }\n}\nfunction _onAfterContextMenuDefaultOptions2(options) {\n  options.items.push({\n    name: '---------'\n  }, copyItem(this));\n  if (_classPrivateFieldGet(this, _enableCopyColumnHeaders)) {\n    options.items.push(copyWithColumnHeadersItem(this));\n  }\n  if (_classPrivateFieldGet(this, _enableCopyColumnGroupHeaders)) {\n    options.items.push(copyWithColumnGroupHeadersItem(this));\n  }\n  if (_classPrivateFieldGet(this, _enableCopyColumnHeadersOnly)) {\n    options.items.push(copyColumnHeadersOnlyItem(this));\n  }\n  options.items.push(cutItem(this));\n}\nfunction _onAfterSelection2(fromRow, fromColumn, toRow, toColumn, preventScrolling) {\n  if (_classPrivateFieldGet(this, _preventViewportScrollOnPaste)) {\n    preventScrolling.value = true;\n  }\n  _classPrivateFieldSet(this, _preventViewportScrollOnPaste, false);\n}\nfunction _onAfterSelectionEnd2() {\n  if (this.isEditorOpened()) {\n    return;\n  }\n  if (this.hot.getSettings().fragmentSelection) {\n    return;\n  }\n  this.setCopyableText();\n}\nfunction _onSafariMouseEnter2() {\n  _classPrivateMethodGet(this, _removeContentEditableFromHighlightedCell, _removeContentEditableFromHighlightedCell2).call(this);\n}\nfunction _onSafariMouseLeave2() {\n  _classPrivateMethodGet(this, _addContentEditableToHighlightedCell, _addContentEditableToHighlightedCell2).call(this);\n}\nfunction _onSafariAfterSelection2() {\n  _classPrivateMethodGet(this, _removeContentEditableFromHighlightedCell, _removeContentEditableFromHighlightedCell2).call(this);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}