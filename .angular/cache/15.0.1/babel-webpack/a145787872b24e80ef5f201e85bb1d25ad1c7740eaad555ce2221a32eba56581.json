{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { getScrollableElement, getScrollbarWidth } from \"../../../helpers/dom/element.mjs\";\nimport { requestAnimationFrame } from \"../../../helpers/feature.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { isKey } from \"../../../helpers/unicode.mjs\";\nimport { isChrome } from \"../../../helpers/browser.mjs\";\nimport { InlineStartOverlay, TopOverlay, TopInlineStartCornerOverlay, BottomOverlay, BottomInlineStartCornerOverlay } from \"./overlay/index.mjs\";\n/**\n * @class Overlays\n */\nclass Overlays {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @todo refactoring remove.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {EventManager} eventManager The walkontable event manager.\n   * @param {MasterTable} wtTable The master table.\n   */\n  constructor(wotInstance, facadeGetter, domBindings, wtSettings, eventManager, wtTable) {\n    /**\n     * Walkontable instance's reference.\n     *\n     * @protected\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"wot\", null);\n    /**\n     * Refer to the TopOverlay instance.\n     *\n     * @protected\n     * @type {TopOverlay}\n     */\n    _defineProperty(this, \"topOverlay\", null);\n    /**\n     * Refer to the BottomOverlay instance.\n     *\n     * @protected\n     * @type {BottomOverlay}\n     */\n    _defineProperty(this, \"bottomOverlay\", null);\n    /**\n     * Refer to the InlineStartOverlay or instance.\n     *\n     * @protected\n     * @type {InlineStartOverlay}\n     */\n    _defineProperty(this, \"inlineStartOverlay\", null);\n    /**\n     * Refer to the TopInlineStartCornerOverlay instance.\n     *\n     * @protected\n     * @type {TopInlineStartCornerOverlay}\n     */\n    _defineProperty(this, \"topInlineStartCornerOverlay\", null);\n    /**\n     * Refer to the BottomInlineStartCornerOverlay instance.\n     *\n     * @protected\n     * @type {BottomInlineStartCornerOverlay}\n     */\n    _defineProperty(this, \"bottomInlineStartCornerOverlay\", null);\n    /**\n     * Browser line height for purposes of translating mouse wheel.\n     *\n     * @private\n     * @type {number}\n     */\n    _defineProperty(this, \"browserLineHeight\", undefined);\n    /**\n     * The walkontable settings.\n     *\n     * @protected\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    /**\n     * The instance of the ResizeObserver that observes the size of the Walkontable wrapper element.\n     * In case of the size change detection the `onContainerElementResize` is fired.\n     *\n     * @private\n     * @type {ResizeObserver}\n     */\n    _defineProperty(this, \"resizeObserver\", new ResizeObserver(entries => {\n      requestAnimationFrame(() => {\n        if (!Array.isArray(entries) || !entries.length) {\n          return;\n        }\n        this.wtSettings.getSetting('onContainerElementResize');\n      });\n    }));\n    this.wot = wotInstance;\n    this.wtSettings = wtSettings;\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtTable = wtTable;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n\n    // legacy support\n    this.instance = this.wot; // todo refactoring: move to facade\n    this.eventManager = eventManager;\n\n    // TODO refactoring: probably invalid place to this logic\n    this.scrollbarSize = getScrollbarWidth(rootDocument);\n    const isOverflowHidden = rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden';\n    this.scrollableElement = isOverflowHidden ? wtTable.holder : getScrollableElement(wtTable.TABLE);\n    this.initOverlays();\n    this.hasScrollbarBottom = false;\n    this.hasScrollbarRight = false;\n    this.destroyed = false;\n    this.keyPressed = false;\n    this.spreaderLastSize = {\n      width: null,\n      height: null\n    };\n    this.verticalScrolling = false;\n    this.horizontalScrolling = false;\n    this.initBrowserLineHeight();\n    this.registerListeners();\n    this.lastScrollX = rootWindow.scrollX;\n    this.lastScrollY = rootWindow.scrollY;\n  }\n\n  /**\n   * Get the list of references to all overlays.\n   *\n   * @param {boolean} [includeMaster = false] If set to `true`, the list will contain the master table as the last\n   * element.\n   * @returns {(TopOverlay|TopInlineStartCornerOverlay|InlineStartOverlay|BottomOverlay|BottomInlineStartCornerOverlay)[]}\n   */\n  getOverlays() {\n    let includeMaster = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const overlays = [this.topOverlay, this.topInlineStartCornerOverlay, this.inlineStartOverlay, this.bottomOverlay, this.bottomInlineStartCornerOverlay];\n    if (includeMaster) {\n      overlays.push(this.wtTable);\n    }\n    return overlays;\n  }\n\n  /**\n   * Retrieve browser line height and apply its value to `browserLineHeight`.\n   *\n   * @private\n   */\n  initBrowserLineHeight() {\n    const {\n      rootWindow,\n      rootDocument\n    } = this.domBindings;\n    const computedStyle = rootWindow.getComputedStyle(rootDocument.body);\n    /**\n     * Sometimes `line-height` might be set to 'normal'. In that case, a default `font-size` should be multiplied by roughly 1.2.\n     * Https://developer.mozilla.org/pl/docs/Web/CSS/line-height#Values.\n     */\n    const lineHeight = parseInt(computedStyle.lineHeight, 10);\n    const lineHeightFalback = parseInt(computedStyle.fontSize, 10) * 1.2;\n    this.browserLineHeight = lineHeight || lineHeightFalback;\n  }\n\n  /**\n   * Prepare overlays based on user settings.\n   *\n   * @private\n   */\n  initOverlays() {\n    const args = [this.wot, this.facadeGetter, this.wtSettings, this.domBindings];\n\n    // todo refactoring: IOC, collection or factories.\n    // TODO refactoring, conceive about using generic collection of overlays.\n    this.topOverlay = new TopOverlay(...args);\n    this.bottomOverlay = new BottomOverlay(...args);\n    this.inlineStartOverlay = new InlineStartOverlay(...args);\n\n    // TODO discuss, the controversial here would be removing the lazy creation mechanism for corners.\n    // TODO cond. Has no any visual impact. They're initially hidden in same way like left, top, and bottom overlays.\n    this.topInlineStartCornerOverlay = new TopInlineStartCornerOverlay(...args, this.topOverlay, this.inlineStartOverlay);\n    this.bottomInlineStartCornerOverlay = new BottomInlineStartCornerOverlay(...args, this.bottomOverlay, this.inlineStartOverlay);\n  }\n\n  /**\n   * Update state of rendering, check if changed.\n   *\n   * @package\n   * @returns {boolean} Returns `true` if changes applied to overlay needs scroll synchronization.\n   */\n  updateStateOfRendering() {\n    let syncScroll = this.topOverlay.updateStateOfRendering();\n    syncScroll = this.bottomOverlay.updateStateOfRendering() || syncScroll;\n    syncScroll = this.inlineStartOverlay.updateStateOfRendering() || syncScroll;\n\n    // todo refactoring: move conditions into updateStateOfRendering(),\n    if (this.inlineStartOverlay.needFullRender) {\n      if (this.topOverlay.needFullRender) {\n        syncScroll = this.topInlineStartCornerOverlay.updateStateOfRendering() || syncScroll;\n      }\n      if (this.bottomOverlay.needFullRender) {\n        syncScroll = this.bottomInlineStartCornerOverlay.updateStateOfRendering() || syncScroll;\n      }\n    }\n    return syncScroll;\n  }\n\n  /**\n   * Refresh and redraw table.\n   */\n  refreshAll() {\n    if (!this.wot.drawn) {\n      return;\n    }\n    if (!this.wtTable.holder.parentNode) {\n      // Walkontable was detached from DOM, but this handler was not removed\n      this.destroy();\n      return;\n    }\n    this.wot.draw(true);\n    if (this.verticalScrolling) {\n      this.inlineStartOverlay.onScroll(); // todo the inlineStartOverlay.onScroll() fires hook. Why is it needed there, not in any another place?\n    }\n\n    if (this.horizontalScrolling) {\n      this.topOverlay.onScroll();\n    }\n    this.verticalScrolling = false;\n    this.horizontalScrolling = false;\n  }\n\n  /**\n   * Register all necessary event listeners.\n   */\n  registerListeners() {\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const {\n      mainTableScrollableElement: topOverlayScrollableElement\n    } = this.topOverlay;\n    const {\n      mainTableScrollableElement: inlineStartOverlayScrollableElement\n    } = this.inlineStartOverlay;\n    this.eventManager.addEventListener(rootDocument.documentElement, 'keydown', event => this.onKeyDown(event));\n    this.eventManager.addEventListener(rootDocument.documentElement, 'keyup', () => this.onKeyUp());\n    this.eventManager.addEventListener(rootDocument, 'visibilitychange', () => this.onKeyUp());\n    this.eventManager.addEventListener(topOverlayScrollableElement, 'scroll', event => this.onTableScroll(event), {\n      passive: true\n    });\n    if (topOverlayScrollableElement !== inlineStartOverlayScrollableElement) {\n      this.eventManager.addEventListener(inlineStartOverlayScrollableElement, 'scroll', event => this.onTableScroll(event), {\n        passive: true\n      });\n    }\n    const isHighPixelRatio = rootWindow.devicePixelRatio && rootWindow.devicePixelRatio > 1;\n    const isScrollOnWindow = this.scrollableElement === rootWindow;\n    const preventWheel = this.wtSettings.getSetting('preventWheel');\n    const wheelEventOptions = {\n      passive: isScrollOnWindow\n    };\n    if (preventWheel || isHighPixelRatio || !isChrome()) {\n      this.eventManager.addEventListener(this.wtTable.wtRootElement, 'wheel', event => this.onCloneWheel(event, preventWheel), wheelEventOptions);\n    }\n    const overlays = [this.topOverlay, this.bottomOverlay, this.inlineStartOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    overlays.forEach(overlay => {\n      if (overlay && overlay.needFullRender) {\n        const {\n          holder\n        } = overlay.clone.wtTable; // todo rethink, maybe: overlay.getHolder()\n\n        this.eventManager.addEventListener(holder, 'wheel', event => this.onCloneWheel(event, preventWheel), wheelEventOptions);\n      }\n    });\n    let resizeTimeout;\n    this.eventManager.addEventListener(rootWindow, 'resize', () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        this.wtSettings.getSetting('onWindowResize');\n      }, 200);\n    });\n    if (!isScrollOnWindow) {\n      this.resizeObserver.observe(this.wtTable.wtRootElement.parentElement);\n    }\n  }\n\n  /**\n   * Deregister all previously registered listeners.\n   */\n  deregisterListeners() {\n    this.eventManager.clearEvents(true);\n  }\n\n  /**\n   * Scroll listener.\n   *\n   * @param {Event} event The mouse event object.\n   */\n  onTableScroll(event) {\n    // There was if statement which controlled flow of this function. It avoided the execution of the next lines\n    // on mobile devices. It was changed. Broader description of this case is included within issue #4856.\n    const rootWindow = this.domBindings.rootWindow;\n    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;\n    const masterVertical = this.topOverlay.mainTableScrollableElement;\n    const target = event.target;\n\n    // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered\n    // by hot.refreshBorder\n    if (this.keyPressed) {\n      if (masterVertical !== rootWindow && target !== rootWindow && !event.target.contains(masterVertical) || masterHorizontal !== rootWindow && target !== rootWindow && !event.target.contains(masterHorizontal)) {\n        return;\n      }\n    }\n    this.syncScrollPositions(event);\n  }\n\n  /**\n   * Wheel listener for cloned overlays.\n   *\n   * @param {Event} event The mouse event object.\n   * @param {boolean} preventDefault If `true`, the `preventDefault` will be called on event object.\n   */\n  onCloneWheel(event, preventDefault) {\n    const {\n      rootWindow\n    } = this.domBindings;\n\n    // There was if statement which controlled flow of this function. It avoided the execution of the next lines\n    // on mobile devices. It was changed. Broader description of this case is included within issue #4856.\n\n    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;\n    const masterVertical = this.topOverlay.mainTableScrollableElement;\n    const target = event.target;\n\n    // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered\n    // by hot.refreshBorder\n    const shouldNotWheelVertically = masterVertical !== rootWindow && target !== rootWindow && !target.contains(masterVertical);\n    const shouldNotWheelHorizontally = masterHorizontal !== rootWindow && target !== rootWindow && !target.contains(masterHorizontal);\n    if (this.keyPressed && (shouldNotWheelVertically || shouldNotWheelHorizontally)) {\n      return;\n    }\n    const isScrollPossible = this.translateMouseWheelToScroll(event);\n    if (preventDefault || this.scrollableElement !== rootWindow && isScrollPossible) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * Key down listener.\n   *\n   * @param {Event} event The keyboard event object.\n   */\n  onKeyDown(event) {\n    this.keyPressed = isKey(event.keyCode, 'ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT');\n  }\n\n  /**\n   * Key up listener.\n   */\n  onKeyUp() {\n    this.keyPressed = false;\n  }\n\n  /**\n   * Translate wheel event into scroll event and sync scroll overlays position.\n   *\n   * @private\n   * @param {Event} event The mouse event object.\n   * @returns {boolean}\n   */\n  translateMouseWheelToScroll(event) {\n    let deltaY = isNaN(event.deltaY) ? -1 * event.wheelDeltaY : event.deltaY;\n    let deltaX = isNaN(event.deltaX) ? -1 * event.wheelDeltaX : event.deltaX;\n    if (event.deltaMode === 1) {\n      deltaX += deltaX * this.browserLineHeight;\n      deltaY += deltaY * this.browserLineHeight;\n    }\n    const isScrollVerticallyPossible = this.scrollVertically(deltaY);\n    const isScrollHorizontallyPossible = this.scrollHorizontally(deltaX);\n    return isScrollVerticallyPossible || isScrollHorizontallyPossible;\n  }\n\n  /**\n   * Scrolls main scrollable element horizontally.\n   *\n   * @param {number} delta Relative value to scroll.\n   * @returns {boolean}\n   */\n  scrollVertically(delta) {\n    const previousScroll = this.scrollableElement.scrollTop;\n    this.scrollableElement.scrollTop += delta;\n    return previousScroll !== this.scrollableElement.scrollTop;\n  }\n\n  /**\n   * Scrolls main scrollable element horizontally.\n   *\n   * @param {number} delta Relative value to scroll.\n   * @returns {boolean}\n   */\n  scrollHorizontally(delta) {\n    const previousScroll = this.scrollableElement.scrollLeft;\n    this.scrollableElement.scrollLeft += delta;\n    return previousScroll !== this.scrollableElement.scrollLeft;\n  }\n\n  /**\n   * Synchronize scroll position between master table and overlay table.\n   *\n   * @private\n   */\n  syncScrollPositions() {\n    if (this.destroyed) {\n      return;\n    }\n    const {\n      rootWindow\n    } = this.domBindings;\n    const topHolder = this.topOverlay.clone.wtTable.holder; // todo rethink\n    const leftHolder = this.inlineStartOverlay.clone.wtTable.holder; // todo rethink\n\n    const [scrollLeft, scrollTop] = [this.scrollableElement.scrollLeft, this.scrollableElement.scrollTop];\n    this.horizontalScrolling = topHolder.scrollLeft !== scrollLeft || this.lastScrollX !== rootWindow.scrollX;\n    this.verticalScrolling = leftHolder.scrollTop !== scrollTop || this.lastScrollY !== rootWindow.scrollY;\n    this.lastScrollX = rootWindow.scrollX;\n    this.lastScrollY = rootWindow.scrollY;\n    if (this.horizontalScrolling) {\n      topHolder.scrollLeft = scrollLeft;\n      const bottomHolder = this.bottomOverlay.needFullRender ? this.bottomOverlay.clone.wtTable.holder : null; // todo rethink\n\n      if (bottomHolder) {\n        bottomHolder.scrollLeft = scrollLeft;\n      }\n    }\n    if (this.verticalScrolling) {\n      leftHolder.scrollTop = scrollTop;\n    }\n    this.refreshAll();\n  }\n\n  /**\n   * Synchronize overlay scrollbars with the master scrollbar.\n   */\n  syncScrollWithMaster() {\n    const master = this.topOverlay.mainTableScrollableElement;\n    const {\n      scrollLeft,\n      scrollTop\n    } = master;\n    if (this.topOverlay.needFullRender) {\n      this.topOverlay.clone.wtTable.holder.scrollLeft = scrollLeft; // todo rethink, *overlay.setScroll*()\n    }\n\n    if (this.bottomOverlay.needFullRender) {\n      this.bottomOverlay.clone.wtTable.holder.scrollLeft = scrollLeft; // todo rethink, *overlay.setScroll*()\n    }\n\n    if (this.inlineStartOverlay.needFullRender) {\n      this.inlineStartOverlay.clone.wtTable.holder.scrollTop = scrollTop; // todo rethink, *overlay.setScroll*()\n    }\n  }\n\n  /**\n   * Update the main scrollable elements for all the overlays.\n   */\n  updateMainScrollableElements() {\n    this.deregisterListeners();\n    this.inlineStartOverlay.updateMainScrollableElement();\n    this.topOverlay.updateMainScrollableElement();\n    if (this.bottomOverlay.needFullRender) {\n      this.bottomOverlay.updateMainScrollableElement();\n    }\n    const {\n      wtTable\n    } = this;\n    const {\n      rootWindow\n    } = this.domBindings;\n    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n      this.scrollableElement = wtTable.holder;\n    } else {\n      this.scrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n    this.registerListeners();\n  }\n\n  /**\n   *\n   */\n  destroy() {\n    this.resizeObserver.disconnect();\n    this.eventManager.destroy();\n    // todo, probably all below `destory` calls has no sense. To analyze\n    this.topOverlay.destroy();\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.destroy();\n    }\n    this.inlineStartOverlay.destroy();\n    if (this.topInlineStartCornerOverlay) {\n      this.topInlineStartCornerOverlay.destroy();\n    }\n    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {\n      this.bottomInlineStartCornerOverlay.destroy();\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   */\n  refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const wasSpreaderSizeUpdated = this.updateLastSpreaderSize();\n    if (wasSpreaderSizeUpdated) {\n      this.adjustElementsSize();\n    }\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.refresh(fastDraw);\n    }\n    this.inlineStartOverlay.refresh(fastDraw);\n    this.topOverlay.refresh(fastDraw);\n    if (this.topInlineStartCornerOverlay) {\n      this.topInlineStartCornerOverlay.refresh(fastDraw);\n    }\n    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {\n      this.bottomInlineStartCornerOverlay.refresh(fastDraw);\n    }\n  }\n\n  /**\n   * Update the last cached spreader size with the current size.\n   *\n   * @returns {boolean} `true` if the lastSpreaderSize cache was updated, `false` otherwise.\n   */\n  updateLastSpreaderSize() {\n    const spreader = this.wtTable.spreader;\n    const width = spreader.clientWidth;\n    const height = spreader.clientHeight;\n    const needsUpdating = width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height;\n    if (needsUpdating) {\n      this.spreaderLastSize.width = width;\n      this.spreaderLastSize.height = height;\n    }\n    return needsUpdating;\n  }\n\n  /**\n   * Adjust overlays elements size and master table size.\n   *\n   * @param {boolean} [force=false] When `true`, it adjust the DOM nodes sizes for all overlays.\n   */\n  adjustElementsSize() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      wtViewport\n    } = this.wot;\n    const {\n      wtTable\n    } = this;\n    const totalColumns = this.wtSettings.getSetting('totalColumns');\n    const totalRows = this.wtSettings.getSetting('totalRows');\n    const headerRowSize = wtViewport.getRowHeaderWidth();\n    const headerColumnSize = wtViewport.getColumnHeaderHeight();\n    const hiderStyle = wtTable.hider.style;\n    hiderStyle.width = `${headerRowSize + this.inlineStartOverlay.sumCellSizes(0, totalColumns)}px`;\n    hiderStyle.height = `${headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1}px`;\n    if (this.scrollbarSize > 0) {\n      // todo refactoring, looking as a part of logic which should be moved outside the class\n      const {\n        scrollHeight: rootElemScrollHeight,\n        scrollWidth: rootElemScrollWidth\n      } = wtTable.wtRootElement;\n      const {\n        scrollHeight: holderScrollHeight,\n        scrollWidth: holderScrollWidth\n      } = wtTable.holder;\n      this.hasScrollbarRight = rootElemScrollHeight < holderScrollHeight;\n      this.hasScrollbarBottom = rootElemScrollWidth < holderScrollWidth;\n      if (this.hasScrollbarRight && wtTable.hider.scrollWidth + this.scrollbarSize > rootElemScrollWidth) {\n        this.hasScrollbarBottom = true;\n      } else if (this.hasScrollbarBottom && wtTable.hider.scrollHeight + this.scrollbarSize > rootElemScrollHeight) {\n        this.hasScrollbarRight = true;\n      }\n    }\n    this.topOverlay.adjustElementsSize(force);\n    this.inlineStartOverlay.adjustElementsSize(force);\n    this.bottomOverlay.adjustElementsSize(force);\n  }\n\n  /**\n   *\n   */\n  applyToDOM() {\n    if (!this.wtTable.isVisible()) {\n      return;\n    }\n    this.topOverlay.applyToDOM();\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.applyToDOM();\n    }\n    this.inlineStartOverlay.applyToDOM();\n  }\n\n  /**\n   * Get the parent overlay of the provided element.\n   *\n   * @param {HTMLElement} element An element to process.\n   * @returns {object|null}\n   */\n  getParentOverlay(element) {\n    if (!element) {\n      return null;\n    }\n    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    let result = null;\n    arrayEach(overlays, overlay => {\n      if (!overlay) {\n        return;\n      }\n      if (overlay.clone && overlay.clone.wtTable.TABLE.contains(element)) {\n        // todo demeter\n        result = overlay.clone;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Synchronize the class names between the main overlay table and the tables on the other overlays.\n   *\n   */\n  syncOverlayTableClassNames() {\n    const masterTable = this.wtTable.TABLE;\n    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    arrayEach(overlays, elem => {\n      if (!elem) {\n        return;\n      }\n      elem.clone.wtTable.TABLE.className = masterTable.className; // todo demeter\n    });\n  }\n}\n\nexport default Overlays;","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","getScrollableElement","getScrollbarWidth","requestAnimationFrame","arrayEach","isKey","isChrome","InlineStartOverlay","TopOverlay","TopInlineStartCornerOverlay","BottomOverlay","BottomInlineStartCornerOverlay","Overlays","constructor","wotInstance","facadeGetter","domBindings","wtSettings","eventManager","wtTable","undefined","ResizeObserver","entries","Array","isArray","length","getSetting","wot","rootDocument","rootWindow","instance","scrollbarSize","isOverflowHidden","getComputedStyle","wtRootElement","parentNode","getPropertyValue","scrollableElement","holder","TABLE","initOverlays","hasScrollbarBottom","hasScrollbarRight","destroyed","keyPressed","spreaderLastSize","width","height","verticalScrolling","horizontalScrolling","initBrowserLineHeight","registerListeners","lastScrollX","scrollX","lastScrollY","scrollY","getOverlays","includeMaster","arguments","overlays","topOverlay","topInlineStartCornerOverlay","inlineStartOverlay","bottomOverlay","bottomInlineStartCornerOverlay","push","computedStyle","body","lineHeight","parseInt","lineHeightFalback","fontSize","browserLineHeight","args","updateStateOfRendering","syncScroll","needFullRender","refreshAll","drawn","destroy","draw","onScroll","mainTableScrollableElement","topOverlayScrollableElement","inlineStartOverlayScrollableElement","addEventListener","documentElement","event","onKeyDown","onKeyUp","onTableScroll","passive","isHighPixelRatio","devicePixelRatio","isScrollOnWindow","preventWheel","wheelEventOptions","onCloneWheel","forEach","overlay","clone","resizeTimeout","clearTimeout","setTimeout","resizeObserver","observe","parentElement","deregisterListeners","clearEvents","masterHorizontal","masterVertical","target","contains","syncScrollPositions","preventDefault","shouldNotWheelVertically","shouldNotWheelHorizontally","isScrollPossible","translateMouseWheelToScroll","keyCode","deltaY","isNaN","wheelDeltaY","deltaX","wheelDeltaX","deltaMode","isScrollVerticallyPossible","scrollVertically","isScrollHorizontallyPossible","scrollHorizontally","delta","previousScroll","scrollTop","scrollLeft","topHolder","leftHolder","bottomHolder","syncScrollWithMaster","master","updateMainScrollableElements","updateMainScrollableElement","disconnect","refresh","fastDraw","wasSpreaderSizeUpdated","updateLastSpreaderSize","adjustElementsSize","spreader","clientWidth","clientHeight","needsUpdating","force","wtViewport","totalColumns","totalRows","headerRowSize","getRowHeaderWidth","headerColumnSize","getColumnHeaderHeight","hiderStyle","hider","style","sumCellSizes","scrollHeight","rootElemScrollHeight","scrollWidth","rootElemScrollWidth","holderScrollHeight","holderScrollWidth","applyToDOM","isVisible","getParentOverlay","element","result","syncOverlayTableClassNames","masterTable","elem","className"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/3rdparty/walkontable/src/overlays.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { getScrollableElement, getScrollbarWidth } from \"../../../helpers/dom/element.mjs\";\nimport { requestAnimationFrame } from \"../../../helpers/feature.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { isKey } from \"../../../helpers/unicode.mjs\";\nimport { isChrome } from \"../../../helpers/browser.mjs\";\nimport { InlineStartOverlay, TopOverlay, TopInlineStartCornerOverlay, BottomOverlay, BottomInlineStartCornerOverlay } from \"./overlay/index.mjs\";\n/**\n * @class Overlays\n */\nclass Overlays {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @todo refactoring remove.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {EventManager} eventManager The walkontable event manager.\n   * @param {MasterTable} wtTable The master table.\n   */\n  constructor(wotInstance, facadeGetter, domBindings, wtSettings, eventManager, wtTable) {\n    /**\n     * Walkontable instance's reference.\n     *\n     * @protected\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"wot\", null);\n    /**\n     * Refer to the TopOverlay instance.\n     *\n     * @protected\n     * @type {TopOverlay}\n     */\n    _defineProperty(this, \"topOverlay\", null);\n    /**\n     * Refer to the BottomOverlay instance.\n     *\n     * @protected\n     * @type {BottomOverlay}\n     */\n    _defineProperty(this, \"bottomOverlay\", null);\n    /**\n     * Refer to the InlineStartOverlay or instance.\n     *\n     * @protected\n     * @type {InlineStartOverlay}\n     */\n    _defineProperty(this, \"inlineStartOverlay\", null);\n    /**\n     * Refer to the TopInlineStartCornerOverlay instance.\n     *\n     * @protected\n     * @type {TopInlineStartCornerOverlay}\n     */\n    _defineProperty(this, \"topInlineStartCornerOverlay\", null);\n    /**\n     * Refer to the BottomInlineStartCornerOverlay instance.\n     *\n     * @protected\n     * @type {BottomInlineStartCornerOverlay}\n     */\n    _defineProperty(this, \"bottomInlineStartCornerOverlay\", null);\n    /**\n     * Browser line height for purposes of translating mouse wheel.\n     *\n     * @private\n     * @type {number}\n     */\n    _defineProperty(this, \"browserLineHeight\", undefined);\n    /**\n     * The walkontable settings.\n     *\n     * @protected\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    /**\n     * The instance of the ResizeObserver that observes the size of the Walkontable wrapper element.\n     * In case of the size change detection the `onContainerElementResize` is fired.\n     *\n     * @private\n     * @type {ResizeObserver}\n     */\n    _defineProperty(this, \"resizeObserver\", new ResizeObserver(entries => {\n      requestAnimationFrame(() => {\n        if (!Array.isArray(entries) || !entries.length) {\n          return;\n        }\n        this.wtSettings.getSetting('onContainerElementResize');\n      });\n    }));\n    this.wot = wotInstance;\n    this.wtSettings = wtSettings;\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtTable = wtTable;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n\n    // legacy support\n    this.instance = this.wot; // todo refactoring: move to facade\n    this.eventManager = eventManager;\n\n    // TODO refactoring: probably invalid place to this logic\n    this.scrollbarSize = getScrollbarWidth(rootDocument);\n    const isOverflowHidden = rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden';\n    this.scrollableElement = isOverflowHidden ? wtTable.holder : getScrollableElement(wtTable.TABLE);\n    this.initOverlays();\n    this.hasScrollbarBottom = false;\n    this.hasScrollbarRight = false;\n    this.destroyed = false;\n    this.keyPressed = false;\n    this.spreaderLastSize = {\n      width: null,\n      height: null\n    };\n    this.verticalScrolling = false;\n    this.horizontalScrolling = false;\n    this.initBrowserLineHeight();\n    this.registerListeners();\n    this.lastScrollX = rootWindow.scrollX;\n    this.lastScrollY = rootWindow.scrollY;\n  }\n\n  /**\n   * Get the list of references to all overlays.\n   *\n   * @param {boolean} [includeMaster = false] If set to `true`, the list will contain the master table as the last\n   * element.\n   * @returns {(TopOverlay|TopInlineStartCornerOverlay|InlineStartOverlay|BottomOverlay|BottomInlineStartCornerOverlay)[]}\n   */\n  getOverlays() {\n    let includeMaster = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const overlays = [this.topOverlay, this.topInlineStartCornerOverlay, this.inlineStartOverlay, this.bottomOverlay, this.bottomInlineStartCornerOverlay];\n    if (includeMaster) {\n      overlays.push(this.wtTable);\n    }\n    return overlays;\n  }\n\n  /**\n   * Retrieve browser line height and apply its value to `browserLineHeight`.\n   *\n   * @private\n   */\n  initBrowserLineHeight() {\n    const {\n      rootWindow,\n      rootDocument\n    } = this.domBindings;\n    const computedStyle = rootWindow.getComputedStyle(rootDocument.body);\n    /**\n     * Sometimes `line-height` might be set to 'normal'. In that case, a default `font-size` should be multiplied by roughly 1.2.\n     * Https://developer.mozilla.org/pl/docs/Web/CSS/line-height#Values.\n     */\n    const lineHeight = parseInt(computedStyle.lineHeight, 10);\n    const lineHeightFalback = parseInt(computedStyle.fontSize, 10) * 1.2;\n    this.browserLineHeight = lineHeight || lineHeightFalback;\n  }\n\n  /**\n   * Prepare overlays based on user settings.\n   *\n   * @private\n   */\n  initOverlays() {\n    const args = [this.wot, this.facadeGetter, this.wtSettings, this.domBindings];\n\n    // todo refactoring: IOC, collection or factories.\n    // TODO refactoring, conceive about using generic collection of overlays.\n    this.topOverlay = new TopOverlay(...args);\n    this.bottomOverlay = new BottomOverlay(...args);\n    this.inlineStartOverlay = new InlineStartOverlay(...args);\n\n    // TODO discuss, the controversial here would be removing the lazy creation mechanism for corners.\n    // TODO cond. Has no any visual impact. They're initially hidden in same way like left, top, and bottom overlays.\n    this.topInlineStartCornerOverlay = new TopInlineStartCornerOverlay(...args, this.topOverlay, this.inlineStartOverlay);\n    this.bottomInlineStartCornerOverlay = new BottomInlineStartCornerOverlay(...args, this.bottomOverlay, this.inlineStartOverlay);\n  }\n\n  /**\n   * Update state of rendering, check if changed.\n   *\n   * @package\n   * @returns {boolean} Returns `true` if changes applied to overlay needs scroll synchronization.\n   */\n  updateStateOfRendering() {\n    let syncScroll = this.topOverlay.updateStateOfRendering();\n    syncScroll = this.bottomOverlay.updateStateOfRendering() || syncScroll;\n    syncScroll = this.inlineStartOverlay.updateStateOfRendering() || syncScroll;\n\n    // todo refactoring: move conditions into updateStateOfRendering(),\n    if (this.inlineStartOverlay.needFullRender) {\n      if (this.topOverlay.needFullRender) {\n        syncScroll = this.topInlineStartCornerOverlay.updateStateOfRendering() || syncScroll;\n      }\n      if (this.bottomOverlay.needFullRender) {\n        syncScroll = this.bottomInlineStartCornerOverlay.updateStateOfRendering() || syncScroll;\n      }\n    }\n    return syncScroll;\n  }\n\n  /**\n   * Refresh and redraw table.\n   */\n  refreshAll() {\n    if (!this.wot.drawn) {\n      return;\n    }\n    if (!this.wtTable.holder.parentNode) {\n      // Walkontable was detached from DOM, but this handler was not removed\n      this.destroy();\n      return;\n    }\n    this.wot.draw(true);\n    if (this.verticalScrolling) {\n      this.inlineStartOverlay.onScroll(); // todo the inlineStartOverlay.onScroll() fires hook. Why is it needed there, not in any another place?\n    }\n    if (this.horizontalScrolling) {\n      this.topOverlay.onScroll();\n    }\n    this.verticalScrolling = false;\n    this.horizontalScrolling = false;\n  }\n\n  /**\n   * Register all necessary event listeners.\n   */\n  registerListeners() {\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const {\n      mainTableScrollableElement: topOverlayScrollableElement\n    } = this.topOverlay;\n    const {\n      mainTableScrollableElement: inlineStartOverlayScrollableElement\n    } = this.inlineStartOverlay;\n    this.eventManager.addEventListener(rootDocument.documentElement, 'keydown', event => this.onKeyDown(event));\n    this.eventManager.addEventListener(rootDocument.documentElement, 'keyup', () => this.onKeyUp());\n    this.eventManager.addEventListener(rootDocument, 'visibilitychange', () => this.onKeyUp());\n    this.eventManager.addEventListener(topOverlayScrollableElement, 'scroll', event => this.onTableScroll(event), {\n      passive: true\n    });\n    if (topOverlayScrollableElement !== inlineStartOverlayScrollableElement) {\n      this.eventManager.addEventListener(inlineStartOverlayScrollableElement, 'scroll', event => this.onTableScroll(event), {\n        passive: true\n      });\n    }\n    const isHighPixelRatio = rootWindow.devicePixelRatio && rootWindow.devicePixelRatio > 1;\n    const isScrollOnWindow = this.scrollableElement === rootWindow;\n    const preventWheel = this.wtSettings.getSetting('preventWheel');\n    const wheelEventOptions = {\n      passive: isScrollOnWindow\n    };\n    if (preventWheel || isHighPixelRatio || !isChrome()) {\n      this.eventManager.addEventListener(this.wtTable.wtRootElement, 'wheel', event => this.onCloneWheel(event, preventWheel), wheelEventOptions);\n    }\n    const overlays = [this.topOverlay, this.bottomOverlay, this.inlineStartOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    overlays.forEach(overlay => {\n      if (overlay && overlay.needFullRender) {\n        const {\n          holder\n        } = overlay.clone.wtTable; // todo rethink, maybe: overlay.getHolder()\n\n        this.eventManager.addEventListener(holder, 'wheel', event => this.onCloneWheel(event, preventWheel), wheelEventOptions);\n      }\n    });\n    let resizeTimeout;\n    this.eventManager.addEventListener(rootWindow, 'resize', () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        this.wtSettings.getSetting('onWindowResize');\n      }, 200);\n    });\n    if (!isScrollOnWindow) {\n      this.resizeObserver.observe(this.wtTable.wtRootElement.parentElement);\n    }\n  }\n\n  /**\n   * Deregister all previously registered listeners.\n   */\n  deregisterListeners() {\n    this.eventManager.clearEvents(true);\n  }\n\n  /**\n   * Scroll listener.\n   *\n   * @param {Event} event The mouse event object.\n   */\n  onTableScroll(event) {\n    // There was if statement which controlled flow of this function. It avoided the execution of the next lines\n    // on mobile devices. It was changed. Broader description of this case is included within issue #4856.\n    const rootWindow = this.domBindings.rootWindow;\n    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;\n    const masterVertical = this.topOverlay.mainTableScrollableElement;\n    const target = event.target;\n\n    // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered\n    // by hot.refreshBorder\n    if (this.keyPressed) {\n      if (masterVertical !== rootWindow && target !== rootWindow && !event.target.contains(masterVertical) || masterHorizontal !== rootWindow && target !== rootWindow && !event.target.contains(masterHorizontal)) {\n        return;\n      }\n    }\n    this.syncScrollPositions(event);\n  }\n\n  /**\n   * Wheel listener for cloned overlays.\n   *\n   * @param {Event} event The mouse event object.\n   * @param {boolean} preventDefault If `true`, the `preventDefault` will be called on event object.\n   */\n  onCloneWheel(event, preventDefault) {\n    const {\n      rootWindow\n    } = this.domBindings;\n\n    // There was if statement which controlled flow of this function. It avoided the execution of the next lines\n    // on mobile devices. It was changed. Broader description of this case is included within issue #4856.\n\n    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;\n    const masterVertical = this.topOverlay.mainTableScrollableElement;\n    const target = event.target;\n\n    // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered\n    // by hot.refreshBorder\n    const shouldNotWheelVertically = masterVertical !== rootWindow && target !== rootWindow && !target.contains(masterVertical);\n    const shouldNotWheelHorizontally = masterHorizontal !== rootWindow && target !== rootWindow && !target.contains(masterHorizontal);\n    if (this.keyPressed && (shouldNotWheelVertically || shouldNotWheelHorizontally)) {\n      return;\n    }\n    const isScrollPossible = this.translateMouseWheelToScroll(event);\n    if (preventDefault || this.scrollableElement !== rootWindow && isScrollPossible) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * Key down listener.\n   *\n   * @param {Event} event The keyboard event object.\n   */\n  onKeyDown(event) {\n    this.keyPressed = isKey(event.keyCode, 'ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT');\n  }\n\n  /**\n   * Key up listener.\n   */\n  onKeyUp() {\n    this.keyPressed = false;\n  }\n\n  /**\n   * Translate wheel event into scroll event and sync scroll overlays position.\n   *\n   * @private\n   * @param {Event} event The mouse event object.\n   * @returns {boolean}\n   */\n  translateMouseWheelToScroll(event) {\n    let deltaY = isNaN(event.deltaY) ? -1 * event.wheelDeltaY : event.deltaY;\n    let deltaX = isNaN(event.deltaX) ? -1 * event.wheelDeltaX : event.deltaX;\n    if (event.deltaMode === 1) {\n      deltaX += deltaX * this.browserLineHeight;\n      deltaY += deltaY * this.browserLineHeight;\n    }\n    const isScrollVerticallyPossible = this.scrollVertically(deltaY);\n    const isScrollHorizontallyPossible = this.scrollHorizontally(deltaX);\n    return isScrollVerticallyPossible || isScrollHorizontallyPossible;\n  }\n\n  /**\n   * Scrolls main scrollable element horizontally.\n   *\n   * @param {number} delta Relative value to scroll.\n   * @returns {boolean}\n   */\n  scrollVertically(delta) {\n    const previousScroll = this.scrollableElement.scrollTop;\n    this.scrollableElement.scrollTop += delta;\n    return previousScroll !== this.scrollableElement.scrollTop;\n  }\n\n  /**\n   * Scrolls main scrollable element horizontally.\n   *\n   * @param {number} delta Relative value to scroll.\n   * @returns {boolean}\n   */\n  scrollHorizontally(delta) {\n    const previousScroll = this.scrollableElement.scrollLeft;\n    this.scrollableElement.scrollLeft += delta;\n    return previousScroll !== this.scrollableElement.scrollLeft;\n  }\n\n  /**\n   * Synchronize scroll position between master table and overlay table.\n   *\n   * @private\n   */\n  syncScrollPositions() {\n    if (this.destroyed) {\n      return;\n    }\n    const {\n      rootWindow\n    } = this.domBindings;\n    const topHolder = this.topOverlay.clone.wtTable.holder; // todo rethink\n    const leftHolder = this.inlineStartOverlay.clone.wtTable.holder; // todo rethink\n\n    const [scrollLeft, scrollTop] = [this.scrollableElement.scrollLeft, this.scrollableElement.scrollTop];\n    this.horizontalScrolling = topHolder.scrollLeft !== scrollLeft || this.lastScrollX !== rootWindow.scrollX;\n    this.verticalScrolling = leftHolder.scrollTop !== scrollTop || this.lastScrollY !== rootWindow.scrollY;\n    this.lastScrollX = rootWindow.scrollX;\n    this.lastScrollY = rootWindow.scrollY;\n    if (this.horizontalScrolling) {\n      topHolder.scrollLeft = scrollLeft;\n      const bottomHolder = this.bottomOverlay.needFullRender ? this.bottomOverlay.clone.wtTable.holder : null; // todo rethink\n\n      if (bottomHolder) {\n        bottomHolder.scrollLeft = scrollLeft;\n      }\n    }\n    if (this.verticalScrolling) {\n      leftHolder.scrollTop = scrollTop;\n    }\n    this.refreshAll();\n  }\n\n  /**\n   * Synchronize overlay scrollbars with the master scrollbar.\n   */\n  syncScrollWithMaster() {\n    const master = this.topOverlay.mainTableScrollableElement;\n    const {\n      scrollLeft,\n      scrollTop\n    } = master;\n    if (this.topOverlay.needFullRender) {\n      this.topOverlay.clone.wtTable.holder.scrollLeft = scrollLeft; // todo rethink, *overlay.setScroll*()\n    }\n    if (this.bottomOverlay.needFullRender) {\n      this.bottomOverlay.clone.wtTable.holder.scrollLeft = scrollLeft; // todo rethink, *overlay.setScroll*()\n    }\n    if (this.inlineStartOverlay.needFullRender) {\n      this.inlineStartOverlay.clone.wtTable.holder.scrollTop = scrollTop; // todo rethink, *overlay.setScroll*()\n    }\n  }\n\n  /**\n   * Update the main scrollable elements for all the overlays.\n   */\n  updateMainScrollableElements() {\n    this.deregisterListeners();\n    this.inlineStartOverlay.updateMainScrollableElement();\n    this.topOverlay.updateMainScrollableElement();\n    if (this.bottomOverlay.needFullRender) {\n      this.bottomOverlay.updateMainScrollableElement();\n    }\n    const {\n      wtTable\n    } = this;\n    const {\n      rootWindow\n    } = this.domBindings;\n    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n      this.scrollableElement = wtTable.holder;\n    } else {\n      this.scrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n    this.registerListeners();\n  }\n\n  /**\n   *\n   */\n  destroy() {\n    this.resizeObserver.disconnect();\n    this.eventManager.destroy();\n    // todo, probably all below `destory` calls has no sense. To analyze\n    this.topOverlay.destroy();\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.destroy();\n    }\n    this.inlineStartOverlay.destroy();\n    if (this.topInlineStartCornerOverlay) {\n      this.topInlineStartCornerOverlay.destroy();\n    }\n    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {\n      this.bottomInlineStartCornerOverlay.destroy();\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   */\n  refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const wasSpreaderSizeUpdated = this.updateLastSpreaderSize();\n    if (wasSpreaderSizeUpdated) {\n      this.adjustElementsSize();\n    }\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.refresh(fastDraw);\n    }\n    this.inlineStartOverlay.refresh(fastDraw);\n    this.topOverlay.refresh(fastDraw);\n    if (this.topInlineStartCornerOverlay) {\n      this.topInlineStartCornerOverlay.refresh(fastDraw);\n    }\n    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {\n      this.bottomInlineStartCornerOverlay.refresh(fastDraw);\n    }\n  }\n\n  /**\n   * Update the last cached spreader size with the current size.\n   *\n   * @returns {boolean} `true` if the lastSpreaderSize cache was updated, `false` otherwise.\n   */\n  updateLastSpreaderSize() {\n    const spreader = this.wtTable.spreader;\n    const width = spreader.clientWidth;\n    const height = spreader.clientHeight;\n    const needsUpdating = width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height;\n    if (needsUpdating) {\n      this.spreaderLastSize.width = width;\n      this.spreaderLastSize.height = height;\n    }\n    return needsUpdating;\n  }\n\n  /**\n   * Adjust overlays elements size and master table size.\n   *\n   * @param {boolean} [force=false] When `true`, it adjust the DOM nodes sizes for all overlays.\n   */\n  adjustElementsSize() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      wtViewport\n    } = this.wot;\n    const {\n      wtTable\n    } = this;\n    const totalColumns = this.wtSettings.getSetting('totalColumns');\n    const totalRows = this.wtSettings.getSetting('totalRows');\n    const headerRowSize = wtViewport.getRowHeaderWidth();\n    const headerColumnSize = wtViewport.getColumnHeaderHeight();\n    const hiderStyle = wtTable.hider.style;\n    hiderStyle.width = `${headerRowSize + this.inlineStartOverlay.sumCellSizes(0, totalColumns)}px`;\n    hiderStyle.height = `${headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1}px`;\n    if (this.scrollbarSize > 0) {\n      // todo refactoring, looking as a part of logic which should be moved outside the class\n      const {\n        scrollHeight: rootElemScrollHeight,\n        scrollWidth: rootElemScrollWidth\n      } = wtTable.wtRootElement;\n      const {\n        scrollHeight: holderScrollHeight,\n        scrollWidth: holderScrollWidth\n      } = wtTable.holder;\n      this.hasScrollbarRight = rootElemScrollHeight < holderScrollHeight;\n      this.hasScrollbarBottom = rootElemScrollWidth < holderScrollWidth;\n      if (this.hasScrollbarRight && wtTable.hider.scrollWidth + this.scrollbarSize > rootElemScrollWidth) {\n        this.hasScrollbarBottom = true;\n      } else if (this.hasScrollbarBottom && wtTable.hider.scrollHeight + this.scrollbarSize > rootElemScrollHeight) {\n        this.hasScrollbarRight = true;\n      }\n    }\n    this.topOverlay.adjustElementsSize(force);\n    this.inlineStartOverlay.adjustElementsSize(force);\n    this.bottomOverlay.adjustElementsSize(force);\n  }\n\n  /**\n   *\n   */\n  applyToDOM() {\n    if (!this.wtTable.isVisible()) {\n      return;\n    }\n    this.topOverlay.applyToDOM();\n    if (this.bottomOverlay.clone) {\n      this.bottomOverlay.applyToDOM();\n    }\n    this.inlineStartOverlay.applyToDOM();\n  }\n\n  /**\n   * Get the parent overlay of the provided element.\n   *\n   * @param {HTMLElement} element An element to process.\n   * @returns {object|null}\n   */\n  getParentOverlay(element) {\n    if (!element) {\n      return null;\n    }\n    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    let result = null;\n    arrayEach(overlays, overlay => {\n      if (!overlay) {\n        return;\n      }\n      if (overlay.clone && overlay.clone.wtTable.TABLE.contains(element)) {\n        // todo demeter\n        result = overlay.clone;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Synchronize the class names between the main overlay table and the tables on the other overlays.\n   *\n   */\n  syncOverlayTableClassNames() {\n    const masterTable = this.wtTable.TABLE;\n    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];\n    arrayEach(overlays, elem => {\n      if (!elem) {\n        return;\n      }\n      elem.clone.wtTable.TABLE.className = masterTable.className; // todo demeter\n    });\n  }\n}\nexport default Overlays;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}