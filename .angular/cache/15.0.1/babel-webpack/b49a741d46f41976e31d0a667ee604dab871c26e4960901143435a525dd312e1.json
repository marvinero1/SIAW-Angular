{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\n/* eslint-disable no-continue */\nimport { addClass } from \"../../../../helpers/dom/element.mjs\";\n/**\n * Selection scanner module scans the rendered cells and headers and if it finds an intersection with\n * the coordinates of the Selection class (highlight) it returns the DOM elements.\n *\n * @private\n */\nvar _selection = /*#__PURE__*/new WeakMap();\nvar _activeOverlaysWot = /*#__PURE__*/new WeakMap();\nvar _scanCellsRange = /*#__PURE__*/new WeakSet();\nexport class SelectionScanner {\n  constructor() {\n    /**\n     * The method triggers a callback for each rendered cell.\n     *\n     * @param {function(number, number): void} callback The callback function to trigger.\n     */\n    _classPrivateMethodInitSpec(this, _scanCellsRange);\n    /**\n     * Active Selection instance to process.\n     *\n     * @type {Selection}\n     */\n    _classPrivateFieldInitSpec(this, _selection, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The Walkontable instance that the scans depends on.\n     *\n     * @type {Walkontable}\n     */\n    _classPrivateFieldInitSpec(this, _activeOverlaysWot, {\n      writable: true,\n      value: void 0\n    });\n  }\n  /**\n   * Sets the Walkontable instance that will be taking into account while scanning the table.\n   *\n   * @param {Walkontable} activeOverlaysWot The Walkontable instance.\n   * @returns {SelectionScanner}\n   */\n  setActiveOverlay(activeOverlaysWot) {\n    _classPrivateFieldSet(this, _activeOverlaysWot, activeOverlaysWot);\n    return this;\n  }\n\n  /**\n   * Sets the Selection instance to process.\n   *\n   * @param {Selection} selection The Selection instance.\n   * @returns {SelectionScanner}\n   */\n  setActiveSelection(selection) {\n    _classPrivateFieldSet(this, _selection, selection);\n    return this;\n  }\n\n  /**\n   * Scans the rendered table with selection and returns elements that intersects\n   * with selection coordinates.\n   *\n   * @returns {HTMLTableElement[]}\n   */\n  scan() {\n    const selectionType = _classPrivateFieldGet(this, _selection).settings.selectionType;\n    const elements = new Set();\n\n    // TODO(improvement): use heuristics from coords to detect what type of scan\n    // the Selection needs instead of using `selectionType` property.\n    if (selectionType === 'active-header') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n    } else if (selectionType === 'area') {\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'focus') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'fill') {\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'header') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n    } else if (selectionType === 'row') {\n      this.scanRowsInHeadersRange(element => elements.add(element));\n      this.scanRowsInCellsRange(element => elements.add(element));\n    } else if (selectionType === 'column') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanColumnsInCellsRange(element => elements.add(element));\n    }\n    return elements;\n  }\n\n  /**\n   * Scans the table (only rendered headers) and collect all column headers (TH) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanColumnsInHeadersRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(this, _selection).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(this, _activeOverlaysWot);\n    const renderedColumnsCount = wtTable.getRenderedColumnsCount();\n    const columnHeadersCount = wtTable.getColumnHeadersCount();\n    let cursor = 0;\n    for (let column = -wtTable.getRowHeadersCount(); column < renderedColumnsCount; column++) {\n      const sourceColumn = wtTable.columnFilter.renderedToSource(column);\n      if (sourceColumn < topColumn || sourceColumn > bottomColumn) {\n        continue;\n      }\n      for (let headerLevel = -columnHeadersCount; headerLevel < 0; headerLevel++) {\n        if (headerLevel < topRow || headerLevel > bottomRow) {\n          continue;\n        }\n        const positiveBasedHeaderLevel = headerLevel + columnHeadersCount;\n        let TH = wtTable.getColumnHeader(sourceColumn, positiveBasedHeaderLevel);\n        const newSourceCol = _classPrivateFieldGet(this, _activeOverlaysWot).getSetting('onBeforeHighlightingColumnHeader', sourceColumn, positiveBasedHeaderLevel, {\n          selectionType: _classPrivateFieldGet(this, _selection).settings.selectionType,\n          columnCursor: cursor,\n          selectionWidth: bottomColumn - topColumn + 1\n        });\n        if (newSourceCol === null) {\n          continue;\n        }\n        if (newSourceCol !== sourceColumn) {\n          TH = wtTable.getColumnHeader(newSourceCol, positiveBasedHeaderLevel);\n        }\n        callback(TH);\n      }\n      cursor += 1;\n    }\n  }\n\n  /**\n   * Scans the table (only rendered headers) and collect all row headers (TH) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanRowsInHeadersRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(this, _selection).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(this, _activeOverlaysWot);\n    const renderedRowsCount = wtTable.getRenderedRowsCount();\n    const rowHeadersCount = wtTable.getRowHeadersCount();\n    let cursor = 0;\n    for (let row = -wtTable.getColumnHeadersCount(); row < renderedRowsCount; row++) {\n      const sourceRow = wtTable.rowFilter.renderedToSource(row);\n      if (sourceRow < topRow || sourceRow > bottomRow) {\n        continue;\n      }\n      for (let headerLevel = -rowHeadersCount; headerLevel < 0; headerLevel++) {\n        if (headerLevel < topColumn || headerLevel > bottomColumn) {\n          continue;\n        }\n        const positiveBasedHeaderLevel = headerLevel + rowHeadersCount;\n        let TH = wtTable.getRowHeader(sourceRow, positiveBasedHeaderLevel);\n        const newSourceRow = _classPrivateFieldGet(this, _activeOverlaysWot).getSetting('onBeforeHighlightingRowHeader', sourceRow, positiveBasedHeaderLevel, {\n          selectionType: _classPrivateFieldGet(this, _selection).settings.selectionType,\n          rowCursor: cursor,\n          selectionHeight: bottomRow - topRow + 1\n        });\n        if (newSourceRow === null) {\n          continue;\n        }\n        if (newSourceRow !== sourceRow) {\n          TH = wtTable.getRowHeader(newSourceRow, positiveBasedHeaderLevel);\n        }\n        callback(TH);\n      }\n      cursor += 1;\n    }\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collect all cells (TR) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanCellsRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(this, _selection).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(this, _activeOverlaysWot);\n    _classPrivateMethodGet(this, _scanCellsRange, _scanCellsRange2).call(this, (sourceRow, sourceColumn) => {\n      if (sourceRow >= topRow && sourceRow <= bottomRow && sourceColumn >= topColumn && sourceColumn <= bottomColumn) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(this, _activeOverlaysWot).createCellCoords(sourceRow, sourceColumn));\n\n        // support for old API\n        const additionalSelectionClass = _classPrivateFieldGet(this, _activeOverlaysWot).getSetting('onAfterDrawSelection', sourceRow, sourceColumn, _classPrivateFieldGet(this, _selection).settings.layerLevel);\n        if (typeof additionalSelectionClass === 'string') {\n          addClass(cell, additionalSelectionClass);\n        }\n        callback(cell);\n      }\n    });\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collects all cells (TR) that match the coordinates\n   * passed in the Selection instance but only for the X axis (rows).\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanRowsInCellsRange(callback) {\n    // eslint-disable-next-line comma-spacing\n    const [topRow,, bottomRow] = _classPrivateFieldGet(this, _selection).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(this, _activeOverlaysWot);\n    _classPrivateMethodGet(this, _scanCellsRange, _scanCellsRange2).call(this, (sourceRow, sourceColumn) => {\n      if (sourceRow >= topRow && sourceRow <= bottomRow) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(this, _activeOverlaysWot).createCellCoords(sourceRow, sourceColumn));\n        callback(cell);\n      }\n    });\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collects all cells (TR) that match the coordinates\n   * passed in the Selection instance but only for the Y axis (columns).\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanColumnsInCellsRange(callback) {\n    const [, topColumn,, bottomColumn] = _classPrivateFieldGet(this, _selection).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(this, _activeOverlaysWot);\n    _classPrivateMethodGet(this, _scanCellsRange, _scanCellsRange2).call(this, (sourceRow, sourceColumn) => {\n      if (sourceColumn >= topColumn && sourceColumn <= bottomColumn) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(this, _activeOverlaysWot).createCellCoords(sourceRow, sourceColumn));\n        callback(cell);\n      }\n    });\n  }\n}\nfunction _scanCellsRange2(callback) {\n  const {\n    wtTable\n  } = _classPrivateFieldGet(this, _activeOverlaysWot);\n  const renderedRowsCount = wtTable.getRenderedRowsCount();\n  const renderedColumnsCount = wtTable.getRenderedColumnsCount();\n  for (let row = 0; row < renderedRowsCount; row += 1) {\n    const sourceRow = wtTable.rowFilter.renderedToSource(row);\n    for (let column = 0; column < renderedColumnsCount; column += 1) {\n      callback(sourceRow, wtTable.columnFilter.renderedToSource(column));\n    }\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","privateMap","value","set","privateCollection","has","TypeError","_classPrivateMethodGet","receiver","fn","_classPrivateFieldGet","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","call","_classPrivateFieldSet","_classApplyDescriptorSet","action","writable","addClass","_selection","WeakMap","_activeOverlaysWot","_scanCellsRange","WeakSet","SelectionScanner","constructor","setActiveOverlay","activeOverlaysWot","setActiveSelection","selection","scan","selectionType","settings","elements","Set","scanColumnsInHeadersRange","element","scanRowsInHeadersRange","scanCellsRange","scanRowsInCellsRange","scanColumnsInCellsRange","callback","topRow","topColumn","bottomRow","bottomColumn","getCorners","wtTable","renderedColumnsCount","getRenderedColumnsCount","columnHeadersCount","getColumnHeadersCount","cursor","column","getRowHeadersCount","sourceColumn","columnFilter","renderedToSource","headerLevel","positiveBasedHeaderLevel","TH","getColumnHeader","newSourceCol","getSetting","columnCursor","selectionWidth","renderedRowsCount","getRenderedRowsCount","rowHeadersCount","row","sourceRow","rowFilter","getRowHeader","newSourceRow","rowCursor","selectionHeight","_scanCellsRange2","cell","getCell","createCellCoords","additionalSelectionClass","layerLevel"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/3rdparty/walkontable/src/selection/scanner.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\n/* eslint-disable no-continue */\nimport { addClass } from \"../../../../helpers/dom/element.mjs\";\n/**\n * Selection scanner module scans the rendered cells and headers and if it finds an intersection with\n * the coordinates of the Selection class (highlight) it returns the DOM elements.\n *\n * @private\n */\nvar _selection = /*#__PURE__*/new WeakMap();\nvar _activeOverlaysWot = /*#__PURE__*/new WeakMap();\nvar _scanCellsRange = /*#__PURE__*/new WeakSet();\nexport class SelectionScanner {\n  constructor() {\n    /**\n     * The method triggers a callback for each rendered cell.\n     *\n     * @param {function(number, number): void} callback The callback function to trigger.\n     */\n    _classPrivateMethodInitSpec(this, _scanCellsRange);\n    /**\n     * Active Selection instance to process.\n     *\n     * @type {Selection}\n     */\n    _classPrivateFieldInitSpec(this, _selection, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The Walkontable instance that the scans depends on.\n     *\n     * @type {Walkontable}\n     */\n    _classPrivateFieldInitSpec(this, _activeOverlaysWot, {\n      writable: true,\n      value: void 0\n    });\n  }\n  /**\n   * Sets the Walkontable instance that will be taking into account while scanning the table.\n   *\n   * @param {Walkontable} activeOverlaysWot The Walkontable instance.\n   * @returns {SelectionScanner}\n   */\n  setActiveOverlay(activeOverlaysWot) {\n    _classPrivateFieldSet(this, _activeOverlaysWot, activeOverlaysWot);\n    return this;\n  }\n\n  /**\n   * Sets the Selection instance to process.\n   *\n   * @param {Selection} selection The Selection instance.\n   * @returns {SelectionScanner}\n   */\n  setActiveSelection(selection) {\n    _classPrivateFieldSet(this, _selection, selection);\n    return this;\n  }\n\n  /**\n   * Scans the rendered table with selection and returns elements that intersects\n   * with selection coordinates.\n   *\n   * @returns {HTMLTableElement[]}\n   */\n  scan() {\n    const selectionType = _classPrivateFieldGet(this, _selection).settings.selectionType;\n    const elements = new Set();\n\n    // TODO(improvement): use heuristics from coords to detect what type of scan\n    // the Selection needs instead of using `selectionType` property.\n    if (selectionType === 'active-header') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n    } else if (selectionType === 'area') {\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'focus') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'fill') {\n      this.scanCellsRange(element => elements.add(element));\n    } else if (selectionType === 'header') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanRowsInHeadersRange(element => elements.add(element));\n    } else if (selectionType === 'row') {\n      this.scanRowsInHeadersRange(element => elements.add(element));\n      this.scanRowsInCellsRange(element => elements.add(element));\n    } else if (selectionType === 'column') {\n      this.scanColumnsInHeadersRange(element => elements.add(element));\n      this.scanColumnsInCellsRange(element => elements.add(element));\n    }\n    return elements;\n  }\n\n  /**\n   * Scans the table (only rendered headers) and collect all column headers (TH) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanColumnsInHeadersRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(this, _selection).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(this, _activeOverlaysWot);\n    const renderedColumnsCount = wtTable.getRenderedColumnsCount();\n    const columnHeadersCount = wtTable.getColumnHeadersCount();\n    let cursor = 0;\n    for (let column = -wtTable.getRowHeadersCount(); column < renderedColumnsCount; column++) {\n      const sourceColumn = wtTable.columnFilter.renderedToSource(column);\n      if (sourceColumn < topColumn || sourceColumn > bottomColumn) {\n        continue;\n      }\n      for (let headerLevel = -columnHeadersCount; headerLevel < 0; headerLevel++) {\n        if (headerLevel < topRow || headerLevel > bottomRow) {\n          continue;\n        }\n        const positiveBasedHeaderLevel = headerLevel + columnHeadersCount;\n        let TH = wtTable.getColumnHeader(sourceColumn, positiveBasedHeaderLevel);\n        const newSourceCol = _classPrivateFieldGet(this, _activeOverlaysWot).getSetting('onBeforeHighlightingColumnHeader', sourceColumn, positiveBasedHeaderLevel, {\n          selectionType: _classPrivateFieldGet(this, _selection).settings.selectionType,\n          columnCursor: cursor,\n          selectionWidth: bottomColumn - topColumn + 1\n        });\n        if (newSourceCol === null) {\n          continue;\n        }\n        if (newSourceCol !== sourceColumn) {\n          TH = wtTable.getColumnHeader(newSourceCol, positiveBasedHeaderLevel);\n        }\n        callback(TH);\n      }\n      cursor += 1;\n    }\n  }\n\n  /**\n   * Scans the table (only rendered headers) and collect all row headers (TH) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanRowsInHeadersRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(this, _selection).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(this, _activeOverlaysWot);\n    const renderedRowsCount = wtTable.getRenderedRowsCount();\n    const rowHeadersCount = wtTable.getRowHeadersCount();\n    let cursor = 0;\n    for (let row = -wtTable.getColumnHeadersCount(); row < renderedRowsCount; row++) {\n      const sourceRow = wtTable.rowFilter.renderedToSource(row);\n      if (sourceRow < topRow || sourceRow > bottomRow) {\n        continue;\n      }\n      for (let headerLevel = -rowHeadersCount; headerLevel < 0; headerLevel++) {\n        if (headerLevel < topColumn || headerLevel > bottomColumn) {\n          continue;\n        }\n        const positiveBasedHeaderLevel = headerLevel + rowHeadersCount;\n        let TH = wtTable.getRowHeader(sourceRow, positiveBasedHeaderLevel);\n        const newSourceRow = _classPrivateFieldGet(this, _activeOverlaysWot).getSetting('onBeforeHighlightingRowHeader', sourceRow, positiveBasedHeaderLevel, {\n          selectionType: _classPrivateFieldGet(this, _selection).settings.selectionType,\n          rowCursor: cursor,\n          selectionHeight: bottomRow - topRow + 1\n        });\n        if (newSourceRow === null) {\n          continue;\n        }\n        if (newSourceRow !== sourceRow) {\n          TH = wtTable.getRowHeader(newSourceRow, positiveBasedHeaderLevel);\n        }\n        callback(TH);\n      }\n      cursor += 1;\n    }\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collect all cells (TR) that match\n   * the coordinates passed in the Selection instance.\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanCellsRange(callback) {\n    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(this, _selection).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(this, _activeOverlaysWot);\n    _classPrivateMethodGet(this, _scanCellsRange, _scanCellsRange2).call(this, (sourceRow, sourceColumn) => {\n      if (sourceRow >= topRow && sourceRow <= bottomRow && sourceColumn >= topColumn && sourceColumn <= bottomColumn) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(this, _activeOverlaysWot).createCellCoords(sourceRow, sourceColumn));\n\n        // support for old API\n        const additionalSelectionClass = _classPrivateFieldGet(this, _activeOverlaysWot).getSetting('onAfterDrawSelection', sourceRow, sourceColumn, _classPrivateFieldGet(this, _selection).settings.layerLevel);\n        if (typeof additionalSelectionClass === 'string') {\n          addClass(cell, additionalSelectionClass);\n        }\n        callback(cell);\n      }\n    });\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collects all cells (TR) that match the coordinates\n   * passed in the Selection instance but only for the X axis (rows).\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanRowsInCellsRange(callback) {\n    // eslint-disable-next-line comma-spacing\n    const [topRow,, bottomRow] = _classPrivateFieldGet(this, _selection).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(this, _activeOverlaysWot);\n    _classPrivateMethodGet(this, _scanCellsRange, _scanCellsRange2).call(this, (sourceRow, sourceColumn) => {\n      if (sourceRow >= topRow && sourceRow <= bottomRow) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(this, _activeOverlaysWot).createCellCoords(sourceRow, sourceColumn));\n        callback(cell);\n      }\n    });\n  }\n\n  /**\n   * Scans the table (only rendered cells) and collects all cells (TR) that match the coordinates\n   * passed in the Selection instance but only for the Y axis (columns).\n   *\n   * @param {function(HTMLTableElement): void} callback The callback function to trigger.\n   */\n  scanColumnsInCellsRange(callback) {\n    const [, topColumn,, bottomColumn] = _classPrivateFieldGet(this, _selection).getCorners();\n    const {\n      wtTable\n    } = _classPrivateFieldGet(this, _activeOverlaysWot);\n    _classPrivateMethodGet(this, _scanCellsRange, _scanCellsRange2).call(this, (sourceRow, sourceColumn) => {\n      if (sourceColumn >= topColumn && sourceColumn <= bottomColumn) {\n        const cell = wtTable.getCell(_classPrivateFieldGet(this, _activeOverlaysWot).createCellCoords(sourceRow, sourceColumn));\n        callback(cell);\n      }\n    });\n  }\n}\nfunction _scanCellsRange2(callback) {\n  const {\n    wtTable\n  } = _classPrivateFieldGet(this, _activeOverlaysWot);\n  const renderedRowsCount = wtTable.getRenderedRowsCount();\n  const renderedColumnsCount = wtTable.getRenderedColumnsCount();\n  for (let row = 0; row < renderedRowsCount; row += 1) {\n    const sourceRow = wtTable.rowFilter.renderedToSource(row);\n    for (let column = 0; column < renderedColumnsCount; column += 1) {\n      callback(sourceRow, wtTable.columnFilter.renderedToSource(column));\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}