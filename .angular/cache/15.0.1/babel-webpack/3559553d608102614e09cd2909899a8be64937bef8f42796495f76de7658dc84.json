{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { TrimmingMap } from \"../../translations/index.mjs\";\nimport { arrayEach, arrayReduce } from \"../../helpers/array.mjs\";\nexport const PLUGIN_KEY = 'trimRows';\nexport const PLUGIN_PRIORITY = 330;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin TrimRows\n * @class TrimRows\n *\n * @description\n * The plugin allows to trim certain rows. The trimming is achieved by applying the transformation algorithm to the data\n * transformation. In this case, when the row is trimmed it is not accessible using `getData*` methods thus the trimmed\n * data is not visible to other plugins.\n *\n * @example\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   // hide selected rows on table initialization\n *   trimRows: [1, 2, 5]\n * });\n *\n * // access the trimRows plugin instance\n * const trimRowsPlugin = hot.getPlugin('trimRows');\n *\n * // hide single row\n * trimRowsPlugin.trimRow(1);\n *\n * // hide multiple rows\n * trimRowsPlugin.trimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.trimRows([1, 2, 9]);\n *\n * // show single row\n * trimRowsPlugin.untrimRow(1);\n *\n * // show multiple rows\n * trimRowsPlugin.untrimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.untrimRows([1, 2, 9]);\n *\n * // rerender table to see the changes\n * hot.render();\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   // hide selected rows on table initialization\n *   trimRows={[1, 2, 5]}\n * />\n *\n * const hot = hotRef.current.hotInstance;\n * // access the trimRows plugin instance\n * const trimRowsPlugin = hot.getPlugin('trimRows');\n *\n * // hide single row\n * trimRowsPlugin.trimRow(1);\n *\n * // hide multiple rows\n * trimRowsPlugin.trimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.trimRows([1, 2, 9]);\n *\n * // show single row\n * trimRowsPlugin.untrimRow(1);\n *\n * // show multiple rows\n * trimRowsPlugin.untrimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.untrimRows([1, 2, 9]);\n *\n * // rerender table to see the changes\n * hot.render();\n * ```\n * :::\n */\nvar _onMapInit = /*#__PURE__*/new WeakSet();\nexport class TrimRows extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * On map initialized hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _onMapInit);\n    /**\n     * Map of skipped rows by the plugin.\n     *\n     * @private\n     * @type {null|TrimmingMap}\n     */\n    _defineProperty(this, \"trimmedRowsMap\", null);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.trimmedRowsMap = this.hot.rowIndexMapper.registerMap('trimRows', new TrimmingMap());\n    this.trimmedRowsMap.addLocalHook('init', () => _classPrivateMethodGet(this, _onMapInit, _onMapInit2).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`trimRows`](@/api/options.md#trimrows)\n   */\n  updatePlugin() {\n    const trimmedRows = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(trimmedRows)) {\n      this.hot.batchExecution(() => {\n        this.trimmedRowsMap.clear();\n        arrayEach(trimmedRows, physicalRow => {\n          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      }, true);\n    }\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.hot.rowIndexMapper.unregisterMap('trimRows');\n    super.disablePlugin();\n  }\n\n  /**\n   * Get list of trimmed rows.\n   *\n   * @returns {Array} Physical rows.\n   */\n  getTrimmedRows() {\n    return this.trimmedRowsMap.getTrimmedIndexes();\n  }\n\n  /**\n   * Trims the rows provided in the array.\n   *\n   * @param {number[]} rows Array of physical row indexes.\n   * @fires Hooks#beforeTrimRow\n   * @fires Hooks#afterTrimRow\n   */\n  trimRows(rows) {\n    const currentTrimConfig = this.getTrimmedRows();\n    const isValidConfig = this.isValidConfig(rows);\n    let destinationTrimConfig = currentTrimConfig;\n    if (isValidConfig) {\n      destinationTrimConfig = Array.from(new Set(currentTrimConfig.concat(rows)));\n    }\n    const allowTrimRow = this.hot.runHooks('beforeTrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig);\n    if (allowTrimRow === false) {\n      return;\n    }\n    if (isValidConfig) {\n      this.hot.batchExecution(() => {\n        arrayEach(rows, physicalRow => {\n          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      }, true);\n    }\n    this.hot.runHooks('afterTrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig, isValidConfig && destinationTrimConfig.length > currentTrimConfig.length);\n  }\n\n  /**\n   * Trims the row provided as a physical row index (counting from 0).\n   *\n   * @param {...number} row Physical row index.\n   */\n  trimRow() {\n    for (var _len = arguments.length, row = new Array(_len), _key = 0; _key < _len; _key++) {\n      row[_key] = arguments[_key];\n    }\n    this.trimRows(row);\n  }\n\n  /**\n   * Untrims the rows provided in the array.\n   *\n   * @param {number[]} rows Array of physical row indexes.\n   * @fires Hooks#beforeUntrimRow\n   * @fires Hooks#afterUntrimRow\n   */\n  untrimRows(rows) {\n    const currentTrimConfig = this.getTrimmedRows();\n    const isValidConfig = this.isValidConfig(rows);\n    let destinationTrimConfig = currentTrimConfig;\n    const trimmingMapValues = this.trimmedRowsMap.getValues().slice();\n    const isAnyRowUntrimmed = rows.length > 0;\n    if (isValidConfig && isAnyRowUntrimmed) {\n      // Preparing new values for trimming map.\n      arrayEach(rows, physicalRow => {\n        trimmingMapValues[physicalRow] = false;\n      });\n\n      // Preparing new trimming config.\n      destinationTrimConfig = arrayReduce(trimmingMapValues, (trimmedIndexes, isTrimmed, physicalIndex) => {\n        if (isTrimmed) {\n          trimmedIndexes.push(physicalIndex);\n        }\n        return trimmedIndexes;\n      }, []);\n    }\n    const allowUntrimRow = this.hot.runHooks('beforeUntrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed);\n    if (allowUntrimRow === false) {\n      return;\n    }\n    if (isValidConfig && isAnyRowUntrimmed) {\n      this.trimmedRowsMap.setValues(trimmingMapValues);\n    }\n    this.hot.runHooks('afterUntrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed, isValidConfig && destinationTrimConfig.length < currentTrimConfig.length);\n  }\n\n  /**\n   * Untrims the row provided as a physical row index (counting from 0).\n   *\n   * @param {...number} row Physical row index.\n   */\n  untrimRow() {\n    for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      row[_key2] = arguments[_key2];\n    }\n    this.untrimRows(row);\n  }\n\n  /**\n   * Checks if given row is hidden.\n   *\n   * @param {number} physicalRow Physical row index.\n   * @returns {boolean}\n   */\n  isTrimmed(physicalRow) {\n    return this.trimmedRowsMap.getValueAtIndex(physicalRow) || false;\n  }\n\n  /**\n   * Untrims all trimmed rows.\n   */\n  untrimAll() {\n    this.untrimRows(this.getTrimmedRows());\n  }\n\n  /**\n   * Get if trim config is valid. Check whether all of the provided physical row indexes are within source data.\n   *\n   * @param {Array} trimmedRows List of physical row indexes.\n   * @returns {boolean}\n   */\n  isValidConfig(trimmedRows) {\n    const sourceRows = this.hot.countSourceRows();\n    return trimmedRows.every(trimmedRow => Number.isInteger(trimmedRow) && trimmedRow >= 0 && trimmedRow < sourceRows);\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onMapInit2() {\n  const trimmedRows = this.hot.getSettings()[PLUGIN_KEY];\n  if (Array.isArray(trimmedRows)) {\n    this.hot.batchExecution(() => {\n      arrayEach(trimmedRows, physicalRow => {\n        this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n      });\n    }, true);\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","privateCollection","has","TypeError","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateMethodGet","receiver","fn","BasePlugin","TrimmingMap","arrayEach","arrayReduce","PLUGIN_KEY","PLUGIN_PRIORITY","_onMapInit","WeakSet","TrimRows","constructor","arguments","isEnabled","hot","getSettings","enablePlugin","enabled","trimmedRowsMap","rowIndexMapper","registerMap","addLocalHook","_onMapInit2","updatePlugin","trimmedRows","Array","isArray","batchExecution","clear","physicalRow","setValueAtIndex","disablePlugin","unregisterMap","getTrimmedRows","getTrimmedIndexes","trimRows","rows","currentTrimConfig","isValidConfig","destinationTrimConfig","from","Set","concat","allowTrimRow","runHooks","length","trimRow","_len","row","_key","untrimRows","trimmingMapValues","getValues","slice","isAnyRowUntrimmed","trimmedIndexes","isTrimmed","physicalIndex","push","allowUntrimRow","setValues","untrimRow","_len2","_key2","getValueAtIndex","untrimAll","sourceRows","countSourceRows","every","trimmedRow","isInteger","destroy"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/trimRows/trimRows.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { TrimmingMap } from \"../../translations/index.mjs\";\nimport { arrayEach, arrayReduce } from \"../../helpers/array.mjs\";\nexport const PLUGIN_KEY = 'trimRows';\nexport const PLUGIN_PRIORITY = 330;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin TrimRows\n * @class TrimRows\n *\n * @description\n * The plugin allows to trim certain rows. The trimming is achieved by applying the transformation algorithm to the data\n * transformation. In this case, when the row is trimmed it is not accessible using `getData*` methods thus the trimmed\n * data is not visible to other plugins.\n *\n * @example\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   // hide selected rows on table initialization\n *   trimRows: [1, 2, 5]\n * });\n *\n * // access the trimRows plugin instance\n * const trimRowsPlugin = hot.getPlugin('trimRows');\n *\n * // hide single row\n * trimRowsPlugin.trimRow(1);\n *\n * // hide multiple rows\n * trimRowsPlugin.trimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.trimRows([1, 2, 9]);\n *\n * // show single row\n * trimRowsPlugin.untrimRow(1);\n *\n * // show multiple rows\n * trimRowsPlugin.untrimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.untrimRows([1, 2, 9]);\n *\n * // rerender table to see the changes\n * hot.render();\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef = useRef(null);\n *\n * ...\n *\n * <HotTable\n *   ref={hotRef}\n *   data={getData()}\n *   // hide selected rows on table initialization\n *   trimRows={[1, 2, 5]}\n * />\n *\n * const hot = hotRef.current.hotInstance;\n * // access the trimRows plugin instance\n * const trimRowsPlugin = hot.getPlugin('trimRows');\n *\n * // hide single row\n * trimRowsPlugin.trimRow(1);\n *\n * // hide multiple rows\n * trimRowsPlugin.trimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.trimRows([1, 2, 9]);\n *\n * // show single row\n * trimRowsPlugin.untrimRow(1);\n *\n * // show multiple rows\n * trimRowsPlugin.untrimRow(1, 2, 9);\n *\n * // or as an array\n * trimRowsPlugin.untrimRows([1, 2, 9]);\n *\n * // rerender table to see the changes\n * hot.render();\n * ```\n * :::\n */\nvar _onMapInit = /*#__PURE__*/new WeakSet();\nexport class TrimRows extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * On map initialized hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _onMapInit);\n    /**\n     * Map of skipped rows by the plugin.\n     *\n     * @private\n     * @type {null|TrimmingMap}\n     */\n    _defineProperty(this, \"trimmedRowsMap\", null);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.trimmedRowsMap = this.hot.rowIndexMapper.registerMap('trimRows', new TrimmingMap());\n    this.trimmedRowsMap.addLocalHook('init', () => _classPrivateMethodGet(this, _onMapInit, _onMapInit2).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`trimRows`](@/api/options.md#trimrows)\n   */\n  updatePlugin() {\n    const trimmedRows = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(trimmedRows)) {\n      this.hot.batchExecution(() => {\n        this.trimmedRowsMap.clear();\n        arrayEach(trimmedRows, physicalRow => {\n          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      }, true);\n    }\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.hot.rowIndexMapper.unregisterMap('trimRows');\n    super.disablePlugin();\n  }\n\n  /**\n   * Get list of trimmed rows.\n   *\n   * @returns {Array} Physical rows.\n   */\n  getTrimmedRows() {\n    return this.trimmedRowsMap.getTrimmedIndexes();\n  }\n\n  /**\n   * Trims the rows provided in the array.\n   *\n   * @param {number[]} rows Array of physical row indexes.\n   * @fires Hooks#beforeTrimRow\n   * @fires Hooks#afterTrimRow\n   */\n  trimRows(rows) {\n    const currentTrimConfig = this.getTrimmedRows();\n    const isValidConfig = this.isValidConfig(rows);\n    let destinationTrimConfig = currentTrimConfig;\n    if (isValidConfig) {\n      destinationTrimConfig = Array.from(new Set(currentTrimConfig.concat(rows)));\n    }\n    const allowTrimRow = this.hot.runHooks('beforeTrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig);\n    if (allowTrimRow === false) {\n      return;\n    }\n    if (isValidConfig) {\n      this.hot.batchExecution(() => {\n        arrayEach(rows, physicalRow => {\n          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n        });\n      }, true);\n    }\n    this.hot.runHooks('afterTrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig, isValidConfig && destinationTrimConfig.length > currentTrimConfig.length);\n  }\n\n  /**\n   * Trims the row provided as a physical row index (counting from 0).\n   *\n   * @param {...number} row Physical row index.\n   */\n  trimRow() {\n    for (var _len = arguments.length, row = new Array(_len), _key = 0; _key < _len; _key++) {\n      row[_key] = arguments[_key];\n    }\n    this.trimRows(row);\n  }\n\n  /**\n   * Untrims the rows provided in the array.\n   *\n   * @param {number[]} rows Array of physical row indexes.\n   * @fires Hooks#beforeUntrimRow\n   * @fires Hooks#afterUntrimRow\n   */\n  untrimRows(rows) {\n    const currentTrimConfig = this.getTrimmedRows();\n    const isValidConfig = this.isValidConfig(rows);\n    let destinationTrimConfig = currentTrimConfig;\n    const trimmingMapValues = this.trimmedRowsMap.getValues().slice();\n    const isAnyRowUntrimmed = rows.length > 0;\n    if (isValidConfig && isAnyRowUntrimmed) {\n      // Preparing new values for trimming map.\n      arrayEach(rows, physicalRow => {\n        trimmingMapValues[physicalRow] = false;\n      });\n\n      // Preparing new trimming config.\n      destinationTrimConfig = arrayReduce(trimmingMapValues, (trimmedIndexes, isTrimmed, physicalIndex) => {\n        if (isTrimmed) {\n          trimmedIndexes.push(physicalIndex);\n        }\n        return trimmedIndexes;\n      }, []);\n    }\n    const allowUntrimRow = this.hot.runHooks('beforeUntrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed);\n    if (allowUntrimRow === false) {\n      return;\n    }\n    if (isValidConfig && isAnyRowUntrimmed) {\n      this.trimmedRowsMap.setValues(trimmingMapValues);\n    }\n    this.hot.runHooks('afterUntrimRow', currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed, isValidConfig && destinationTrimConfig.length < currentTrimConfig.length);\n  }\n\n  /**\n   * Untrims the row provided as a physical row index (counting from 0).\n   *\n   * @param {...number} row Physical row index.\n   */\n  untrimRow() {\n    for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      row[_key2] = arguments[_key2];\n    }\n    this.untrimRows(row);\n  }\n\n  /**\n   * Checks if given row is hidden.\n   *\n   * @param {number} physicalRow Physical row index.\n   * @returns {boolean}\n   */\n  isTrimmed(physicalRow) {\n    return this.trimmedRowsMap.getValueAtIndex(physicalRow) || false;\n  }\n\n  /**\n   * Untrims all trimmed rows.\n   */\n  untrimAll() {\n    this.untrimRows(this.getTrimmedRows());\n  }\n\n  /**\n   * Get if trim config is valid. Check whether all of the provided physical row indexes are within source data.\n   *\n   * @param {Array} trimmedRows List of physical row indexes.\n   * @returns {boolean}\n   */\n  isValidConfig(trimmedRows) {\n    const sourceRows = this.hot.countSourceRows();\n    return trimmedRows.every(trimmedRow => Number.isInteger(trimmedRow) && trimmedRow >= 0 && trimmedRow < sourceRows);\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onMapInit2() {\n  const trimmedRows = this.hot.getSettings()[PLUGIN_KEY];\n  if (Array.isArray(trimmedRows)) {\n    this.hot.batchExecution(() => {\n      arrayEach(trimmedRows, physicalRow => {\n        this.trimmedRowsMap.setValueAtIndex(physicalRow, true);\n      });\n    }, true);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}