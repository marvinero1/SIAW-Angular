{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/web.immediate.js\";\nimport { addClass, empty, observeVisibilityChangeOnce, removeClass } from \"./helpers/dom/element.mjs\";\nimport { isFunction } from \"./helpers/function.mjs\";\nimport { isDefined, isUndefined, isRegExp, _injectProductInfo, isEmpty } from \"./helpers/mixed.mjs\";\nimport { isMobileBrowser, isIpadOS } from \"./helpers/browser.mjs\";\nimport EditorManager from \"./editorManager.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { deepClone, duckSchema, isObjectEqual, isObject, deepObjectSize, hasOwnProperty, createObjectPropListener, objectEach } from \"./helpers/object.mjs\";\nimport { FocusManager } from \"./focusManager.mjs\";\nimport { arrayMap, arrayEach, arrayReduce, getDifferenceOfArrays, stringToArray, pivot } from \"./helpers/array.mjs\";\nimport { instanceToHTML } from \"./utils/parseTable.mjs\";\nimport { getPlugin, getPluginsNames } from \"./plugins/registry.mjs\";\nimport { getRenderer } from \"./renderers/registry.mjs\";\nimport { getEditor } from \"./editors/registry.mjs\";\nimport { getValidator } from \"./validators/registry.mjs\";\nimport { randomString, toUpperCaseFirst } from \"./helpers/string.mjs\";\nimport { rangeEach, rangeEachReverse, isNumericLike } from \"./helpers/number.mjs\";\nimport TableView from \"./tableView.mjs\";\nimport DataSource from \"./dataMap/dataSource.mjs\";\nimport { spreadsheetColumnLabel } from \"./helpers/data.mjs\";\nimport { IndexMapper } from \"./translations/index.mjs\";\nimport { registerAsRootInstance, hasValidParameter, isRootInstance } from \"./utils/rootInstance.mjs\";\nimport { ViewportColumnsCalculator } from \"./3rdparty/walkontable/src/index.mjs\";\nimport Hooks from \"./pluginHooks.mjs\";\nimport { hasLanguageDictionary, getValidLanguageCode, getTranslatedPhrase } from \"./i18n/registry.mjs\";\nimport { warnUserAboutLanguageRegistration, normalizeLanguageCode } from \"./i18n/utils.mjs\";\nimport { Selection } from \"./selection/index.mjs\";\nimport { MetaManager, DynamicCellMetaMod, ExtendMetaPropertiesMod, replaceData } from \"./dataMap/index.mjs\";\nimport { installFocusCatcher } from \"./core/index.mjs\";\nimport { createUniqueMap } from \"./utils/dataStructures/uniqueMap.mjs\";\nimport { createShortcutManager } from \"./shortcuts/index.mjs\";\nimport { registerAllShortcutContexts } from \"./shortcutContexts/index.mjs\";\nlet activeGuid = null;\n\n/**\n * Keeps the collection of the all Handsontable instances created on the same page. The\n * list is then used to trigger the \"afterUnlisten\" hook when the \"listen()\" method was\n * called on another instance.\n *\n * @type {Map<string, Core>}\n */\nconst foreignHotInstances = new Map();\n\n/**\n * A set of deprecated feature names.\n *\n * @type {Set<string>}\n */\n// eslint-disable-next-line no-unused-vars\nconst deprecationWarns = new Set();\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * Handsontable constructor.\n *\n * @core\n * @class Core\n * @description\n *\n * The `Handsontable` class (known as the `Core`) lets you modify the grid's behavior by using Handsontable's public API methods.\n *\n * ::: only-for react\n * To use these methods, associate a Handsontable instance with your instance\n * of the [`HotTable` component](@/guides/getting-started/installation.md#_4-use-the-hottable-component),\n * by using React's `ref` feature (read more on the [Instance methods](@/guides/getting-started/react-methods.md) page).\n * :::\n *\n * ## How to call a method\n *\n * ::: only-for javascript\n * ```js\n * // create a Handsontable instance\n * const hot = new Handsontable(document.getElementById('example'), options);\n *\n * // call a method\n * hot.setDataAtCell(0, 0, 'new value');\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * import { useRef } from 'react';\n *\n * const hotTableComponent = useRef(null);\n *\n * <HotTable\n *   // associate your `HotTable` component with a Handsontable instance\n *   ref={hotTableComponent}\n *   settings={options}\n * />\n *\n * // access the Handsontable instance, under the `.current.hotInstance` property\n * // call a method\n * hotTableComponent.current.hotInstance.setDataAtCell(0, 0, 'new value');\n * ```\n * :::\n *\n * @param {HTMLElement} rootElement The element to which the Handsontable instance is injected.\n * @param {object} userSettings The user defined options.\n * @param {boolean} [rootInstanceSymbol=false] Indicates if the instance is root of all later instances created.\n */\nexport default function Core(rootElement, userSettings) {\n  var _userSettings$layoutD,\n    _this = this;\n  let rootInstanceSymbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let preventScrollingToCell = false;\n  let instance = this;\n  const eventManager = new EventManager(instance);\n  let datamap;\n  let dataSource;\n  let grid;\n  let editorManager;\n  let focusManager;\n  let firstRun = true;\n  if (hasValidParameter(rootInstanceSymbol)) {\n    registerAsRootInstance(this);\n  }\n\n  // TODO: check if references to DOM elements should be move to UI layer (Walkontable)\n  /**\n   * Reference to the container element.\n   *\n   * @private\n   * @type {HTMLElement}\n   */\n  this.rootElement = rootElement;\n  /**\n   * The nearest document over container.\n   *\n   * @private\n   * @type {Document}\n   */\n  this.rootDocument = rootElement.ownerDocument;\n  /**\n   * Window object over container's document.\n   *\n   * @private\n   * @type {Window}\n   */\n  this.rootWindow = this.rootDocument.defaultView;\n  /**\n   * A boolean to tell if the Handsontable has been fully destroyed. This is set to `true`\n   * after `afterDestroy` hook is called.\n   *\n   * @memberof Core#\n   * @member isDestroyed\n   * @type {boolean}\n   */\n  this.isDestroyed = false;\n  /**\n   * The counter determines how many times the render suspending was called. It allows\n   * tracking the nested suspending calls. For each render suspend resuming call the\n   * counter is decremented. The value equal to 0 means the render suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n  this.renderSuspendedCounter = 0;\n  /**\n   * The counter determines how many times the execution suspending was called. It allows\n   * tracking the nested suspending calls. For each execution suspend resuming call the\n   * counter is decremented. The value equal to 0 means the execution suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n  this.executionSuspendedCounter = 0;\n  const layoutDirection = (_userSettings$layoutD = userSettings === null || userSettings === void 0 ? void 0 : userSettings.layoutDirection) !== null && _userSettings$layoutD !== void 0 ? _userSettings$layoutD : 'inherit';\n  const rootElementDirection = ['rtl', 'ltr'].includes(layoutDirection) ? layoutDirection : this.rootWindow.getComputedStyle(this.rootElement).direction;\n  this.rootElement.setAttribute('dir', rootElementDirection);\n\n  /**\n   * Checks if the grid is rendered using the right-to-left layout direction.\n   *\n   * @since 12.0.0\n   * @memberof Core#\n   * @function isRtl\n   * @returns {boolean} True if RTL.\n   */\n  this.isRtl = function () {\n    return rootElementDirection === 'rtl';\n  };\n\n  /**\n   * Checks if the grid is rendered using the left-to-right layout direction.\n   *\n   * @since 12.0.0\n   * @memberof Core#\n   * @function isLtr\n   * @returns {boolean} True if LTR.\n   */\n  this.isLtr = function () {\n    return !instance.isRtl();\n  };\n\n  /**\n   * Returns 1 for LTR; -1 for RTL. Useful for calculations.\n   *\n   * @since 12.0.0\n   * @memberof Core#\n   * @function getDirectionFactor\n   * @returns {number} Returns 1 for LTR; -1 for RTL.\n   */\n  this.getDirectionFactor = function () {\n    return instance.isLtr() ? 1 : -1;\n  };\n  userSettings.language = getValidLanguageCode(userSettings.language);\n  const metaManager = new MetaManager(instance, userSettings, [DynamicCellMetaMod, ExtendMetaPropertiesMod]);\n  const tableMeta = metaManager.getTableMeta();\n  const globalMeta = metaManager.getGlobalMeta();\n  const pluginsRegistry = createUniqueMap();\n  this.container = this.rootDocument.createElement('div');\n  this.renderCall = false;\n  rootElement.insertBefore(this.container, rootElement.firstChild);\n  if (isRootInstance(this)) {\n    _injectProductInfo(userSettings.licenseKey, rootElement);\n  }\n  this.guid = `ht_${randomString()}`; // this is the namespace for global events\n\n  foreignHotInstances.set(this.guid, this);\n\n  /**\n   * Instance of index mapper which is responsible for managing the column indexes.\n   *\n   * @memberof Core#\n   * @member columnIndexMapper\n   * @type {IndexMapper}\n   */\n  this.columnIndexMapper = new IndexMapper();\n  /**\n   * Instance of index mapper which is responsible for managing the row indexes.\n   *\n   * @memberof Core#\n   * @member rowIndexMapper\n   * @type {IndexMapper}\n   */\n  this.rowIndexMapper = new IndexMapper();\n  this.columnIndexMapper.addLocalHook('indexesSequenceChange', source => {\n    instance.runHooks('afterColumnSequenceChange', source);\n  });\n  this.rowIndexMapper.addLocalHook('indexesSequenceChange', source => {\n    instance.runHooks('afterRowSequenceChange', source);\n  });\n  dataSource = new DataSource(instance);\n  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {\n    this.rootElement.id = this.guid; // if root element does not have an id, assign a random id\n  }\n\n  const visualToRenderableCoords = coords => {\n    const {\n      row: visualRow,\n      col: visualColumn\n    } = coords;\n    return instance._createCellCoords(\n    // We just store indexes for rows and columns without headers.\n    visualRow >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : visualRow, visualColumn >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : visualColumn);\n  };\n  const renderableToVisualCoords = coords => {\n    const {\n      row: renderableRow,\n      col: renderableColumn\n    } = coords;\n    return instance._createCellCoords(\n    // We just store indexes for rows and columns without headers.\n    renderableRow >= 0 ? instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow, renderableColumn >= 0 ? instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn // eslint-disable-line max-len\n    );\n  };\n\n  let selection = new Selection(tableMeta, {\n    rowIndexMapper: instance.rowIndexMapper,\n    columnIndexMapper: instance.columnIndexMapper,\n    countCols: () => instance.countCols(),\n    countRows: () => instance.countRows(),\n    propToCol: prop => datamap.propToCol(prop),\n    isEditorOpened: () => instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false,\n    countRenderableColumns: () => this.view.countRenderableColumns(),\n    countRenderableRows: () => this.view.countRenderableRows(),\n    countRowHeaders: () => this.countRowHeaders(),\n    countColHeaders: () => this.countColHeaders(),\n    getShortcutManager: () => instance.getShortcutManager(),\n    createCellCoords: (row, column) => instance._createCellCoords(row, column),\n    createCellRange: (highlight, from, to) => instance._createCellRange(highlight, from, to),\n    visualToRenderableCoords,\n    renderableToVisualCoords,\n    isDisabledCellSelection: (visualRow, visualColumn) => {\n      if (visualRow < 0 || visualColumn < 0) {\n        return instance.getSettings().disableVisualSelection;\n      }\n      return instance.getCellMeta(visualRow, visualColumn).disableVisualSelection;\n    }\n  });\n  this.selection = selection;\n  const onIndexMapperCacheUpdate = _ref => {\n    let {\n      hiddenIndexesChanged\n    } = _ref;\n    if (hiddenIndexesChanged) {\n      this.selection.refresh();\n    }\n  };\n  this.columnIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.rowIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.selection.addLocalHook('afterSetRangeEnd', cellCoords => {\n    const preventScrolling = createObjectPropListener(false);\n    const selectionRange = this.selection.getSelectedRange();\n    const {\n      from,\n      to\n    } = selectionRange.current();\n    const selectionLayerLevel = selectionRange.size() - 1;\n    this.runHooks('afterSelection', from.row, from.col, to.row, to.col, preventScrolling, selectionLayerLevel);\n    this.runHooks('afterSelectionByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel); // eslint-disable-line max-len\n\n    let scrollToCell = true;\n    if (preventScrollingToCell) {\n      scrollToCell = false;\n    }\n    if (preventScrolling.isTouched()) {\n      scrollToCell = !preventScrolling.value;\n    }\n    const currentSelectedRange = this.selection.selectedRange.current();\n    const isSelectedByAnyHeader = this.selection.isSelectedByAnyHeader();\n    const isSelectedByRowHeader = this.selection.isSelectedByRowHeader();\n    const isSelectedByColumnHeader = this.selection.isSelectedByColumnHeader();\n    if (scrollToCell !== false) {\n      if (!isSelectedByAnyHeader) {\n        if (currentSelectedRange && !this.selection.isMultiple()) {\n          const {\n            row,\n            col\n          } = currentSelectedRange.from;\n          if (row < 0 && col >= 0) {\n            this.scrollViewportTo({\n              col\n            });\n          } else if (col < 0 && row >= 0) {\n            this.scrollViewportTo({\n              row\n            });\n          } else {\n            this.scrollViewportTo({\n              row,\n              col\n            });\n          }\n        } else {\n          this.scrollViewportTo(cellCoords.toObject());\n        }\n      } else if (isSelectedByRowHeader) {\n        this.scrollViewportTo({\n          row: cellCoords.row\n        });\n      } else if (isSelectedByColumnHeader) {\n        this.scrollViewportTo({\n          col: cellCoords.col\n        });\n      }\n    }\n\n    // @TODO: These CSS classes are no longer needed anymore. They are used only as a indicator of the selected\n    // rows/columns in the MergedCells plugin (via border.js#L520 in the walkontable module). After fixing\n    // the Border class this should be removed.\n    if (isSelectedByRowHeader && isSelectedByColumnHeader) {\n      addClass(this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    } else if (isSelectedByRowHeader) {\n      removeClass(this.rootElement, 'ht__selection--columns');\n      addClass(this.rootElement, 'ht__selection--rows');\n    } else if (isSelectedByColumnHeader) {\n      removeClass(this.rootElement, 'ht__selection--rows');\n      addClass(this.rootElement, 'ht__selection--columns');\n    } else {\n      removeClass(this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    }\n    this._refreshBorders(null);\n  });\n  this.selection.addLocalHook('afterSelectionFinished', cellRanges => {\n    const selectionLayerLevel = cellRanges.length - 1;\n    const {\n      from,\n      to\n    } = cellRanges[selectionLayerLevel];\n    this.runHooks('afterSelectionEnd', from.row, from.col, to.row, to.col, selectionLayerLevel);\n    this.runHooks('afterSelectionEndByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), selectionLayerLevel);\n  });\n  this.selection.addLocalHook('afterIsMultipleSelection', isMultiple => {\n    const changedIsMultiple = this.runHooks('afterIsMultipleSelection', isMultiple.value);\n    if (isMultiple.value) {\n      isMultiple.value = changedIsMultiple;\n    }\n  });\n  this.selection.addLocalHook('afterDeselect', () => {\n    editorManager.destroyEditor();\n    this._refreshBorders();\n    removeClass(this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    this.runHooks('afterDeselect');\n  });\n  this.selection.addLocalHook('beforeHighlightSet', () => this.runHooks('beforeSelectionHighlightSet')).addLocalHook('beforeSetRangeStart', function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _this.runHooks('beforeSetRangeStart', ...args);\n  }).addLocalHook('beforeSetRangeStartOnly', function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return _this.runHooks('beforeSetRangeStartOnly', ...args);\n  }).addLocalHook('beforeSetRangeEnd', function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return _this.runHooks('beforeSetRangeEnd', ...args);\n  }).addLocalHook('beforeSelectColumns', function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return _this.runHooks('beforeSelectColumns', ...args);\n  }).addLocalHook('afterSelectColumns', function () {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    return _this.runHooks('afterSelectColumns', ...args);\n  }).addLocalHook('beforeSelectRows', function () {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    return _this.runHooks('beforeSelectRows', ...args);\n  }).addLocalHook('afterSelectRows', function () {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    return _this.runHooks('afterSelectRows', ...args);\n  }).addLocalHook('beforeModifyTransformStart', function () {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    return _this.runHooks('modifyTransformStart', ...args);\n  }).addLocalHook('afterModifyTransformStart', function () {\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    return _this.runHooks('afterModifyTransformStart', ...args);\n  }).addLocalHook('beforeModifyTransformEnd', function () {\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n    return _this.runHooks('modifyTransformEnd', ...args);\n  }).addLocalHook('afterModifyTransformEnd', function () {\n    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      args[_key11] = arguments[_key11];\n    }\n    return _this.runHooks('afterModifyTransformEnd', ...args);\n  }).addLocalHook('beforeRowWrap', function () {\n    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      args[_key12] = arguments[_key12];\n    }\n    return _this.runHooks('beforeRowWrap', ...args);\n  }).addLocalHook('beforeColumnWrap', function () {\n    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      args[_key13] = arguments[_key13];\n    }\n    return _this.runHooks('beforeColumnWrap', ...args);\n  }).addLocalHook('insertRowRequire', totalRows => this.alter('insert_row_above', totalRows, 1, 'auto')).addLocalHook('insertColRequire', totalCols => this.alter('insert_col_start', totalCols, 1, 'auto'));\n  grid = {\n    /**\n     * Inserts or removes rows and columns.\n     *\n     * @private\n     * @param {string} action Possible values: \"insert_row_above\", \"insert_row_below\", \"insert_col_start\", \"insert_col_end\",\n     *                        \"remove_row\", \"remove_col\".\n     * @param {number|Array} index Row or column visual index which from the alter action will be triggered.\n     *                             Alter actions such as \"remove_row\" and \"remove_col\" support array indexes in the\n     *                             format `[[index, amount], [index, amount]...]` this can be used to remove\n     *                             non-consecutive columns or rows in one call.\n     * @param {number} [amount=1] Amount of rows or columns to remove.\n     * @param {string} [source] Optional. Source of hook runner.\n     * @param {boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n     */\n    alter(action, index) {\n      var _index, _index2;\n      let amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      let source = arguments.length > 3 ? arguments[3] : undefined;\n      let keepEmptyRows = arguments.length > 4 ? arguments[4] : undefined;\n      const normalizeIndexesGroup = indexes => {\n        if (indexes.length === 0) {\n          return [];\n        }\n        const sortedIndexes = [...indexes];\n\n        // Sort the indexes in ascending order.\n        sortedIndexes.sort((_ref2, _ref3) => {\n          let [indexA] = _ref2;\n          let [indexB] = _ref3;\n          if (indexA === indexB) {\n            return 0;\n          }\n          return indexA > indexB ? 1 : -1;\n        });\n\n        // Normalize the {index, amount} groups into bigger groups.\n        const normalizedIndexes = arrayReduce(sortedIndexes, (acc, _ref4) => {\n          let [groupIndex, groupAmount] = _ref4;\n          const previousItem = acc[acc.length - 1];\n          const [prevIndex, prevAmount] = previousItem;\n          const prevLastIndex = prevIndex + prevAmount;\n          if (groupIndex <= prevLastIndex) {\n            const amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);\n            previousItem[1] += amountToAdd;\n          } else {\n            acc.push([groupIndex, groupAmount]);\n          }\n          return acc;\n        }, [sortedIndexes[0]]);\n        return normalizedIndexes;\n      };\n\n      /* eslint-disable no-case-declarations */\n      switch (action) {\n        case 'insert_row_below':\n        case 'insert_row_above':\n          const numberOfSourceRows = instance.countSourceRows();\n          if (tableMeta.maxRows === numberOfSourceRows) {\n            return;\n          }\n\n          // `above` is the default behavior for creating new rows\n          const insertRowMode = action === 'insert_row_below' ? 'below' : 'above';\n\n          // Calling the `insert_row_above` action adds a new row at the beginning of the data set.\n          // eslint-disable-next-line no-param-reassign\n          index = (_index = index) !== null && _index !== void 0 ? _index : insertRowMode === 'below' ? numberOfSourceRows : 0;\n          const {\n            delta: rowDelta,\n            startPhysicalIndex: startRowPhysicalIndex\n          } = datamap.createRow(index, amount, {\n            source,\n            mode: insertRowMode\n          });\n          if (rowDelta) {\n            const currentSelectedRange = selection.selectedRange.current();\n            const currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;\n            const currentFromRow = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.row;\n            const startVisualRowIndex = instance.toVisualRow(startRowPhysicalIndex);\n            if (selection.isSelectedByCorner()) {\n              selection.selectAll(true, true, {\n                disableHeadersHighlight: true\n              });\n            } else if (isDefined(currentFromRow) && currentFromRow >= startVisualRowIndex) {\n              // Moving the selection (if it exists) downward – it should be applied to the \"old\" row.\n              // TODO: The logic here should be handled by selection module.\n              const {\n                row: currentToRow,\n                col: currentToColumn\n              } = currentSelectedRange.to;\n              let currentFromColumn = currentFromRange.col;\n\n              // Workaround: headers are not stored inside selection.\n              if (selection.isSelectedByRowHeader()) {\n                currentFromColumn = -1;\n              }\n\n              // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n              selection.getSelectedRange().pop();\n              // I can't use transforms as they don't work in negative indexes.\n              selection.setRangeStartOnly(instance._createCellCoords(currentFromRow + rowDelta, currentFromColumn), true);\n              selection.setRangeEnd(instance._createCellCoords(currentToRow + rowDelta, currentToColumn)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n            }\n          }\n\n          break;\n        case 'insert_col_start':\n        case 'insert_col_end':\n          // \"start\" is a default behavior for creating new columns\n          const insertColumnMode = action === 'insert_col_end' ? 'end' : 'start';\n\n          // Calling the `insert_col_start` action adds a new column to the left of the data set.\n          // eslint-disable-next-line no-param-reassign\n          index = (_index2 = index) !== null && _index2 !== void 0 ? _index2 : insertColumnMode === 'end' ? instance.countSourceCols() : 0;\n          const {\n            delta: colDelta,\n            startPhysicalIndex: startColumnPhysicalIndex\n          } = datamap.createCol(index, amount, {\n            source,\n            mode: insertColumnMode\n          });\n          if (colDelta) {\n            if (Array.isArray(tableMeta.colHeaders)) {\n              const spliceArray = [instance.toVisualColumn(startColumnPhysicalIndex), 0];\n              spliceArray.length += colDelta; // inserts empty (undefined) elements at the end of an array\n              Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray); // inserts empty (undefined) elements into the colHeader array\n            }\n\n            const currentSelectedRange = selection.selectedRange.current();\n            const currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;\n            const currentFromColumn = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.col;\n            const startVisualColumnIndex = instance.toVisualColumn(startColumnPhysicalIndex);\n            if (selection.isSelectedByCorner()) {\n              selection.selectAll(true, true, {\n                disableHeadersHighlight: true\n              });\n            } else if (isDefined(currentFromColumn) && currentFromColumn >= startVisualColumnIndex) {\n              // Moving the selection (if it exists) rightward – it should be applied to the \"old\" column.\n              // TODO: The logic here should be handled by selection module.\n              const {\n                row: currentToRow,\n                col: currentToColumn\n              } = currentSelectedRange.to;\n              let currentFromRow = currentFromRange.row;\n\n              // Workaround: headers are not stored inside selection.\n              if (selection.isSelectedByColumnHeader()) {\n                currentFromRow = -1;\n              }\n\n              // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n              selection.getSelectedRange().pop();\n\n              // I can't use transforms as they don't work in negative indexes.\n              selection.setRangeStartOnly(instance._createCellCoords(currentFromRow, currentFromColumn + colDelta), true);\n              selection.setRangeEnd(instance._createCellCoords(currentToRow, currentToColumn + colDelta)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n            }\n          }\n\n          break;\n        case 'remove_row':\n          const removeRow = indexes => {\n            let offset = 0;\n\n            // Normalize the {index, amount} groups into bigger groups.\n            arrayEach(indexes, _ref5 => {\n              let [groupIndex, groupAmount] = _ref5;\n              const calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset, 0);\n\n              // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              }\n\n              // TODO: for datamap.removeRow index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeRow breaks the removing functionality.\n              const wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);\n              if (!wasRemoved) {\n                return;\n              }\n              const totalRows = instance.countRows();\n              const fixedRowsTop = tableMeta.fixedRowsTop;\n              if (fixedRowsTop >= calcIndex + 1) {\n                tableMeta.fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);\n              }\n              const fixedRowsBottom = tableMeta.fixedRowsBottom;\n              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {\n                tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);\n              }\n              offset += groupAmount;\n            });\n          };\n          if (Array.isArray(index)) {\n            removeRow(normalizeIndexesGroup(index));\n          } else {\n            removeRow([[index, amount]]);\n          }\n          grid.adjustRowsAndCols();\n          instance._refreshBorders(); // it will call render and prepare methods\n          break;\n        case 'remove_col':\n          const removeCol = indexes => {\n            let offset = 0;\n\n            // Normalize the {index, amount} groups into bigger groups.\n            arrayEach(indexes, _ref6 => {\n              let [groupIndex, groupAmount] = _ref6;\n              const calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset, 0);\n              let physicalColumnIndex = instance.toPhysicalColumn(calcIndex);\n\n              // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              }\n\n              // TODO: for datamap.removeCol index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeCol breaks the removing functionality.\n              const wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);\n              if (!wasRemoved) {\n                return;\n              }\n              const fixedColumnsStart = tableMeta.fixedColumnsStart;\n              if (fixedColumnsStart >= calcIndex + 1) {\n                tableMeta.fixedColumnsStart -= Math.min(groupAmount, fixedColumnsStart - calcIndex);\n              }\n              if (Array.isArray(tableMeta.colHeaders)) {\n                if (typeof physicalColumnIndex === 'undefined') {\n                  physicalColumnIndex = -1;\n                }\n                tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);\n              }\n              offset += groupAmount;\n            });\n          };\n          if (Array.isArray(index)) {\n            removeCol(normalizeIndexesGroup(index));\n          } else {\n            removeCol([[index, amount]]);\n          }\n          grid.adjustRowsAndCols();\n          instance._refreshBorders(); // it will call render and prepare methods\n\n          break;\n        default:\n          throw new Error(`There is no such action \"${action}\"`);\n      }\n      if (!keepEmptyRows) {\n        grid.adjustRowsAndCols(); // makes sure that we did not add rows that will be removed in next refresh\n      }\n    },\n\n    /**\n     * Makes sure there are empty rows at the bottom of the table.\n     *\n     * @private\n     */\n    adjustRowsAndCols() {\n      const minRows = tableMeta.minRows;\n      const minSpareRows = tableMeta.minSpareRows;\n      const minCols = tableMeta.minCols;\n      const minSpareCols = tableMeta.minSpareCols;\n      if (instance.countRows() === 0 && instance.countCols() === 0) {\n        selection.deselect();\n      }\n      if (minRows) {\n        // should I add empty rows to data source to meet minRows?\n        const nrOfRows = instance.countRows();\n        if (nrOfRows < minRows) {\n          // The synchronization with cell meta is not desired here. For `minRows` option,\n          // we don't want to touch/shift cell meta objects.\n          datamap.createRow(nrOfRows, minRows - nrOfRows, {\n            source: 'auto'\n          });\n        }\n      }\n      if (minSpareRows) {\n        const emptyRows = instance.countEmptyRows(true);\n\n        // should I add empty rows to meet minSpareRows?\n        if (emptyRows < minSpareRows) {\n          const emptyRowsMissing = minSpareRows - emptyRows;\n          const rowsToCreate = Math.min(emptyRowsMissing, tableMeta.maxRows - instance.countSourceRows());\n\n          // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n          datamap.createRow(instance.countRows(), rowsToCreate, {\n            source: 'auto'\n          });\n        }\n      }\n      {\n        let emptyCols;\n\n        // count currently empty cols\n        if (minCols || minSpareCols) {\n          emptyCols = instance.countEmptyCols(true);\n        }\n        let nrOfColumns = instance.countCols();\n\n        // should I add empty cols to meet minCols?\n        if (minCols && !tableMeta.columns && nrOfColumns < minCols) {\n          // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n          const colsToCreate = minCols - nrOfColumns;\n          emptyCols += colsToCreate;\n          datamap.createCol(nrOfColumns, colsToCreate, {\n            source: 'auto'\n          });\n        }\n        // should I add empty cols to meet minSpareCols?\n        if (minSpareCols && !tableMeta.columns && instance.dataType === 'array' && emptyCols < minSpareCols) {\n          nrOfColumns = instance.countCols();\n          const emptyColsMissing = minSpareCols - emptyCols;\n          const colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns);\n\n          // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n          datamap.createCol(nrOfColumns, colsToCreate, {\n            source: 'auto'\n          });\n        }\n      }\n      if (selection.isSelected()) {\n        const rowCount = instance.countRows();\n        const colCount = instance.countCols();\n        arrayEach(selection.selectedRange, range => {\n          let selectionChanged = false;\n          let fromRow = range.from.row;\n          let fromCol = range.from.col;\n          let toRow = range.to.row;\n          let toCol = range.to.col;\n\n          // if selection is outside, move selection to last row\n          if (fromRow > rowCount - 1) {\n            fromRow = rowCount - 1;\n            selectionChanged = true;\n            if (toRow > fromRow) {\n              toRow = fromRow;\n            }\n          } else if (toRow > rowCount - 1) {\n            toRow = rowCount - 1;\n            selectionChanged = true;\n            if (fromRow > toRow) {\n              fromRow = toRow;\n            }\n          }\n          // if selection is outside, move selection to last row\n          if (fromCol > colCount - 1) {\n            fromCol = colCount - 1;\n            selectionChanged = true;\n            if (toCol > fromCol) {\n              toCol = fromCol;\n            }\n          } else if (toCol > colCount - 1) {\n            toCol = colCount - 1;\n            selectionChanged = true;\n            if (fromCol > toCol) {\n              fromCol = toCol;\n            }\n          }\n          if (selectionChanged) {\n            if (fromCol < 0) {\n              instance.selectRows(fromRow, toRow, fromCol);\n            } else if (fromRow < 0) {\n              instance.selectColumns(fromCol, toCol, fromRow);\n            } else {\n              instance.selectCell(fromRow, fromCol, toRow, toCol);\n            }\n          }\n        });\n      }\n      if (instance.view) {\n        instance.view.adjustElementsSize();\n      }\n    },\n    /**\n     * Populate the data from the provided 2d array from the given cell coordinates.\n     *\n     * @private\n     * @param {object} start Start selection position. Visual indexes.\n     * @param {Array} input 2d data array.\n     * @param {object} [end] End selection position (only for drag-down mode). Visual indexes.\n     * @param {string} [source=\"populateFromArray\"] Source information string.\n     * @param {string} [method=\"overwrite\"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.\n     * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n     */\n    populateFromArray(start, input, end, source, method) {\n      let r;\n      let rlen;\n      let c;\n      let clen;\n      const setData = [];\n      const current = {};\n      const newDataByColumns = [];\n      const startRow = start.row;\n      const startColumn = start.col;\n      rlen = input.length;\n      if (rlen === 0) {\n        return false;\n      }\n      let columnsPopulationEnd = 0;\n      let rowsPopulationEnd = 0;\n      if (isObject(end)) {\n        columnsPopulationEnd = end.col - startColumn + 1;\n        rowsPopulationEnd = end.row - startRow + 1;\n      }\n\n      // insert data with specified pasteMode method\n      switch (method) {\n        case 'shift_down':\n          // translate data from a list of rows to a list of columns\n          const populatedDataByColumns = pivot(input);\n          const numberOfDataColumns = populatedDataByColumns.length;\n          // method's argument can extend the range of data population (data would be repeated)\n          const numberOfColumnsToPopulate = Math.max(numberOfDataColumns, columnsPopulationEnd);\n          const pushedDownDataByRows = instance.getData().slice(startRow);\n\n          // translate data from a list of rows to a list of columns\n          const pushedDownDataByColumns = pivot(pushedDownDataByRows).slice(startColumn, startColumn + numberOfColumnsToPopulate);\n          for (c = 0; c < numberOfColumnsToPopulate; c += 1) {\n            if (c < numberOfDataColumns) {\n              for (r = 0, rlen = populatedDataByColumns[c].length; r < rowsPopulationEnd - rlen; r += 1) {\n                // repeating data for rows\n                populatedDataByColumns[c].push(populatedDataByColumns[c][r % rlen]);\n              }\n              if (c < pushedDownDataByColumns.length) {\n                newDataByColumns.push(populatedDataByColumns[c].concat(pushedDownDataByColumns[c]));\n              } else {\n                // if before data population, there was no data in the column\n                // we fill the required rows' newly-created cells with `null` values\n                newDataByColumns.push(populatedDataByColumns[c].concat(new Array(pushedDownDataByRows.length).fill(null)));\n              }\n            } else {\n              // Repeating data for columns.\n              newDataByColumns.push(populatedDataByColumns[c % numberOfDataColumns].concat(pushedDownDataByColumns[c]));\n            }\n          }\n          instance.populateFromArray(startRow, startColumn, pivot(newDataByColumns));\n          break;\n        case 'shift_right':\n          const numberOfDataRows = input.length;\n          // method's argument can extend the range of data population (data would be repeated)\n          const numberOfRowsToPopulate = Math.max(numberOfDataRows, rowsPopulationEnd);\n          const pushedRightDataByRows = instance.getData().slice(startRow).map(rowData => rowData.slice(startColumn));\n          for (r = 0; r < numberOfRowsToPopulate; r += 1) {\n            if (r < numberOfDataRows) {\n              for (c = 0, clen = input[r].length; c < columnsPopulationEnd - clen; c += 1) {\n                // repeating data for rows\n                input[r].push(input[r][c % clen]);\n              }\n              if (r < pushedRightDataByRows.length) {\n                for (let i = 0; i < pushedRightDataByRows[r].length; i += 1) {\n                  input[r].push(pushedRightDataByRows[r][i]);\n                }\n              } else {\n                // if before data population, there was no data in the row\n                // we fill the required columns' newly-created cells with `null` values\n                input[r].push(...new Array(pushedRightDataByRows[0].length).fill(null));\n              }\n            } else {\n              // Repeating data for columns.\n              input.push(input[r % rlen].slice(0, numberOfRowsToPopulate).concat(pushedRightDataByRows[r]));\n            }\n          }\n          instance.populateFromArray(startRow, startColumn, input);\n          break;\n        case 'overwrite':\n        default:\n          // overwrite and other not specified options\n          current.row = start.row;\n          current.col = start.col;\n          let skippedRow = 0;\n          let skippedColumn = 0;\n          let pushData = true;\n          let cellMeta;\n          const getInputValue = function getInputValue(row) {\n            let col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            const rowValue = input[row % input.length];\n            if (col !== null) {\n              return rowValue[col % rowValue.length];\n            }\n            return rowValue;\n          };\n          const rowInputLength = input.length;\n          const rowSelectionLength = end ? end.row - start.row + 1 : 0;\n          if (end) {\n            rlen = rowSelectionLength;\n          } else {\n            rlen = Math.max(rowInputLength, rowSelectionLength);\n          }\n          for (r = 0; r < rlen; r++) {\n            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= tableMeta.maxRows) {\n              break;\n            }\n            const visualRow = r - skippedRow;\n            const colInputLength = getInputValue(visualRow).length;\n            const colSelectionLength = end ? end.col - start.col + 1 : 0;\n            if (end) {\n              clen = colSelectionLength;\n            } else {\n              clen = Math.max(colInputLength, colSelectionLength);\n            }\n            current.col = start.col;\n            cellMeta = instance.getCellMeta(current.row, current.col);\n            if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipRowOnPaste) {\n              skippedRow += 1;\n              current.row += 1;\n              rlen += 1;\n              /* eslint-disable no-continue */\n              continue;\n            }\n            skippedColumn = 0;\n            for (c = 0; c < clen; c++) {\n              if (end && current.col > end.col && colSelectionLength > colInputLength || !tableMeta.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= tableMeta.maxCols) {\n                break;\n              }\n              cellMeta = instance.getCellMeta(current.row, current.col);\n              if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipColumnOnPaste) {\n                skippedColumn += 1;\n                current.col += 1;\n                clen += 1;\n                continue;\n              }\n              if (cellMeta.readOnly && source !== 'UndoRedo.undo') {\n                current.col += 1;\n                /* eslint-disable no-continue */\n                continue;\n              }\n              const visualColumn = c - skippedColumn;\n              let value = getInputValue(visualRow, visualColumn);\n              let orgValue = instance.getDataAtCell(current.row, current.col);\n              if (value !== null && typeof value === 'object') {\n                // when 'value' is array and 'orgValue' is null, set 'orgValue' to\n                // an empty array so that the null value can be compared to 'value'\n                // as an empty value for the array context\n                if (Array.isArray(value) && orgValue === null) orgValue = [];\n                if (orgValue === null || typeof orgValue !== 'object') {\n                  pushData = false;\n                } else {\n                  const orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);\n                  const valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);\n\n                  // Allow overwriting values with the same object-based schema or any array-based schema.\n                  if (isObjectEqual(orgValueSchema, valueSchema) || Array.isArray(orgValueSchema) && Array.isArray(valueSchema)) {\n                    value = deepClone(value);\n                  } else {\n                    pushData = false;\n                  }\n                }\n              } else if (orgValue !== null && typeof orgValue === 'object') {\n                pushData = false;\n              }\n              if (pushData) {\n                setData.push([current.row, current.col, value]);\n              }\n              pushData = true;\n              current.col += 1;\n            }\n            current.row += 1;\n          }\n          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');\n          break;\n      }\n    }\n  };\n\n  /**\n   * Internal function to set `language` key of settings.\n   *\n   * @private\n   * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n   * @fires Hooks#afterLanguageChange\n   */\n  function setLanguage(languageCode) {\n    const normalizedLanguageCode = normalizeLanguageCode(languageCode);\n    if (hasLanguageDictionary(normalizedLanguageCode)) {\n      instance.runHooks('beforeLanguageChange', normalizedLanguageCode);\n      globalMeta.language = normalizedLanguageCode;\n      instance.runHooks('afterLanguageChange', normalizedLanguageCode);\n    } else {\n      warnUserAboutLanguageRegistration(languageCode);\n    }\n  }\n\n  /**\n   * Internal function to set `className` or `tableClassName`, depending on the key from the settings object.\n   *\n   * @private\n   * @param {string} className `className` or `tableClassName` from the key in the settings object.\n   * @param {string|string[]} classSettings String or array of strings. Contains class name(s) from settings object.\n   */\n  function setClassName(className, classSettings) {\n    const element = className === 'className' ? instance.rootElement : instance.table;\n    if (firstRun) {\n      addClass(element, classSettings);\n    } else {\n      let globalMetaSettingsArray = [];\n      let settingsArray = [];\n      if (globalMeta[className]) {\n        globalMetaSettingsArray = Array.isArray(globalMeta[className]) ? globalMeta[className] : stringToArray(globalMeta[className]);\n      }\n      if (classSettings) {\n        settingsArray = Array.isArray(classSettings) ? classSettings : stringToArray(classSettings);\n      }\n      const classNameToRemove = getDifferenceOfArrays(globalMetaSettingsArray, settingsArray);\n      const classNameToAdd = getDifferenceOfArrays(settingsArray, globalMetaSettingsArray);\n      if (classNameToRemove.length) {\n        removeClass(element, classNameToRemove);\n      }\n      if (classNameToAdd.length) {\n        addClass(element, classNameToAdd);\n      }\n    }\n    globalMeta[className] = classSettings;\n  }\n  this.init = function () {\n    dataSource.setData(tableMeta.data);\n    instance.runHooks('beforeInit');\n    if (isMobileBrowser() || isIpadOS()) {\n      addClass(instance.rootElement, 'mobile');\n    }\n    this.updateSettings(tableMeta, true);\n    this.view = new TableView(this);\n    editorManager = EditorManager.getInstance(instance, tableMeta, selection);\n    focusManager = new FocusManager(instance);\n    if (isRootInstance(this)) {\n      installFocusCatcher(instance);\n    }\n    instance.runHooks('init');\n    this.forceFullRender = true; // used when data was changed\n    this.view.render();\n\n    // Run the logic only if it's the table's initialization and the root element is not visible.\n    if (!!firstRun && instance.rootElement.offsetParent === null) {\n      observeVisibilityChangeOnce(instance.rootElement, () => {\n        // Update the spreader size cache before rendering.\n        instance.view._wt.wtOverlays.updateLastSpreaderSize();\n        instance.render();\n        instance.view.adjustElementsSize();\n      });\n    }\n    if (typeof firstRun === 'object') {\n      instance.runHooks('afterChange', firstRun[0], firstRun[1]);\n      firstRun = false;\n    }\n    instance.runHooks('afterInit');\n  };\n\n  /**\n   * @ignore\n   * @returns {object}\n   */\n  function ValidatorsQueue() {\n    // moved this one level up so it can be used in any function here. Probably this should be moved to a separate file\n    let resolved = false;\n    return {\n      validatorsInQueue: 0,\n      valid: true,\n      addValidatorToQueue() {\n        this.validatorsInQueue += 1;\n        resolved = false;\n      },\n      removeValidatorFormQueue() {\n        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;\n        this.checkIfQueueIsEmpty();\n      },\n      onQueueEmpty() {},\n      checkIfQueueIsEmpty() {\n        if (this.validatorsInQueue === 0 && resolved === false) {\n          resolved = true;\n          this.onQueueEmpty(this.valid);\n        }\n      }\n    };\n  }\n\n  /**\n   * Get parsed number from numeric string.\n   *\n   * @private\n   * @param {string} numericData Float (separated by a dot or a comma) or integer.\n   * @returns {number} Number if we get data in parsable format, not changed value otherwise.\n   */\n  function getParsedNumber(numericData) {\n    // Unifying \"float like\" string. Change from value with comma determiner to value with dot determiner,\n    // for example from `450,65` to `450.65`.\n    const unifiedNumericData = numericData.replace(',', '.');\n    if (isNaN(parseFloat(unifiedNumericData)) === false) {\n      return parseFloat(unifiedNumericData);\n    }\n    return numericData;\n  }\n\n  /**\n   * @ignore\n   * @param {Array} changes The 2D array containing information about each of the edited cells.\n   * @param {string} source The string that identifies source of validation.\n   * @param {Function} callback The callback function fot async validation.\n   */\n  function validateChanges(changes, source, callback) {\n    if (!changes.length) {\n      return;\n    }\n    const activeEditor = instance.getActiveEditor();\n    const waitingForValidator = new ValidatorsQueue();\n    let shouldBeCanceled = true;\n    waitingForValidator.onQueueEmpty = isValid => {\n      if (activeEditor && shouldBeCanceled) {\n        activeEditor.cancelChanges();\n      }\n      callback(isValid); // called when async validators are resolved and beforeChange was not async\n    };\n\n    for (let i = changes.length - 1; i >= 0; i--) {\n      const [row, prop,, newValue] = changes[i];\n      const col = datamap.propToCol(prop);\n      const cellProperties = instance.getCellMeta(row, col);\n      if (cellProperties.type === 'numeric' && typeof newValue === 'string' && isNumericLike(newValue)) {\n        changes[i][3] = getParsedNumber(newValue);\n      }\n\n      /* eslint-disable no-loop-func */\n      if (instance.getCellValidator(cellProperties)) {\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(changes[i][3], cellProperties, function (index, cellPropertiesReference) {\n          return function (result) {\n            if (typeof result !== 'boolean') {\n              throw new Error('Validation error: result is not boolean');\n            }\n            if (result === false && cellPropertiesReference.allowInvalid === false) {\n              shouldBeCanceled = false;\n              changes.splice(index, 1); // cancel the change\n              cellPropertiesReference.valid = true; // we cancelled the change, so cell value is still valid\n\n              const cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);\n              if (cell !== null) {\n                removeClass(cell, tableMeta.invalidCellClassName);\n              }\n            }\n            waitingForValidator.removeValidatorFormQueue();\n          };\n        }(i, cellProperties), source);\n      }\n    }\n    waitingForValidator.checkIfQueueIsEmpty();\n  }\n\n  /**\n   * Internal function to apply changes. Called after validateChanges.\n   *\n   * @private\n   * @param {Array} changes Array in form of [row, prop, oldValue, newValue].\n   * @param {string} source String that identifies how this change will be described in changes array (useful in onChange callback).\n   * @fires Hooks#beforeChangeRender\n   * @fires Hooks#afterChange\n   */\n  function applyChanges(changes, source) {\n    let i = changes.length - 1;\n    if (i < 0) {\n      return;\n    }\n    for (; i >= 0; i--) {\n      let skipThisChange = false;\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n        /* eslint-disable no-continue */\n        continue;\n      }\n      if ((changes[i][2] === null || changes[i][2] === undefined) && (changes[i][3] === null || changes[i][3] === undefined)) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      if (tableMeta.allowInsertRow) {\n        while (changes[i][0] > instance.countRows() - 1) {\n          const {\n            delta: numberOfCreatedRows\n          } = datamap.createRow(undefined, undefined, {\n            source\n          });\n          if (numberOfCreatedRows === 0) {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n      if (instance.dataType === 'array' && (!tableMeta.columns || tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {\n        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {\n          const {\n            delta: numberOfCreatedColumns\n          } = datamap.createCol(undefined, undefined, {\n            source\n          });\n          if (numberOfCreatedColumns === 0) {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n      if (skipThisChange) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      datamap.set(changes[i][0], changes[i][1], changes[i][3]);\n    }\n    instance.forceFullRender = true; // used when data was changed\n    grid.adjustRowsAndCols();\n    instance.runHooks('beforeChangeRender', changes, source);\n    editorManager.lockEditor();\n    instance._refreshBorders(null);\n    editorManager.unlockEditor();\n    instance.view.adjustElementsSize();\n    instance.runHooks('afterChange', changes, source || 'edit');\n    const activeEditor = instance.getActiveEditor();\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  }\n\n  /**\n   * Creates and returns the CellCoords object.\n   *\n   * @private\n   * @memberof Core#\n   * @function _createCellCoords\n   * @param {number} row The row index.\n   * @param {number} column The column index.\n   * @returns {CellCoords}\n   */\n  this._createCellCoords = function (row, column) {\n    return instance.view._wt.createCellCoords(row, column);\n  };\n\n  /**\n   * Creates and returns the CellRange object.\n   *\n   * @private\n   * @memberof Core#\n   * @function _createCellRange\n   * @param {CellCoords} highlight Defines the border around a cell where selection was started and to edit the cell\n   *                               when you press Enter. The highlight cannot point to headers (negative values).\n   * @param {CellCoords} from Initial coordinates.\n   * @param {CellCoords} to Final coordinates.\n   * @returns {CellRange}\n   */\n  this._createCellRange = function (highlight, from, to) {\n    return instance.view._wt.createCellRange(highlight, from, to);\n  };\n\n  /**\n   * Validate a single cell.\n   *\n   * @memberof Core#\n   * @function validateCell\n   * @param {string|number} value The value to validate.\n   * @param {object} cellProperties The cell meta which corresponds with the value.\n   * @param {Function} callback The callback function.\n   * @param {string} source The string that identifies source of the validation.\n   */\n  this.validateCell = function (value, cellProperties, callback, source) {\n    let validator = instance.getCellValidator(cellProperties);\n\n    // the `canBeValidated = false` argument suggests, that the cell passes validation by default.\n    /**\n     * @private\n     * @function done\n     * @param {boolean} valid Indicates if the validation was successful.\n     * @param {boolean} [canBeValidated=true] Flag which controls the validation process.\n     */\n    function done(valid) {\n      let canBeValidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      // Fixes GH#3903\n      if (!canBeValidated || cellProperties.hidden === true) {\n        callback(valid);\n        return;\n      }\n      const col = cellProperties.visualCol;\n      const row = cellProperties.visualRow;\n      const td = instance.getCell(row, col, true);\n      if (td && td.nodeName !== 'TH') {\n        const renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);\n        const renderableColumn = instance.columnIndexMapper.getRenderableFromVisualIndex(col);\n        instance.view._wt.getSetting('cellRenderer', renderableRow, renderableColumn, td);\n      }\n      callback(valid);\n    }\n    if (isRegExp(validator)) {\n      validator = function (expression) {\n        return function (cellValue, validatorCallback) {\n          validatorCallback(expression.test(cellValue));\n        };\n      }(validator);\n    }\n    if (isFunction(validator)) {\n      // eslint-disable-next-line no-param-reassign\n      value = instance.runHooks('beforeValidate', value, cellProperties.visualRow, cellProperties.prop, source);\n\n      // To provide consistent behaviour, validation should be always asynchronous\n      instance._registerImmediate(() => {\n        validator.call(cellProperties, value, valid => {\n          if (!instance) {\n            return;\n          }\n          // eslint-disable-next-line no-param-reassign\n          valid = instance.runHooks('afterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n          cellProperties.valid = valid;\n          done(valid);\n          instance.runHooks('postAfterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n        });\n      });\n    } else {\n      // resolve callback even if validator function was not found\n      instance._registerImmediate(() => {\n        cellProperties.valid = true;\n        done(cellProperties.valid, false);\n      });\n    }\n  };\n\n  /**\n   * @ignore\n   * @param {number} row The visual row index.\n   * @param {string|number} propOrCol The visual prop or column index.\n   * @param {*} value The cell value.\n   * @returns {Array}\n   */\n  function setDataInputToArray(row, propOrCol, value) {\n    if (Array.isArray(row)) {\n      // it's an array of changes\n      return row;\n    }\n    return [[row, propOrCol, value]];\n  }\n\n  /**\n   * Process changes prepared for applying to the dataset (unifying list of changes, closing an editor - when needed,\n   * calling a hook).\n   *\n   * @private\n   * @param {Array} changes Array of changes in format `[[row, col, value],...]`.\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   * @returns {Array} List of changes finally applied to the dataset.\n   */\n  function processChanges(changes, source) {\n    const activeEditor = instance.getActiveEditor();\n    const beforeChangeResult = instance.runHooks('beforeChange', changes, source || 'edit');\n    // The `beforeChange` hook could add a `null` for purpose of cancelling some dataset's change.\n    const filteredChanges = changes.filter(change => change !== null);\n    if (beforeChangeResult === false || filteredChanges.length === 0) {\n      if (activeEditor) {\n        activeEditor.cancelChanges();\n      }\n      return [];\n    }\n    return filteredChanges;\n  }\n\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, col, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtCell\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, col, value],...]`.\n   * @param {number} [column] Visual column index.\n   * @param {string} [value] New value.\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   */\n  this.setDataAtCell = function (row, column, value, source) {\n    const input = setDataInputToArray(row, column, value);\n    const changes = [];\n    let changeSource = source;\n    let i;\n    let ilen;\n    let prop;\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      if (typeof input[i] !== 'object') {\n        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');\n      }\n      if (typeof input[i][1] !== 'number') {\n        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`'); // eslint-disable-line max-len\n      }\n\n      if (input[i][1] >= this.countCols()) {\n        prop = input[i][1];\n      } else {\n        prop = datamap.colToProp(input[i][1]);\n      }\n      changes.push([input[i][0], prop, dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n    if (!changeSource && typeof row === 'object') {\n      changeSource = column;\n    }\n    const processedChanges = processChanges(changes, source);\n    instance.runHooks('afterSetDataAtCell', processedChanges, changeSource);\n    validateChanges(processedChanges, changeSource, () => {\n      applyChanges(processedChanges, changeSource);\n    });\n  };\n\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, prop, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtRowProp\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {string} prop Property name or the source string (e.g. `'first.name'` or `'0'`).\n   * @param {string} value Value to be set.\n   * @param {string} [source] String that identifies how this change will be described in changes array (useful in onChange callback).\n   */\n  this.setDataAtRowProp = function (row, prop, value, source) {\n    const input = setDataInputToArray(row, prop, value);\n    const changes = [];\n    let changeSource = source;\n    let i;\n    let ilen;\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      changes.push([input[i][0], input[i][1], dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n    if (!changeSource && typeof row === 'object') {\n      changeSource = prop;\n    }\n    const processedChanges = processChanges(changes, source);\n    instance.runHooks('afterSetDataAtRowProp', processedChanges, changeSource);\n    validateChanges(processedChanges, changeSource, () => {\n      applyChanges(processedChanges, changeSource);\n    });\n  };\n\n  /**\n   * Listen to the keyboard input on document body. This allows Handsontable to capture keyboard events and respond\n   * in the right way.\n   *\n   * @memberof Core#\n   * @function listen\n   * @fires Hooks#afterListen\n   */\n  this.listen = function () {\n    if (instance && !instance.isListening()) {\n      foreignHotInstances.forEach(foreignHot => {\n        if (instance !== foreignHot) {\n          foreignHot.unlisten();\n        }\n      });\n      activeGuid = instance.guid;\n      instance.runHooks('afterListen');\n    }\n  };\n\n  /**\n   * Stop listening to keyboard input on the document body. Calling this method makes the Handsontable inactive for\n   * any keyboard events.\n   *\n   * @memberof Core#\n   * @function unlisten\n   */\n  this.unlisten = function () {\n    if (this.isListening()) {\n      activeGuid = null;\n      instance.runHooks('afterUnlisten');\n    }\n  };\n\n  /**\n   * Returns `true` if the current Handsontable instance is listening to keyboard input on document body.\n   *\n   * @memberof Core#\n   * @function isListening\n   * @returns {boolean} `true` if the instance is listening, `false` otherwise.\n   */\n  this.isListening = function () {\n    return activeGuid === instance.guid;\n  };\n\n  /**\n   * Destroys the current editor, render the table and prepares the editor of the newly selected cell.\n   *\n   * @memberof Core#\n   * @function destroyEditor\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n  this.destroyEditor = function () {\n    let revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);\n  };\n\n  /**\n   * Populates cells at position with 2D input array (e.g. `[[1, 2], [3, 4]]`). Use `endRow`, `endCol` when you\n   * want to cut input when a certain row is reached.\n   *\n   * The `populateFromArray()` method can't change [`readOnly`](@/api/options.md#readonly) cells.\n   *\n   * Optional `method` argument has the same effect as pasteMode option (see {@link Options#pasteMode}).\n   *\n   * @memberof Core#\n   * @function populateFromArray\n   * @param {number} row Start visual row index.\n   * @param {number} column Start visual column index.\n   * @param {Array} input 2d array.\n   * @param {number} [endRow] End visual row index (use when you want to cut input when certain row is reached).\n   * @param {number} [endCol] End visual column index (use when you want to cut input when certain column is reached).\n   * @param {string} [source=populateFromArray] Used to identify this call in the resulting events (beforeChange, afterChange).\n   * @param {string} [method=overwrite] Populate method, possible values: `'shift_down'`, `'shift_right'`, `'overwrite'`.\n   * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n   */\n  this.populateFromArray = function (row, column, input, endRow, endCol, source, method) {\n    if (!(typeof input === 'object' && typeof input[0] === 'object')) {\n      throw new Error('populateFromArray parameter `input` must be an array of arrays'); // API changed in 0.9-beta2, let's check if you use it correctly\n    }\n\n    const c = typeof endRow === 'number' ? instance._createCellCoords(endRow, endCol) : null;\n    return grid.populateFromArray(instance._createCellCoords(row, column), input, c, source, method);\n  };\n\n  /**\n   * Adds/removes data from the column. This method works the same as Array.splice for arrays.\n   *\n   * @memberof Core#\n   * @function spliceCol\n   * @param {number} column Index of the column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of columns.\n   */\n  this.spliceCol = function (column, index, amount) {\n    for (var _len14 = arguments.length, elements = new Array(_len14 > 3 ? _len14 - 3 : 0), _key14 = 3; _key14 < _len14; _key14++) {\n      elements[_key14 - 3] = arguments[_key14];\n    }\n    return datamap.spliceCol(column, index, amount, ...elements);\n  };\n\n  /**\n   * Adds/removes data from the row. This method works the same as Array.splice for arrays.\n   *\n   * @memberof Core#\n   * @function spliceRow\n   * @param {number} row Index of column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of rows.\n   */\n  this.spliceRow = function (row, index, amount) {\n    for (var _len15 = arguments.length, elements = new Array(_len15 > 3 ? _len15 - 3 : 0), _key15 = 3; _key15 < _len15; _key15++) {\n      elements[_key15 - 3] = arguments[_key15];\n    }\n    return datamap.spliceRow(row, index, amount, ...elements);\n  };\n\n  /**\n   * Returns indexes of the currently selected cells as an array of arrays `[[startRow, startCol, endRow, endCol],...]`.\n   *\n   * Start row and start column are the coordinates of the active cell (where the selection was started).\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedLast` method.\n   *\n   * @memberof Core#\n   * @function getSelected\n   * @returns {Array[]|undefined} An array of arrays of the selection's coordinates.\n   */\n  this.getSelected = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return arrayMap(selection.getSelectedRange(), _ref7 => {\n        let {\n          from,\n          to\n        } = _ref7;\n        return [from.row, from.col, to.row, to.col];\n      });\n    }\n  };\n\n  /**\n   * Returns the last coordinates applied to the table as a an array `[startRow, startCol, endRow, endCol]`.\n   *\n   * @since 0.36.0\n   * @memberof Core#\n   * @function getSelectedLast\n   * @returns {Array|undefined} An array of the selection's coordinates.\n   */\n  this.getSelectedLast = function () {\n    const selected = this.getSelected();\n    let result;\n    if (selected && selected.length > 0) {\n      result = selected[selected.length - 1];\n    }\n    return result;\n  };\n\n  /**\n   * Returns the current selection as an array of CellRange objects.\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedRangeLast` method.\n   *\n   * @memberof Core#\n   * @function getSelectedRange\n   * @returns {CellRange[]|undefined} Selected range object or undefined if there is no selection.\n   */\n  this.getSelectedRange = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return Array.from(selection.getSelectedRange());\n    }\n  };\n\n  /**\n   * Returns the last coordinates applied to the table as a CellRange object.\n   *\n   * @memberof Core#\n   * @function getSelectedRangeLast\n   * @since 0.36.0\n   * @returns {CellRange|undefined} Selected range object or undefined` if there is no selection.\n   */\n  this.getSelectedRangeLast = function () {\n    const selectedRange = this.getSelectedRange();\n    let result;\n    if (selectedRange && selectedRange.length > 0) {\n      result = selectedRange[selectedRange.length - 1];\n    }\n    return result;\n  };\n\n  /**\n   * Erases content from cells that have been selected in the table.\n   *\n   * @memberof Core#\n   * @function emptySelectedCells\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   * @since 0.36.0\n   */\n  this.emptySelectedCells = function (source) {\n    if (!selection.isSelected() || this.countRows() === 0 || this.countCols() === 0) {\n      return;\n    }\n    const changes = [];\n    arrayEach(selection.getSelectedRange(), cellRange => {\n      if (cellRange.isSingleHeader()) {\n        return;\n      }\n      const topStart = cellRange.getTopStartCorner();\n      const bottomEnd = cellRange.getBottomEndCorner();\n      rangeEach(topStart.row, bottomEnd.row, row => {\n        rangeEach(topStart.col, bottomEnd.col, column => {\n          if (!this.getCellMeta(row, column).readOnly) {\n            changes.push([row, column, null]);\n          }\n        });\n      });\n    });\n    if (changes.length > 0) {\n      this.setDataAtCell(changes, source);\n    }\n  };\n\n  /**\n   * Checks if the table rendering process was suspended. See explanation in {@link Core#suspendRender}.\n   *\n   * @memberof Core#\n   * @function isRenderSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n  this.isRenderSuspended = function () {\n    return this.renderSuspendedCounter > 0;\n  };\n\n  /**\n   * Suspends the rendering process. It's helpful to wrap the table render\n   * cycles triggered by API calls or UI actions (or both) and call the \"render\"\n   * once in the end. As a result, it improves the performance of wrapped operations.\n   * When the table is in the suspend state, most operations will have no visual\n   * effect until the rendering state is resumed. Resuming the state automatically\n   * invokes the table rendering. To make sure that after executing all operations,\n   * the table will be rendered, it's highly recommended to use the {@link Core#batchRender}\n   * method or {@link Core#batch}, which additionally aggregates the logic execution\n   * that happens behind the table.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * Every [`suspendRender()`](@/api/core.md#suspendrender) call needs to correspond with one [`resumeRender()`](@/api/core.md#resumerender) call.\n   * For example, if you call [`suspendRender()`](@/api/core.md#suspendrender) 5 times, you need to call [`resumeRender()`](@/api/core.md#resumerender) 5 times as well.\n   *\n   * @memberof Core#\n   * @function suspendRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row_above', 5, 45);\n   * hot.alter('insert_col_start', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n  this.suspendRender = function () {\n    this.renderSuspendedCounter += 1;\n  };\n\n  /**\n   * Resumes the rendering process. In combination with the {@link Core#suspendRender}\n   * method it allows aggregating the table render cycles triggered by API calls or UI\n   * actions (or both) and calls the \"render\" once in the end. When the table is in\n   * the suspend state, most operations will have no visual effect until the rendering\n   * state is resumed. Resuming the state automatically invokes the table rendering.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * Every [`suspendRender()`](@/api/core.md#suspendrender) call needs to correspond with one [`resumeRender()`](@/api/core.md#resumerender) call.\n   * For example, if you call [`suspendRender()`](@/api/core.md#suspendrender) 5 times, you need to call [`resumeRender()`](@/api/core.md#resumerender) 5 times as well.\n   *\n   * @memberof Core#\n   * @function resumeRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row_above', 5, 45);\n   * hot.alter('insert_col_start', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n  this.resumeRender = function () {\n    const nextValue = this.renderSuspendedCounter - 1;\n    this.renderSuspendedCounter = Math.max(nextValue, 0);\n    if (!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {\n      if (this.renderCall) {\n        this.render();\n      } else {\n        this._refreshBorders(null);\n      }\n    }\n  };\n\n  /**\n   * Rerender the table. Calling this method starts the process of recalculating, redrawing and applying the changes\n   * to the DOM. While rendering the table all cell renderers are recalled.\n   *\n   * Calling this method manually is not recommended. Handsontable tries to render itself by choosing the most\n   * optimal moments in its lifecycle.\n   *\n   * @memberof Core#\n   * @function render\n   */\n  this.render = function () {\n    if (this.view) {\n      this.renderCall = true;\n      this.forceFullRender = true; // used when data was changed\n\n      if (!this.isRenderSuspended()) {\n        editorManager.lockEditor();\n        this._refreshBorders(null);\n        editorManager.unlockEditor();\n      }\n    }\n  };\n\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table rendering process. After the execution of the operations, the table is\n   * rendered once. As a result, it improves the performance of wrapped operations.\n   * Without batching, a similar case could trigger multiple table render calls.\n   *\n   * @memberof Core#\n   * @function batchRender\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchRender(() => {\n   *   hot.alter('insert_row_above', 5, 45);\n   *   hot.alter('insert_col_start', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'John');\n   *   hot.setDataAtCell(2, 2, 'Mark');\n   *   hot.setDataAtCell(3, 3, 'Ann');\n   *   hot.setDataAtCell(4, 4, 'Sophia');\n   *   hot.setDataAtCell(5, 5, 'Mia');\n   *   hot.selectCell(0, 0);\n   *   // The table will be rendered once after executing the callback\n   * });\n   * ```\n   */\n  this.batchRender = function (wrappedOperations) {\n    this.suspendRender();\n    const result = wrappedOperations();\n    this.resumeRender();\n    return result;\n  };\n\n  /**\n   * Checks if the table indexes recalculation process was suspended. See explanation\n   * in {@link Core#suspendExecution}.\n   *\n   * @memberof Core#\n   * @function isExecutionSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n  this.isExecutionSuspended = function () {\n    return this.executionSuspendedCounter > 0;\n  };\n\n  /**\n   * Suspends the execution process. It's helpful to wrap the table logic changes\n   * such as index changes into one call after which the cache is updated. As a result,\n   * it improves the performance of wrapped operations.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function suspendExecution\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n  this.suspendExecution = function () {\n    this.executionSuspendedCounter += 1;\n    this.columnIndexMapper.suspendOperations();\n    this.rowIndexMapper.suspendOperations();\n  };\n\n  /**\n   * Resumes the execution process. In combination with the {@link Core#suspendExecution}\n   * method it allows aggregating the table logic changes after which the cache is\n   * updated. Resuming the state automatically invokes the table cache updating process.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function resumeExecution\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested\n   * {@link Core#batchExecution} calls, it can be desire to recalculate the table\n   * after each batch.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n  this.resumeExecution = function () {\n    let forceFlushChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const nextValue = this.executionSuspendedCounter - 1;\n    this.executionSuspendedCounter = Math.max(nextValue, 0);\n    if (!this.isExecutionSuspended() && nextValue === this.executionSuspendedCounter || forceFlushChanges) {\n      this.columnIndexMapper.resumeOperations();\n      this.rowIndexMapper.resumeOperations();\n    }\n  };\n\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table execution process. After the execution of the operations, the internal table\n   * cache is recalculated once. As a result, it improves the performance of wrapped\n   * operations. Without batching, a similar case could trigger multiple table cache rebuilds.\n   *\n   * @memberof Core#\n   * @function batchExecution\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested calls,\n   * it can be a desire to recalculate the table after each batch.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchExecution(() => {\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n  this.batchExecution = function (wrappedOperations) {\n    let forceFlushChanges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.suspendExecution();\n    const result = wrappedOperations();\n    this.resumeExecution(forceFlushChanges);\n    return result;\n  };\n\n  /**\n   * It batches the rendering process and index recalculations. The method aggregates\n   * multi-line API calls into a callback and postpones the table rendering process\n   * as well aggregates the table logic changes such as index changes into one call\n   * after which the cache is updated. After the execution of the operations, the\n   * table is rendered, and the cache is updated once. As a result, it improves the\n   * performance of wrapped operations.\n   *\n   * @memberof Core#\n   * @function batch\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batch(() => {\n   *   hot.alter('insert_row_above', 5, 45);\n   *   hot.alter('insert_col_start', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'x');\n   *   hot.setDataAtCell(2, 2, 'c');\n   *   hot.setDataAtCell(3, 3, 'v');\n   *   hot.setDataAtCell(4, 4, 'b');\n   *   hot.setDataAtCell(5, 5, 'n');\n   *   hot.selectCell(0, 0);\n   *\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table will be re-rendered and cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n  this.batch = function (wrappedOperations) {\n    this.suspendRender();\n    this.suspendExecution();\n    const result = wrappedOperations();\n    this.resumeExecution();\n    this.resumeRender();\n    return result;\n  };\n\n  /**\n   * Updates dimensions of the table. The method compares previous dimensions with the current ones and updates accordingly.\n   *\n   * @memberof Core#\n   * @function refreshDimensions\n   * @fires Hooks#beforeRefreshDimensions\n   * @fires Hooks#afterRefreshDimensions\n   */\n  this.refreshDimensions = function () {\n    if (!instance.view) {\n      return;\n    }\n    const {\n      width: lastWidth,\n      height: lastHeight\n    } = instance.view.getLastSize();\n    const {\n      width,\n      height\n    } = instance.rootElement.getBoundingClientRect();\n    const isSizeChanged = width !== lastWidth || height !== lastHeight;\n    const isResizeBlocked = instance.runHooks('beforeRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width,\n      height\n    }, isSizeChanged) === false;\n    if (isResizeBlocked) {\n      return;\n    }\n    if (isSizeChanged || instance.view._wt.wtOverlays.scrollableElement === instance.rootWindow) {\n      instance.view.setLastSize(width, height);\n      instance.render();\n    }\n    instance.runHooks('afterRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width,\n      height\n    }, isSizeChanged);\n  };\n\n  /**\n   * The `updateData()` method replaces Handsontable's [`data`](@/api/options.md#data) with a new dataset.\n   *\n   * The `updateData()` method:\n   * - Keeps cells' states (e.g. cells' [formatting](@/guides/cell-features/formatting-cells.md) and cells' [`readOnly`](@/api/options.md#readonly) states)\n   * - Keeps rows' states (e.g. row order)\n   * - Keeps columns' states (e.g. column order)\n   *\n   * To replace Handsontable's [`data`](@/api/options.md#data) and reset states, use the [`loadData()`](#loaddata) method.\n   *\n   * Read more:\n   * - [Binding to data](@/guides/getting-started/binding-to-data.md)\n   * - [Saving data](@/guides/getting-started/saving-data.md)\n   *\n   * @memberof Core#\n   * @function updateData\n   * @since 11.1.0\n   * @param {Array} data An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data\n   * @param {string} [source] The source of the `updateData()` call\n   * @fires Hooks#beforeUpdateData\n   * @fires Hooks#afterUpdateData\n   * @fires Hooks#afterChange\n   */\n  this.updateData = function (data, source) {\n    replaceData(data, newDataMap => {\n      datamap = newDataMap;\n    }, newDataMap => {\n      datamap = newDataMap;\n      instance.columnIndexMapper.fitToLength(this.getInitialColumnCount());\n      instance.rowIndexMapper.fitToLength(this.countSourceRows());\n      grid.adjustRowsAndCols();\n    }, {\n      hotInstance: instance,\n      dataMap: datamap,\n      dataSource,\n      internalSource: 'updateData',\n      source,\n      metaManager,\n      firstRun\n    });\n  };\n\n  /**\n   * The `loadData()` method replaces Handsontable's [`data`](@/api/options.md#data) with a new dataset.\n   *\n   * Additionally, the `loadData()` method:\n   * - Resets cells' states (e.g. cells' [formatting](@/guides/cell-features/formatting-cells.md) and cells' [`readOnly`](@/api/options.md#readonly) states)\n   * - Resets rows' states (e.g. row order)\n   * - Resets columns' states (e.g. column order)\n   *\n   * To replace Handsontable's [`data`](@/api/options.md#data) without resetting states, use the [`updateData()`](#updatedata) method.\n   *\n   * Read more:\n   * - [Binding to data](@/guides/getting-started/binding-to-data.md)\n   * - [Saving data](@/guides/getting-started/saving-data.md)\n   *\n   * @memberof Core#\n   * @function loadData\n   * @param {Array} data An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data\n   * @param {string} [source] The source of the `loadData()` call\n   * @fires Hooks#beforeLoadData\n   * @fires Hooks#afterLoadData\n   * @fires Hooks#afterChange\n   */\n  this.loadData = function (data, source) {\n    replaceData(data, newDataMap => {\n      datamap = newDataMap;\n    }, () => {\n      metaManager.clearCellsCache();\n      instance.initIndexMappers();\n      grid.adjustRowsAndCols();\n      if (firstRun) {\n        firstRun = [null, 'loadData'];\n      }\n    }, {\n      hotInstance: instance,\n      dataMap: datamap,\n      dataSource,\n      internalSource: 'loadData',\n      source,\n      metaManager,\n      firstRun\n    });\n  };\n\n  /**\n   * Gets the initial column count, calculated based on the `columns` setting.\n   *\n   * @private\n   * @returns {number} The calculated number of columns.\n   */\n  this.getInitialColumnCount = function () {\n    const columnsSettings = tableMeta.columns;\n    let finalNrOfColumns = 0;\n\n    // We will check number of columns when the `columns` property was defined as an array. Columns option may\n    // narrow down or expand displayed dataset in that case.\n    if (Array.isArray(columnsSettings)) {\n      finalNrOfColumns = columnsSettings.length;\n    } else if (isFunction(columnsSettings)) {\n      if (instance.dataType === 'array') {\n        const nrOfSourceColumns = this.countSourceCols();\n        for (let columnIndex = 0; columnIndex < nrOfSourceColumns; columnIndex += 1) {\n          if (columnsSettings(columnIndex)) {\n            finalNrOfColumns += 1;\n          }\n        }\n\n        // Extended dataset by the `columns` property? Moved code right from the refactored `countCols` method.\n      } else if (instance.dataType === 'object' || instance.dataType === 'function') {\n        finalNrOfColumns = datamap.colToPropCache.length;\n      }\n\n      // In some cases we need to check columns length from the schema, i.e. `data` may be empty.\n    } else if (isDefined(tableMeta.dataSchema)) {\n      const schema = datamap.getSchema();\n\n      // Schema may be defined as an array of objects. Each object will define column.\n      finalNrOfColumns = Array.isArray(schema) ? schema.length : deepObjectSize(schema);\n    } else {\n      // We init index mappers by length of source data to provide indexes also for skipped indexes.\n      finalNrOfColumns = this.countSourceCols();\n    }\n    return finalNrOfColumns;\n  };\n\n  /**\n   * Init index mapper which manage indexes assigned to the data.\n   *\n   * @private\n   */\n  this.initIndexMappers = function () {\n    this.columnIndexMapper.initToLength(this.getInitialColumnCount());\n    this.rowIndexMapper.initToLength(this.countSourceRows());\n  };\n\n  /**\n   * Returns the current data object (the same one that was passed by `data` configuration option or `loadData` method,\n   * unless some modifications have been applied (i.e. Sequence of rows/columns was changed, some row/column was skipped).\n   * If that's the case - use the {@link Core#getSourceData} method.).\n   *\n   * Optionally you can provide cell range by defining `row`, `column`, `row2`, `column2` to get only a fragment of table data.\n   *\n   * @memberof Core#\n   * @function getData\n   * @param {number} [row] From visual row index.\n   * @param {number} [column] From visual column index.\n   * @param {number} [row2] To visual row index.\n   * @param {number} [column2] To visual column index.\n   * @returns {Array[]} Array with the data.\n   * @example\n   * ```js\n   * // Get all data (in order how it is rendered in the table).\n   * hot.getData();\n   * // Get data fragment (from top-left 0, 0 to bottom-right 3, 3).\n   * hot.getData(3, 3);\n   * // Get data fragment (from top-left 2, 1 to bottom-right 3, 3).\n   * hot.getData(2, 1, 3, 3);\n   * ```\n   */\n  this.getData = function (row, column, row2, column2) {\n    if (isUndefined(row)) {\n      return datamap.getAll();\n    }\n    return datamap.getRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2), datamap.DESTINATION_RENDERER);\n  };\n\n  /**\n   * Returns a string value of the selected range. Each column is separated by tab, each row is separated by a new\n   * line character.\n   *\n   * @memberof Core#\n   * @function getCopyableText\n   * @param {number} startRow From visual row index.\n   * @param {number} startCol From visual column index.\n   * @param {number} endRow To visual row index.\n   * @param {number} endCol To visual column index.\n   * @returns {string}\n   */\n  this.getCopyableText = function (startRow, startCol, endRow, endCol) {\n    return datamap.getCopyableText(instance._createCellCoords(startRow, startCol), instance._createCellCoords(endRow, endCol));\n  };\n\n  /**\n   * Returns the data's copyable value at specified `row` and `column` index.\n   *\n   * @memberof Core#\n   * @function getCopyableData\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {string}\n   */\n  this.getCopyableData = function (row, column) {\n    return datamap.getCopyable(row, datamap.colToProp(column));\n  };\n\n  /**\n   * Returns schema provided by constructor settings. If it doesn't exist then it returns the schema based on the data\n   * structure in the first row.\n   *\n   * @memberof Core#\n   * @function getSchema\n   * @returns {object} Schema object.\n   */\n  this.getSchema = function () {\n    return datamap.getSchema();\n  };\n\n  /**\n   * Use it if you need to change configuration after initialization. The `settings` argument is an object containing the changed\n   * settings, declared the same way as in the initial settings object.\n   *\n   * __Note__, that although the `updateSettings` method doesn't overwrite the previously declared settings, it might reset\n   * the settings made post-initialization. (for example - ignore changes made using the columnResize feature).\n   *\n   * Since 8.0.0 passing `columns` or `data` inside `settings` objects will result in resetting states corresponding to rows and columns\n   * (for example, row/column sequence, column width, row height, frozen columns etc.).\n   *\n   * Since 12.0.0 passing `data` inside `settings` objects no longer results in resetting states corresponding to rows and columns\n   * (for example, row/column sequence, column width, row height, frozen columns etc.).\n   *\n   * @memberof Core#\n   * @function updateSettings\n   * @param {object} settings A settings object (see {@link Options}). Only provide the settings that are changed, not the whole settings object that was used for initialization.\n   * @param {boolean} [init=false] Internally used for in initialization mode.\n   * @example\n   * ```js\n   * hot.updateSettings({\n   *    contextMenu: true,\n   *    colHeaders: true,\n   *    fixedRowsTop: 2\n   * });\n   * ```\n   * @fires Hooks#afterCellMetaReset\n   * @fires Hooks#afterUpdateSettings\n   */\n  this.updateSettings = function (settings) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const dataUpdateFunction = (firstRun ? instance.loadData : instance.updateData).bind(this);\n    let columnsAsFunc = false;\n    let i;\n    let j;\n    if (isDefined(settings.rows)) {\n      throw new Error('The \"rows\" setting is no longer supported. Do you mean startRows, minRows or maxRows?');\n    }\n    if (isDefined(settings.cols)) {\n      throw new Error('The \"cols\" setting is no longer supported. Do you mean startCols, minCols or maxCols?');\n    }\n    if (isDefined(settings.ganttChart)) {\n      throw new Error('Since 8.0.0 the \"ganttChart\" setting is no longer supported.');\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (i in settings) {\n      if (i === 'data') {\n        // Do nothing. loadData will be triggered later\n      } else if (i === 'language') {\n        setLanguage(settings.language);\n      } else if (i === 'className') {\n        setClassName('className', settings.className);\n      } else if (i === 'tableClassName' && instance.table) {\n        setClassName('tableClassName', settings.tableClassName);\n        instance.view._wt.wtOverlays.syncOverlayTableClassNames();\n      } else if (Hooks.getSingleton().isRegistered(i) || Hooks.getSingleton().isDeprecated(i)) {\n        if (isFunction(settings[i]) || Array.isArray(settings[i])) {\n          settings[i].initialHook = true;\n          instance.addHook(i, settings[i]);\n        }\n      } else if (!init && hasOwnProperty(settings, i)) {\n        // Update settings\n        globalMeta[i] = settings[i];\n      }\n    }\n\n    // Load data or create data map\n    if (settings.data === undefined && tableMeta.data === undefined) {\n      dataUpdateFunction(null, 'updateSettings'); // data source created just now\n    } else if (settings.data !== undefined) {\n      dataUpdateFunction(settings.data, 'updateSettings'); // data source given as option\n    } else if (settings.columns !== undefined) {\n      datamap.createMap();\n\n      // The `column` property has changed - dataset may be expanded or narrowed down. The `loadData` do the same.\n      instance.initIndexMappers();\n    }\n    const clen = instance.countCols();\n    const columnSetting = tableMeta.columns;\n\n    // Init columns constructors configuration\n    if (columnSetting && isFunction(columnSetting)) {\n      columnsAsFunc = true;\n    }\n\n    // Clear cell meta cache\n    if (settings.cell !== undefined || settings.cells !== undefined || settings.columns !== undefined) {\n      metaManager.clearCache();\n    }\n    if (clen > 0) {\n      for (i = 0, j = 0; i < clen; i++) {\n        // Use settings provided by user\n        if (columnSetting) {\n          const column = columnsAsFunc ? columnSetting(i) : columnSetting[j];\n          if (column) {\n            metaManager.updateColumnMeta(j, column);\n          }\n        }\n        j += 1;\n      }\n    }\n    if (isDefined(settings.cell)) {\n      objectEach(settings.cell, cell => {\n        instance.setCellMetaObject(cell.row, cell.col, cell);\n      });\n    }\n    instance.runHooks('afterCellMetaReset');\n    let currentHeight = instance.rootElement.style.height;\n    if (currentHeight !== '') {\n      currentHeight = parseInt(instance.rootElement.style.height, 10);\n    }\n    let height = settings.height;\n    if (isFunction(height)) {\n      height = height();\n    }\n    if (init) {\n      const initialStyle = instance.rootElement.getAttribute('style');\n      if (initialStyle) {\n        instance.rootElement.setAttribute('data-initialstyle', instance.rootElement.getAttribute('style'));\n      }\n    }\n    if (height === null) {\n      const initialStyle = instance.rootElement.getAttribute('data-initialstyle');\n      if (initialStyle && (initialStyle.indexOf('height') > -1 || initialStyle.indexOf('overflow') > -1)) {\n        instance.rootElement.setAttribute('style', initialStyle);\n      } else {\n        instance.rootElement.style.height = '';\n        instance.rootElement.style.overflow = '';\n      }\n    } else if (height !== undefined) {\n      instance.rootElement.style.height = isNaN(height) ? `${height}` : `${height}px`;\n      instance.rootElement.style.overflow = 'hidden';\n    }\n    if (typeof settings.width !== 'undefined') {\n      let width = settings.width;\n      if (isFunction(width)) {\n        width = width();\n      }\n      instance.rootElement.style.width = isNaN(width) ? `${width}` : `${width}px`;\n    }\n    if (!init) {\n      if (instance.view) {\n        instance.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();\n        instance.view._wt.exportSettingsAsClassNames();\n      }\n      instance.runHooks('afterUpdateSettings', settings);\n    }\n    grid.adjustRowsAndCols();\n    if (instance.view && !firstRun) {\n      instance.forceFullRender = true; // used when data was changed\n      editorManager.lockEditor();\n      instance._refreshBorders(null);\n      instance.view._wt.wtOverlays.adjustElementsSize();\n      editorManager.unlockEditor();\n    }\n    if (!init && instance.view && (currentHeight === '' || height === '' || height === undefined) && currentHeight !== height) {\n      instance.view._wt.wtOverlays.updateMainScrollableElements();\n    }\n  };\n\n  /**\n   * Gets the value of the currently focused cell.\n   *\n   * For column headers and row headers, returns `null`.\n   *\n   * @memberof Core#\n   * @function getValue\n   * @returns {*} The value of the focused cell.\n   */\n  this.getValue = function () {\n    const sel = instance.getSelectedLast();\n    if (tableMeta.getValue) {\n      if (isFunction(tableMeta.getValue)) {\n        return tableMeta.getValue.call(instance);\n      } else if (sel) {\n        return instance.getData()[sel[0][0]][tableMeta.getValue];\n      }\n    } else if (sel) {\n      return instance.getDataAtCell(sel[0], sel[1]);\n    }\n  };\n\n  /**\n   * Returns the object settings.\n   *\n   * @memberof Core#\n   * @function getSettings\n   * @returns {TableMeta} Object containing the current table settings.\n   */\n  this.getSettings = function () {\n    return tableMeta;\n  };\n\n  /**\n   * Clears the data from the table (the table settings remain intact).\n   *\n   * @memberof Core#\n   * @function clear\n   */\n  this.clear = function () {\n    this.selectAll();\n    this.emptySelectedCells();\n  };\n\n  /**\n   * The `alter()` method lets you alter the grid's structure\n   * by adding or removing rows and columns at specified positions.\n   *\n   * ::: tip\n   * The `alter()` method works only when your [`data`](@/api/options.md#data)\n   * is an [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).\n   * :::\n   *\n   * ```js\n   * // above row 10 (by visual index), insert 1 new row\n   * hot.alter('insert_row_above', 10);\n   * ```\n   *\n   *  | Action               | With `index` | Without `index` |\n   *  | -------------------- | ------------ | --------------- |\n   *  | `'insert_row_above'` | Inserts rows above the `index` row. | Inserts rows above the first row. |\n   *  | `'insert_row_below'` | Inserts rows below the `index` row. | Inserts rows below the last row. |\n   *  | `'remove_row'`       | Removes rows, starting from the `index` row. | Removes rows, starting from the last row. |\n   *  | `'insert_col_start'` | Inserts columns before the `index` column. | Inserts columns before the first column. |\n   *  | `'insert_col_end'`   | Inserts columns after the `index` column. | Inserts columns after the last column. |\n   *  | `'remove_col'`       | Removes columns, starting from the `index` column. | Removes columns, starting from the last column. |\n   *\n   * Additional information about `'insert_col_start'` and `'insert_col_end'`:\n   * - Their behavior depends on your [`layoutDirection`](@/api/options.md#layoutdirection).\n   * - If the provided `index` is higher than the actual number of columns, Handsontable doesn't generate\n   * the columns missing in between. Instead, the new columns are inserted next to the last column.\n   *\n   * @memberof Core#\n   * @function alter\n   * @param {string} action Available operations:\n   * <ul>\n   *    <li> `'insert_row_above'` </li>\n   *    <li> `'insert_row_below'` </li>\n   *    <li> `'remove_row'` </li> </li>\n   *    <li> `'insert_col_start'` </li>\n   *    <li> `'insert_col_end'` </li>\n   *    <li> `'remove_col'` </li>\n   * </ul>\n   * @param {number|number[]} [index] A visual index of the row/column before or after which the new row/column will be\n   *                                inserted or removed. Can also be an array of arrays, in format `[[index, amount],...]`.\n   * @param {number} [amount] The amount of rows or columns to be inserted or removed (default: `1`).\n   * @param {string} [source] Source indicator.\n   * @param {boolean} [keepEmptyRows] If set to `true`: prevents removing empty rows.\n   * @example\n   * ```js\n   * // above row 10 (by visual index), insert 1 new row\n   * hot.alter('insert_row_above', 10);\n   *\n   * // below row 10 (by visual index), insert 3 new rows\n   * hot.alter('insert_row_below', 10, 3);\n   *\n   * // in the LTR layout direction: to the left of column 10 (by visual index), insert 3 new columns\n   * // in the RTL layout direction: to the right of column 10 (by visual index), insert 3 new columns\n   * hot.alter('insert_col_start', 10, 3);\n   *\n   * // in the LTR layout direction: to the right of column 10 (by visual index), insert 1 new column\n   * // in the RTL layout direction: to the left of column 10 (by visual index), insert 1 new column\n   * hot.alter('insert_col_end', 10);\n   *\n   * // remove 2 rows, starting from row 10 (by visual index)\n   * hot.alter('remove_row', 10, 2);\n   *\n   * // remove 3 rows, starting from row 1 (by visual index)\n   * // remove 2 rows, starting from row 5 (by visual index)\n   * hot.alter('remove_row', [[1, 3], [5, 2]]);\n   * ```\n   */\n  this.alter = function (action, index, amount, source, keepEmptyRows) {\n    grid.alter(action, index, amount, source, keepEmptyRows);\n  };\n\n  /**\n   * Returns a TD element for the given `row` and `column` arguments, if it is rendered on screen.\n   * Returns `null` if the TD is not rendered on screen (probably because that part of the table is not visible).\n   *\n   * @memberof Core#\n   * @function getCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   * if the wanted cell is in the range of fixed rows, it will return a TD element from the `top` overlay.\n   * @returns {HTMLTableCellElement|null} The cell's TD element.\n   */\n  this.getCell = function (row, column) {\n    let topmost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let renderableColumnIndex = column; // Handling also column headers.\n    let renderableRowIndex = row; // Handling also row headers.\n\n    if (column >= 0) {\n      if (this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {\n        return null;\n      }\n      renderableColumnIndex = this.columnIndexMapper.getRenderableFromVisualIndex(column);\n    }\n    if (row >= 0) {\n      if (this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {\n        return null;\n      }\n      renderableRowIndex = this.rowIndexMapper.getRenderableFromVisualIndex(row);\n    }\n    if (renderableRowIndex === null || renderableColumnIndex === null) {\n      return null;\n    }\n    return instance.view.getCellAtCoords(instance._createCellCoords(renderableRowIndex, renderableColumnIndex), topmost);\n  };\n\n  /**\n   * Returns the coordinates of the cell, provided as a HTML table cell element.\n   *\n   * @memberof Core#\n   * @function getCoords\n   * @param {HTMLTableCellElement} element The HTML Element representing the cell.\n   * @returns {CellCoords|null} Visual coordinates object.\n   * @example\n   * ```js\n   * hot.getCoords(hot.getCell(1, 1));\n   * // it returns CellCoords object instance with props row: 1 and col: 1.\n   * ```\n   */\n  this.getCoords = function (element) {\n    const renderableCoords = this.view._wt.wtTable.getCoords(element);\n    if (renderableCoords === null) {\n      return null;\n    }\n    const {\n      row: renderableRow,\n      col: renderableColumn\n    } = renderableCoords;\n    let visualRow = renderableRow;\n    let visualColumn = renderableColumn;\n    if (renderableRow >= 0) {\n      visualRow = this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);\n    }\n    if (renderableColumn >= 0) {\n      visualColumn = this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);\n    }\n    return instance._createCellCoords(visualRow, visualColumn);\n  };\n\n  /**\n   * Returns the property name that corresponds with the given column index.\n   * If the data source is an array of arrays, it returns the columns index.\n   *\n   * @memberof Core#\n   * @function colToProp\n   * @param {number} column Visual column index.\n   * @returns {string|number} Column property or physical column index.\n   */\n  this.colToProp = function (column) {\n    return datamap.colToProp(column);\n  };\n\n  /**\n   * Returns column index that corresponds with the given property.\n   *\n   * @memberof Core#\n   * @function propToCol\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {number} Visual column index.\n   */\n  this.propToCol = function (prop) {\n    return datamap.propToCol(prop);\n  };\n\n  /**\n   * Translate physical row index into visual.\n   *\n   * This method is useful when you want to retrieve visual row index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualRow\n   * @param {number} row Physical row index.\n   * @returns {number} Returns visual row index.\n   */\n  this.toVisualRow = row => this.rowIndexMapper.getVisualFromPhysicalIndex(row);\n\n  /**\n   * Translate physical column index into visual.\n   *\n   * This method is useful when you want to retrieve visual column index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualColumn\n   * @param {number} column Physical column index.\n   * @returns {number} Returns visual column index.\n   */\n  this.toVisualColumn = column => this.columnIndexMapper.getVisualFromPhysicalIndex(column);\n\n  /**\n   * Translate visual row index into physical.\n   *\n   * This method is useful when you want to retrieve physical row index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalRow\n   * @param {number} row Visual row index.\n   * @returns {number} Returns physical row index.\n   */\n  this.toPhysicalRow = row => this.rowIndexMapper.getPhysicalFromVisualIndex(row);\n\n  /**\n   * Translate visual column index into physical.\n   *\n   * This method is useful when you want to retrieve physical column index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalColumn\n   * @param {number} column Visual column index.\n   * @returns {number} Returns physical column index.\n   */\n  this.toPhysicalColumn = column => this.columnIndexMapper.getPhysicalFromVisualIndex(column);\n\n  /**\n   * @description\n   * Returns the cell value at `row`, `column`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Data at cell.\n   */\n  this.getDataAtCell = function (row, column) {\n    return datamap.get(row, datamap.colToProp(column));\n  };\n\n  /**\n   * Returns value at visual `row` and `prop` indexes.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRowProp\n   * @param {number} row Visual row index.\n   * @param {string} prop Property name.\n   * @returns {*} Cell value.\n   */\n  this.getDataAtRowProp = function (row, prop) {\n    return datamap.get(row, prop);\n  };\n\n  /**\n   * @description\n   * Returns array of column values from the data source.\n   *\n   * __Note__: If columns were reordered or sorted, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of cell values.\n   */\n  this.getDataAtCol = function (column) {\n    const columnData = [];\n    const dataByRows = datamap.getRange(instance._createCellCoords(0, column), instance._createCellCoords(tableMeta.data.length - 1, column), datamap.DESTINATION_RENDERER);\n    for (let i = 0; i < dataByRows.length; i += 1) {\n      for (let j = 0; j < dataByRows[i].length; j += 1) {\n        columnData.push(dataByRows[i][j]);\n      }\n    }\n    return columnData;\n  };\n\n  /**\n   * Given the object property name (e.g. `'first.name'` or `'0'`), returns an array of column's values from the table data.\n   * You can also provide a column index as the first argument.\n   *\n   * @memberof Core#\n   * @function getDataAtProp\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {Array} Array of cell values.\n   */\n  // TODO: Getting data from `datamap` should work on visual indexes.\n  this.getDataAtProp = function (prop) {\n    const columnData = [];\n    const dataByRows = datamap.getRange(instance._createCellCoords(0, datamap.propToCol(prop)), instance._createCellCoords(tableMeta.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);\n    for (let i = 0; i < dataByRows.length; i += 1) {\n      for (let j = 0; j < dataByRows[i].length; j += 1) {\n        columnData.push(dataByRows[i][j]);\n      }\n    }\n    return columnData;\n  };\n\n  /**\n   * Returns a clone of the source data object.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * __Note__: This method may return incorrect values for cells that contain\n   * [formulas](@/guides/formulas/formula-calculation.md). This is because `getSourceData()`\n   * operates on source data ([physical indexes](@/api/indexMapper.md)),\n   * whereas formulas operate on visual data (visual indexes).\n   *\n   * @memberof Core#\n   * @function getSourceData\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array[]|object[]} The table data.\n   */\n  this.getSourceData = function (row, column, row2, column2) {\n    let data;\n    if (row === undefined) {\n      data = dataSource.getData();\n    } else {\n      data = dataSource.getByRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2));\n    }\n    return data;\n  };\n\n  /**\n   * Returns the source data object as an arrays of arrays format even when source data was provided in another format.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataArray\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array} An array of arrays.\n   */\n  this.getSourceDataArray = function (row, column, row2, column2) {\n    let data;\n    if (row === undefined) {\n      data = dataSource.getData(true);\n    } else {\n      data = dataSource.getByRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2), true);\n    }\n    return data;\n  };\n\n  /**\n   * Returns an array of column values from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of the column's cell values.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n  this.getSourceDataAtCol = function (column) {\n    return dataSource.getAtColumn(column);\n  };\n\n  /* eslint-disable jsdoc/require-param */\n  /**\n   * Set the provided value in the source data set at the provided coordinates.\n   *\n   * @memberof Core#\n   * @function setSourceDataAtCell\n   * @param {number|Array} row Physical row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {number|string} column Physical column index / prop name.\n   * @param {*} value The value to be set at the provided coordinates.\n   * @param {string} [source] Source of the change as a string.\n   */\n  /* eslint-enable jsdoc/require-param */\n  this.setSourceDataAtCell = function (row, column, value, source) {\n    const input = setDataInputToArray(row, column, value);\n    const isThereAnySetSourceListener = this.hasHook('afterSetSourceDataAtCell');\n    const changesForHook = [];\n    if (isThereAnySetSourceListener) {\n      arrayEach(input, _ref8 => {\n        let [changeRow, changeProp, changeValue] = _ref8;\n        changesForHook.push([changeRow, changeProp, dataSource.getAtCell(changeRow, changeProp),\n        // The previous value.\n        changeValue]);\n      });\n    }\n    arrayEach(input, _ref9 => {\n      let [changeRow, changeProp, changeValue] = _ref9;\n      dataSource.setAtCell(changeRow, changeProp, changeValue);\n    });\n    if (isThereAnySetSourceListener) {\n      this.runHooks('afterSetSourceDataAtCell', changesForHook, source);\n    }\n    this.render();\n    const activeEditor = instance.getActiveEditor();\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  };\n\n  /**\n   * Returns a single row of the data (array or object, depending on what data format you use).\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array|object} Single row of data.\n   */\n  this.getSourceDataAtRow = function (row) {\n    return dataSource.getAtRow(row);\n  };\n\n  /**\n   * Returns a single value from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCell\n   * @param {number} row Physical row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Cell data.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n  this.getSourceDataAtCell = function (row, column) {\n    return dataSource.getAtCell(row, column);\n  };\n\n  /**\n   * @description\n   * Returns a single row of the data.\n   *\n   * __Note__: If rows were reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRow\n   * @param {number} row Visual row index.\n   * @returns {Array} Array of row's cell data.\n   */\n  this.getDataAtRow = function (row) {\n    const data = datamap.getRange(instance._createCellCoords(row, 0), instance._createCellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);\n    return data[0] || [];\n  };\n\n  /**\n   * @description\n   * Returns a data type defined in the Handsontable settings under the `type` key ({@link Options#type}).\n   * If there are cells with different types in the selected range, it returns `'mixed'`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataType\n   * @param {number} rowFrom From visual row index.\n   * @param {number} columnFrom From visual column index.\n   * @param {number} rowTo To visual row index.\n   * @param {number} columnTo To visual column index.\n   * @returns {string} Cell type (e.q: `'mixed'`, `'text'`, `'numeric'`, `'autocomplete'`).\n   */\n  this.getDataType = function (rowFrom, columnFrom, rowTo, columnTo) {\n    const coords = rowFrom === undefined ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];\n    const [rowStart, columnStart] = coords;\n    let [,, rowEnd, columnEnd] = coords;\n    let previousType = null;\n    let currentType = null;\n    if (rowEnd === undefined) {\n      rowEnd = rowStart;\n    }\n    if (columnEnd === undefined) {\n      columnEnd = columnStart;\n    }\n    let type = 'mixed';\n    rangeEach(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, rowEnd), row => {\n      let isTypeEqual = true;\n      rangeEach(Math.max(Math.min(columnStart, columnEnd), 0), Math.max(columnStart, columnEnd), column => {\n        const cellType = this.getCellMeta(row, column);\n        currentType = cellType.type;\n        if (previousType) {\n          isTypeEqual = previousType === currentType;\n        } else {\n          previousType = currentType;\n        }\n        return isTypeEqual;\n      });\n      type = isTypeEqual ? currentType : 'mixed';\n      return isTypeEqual;\n    });\n    return type;\n  };\n\n  /**\n   * Remove a property defined by the `key` argument from the cell meta object for the provided `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function removeCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @fires Hooks#beforeRemoveCellMeta\n   * @fires Hooks#afterRemoveCellMeta\n   */\n  this.removeCellMeta = function (row, column, key) {\n    const [physicalRow, physicalColumn] = [this.toPhysicalRow(row), this.toPhysicalColumn(column)];\n    let cachedValue = metaManager.getCellMetaKeyValue(physicalRow, physicalColumn, key);\n    const hookResult = instance.runHooks('beforeRemoveCellMeta', row, column, key, cachedValue);\n    if (hookResult !== false) {\n      metaManager.removeCellMeta(physicalRow, physicalColumn, key);\n      instance.runHooks('afterRemoveCellMeta', row, column, key, cachedValue);\n    }\n    cachedValue = null;\n  };\n\n  /**\n   * Removes or adds one or more rows of the cell meta objects to the cell meta collections.\n   *\n   * @since 0.30.0\n   * @memberof Core#\n   * @function spliceCellsMeta\n   * @param {number} visualIndex A visual index that specifies at what position to add/remove items.\n   * @param {number} [deleteAmount=0] The number of items to be removed. If set to 0, no cell meta objects will be removed.\n   * @param {...object} [cellMetaRows] The new cell meta row objects to be added to the cell meta collection.\n   */\n  this.spliceCellsMeta = function (visualIndex) {\n    let deleteAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    for (var _len16 = arguments.length, cellMetaRows = new Array(_len16 > 2 ? _len16 - 2 : 0), _key16 = 2; _key16 < _len16; _key16++) {\n      cellMetaRows[_key16 - 2] = arguments[_key16];\n    }\n    if (cellMetaRows.length > 0 && !Array.isArray(cellMetaRows[0])) {\n      throw new Error('The 3rd argument (cellMetaRows) has to be passed as an array of cell meta objects array.');\n    }\n    if (deleteAmount > 0) {\n      metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);\n    }\n    if (cellMetaRows.length > 0) {\n      arrayEach(cellMetaRows.reverse(), cellMetaRow => {\n        metaManager.createRow(this.toPhysicalRow(visualIndex));\n        arrayEach(cellMetaRow, (cellMeta, columnIndex) => this.setCellMetaObject(visualIndex, columnIndex, cellMeta));\n      });\n    }\n    instance.render();\n  };\n\n  /**\n   * Set cell meta data object defined by `prop` to the corresponding params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMetaObject\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} prop Meta object.\n   */\n  this.setCellMetaObject = function (row, column, prop) {\n    if (typeof prop === 'object') {\n      objectEach(prop, (value, key) => {\n        this.setCellMeta(row, column, key, value);\n      });\n    }\n  };\n\n  /**\n   * Sets a property defined by the `key` property to the meta object of a cell corresponding to params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @param {string} value Property value.\n   * @fires Hooks#beforeSetCellMeta\n   * @fires Hooks#afterSetCellMeta\n   */\n  this.setCellMeta = function (row, column, key, value) {\n    const allowSetCellMeta = instance.runHooks('beforeSetCellMeta', row, column, key, value);\n    if (allowSetCellMeta === false) {\n      return;\n    }\n    let physicalRow = row;\n    let physicalColumn = column;\n    if (row < this.countRows()) {\n      physicalRow = this.toPhysicalRow(row);\n    }\n    if (column < this.countCols()) {\n      physicalColumn = this.toPhysicalColumn(column);\n    }\n    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);\n    instance.runHooks('afterSetCellMeta', row, column, key, value);\n  };\n\n  /**\n   * Get all the cells meta settings at least once generated in the table (in order of cell initialization).\n   *\n   * @memberof Core#\n   * @function getCellsMeta\n   * @returns {Array} Returns an array of ColumnSettings object instances.\n   */\n  this.getCellsMeta = function () {\n    return metaManager.getCellsMeta();\n  };\n\n  /**\n   * Returns the cell properties object for the given `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function getCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {object} The cell properties object.\n   * @fires Hooks#beforeGetCellMeta\n   * @fires Hooks#afterGetCellMeta\n   */\n  this.getCellMeta = function (row, column) {\n    let physicalRow = this.toPhysicalRow(row);\n    let physicalColumn = this.toPhysicalColumn(column);\n    if (physicalRow === null) {\n      physicalRow = row;\n    }\n    if (physicalColumn === null) {\n      physicalColumn = column;\n    }\n    return metaManager.getCellMeta(physicalRow, physicalColumn, {\n      visualRow: row,\n      visualColumn: column\n    });\n  };\n\n  /**\n   * Returns an array of cell meta objects for specified physical row index.\n   *\n   * @memberof Core#\n   * @function getCellMetaAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array}\n   */\n  this.getCellMetaAtRow = function (row) {\n    return metaManager.getCellsMetaAtRow(row);\n  };\n\n  /**\n   * Checks if your [data format](@/guides/getting-started/binding-to-data.md#compatible-data-types)\n   * and [configuration options](@/guides/getting-started/configuration-options.md)\n   * allow for changing the number of columns.\n   *\n   * Returns `false` when your data is an array of objects,\n   * or when you use the [`columns`](@/api/options.md#columns) option.\n   * Otherwise, returns `true`.\n   *\n   * @memberof Core#\n   * @function isColumnModificationAllowed\n   * @returns {boolean}\n   */\n  this.isColumnModificationAllowed = function () {\n    return !(instance.dataType === 'object' || tableMeta.columns);\n  };\n\n  /**\n   * Returns the cell renderer function by given `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellRenderer\n   * @param {number|object} rowOrMeta Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function} Returns the renderer function.\n   * @example\n   * ```js\n   * // Get cell renderer using `row` and `column` coordinates.\n   * hot.getCellRenderer(1, 1);\n   * // Get cell renderer using cell meta object.\n   * hot.getCellRenderer(hot.getCellMeta(1, 1));\n   * ```\n   */\n  this.getCellRenderer = function (rowOrMeta, column) {\n    const cellRenderer = typeof rowOrMeta === 'number' ? instance.getCellMeta(rowOrMeta, column).renderer : rowOrMeta.renderer;\n    if (typeof cellRenderer === 'string') {\n      return getRenderer(cellRenderer);\n    }\n    return isUndefined(cellRenderer) ? getRenderer('text') : cellRenderer;\n  };\n\n  /**\n   * Returns the cell editor class by the provided `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellEditor\n   * @param {number} rowOrMeta Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function|boolean} Returns the editor class or `false` is cell editor is disabled.\n   * @example\n   * ```js\n   * // Get cell editor class using `row` and `column` coordinates.\n   * hot.getCellEditor(1, 1);\n   * // Get cell editor class using cell meta object.\n   * hot.getCellEditor(hot.getCellMeta(1, 1));\n   * ```\n   */\n  this.getCellEditor = function (rowOrMeta, column) {\n    const cellEditor = typeof rowOrMeta === 'number' ? instance.getCellMeta(rowOrMeta, column).editor : rowOrMeta.editor;\n    if (typeof cellEditor === 'string') {\n      return getEditor(cellEditor);\n    }\n    return isUndefined(cellEditor) ? getEditor('text') : cellEditor;\n  };\n\n  /**\n   * Returns the cell validator by `row` and `column`.\n   *\n   * @memberof Core#\n   * @function getCellValidator\n   * @param {number|object} rowOrMeta Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function|RegExp|undefined} The validator function.\n   * @example\n   * ```js\n   * // Get cell validator using `row` and `column` coordinates.\n   * hot.getCellValidator(1, 1);\n   * // Get cell validator using cell meta object.\n   * hot.getCellValidator(hot.getCellMeta(1, 1));\n   * ```\n   */\n  this.getCellValidator = function (rowOrMeta, column) {\n    const cellValidator = typeof rowOrMeta === 'number' ? instance.getCellMeta(rowOrMeta, column).validator : rowOrMeta.validator;\n    if (typeof cellValidator === 'string') {\n      return getValidator(cellValidator);\n    }\n    return cellValidator;\n  };\n\n  /**\n   * Validates every cell in the data set,\n   * using a [validator function](@/guides/cell-functions/cell-validator.md) configured for each cell.\n   *\n   * Doesn't validate cells that are currently [trimmed](@/guides/rows/row-trimming.md),\n   * [hidden](@/guides/rows/row-hiding.md), or [filtered](@/guides/columns/column-filter.md),\n   * as such cells are not included in the data set until you bring them back again.\n   *\n   * After the validation, the `callback` function is fired, with the `valid` argument set to:\n   * - `true` for valid cells\n   * - `false` for invalid cells\n   *\n   * @memberof Core#\n   * @function validateCells\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateCells((valid) => {\n   *   if (valid) {\n   *     // ... code for validated cells\n   *   }\n   * })\n   * ```\n   */\n  this.validateCells = function (callback) {\n    this._validateCells(callback);\n  };\n\n  /**\n   * Validates rows using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateRows\n   * @param {Array} [rows] Array of validation target visual row indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateRows([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated rows\n   *   }\n   * })\n   * ```\n   */\n  this.validateRows = function (rows, callback) {\n    if (!Array.isArray(rows)) {\n      throw new Error('validateRows parameter `rows` must be an array');\n    }\n    this._validateCells(callback, rows);\n  };\n\n  /**\n   * Validates columns using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateColumns\n   * @param {Array} [columns] Array of validation target visual columns indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateColumns([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated columns\n   *   }\n   * })\n   * ```\n   */\n  this.validateColumns = function (columns, callback) {\n    if (!Array.isArray(columns)) {\n      throw new Error('validateColumns parameter `columns` must be an array');\n    }\n    this._validateCells(callback, undefined, columns);\n  };\n\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it would equal `true`.\n   *\n   * Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _validateCells\n   * @param {Function} [callback] The callback function.\n   * @param {Array} [rows] An array of validation target visual row indexes.\n   * @param {Array} [columns] An array of validation target visual column indexes.\n   */\n  this._validateCells = function (callback, rows, columns) {\n    const waitingForValidator = new ValidatorsQueue();\n    if (callback) {\n      waitingForValidator.onQueueEmpty = callback;\n    }\n    let i = instance.countRows() - 1;\n    while (i >= 0) {\n      if (rows !== undefined && rows.indexOf(i) === -1) {\n        i -= 1;\n        continue;\n      }\n      let j = instance.countCols() - 1;\n      while (j >= 0) {\n        if (columns !== undefined && columns.indexOf(j) === -1) {\n          j -= 1;\n          continue;\n        }\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), result => {\n          if (typeof result !== 'boolean') {\n            throw new Error('Validation error: result is not boolean');\n          }\n          if (result === false) {\n            waitingForValidator.valid = false;\n          }\n          waitingForValidator.removeValidatorFormQueue();\n        }, 'validateCells');\n        j -= 1;\n      }\n      i -= 1;\n    }\n    waitingForValidator.checkIfQueueIsEmpty();\n  };\n\n  /**\n   * Returns an array of row headers' values (if they are enabled). If param `row` was given, it returns the header of the given row as a string.\n   *\n   * @memberof Core#\n   * @function getRowHeader\n   * @param {number} [row] Visual row index.\n   * @fires Hooks#modifyRowHeader\n   * @returns {Array|string|number} Array of header values / single header value.\n   */\n  this.getRowHeader = function (row) {\n    let rowHeader = tableMeta.rowHeaders;\n    let physicalRow = row;\n    if (physicalRow !== undefined) {\n      physicalRow = instance.runHooks('modifyRowHeader', physicalRow);\n    }\n    if (physicalRow === undefined) {\n      rowHeader = [];\n      rangeEach(instance.countRows() - 1, i => {\n        rowHeader.push(instance.getRowHeader(i));\n      });\n    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== undefined) {\n      rowHeader = rowHeader[physicalRow];\n    } else if (isFunction(rowHeader)) {\n      rowHeader = rowHeader(physicalRow);\n    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {\n      rowHeader = physicalRow + 1;\n    }\n    return rowHeader;\n  };\n\n  /**\n   * Returns information about if this table is configured to display row headers.\n   *\n   * @memberof Core#\n   * @function hasRowHeaders\n   * @returns {boolean} `true` if the instance has the row headers enabled, `false` otherwise.\n   */\n  this.hasRowHeaders = function () {\n    return !!tableMeta.rowHeaders;\n  };\n\n  /**\n   * Returns information about if this table is configured to display column headers.\n   *\n   * @memberof Core#\n   * @function hasColHeaders\n   * @returns {boolean} `true` if the instance has the column headers enabled, `false` otherwise.\n   */\n  this.hasColHeaders = function () {\n    if (tableMeta.colHeaders !== undefined && tableMeta.colHeaders !== null) {\n      // Polymer has empty value = null\n      return !!tableMeta.colHeaders;\n    }\n    for (let i = 0, ilen = instance.countCols(); i < ilen; i++) {\n      if (instance.getColHeader(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Gets the values of column headers (if column headers are [enabled](@/api/options.md#colheaders)).\n   *\n   * To get an array with the values of all\n   * [bottom-most](@/guides/cell-features/clipboard.md#copy-with-headers) column headers,\n   * call `getColHeader()` with no arguments.\n   *\n   * To get the value of the bottom-most header of a specific column, use the `column` parameter.\n   *\n   * To get the value of a [specific-level](@/guides/columns/column-groups.md) header\n   * of a specific column, use the `column` and `headerLevel` parameters.\n   *\n   * Read more:\n   * - [Guides: Column groups](@/guides/columns/column-groups.md)\n   * - [Options: `colHeaders`](@/api/options.md#colheaders)\n   * - [Guides: Copy with headers](@/guides/cell-features/clipboard.md#copy-with-headers)\n   *\n   * ```js\n   * // get the contents of all bottom-most column headers\n   * hot.getColHeader();\n   *\n   * // get the contents of the bottom-most header of a specific column\n   * hot.getColHeader(5);\n   *\n   * // get the contents of a specific column header at a specific level\n   * hot.getColHeader(5, -2);\n   * ```\n   *\n   * @memberof Core#\n   * @function getColHeader\n   * @param {number} [column] A visual column index.\n   * @param {number} [headerLevel=-1] (Since 12.3.0) Header level index. Accepts positive (0 to n)\n   *                                  and negative (-1 to -n) values. For positive values, 0 points to the\n   *                                  topmost header. For negative values, -1 points to the bottom-most\n   *                                  header (the header closest to the cells).\n   * @fires Hooks#modifyColHeader\n   * @fires Hooks#modifyColumnHeaderValue\n   * @returns {Array|string|number} Column header values.\n   */\n  this.getColHeader = function (column) {\n    let headerLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    const columnIndex = instance.runHooks('modifyColHeader', column);\n    if (columnIndex === undefined) {\n      const out = [];\n      const ilen = instance.countCols();\n      for (let i = 0; i < ilen; i++) {\n        out.push(instance.getColHeader(i));\n      }\n      return out;\n    }\n    let result = tableMeta.colHeaders;\n    const translateVisualIndexToColumns = function (visualColumnIndex) {\n      const arr = [];\n      const columnsLen = instance.countCols();\n      let index = 0;\n      for (; index < columnsLen; index++) {\n        if (isFunction(tableMeta.columns) && tableMeta.columns(index)) {\n          arr.push(index);\n        }\n      }\n      return arr[visualColumnIndex];\n    };\n    const physicalColumn = instance.toPhysicalColumn(columnIndex);\n    const prop = translateVisualIndexToColumns(physicalColumn);\n    if (tableMeta.colHeaders === false) {\n      result = null;\n    } else if (tableMeta.columns && isFunction(tableMeta.columns) && tableMeta.columns(prop) && tableMeta.columns(prop).title) {\n      result = tableMeta.columns(prop).title;\n    } else if (tableMeta.columns && tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) {\n      result = tableMeta.columns[physicalColumn].title;\n    } else if (Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] !== undefined) {\n      result = tableMeta.colHeaders[physicalColumn];\n    } else if (isFunction(tableMeta.colHeaders)) {\n      result = tableMeta.colHeaders(physicalColumn);\n    } else if (tableMeta.colHeaders && typeof tableMeta.colHeaders !== 'string' && typeof tableMeta.colHeaders !== 'number') {\n      result = spreadsheetColumnLabel(columnIndex); // see #1458\n    }\n\n    result = instance.runHooks('modifyColumnHeaderValue', result, column, headerLevel);\n    return result;\n  };\n\n  /**\n   * Return column width from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getColWidthFromSettings\n   * @param {number} col Visual col index.\n   * @returns {number}\n   */\n  this._getColWidthFromSettings = function (col) {\n    let width;\n\n    // We currently don't support cell meta objects for headers (negative values)\n    if (col >= 0) {\n      const cellProperties = instance.getCellMeta(0, col);\n      width = cellProperties.width;\n    }\n    if (width === undefined || width === tableMeta.width) {\n      width = tableMeta.colWidths;\n    }\n    if (width !== undefined && width !== null) {\n      switch (typeof width) {\n        case 'object':\n          // array\n          width = width[col];\n          break;\n        case 'function':\n          width = width(col);\n          break;\n        default:\n          break;\n      }\n      if (typeof width === 'string') {\n        width = parseInt(width, 10);\n      }\n    }\n    return width;\n  };\n\n  /**\n   * Returns the width of the requested column.\n   *\n   * @memberof Core#\n   * @function getColWidth\n   * @param {number} column Visual column index.\n   * @returns {number} Column width.\n   * @fires Hooks#modifyColWidth\n   */\n  this.getColWidth = function (column) {\n    let width = instance._getColWidthFromSettings(column);\n    width = instance.runHooks('modifyColWidth', width, column);\n    if (width === undefined) {\n      width = ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n    return width;\n  };\n\n  /**\n   * Return row height from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getRowHeightFromSettings\n   * @param {number} row Visual row index.\n   * @returns {number}\n   */\n  this._getRowHeightFromSettings = function (row) {\n    // let cellProperties = instance.getCellMeta(row, 0);\n    // let height = cellProperties.height;\n    //\n    // if (height === undefined || height === tableMeta.height) {\n    //  height = cellProperties.rowHeights;\n    // }\n    let height = tableMeta.rowHeights;\n    if (height !== undefined && height !== null) {\n      switch (typeof height) {\n        case 'object':\n          // array\n          height = height[row];\n          break;\n        case 'function':\n          height = height(row);\n          break;\n        default:\n          break;\n      }\n      if (typeof height === 'string') {\n        height = parseInt(height, 10);\n      }\n    }\n    return height;\n  };\n\n  /**\n   * Returns a row's height, as recognized by Handsontable.\n   *\n   * Depending on your configuration, the method returns (in order of priority):\n   *   1. The row height set by the [`ManualRowResize`](@/api/manualRowResize.md) plugin\n   *     (if the plugin is enabled).\n   *   2. The row height set by the [`rowHeights`](@/api/options.md#rowheights) configuration option\n   *     (if the option is set).\n   *   3. The row height as measured in the DOM by the [`AutoRowSize`](@/api/autoRowSize.md) plugin\n   *     (if the plugin is enabled).\n   *   4. `undefined`, if neither [`ManualRowResize`](@/api/manualRowResize.md),\n   *     nor [`rowHeights`](@/api/options.md#rowheights),\n   *     nor [`AutoRowSize`](@/api/autoRowSize.md) is used.\n   *\n   * The height returned includes 1 px of the row's bottom border.\n   *\n   * Mind that this method is different from the\n   * [`getRowHeight()`](@/api/autoRowSize.md#getrowheight) method\n   * of the [`AutoRowSize`](@/api/autoRowSize.md) plugin.\n   *\n   * @memberof Core#\n   * @function getRowHeight\n   * @param {number} row A visual row index.\n   * @returns {number|undefined} The height of the specified row, in pixels.\n   * @fires Hooks#modifyRowHeight\n   */\n  this.getRowHeight = function (row) {\n    let height = instance._getRowHeightFromSettings(row);\n    height = instance.runHooks('modifyRowHeight', height, row);\n    return height;\n  };\n\n  /**\n   * Returns the total number of rows in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceRows\n   * @returns {number} Total number of rows.\n   */\n  this.countSourceRows = function () {\n    return dataSource.countRows();\n  };\n\n  /**\n   * Returns the total number of columns in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceCols\n   * @returns {number} Total number of columns.\n   */\n  this.countSourceCols = function () {\n    return dataSource.countFirstRowKeys();\n  };\n\n  /**\n   * Returns the total number of visual rows in the table.\n   *\n   * @memberof Core#\n   * @function countRows\n   * @returns {number} Total number of rows.\n   */\n  this.countRows = function () {\n    return datamap.getLength();\n  };\n\n  /**\n   * Returns the total number of visible columns in the table.\n   *\n   * @memberof Core#\n   * @function countCols\n   * @returns {number} Total number of columns.\n   */\n  this.countCols = function () {\n    const maxCols = tableMeta.maxCols;\n    const dataLen = this.columnIndexMapper.getNotTrimmedIndexesLength();\n    return Math.min(maxCols, dataLen);\n  };\n\n  /**\n   * Returns the number of rendered rows including rows that are partially or fully rendered\n   * outside the table viewport.\n   *\n   * @memberof Core#\n   * @function countRenderedRows\n   * @returns {number} Returns -1 if table is not visible.\n   */\n  this.countRenderedRows = function () {\n    return instance.view._wt.drawn ? instance.view._wt.wtTable.getRenderedRowsCount() : -1;\n  };\n\n  /**\n   * Returns the number of rendered rows that are only visible in the table viewport.\n   * The rows that are partially visible are not counted.\n   *\n   * @memberof Core#\n   * @function countVisibleRows\n   * @returns {number} Number of visible rows or -1.\n   */\n  this.countVisibleRows = function () {\n    return instance.view._wt.drawn ? instance.view._wt.wtTable.getVisibleRowsCount() : -1;\n  };\n\n  /**\n   * Returns the number of rendered rows including columns that are partially or fully rendered\n   * outside the table viewport.\n   *\n   * @memberof Core#\n   * @function countRenderedCols\n   * @returns {number} Returns -1 if table is not visible.\n   */\n  this.countRenderedCols = function () {\n    return instance.view._wt.drawn ? instance.view._wt.wtTable.getRenderedColumnsCount() : -1;\n  };\n\n  /**\n   * Returns the number of rendered columns that are only visible in the table viewport.\n   * The columns that are partially visible are not counted.\n   *\n   * @memberof Core#\n   * @function countVisibleCols\n   * @returns {number} Number of visible columns or -1.\n   */\n  this.countVisibleCols = function () {\n    return instance.view._wt.drawn ? instance.view._wt.wtTable.getVisibleColumnsCount() : -1;\n  };\n\n  /**\n   * Returns the number of rendered row headers.\n   *\n   * @since 14.0.0\n   * @memberof Core#\n   * @function countRowHeaders\n   * @returns {number} Number of row headers.\n   */\n  this.countRowHeaders = function () {\n    return this.view.getRowHeadersCount();\n  };\n\n  /**\n   * Returns the number of rendered column headers.\n   *\n   * @since 14.0.0\n   * @memberof Core#\n   * @function countColHeaders\n   * @returns {number} Number of column headers.\n   */\n  this.countColHeaders = function () {\n    return this.view.getColumnHeadersCount();\n  };\n\n  /**\n   * Returns the number of empty rows. If the optional ending parameter is `true`, returns the\n   * number of empty rows at the bottom of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyRows\n   * @param {boolean} [ending=false] If `true`, will only count empty rows at the end of the data source.\n   * @returns {number} Count empty rows.\n   */\n  this.countEmptyRows = function () {\n    let ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let emptyRows = 0;\n    rangeEachReverse(instance.countRows() - 1, visualIndex => {\n      if (instance.isEmptyRow(visualIndex)) {\n        emptyRows += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyRows;\n  };\n\n  /**\n   * Returns the number of empty columns. If the optional ending parameter is `true`, returns the number of empty\n   * columns at right hand edge of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyCols\n   * @param {boolean} [ending=false] If `true`, will only count empty columns at the end of the data source row.\n   * @returns {number} Count empty cols.\n   */\n  this.countEmptyCols = function () {\n    let ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let emptyColumns = 0;\n    rangeEachReverse(instance.countCols() - 1, visualIndex => {\n      if (instance.isEmptyCol(visualIndex)) {\n        emptyColumns += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyColumns;\n  };\n\n  /**\n   * Check if all cells in the row declared by the `row` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyRow\n   * @param {number} row Visual row index.\n   * @returns {boolean} `true` if the row at the given `row` is empty, `false` otherwise.\n   */\n  this.isEmptyRow = function (row) {\n    return tableMeta.isEmptyRow.call(instance, row);\n  };\n\n  /**\n   * Check if all cells in the the column declared by the `column` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyCol\n   * @param {number} column Column index.\n   * @returns {boolean} `true` if the column at the given `col` is empty, `false` otherwise.\n   */\n  this.isEmptyCol = function (column) {\n    return tableMeta.isEmptyCol.call(instance, column);\n  };\n\n  /**\n   * Select a single cell, or a single range of adjacent cells.\n   *\n   * To select a cell, pass its visual row and column indexes, for example: `selectCell(2, 4)`.\n   *\n   * To select a range, pass the visual indexes of the first and last cell in the range, for example: `selectCell(2, 4, 3, 5)`.\n   *\n   * If your columns have properties, you can pass those properties' values instead of column indexes, for example: `selectCell(2, 'first_name')`.\n   *\n   * By default, `selectCell()` also:\n   *  - Scrolls the viewport to the newly-selected cells.\n   *  - Switches the keyboard focus to Handsontable (by calling Handsontable's [`listen()`](#listen) method).\n   *\n   * @example\n   * ```js\n   * // select a single cell\n   * hot.selectCell(2, 4);\n   *\n   * // select a range of cells\n   * hot.selectCell(2, 4, 3, 5);\n   *\n   * // select a single cell, using a column property\n   * hot.selectCell(2, 'first_name');\n   *\n   * // select a range of cells, using column properties\n   * hot.selectCell(2, 'first_name', 3, 'last_name');\n   *\n   * // select a range of cells, without scrolling to them\n   * hot.selectCell(2, 4, 3, 5, false);\n   *\n   * // select a range of cells, without switching the keyboard focus to Handsontable\n   * hot.selectCell(2, 4, 3, 5, null, false);\n   * ```\n   *\n   * @memberof Core#\n   * @function selectCell\n   * @param {number} row A visual row index.\n   * @param {number|string} column A visual column index (`number`), or a column property's value (`string`).\n   * @param {number} [endRow] If selecting a range: the visual row index of the last cell in the range.\n   * @param {number|string} [endColumn] If selecting a range: the visual column index (or a column property's value) of the last cell in the range.\n   * @param {boolean} [scrollToCell=true] `true`: scroll the viewport to the newly-selected cells. `false`: keep the previous viewport.\n   * @param {boolean} [changeListener=true] `true`: switch the keyboard focus to Handsontable. `false`: keep the previous keyboard focus.\n   * @returns {boolean} `true`: the selection was successful, `false`: the selection failed.\n   */\n  this.selectCell = function (row, column, endRow, endColumn) {\n    let scrollToCell = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let changeListener = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    if (isUndefined(row) || isUndefined(column)) {\n      return false;\n    }\n    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);\n  };\n\n  /**\n   * Select multiple cells or ranges of cells, adjacent or non-adjacent.\n   *\n   * You can pass one of the below:\n   * - An array of arrays (which matches the output of Handsontable's [`getSelected()`](#getselected) method).\n   * - An array of [`CellRange`](@/api/cellRange.md) objects (which matches the output of Handsontable's [`getSelectedRange()`](#getselectedrange) method).\n   *\n   * To select multiple cells, pass the visual row and column indexes of each cell, for example: `hot.selectCells([[1, 1], [5, 5]])`.\n   *\n   * To select multiple ranges, pass the visual indexes of the first and last cell in each range, for example: `hot.selectCells([[1, 1, 2, 2], [6, 2, 0, 2]])`.\n   *\n   * If your columns have properties, you can pass those properties' values instead of column indexes, for example: `hot.selectCells([[1, 'first_name'], [5, 'last_name']])`.\n   *\n   * By default, `selectCell()` also:\n   *  - Scrolls the viewport to the newly-selected cells.\n   *  - Switches the keyboard focus to Handsontable (by calling Handsontable's [`listen()`](#listen) method).\n   *\n   * @example\n   * ```js\n   * // select non-adjacent cells\n   * hot.selectCells([[1, 1], [5, 5], [10, 10]]);\n   *\n   * // select non-adjacent ranges of cells\n   * hot.selectCells([[1, 1, 2, 2], [10, 10, 20, 20]]);\n   *\n   * // select cells and ranges of cells\n   * hot.selectCells([[1, 1, 2, 2], [3, 3], [6, 2, 0, 2]]);\n   *\n   * // select cells, using column properties\n   * hot.selectCells([[1, 'id', 2, 'first_name'], [3, 'full_name'], [6, 'last_name', 0, 'first_name']]);\n   *\n   * // select multiple ranges, using an array of `CellRange` objects\n   * const selected = hot.getSelectedRange();\n   *\n   * selected[0].from.row = 0;\n   * selected[0].from.col = 0;\n   * selected[0].to.row = 5;\n   * selected[0].to.col = 5;\n   *\n   * selected[1].from.row = 10;\n   * selected[1].from.col = 10;\n   * selected[1].to.row = 20;\n   * selected[1].to.col = 20;\n   *\n   * hot.selectCells(selected);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectCells\n   * @param {Array[]|CellRange[]} coords Visual coordinates,\n   * passed either as an array of arrays (`[[rowStart, columnStart, rowEnd, columnEnd], ...]`)\n   * or as an array of [`CellRange`](@/api/cellRange.md) objects.\n   * @param {boolean} [scrollToCell=true] `true`: scroll the viewport to the newly-selected cells. `false`: keep the previous viewport.\n   * @param {boolean} [changeListener=true] `true`: switch the keyboard focus to Handsontable. `false`: keep the previous keyboard focus.\n   * @returns {boolean} `true`: the selection was successful, `false`: the selection failed.\n   */\n  this.selectCells = function () {\n    let coords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[]];\n    let scrollToCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let changeListener = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (scrollToCell === false) {\n      preventScrollingToCell = true;\n    }\n    const wasSelected = selection.selectCells(coords);\n    if (wasSelected && changeListener) {\n      instance.listen();\n    }\n    preventScrollingToCell = false;\n    return wasSelected;\n  };\n\n  /**\n   * Select column specified by `startColumn` visual index, column property or a range of columns finishing at `endColumn`.\n   *\n   * @example\n   * ```js\n   * // Select column using visual index.\n   * hot.selectColumns(1);\n   * // Select column using column property.\n   * hot.selectColumns('id');\n   * // Select range of columns using visual indexes.\n   * hot.selectColumns(1, 4);\n   * // Select range of columns using visual indexes and mark the first header as highlighted.\n   * hot.selectColumns(1, 2, -1);\n   * // Select range of columns using visual indexes and mark the second cell as highlighted.\n   * hot.selectColumns(2, 1, 1);\n   * // Select range of columns using column properties.\n   * hot.selectColumns('id', 'last_name');\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectColumns\n   * @param {number} startColumn The visual column index from which the selection starts.\n   * @param {number} [endColumn=startColumn] The visual column index to which the selection finishes. If `endColumn`\n   *                                         is not defined the column defined by `startColumn` will be selected.\n   * @param {number} [focusPosition=0] The argument allows changing the cell/header focus position.\n   *                                   The value can take visual row index from -N to N, where negative values\n   *                                   point to the headers and positive values point to the cell range.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n  this.selectColumns = function (startColumn) {\n    let endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    let focusPosition = arguments.length > 2 ? arguments[2] : undefined;\n    return selection.selectColumns(startColumn, endColumn, focusPosition);\n  };\n\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @example\n   * ```js\n   * // Select row using visual index.\n   * hot.selectRows(1);\n   * // select a range of rows, using visual indexes.\n   * hot.selectRows(1, 4);\n   * // select a range of rows, using visual indexes, and mark the header as highlighted.\n   * hot.selectRows(1, 2, -1);\n   * // Select range of rows using visual indexes and mark the second cell as highlighted.\n   * hot.selectRows(2, 1, 1);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectRows\n   * @param {number} startRow The visual row index from which the selection starts.\n   * @param {number} [endRow=startRow] The visual row index to which the selection finishes. If `endRow`\n   *                                   is not defined the row defined by `startRow` will be selected.\n   * @param {number} [focusPosition=0] The argument allows changing the cell/header focus position.\n   *                                   The value can take visual column index from -N to N, where negative values\n   *                                   point to the headers and positive values point to the cell range.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n  this.selectRows = function (startRow) {\n    let endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    let focusPosition = arguments.length > 2 ? arguments[2] : undefined;\n    return selection.selectRows(startRow, endRow, focusPosition);\n  };\n\n  /**\n   * Deselects the current cell selection on the table.\n   *\n   * @memberof Core#\n   * @function deselectCell\n   */\n  this.deselectCell = function () {\n    selection.deselect();\n  };\n\n  /**\n   * Select all cells in the table excluding headers and corner elements.\n   *\n   * The previous selection is overwritten.\n   *\n   * ```js\n   * // Select all cells in the table along with row headers, including all headers and the corner cell.\n   * // Doesn't select column headers and corner elements.\n   * hot.selectAll();\n   *\n   * // Select all cells in the table, including row headers but excluding the corner cell and column headers.\n   * hot.selectAll(true, false);\n   *\n   * // Select all cells in the table, including all headers and the corner cell, but move the focus.\n   * // highlight to position 2, 1\n   * hot.selectAll(-2, -1, {\n   *    focusPosition: { row: 2, col: 1 }\n   * });\n   *\n   * // Select all cells in the table, without headers and corner elements.\n   * hot.selectAll(false);\n   * ```\n   *\n   * @since 0.38.2\n   * @memberof Core#\n   * @function selectAll\n   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers,\n   * `false` otherwise.\n   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column\n   * headers, `false` otherwise.\n   *\n   * @param {object} [options] Additional object with options. Since 14.0.0\n   * @param {{row: number, col: number} | boolean} [options.focusPosition] The argument allows changing the cell/header\n   * focus position. The value takes an object with a `row` and `col` properties from -N to N, where\n   * negative values point to the headers and positive values point to the cell range. If `false`, the focus\n   * position won't be changed. Example:\n   * ```js\n   * hot.selectAll(0, 0, {\n   * focusPosition: { row: 0, col: 1 },\n   * disableHeadersHighlight: true\n   * })\n   * ```\n   *\n   * @param {boolean} [options.disableHeadersHighlight] If `true`, disables highlighting the headers even when\n   * the logical coordinates points on them.\n   */\n  this.selectAll = function () {\n    let includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : includeRowHeaders;\n    let options = arguments.length > 2 ? arguments[2] : undefined;\n    preventScrollingToCell = true;\n    selection.selectAll(includeRowHeaders, includeColumnHeaders, options);\n    preventScrollingToCell = false;\n  };\n  const getIndexToScroll = (indexMapper, visualIndex) => {\n    // Looking for a visual index on the right and then (when not found) on the left.\n    return indexMapper.getNearestNotHiddenIndex(visualIndex, 1, true);\n  };\n\n  /**\n   * Scroll viewport to coordinates specified by the `row` and/or `col` object properties.\n   *\n   * ```js\n   * // scroll the viewport to the visual row index (leave the horizontal scroll untouched)\n   * hot.scrollViewportTo({ row: 50 });\n   *\n   * // scroll the viewport to the passed coordinates so that the cell at 50, 50 will be snapped to\n   * // the bottom-end table's edge.\n   * hot.scrollViewportTo({\n   *   row: 50,\n   *   col: 50,\n   *   verticalSnap: 'bottom',\n   *   horizontalSnap: 'end',\n   * });\n   * ```\n   *\n   * @memberof Core#\n   * @function scrollViewportTo\n   * @param {object} options A dictionary containing the following parameters:\n   * @param {number} [options.row] Specifies the number of visual rows along the Y axis to scroll the viewport.\n   * @param {number} [options.col] Specifies the number of visual columns along the X axis to scroll the viewport.\n   * @param {'top' | 'bottom'} [options.verticalSnap] Determines to which edge of the table the viewport will be scrolled based on the passed coordinates.\n   * This option is a string which must take one of the following values:\n   * - `top`: The viewport will be scrolled to a row in such a way that it will be positioned on the top of the viewport;\n   * - `bottom`: The viewport will be scrolled to a row in such a way that it will be positioned on the bottom of the viewport;\n   * - If the property is not defined the vertical auto-snapping is enabled. Depending on where the viewport is scrolled from, a row will\n   * be positioned at the top or bottom of the viewport.\n   * @param {'start' | 'end'} [options.horizontalSnap] Determines to which edge of the table the viewport will be scrolled based on the passed coordinates.\n   * This option is a string which must take one of the following values:\n   * - `start`: The viewport will be scrolled to a column in such a way that it will be positioned on the start (left edge or right, if the layout direction is set to `rtl`) of the viewport;\n   * - `end`: The viewport will be scrolled to a column in such a way that it will be positioned on the end (right edge or left, if the layout direction is set to `rtl`) of the viewport;\n   * - If the property is not defined the horizontal auto-snapping is enabled. Depending on where the viewport is scrolled from, a column will\n   * be positioned at the start or end of the viewport.\n   * @param {boolean} [options.considerHiddenIndexes=true] If `true`, we handle visual indexes, otherwise we handle only indexes which\n   * may be rendered when they are in the viewport (we don't consider hidden indexes as they aren't rendered).\n   * @returns {boolean} `true` if viewport was scrolled, `false` otherwise.\n   */\n  this.scrollViewportTo = function (options) {\n    var _options;\n    // Support for backward compatibility arguments: (row, col, snapToBottom, snapToRight, considerHiddenIndexes)\n    if (typeof options === 'number') {\n      var _arguments$;\n      /* eslint-disable prefer-rest-params */\n      options = {\n        row: arguments[0],\n        col: arguments[1],\n        verticalSnap: arguments[2] ? 'bottom' : 'top',\n        horizontalSnap: arguments[3] ? 'end' : 'start',\n        considerHiddenIndexes: (_arguments$ = arguments[4]) !== null && _arguments$ !== void 0 ? _arguments$ : true\n      };\n      /* eslint-enable prefer-rest-params */\n    }\n\n    const {\n      row,\n      col,\n      verticalSnap,\n      horizontalSnap,\n      considerHiddenIndexes\n    } = (_options = options) !== null && _options !== void 0 ? _options : {};\n    let snapToTop;\n    let snapToBottom;\n    let snapToInlineStart;\n    let snapToInlineEnd;\n    if (verticalSnap !== undefined) {\n      snapToTop = verticalSnap === 'top';\n      snapToBottom = !snapToTop;\n    }\n    if (horizontalSnap !== undefined) {\n      snapToInlineStart = horizontalSnap === 'start';\n      snapToInlineEnd = !snapToInlineStart;\n    }\n    let renderableRow = row;\n    let renderableColumn = col;\n    if (considerHiddenIndexes === undefined || considerHiddenIndexes) {\n      const isValidRowGrid = Number.isInteger(row) && row >= 0;\n      const isValidColumnGrid = Number.isInteger(col) && col >= 0;\n      const visualRowToScroll = isValidRowGrid ? getIndexToScroll(this.rowIndexMapper, row) : undefined;\n      const visualColumnToScroll = isValidColumnGrid ? getIndexToScroll(this.columnIndexMapper, col) : undefined;\n      if (visualRowToScroll === null || visualColumnToScroll === null) {\n        return false;\n      }\n      renderableRow = isValidRowGrid ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : row;\n      renderableColumn = isValidColumnGrid ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) : col;\n    }\n    const isRowInteger = Number.isInteger(renderableRow);\n    const isColumnInteger = Number.isInteger(renderableColumn);\n    if (isRowInteger && renderableRow >= 0 && isColumnInteger && renderableColumn >= 0) {\n      return instance.view.scrollViewport(instance._createCellCoords(renderableRow, renderableColumn), snapToTop, snapToInlineEnd, snapToBottom, snapToInlineStart);\n    }\n    if (isRowInteger && renderableRow >= 0 && (isColumnInteger && renderableColumn < 0 || !isColumnInteger)) {\n      return instance.view.scrollViewportVertically(renderableRow, snapToTop, snapToBottom);\n    }\n    if (isColumnInteger && renderableColumn >= 0 && (isRowInteger && renderableRow < 0 || !isRowInteger)) {\n      return instance.view.scrollViewportHorizontally(renderableColumn, snapToInlineEnd, snapToInlineStart);\n    }\n    return false;\n  };\n\n  /**\n   * Scrolls the viewport to coordinates specified by the currently focused cell.\n   *\n   * @since 14.0.0\n   * @memberof Core#\n   * @fires Hooks#afterScroll\n   * @function scrollToFocusedCell\n   * @param {Function} callback The callback function to call after the viewport is scrolled.\n   */\n  this.scrollToFocusedCell = function () {\n    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n    if (!this.selection.isSelected()) {\n      return;\n    }\n    this.addHookOnce('afterScroll', callback);\n    const {\n      highlight\n    } = this.getSelectedRangeLast();\n    const isScrolled = this.scrollViewportTo(highlight.toObject());\n    if (isScrolled) {\n      this.view.render();\n    } else {\n      this.removeHook('afterScroll', callback);\n      this._registerImmediate(() => callback());\n    }\n  };\n\n  /**\n   * Removes the table from the DOM and destroys the instance of the Handsontable.\n   *\n   * @memberof Core#\n   * @function destroy\n   * @fires Hooks#afterDestroy\n   */\n  this.destroy = function () {\n    instance._clearTimeouts();\n    instance._clearImmediates();\n    if (instance.view) {\n      // in case HT is destroyed before initialization has finished\n      instance.view.destroy();\n    }\n    if (dataSource) {\n      dataSource.destroy();\n    }\n    dataSource = null;\n    this.getShortcutManager().destroy();\n    metaManager.clearCache();\n    foreignHotInstances.delete(this.guid);\n    if (isRootInstance(instance)) {\n      const licenseInfo = this.rootDocument.querySelector('.hot-display-license-info');\n      if (licenseInfo) {\n        licenseInfo.parentNode.removeChild(licenseInfo);\n      }\n    }\n    empty(instance.rootElement);\n    eventManager.destroy();\n    if (editorManager) {\n      editorManager.destroy();\n    }\n\n    // The plugin's `destroy` method is called as a consequence and it should handle\n    // unregistration of plugin's maps. Some unregistered maps reset the cache.\n    instance.batchExecution(() => {\n      instance.rowIndexMapper.unregisterAll();\n      instance.columnIndexMapper.unregisterAll();\n      pluginsRegistry.getItems().forEach(_ref10 => {\n        let [, plugin] = _ref10;\n        plugin.destroy();\n      });\n      pluginsRegistry.clear();\n      instance.runHooks('afterDestroy');\n    }, true);\n    Hooks.getSingleton().destroy(instance);\n    objectEach(instance, (property, key, obj) => {\n      // replace instance methods with post mortem\n      if (isFunction(property)) {\n        obj[key] = postMortem(key);\n      } else if (key !== 'guid') {\n        // replace instance properties with null (restores memory)\n        // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n        obj[key] = null;\n      }\n    });\n    instance.isDestroyed = true;\n\n    // replace private properties with null (restores memory)\n    // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n    if (datamap) {\n      datamap.destroy();\n    }\n    datamap = null;\n    grid = null;\n    selection = null;\n    editorManager = null;\n    instance = null;\n  };\n\n  /**\n   * Replacement for all methods after the Handsontable was destroyed.\n   *\n   * @private\n   * @param {string} method The method name.\n   * @returns {Function}\n   */\n  function postMortem(method) {\n    return () => {\n      throw new Error(`The \"${method}\" method cannot be called because this Handsontable instance has been destroyed`);\n    };\n  }\n\n  /**\n   * Returns the active editor class instance.\n   *\n   * @memberof Core#\n   * @function getActiveEditor\n   * @returns {BaseEditor} The active editor instance.\n   */\n  this.getActiveEditor = function () {\n    return editorManager.getActiveEditor();\n  };\n\n  /**\n   * Returns plugin instance by provided its name.\n   *\n   * @memberof Core#\n   * @function getPlugin\n   * @param {string} pluginName The plugin name.\n   * @returns {BasePlugin|undefined} The plugin instance or undefined if there is no plugin.\n   */\n  this.getPlugin = function (pluginName) {\n    const unifiedPluginName = toUpperCaseFirst(pluginName);\n\n    // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n    if (unifiedPluginName === 'UndoRedo') {\n      return this.undoRedo;\n    }\n    return pluginsRegistry.getItem(unifiedPluginName);\n  };\n\n  /**\n   * Returns name of the passed plugin.\n   *\n   * @private\n   * @memberof Core#\n   * @param {BasePlugin} plugin The plugin instance.\n   * @returns {string}\n   */\n  this.getPluginName = function (plugin) {\n    // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n    if (plugin === this.undoRedo) {\n      return this.undoRedo.constructor.PLUGIN_KEY;\n    }\n    return pluginsRegistry.getId(plugin);\n  };\n\n  /**\n   * Returns the Handsontable instance.\n   *\n   * @memberof Core#\n   * @function getInstance\n   * @returns {Handsontable} The Handsontable instance.\n   */\n  this.getInstance = function () {\n    return instance;\n  };\n\n  /**\n   * Adds listener to the specified hook name (only for this Handsontable instance).\n   *\n   * @memberof Core#\n   * @function addHook\n   * @see Hooks#add\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHook('beforeInit', myCallback);\n   * ```\n   */\n  this.addHook = function (key, callback) {\n    Hooks.getSingleton().add(key, callback, instance);\n  };\n\n  /**\n   * Check if for a specified hook name there are added listeners (only for this Handsontable instance). All available\n   * hooks you will find {@link Hooks}.\n   *\n   * @memberof Core#\n   * @function hasHook\n   * @see Hooks#has\n   * @param {string} key Hook name.\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * const hasBeforeInitListeners = hot.hasHook('beforeInit');\n   * ```\n   */\n  this.hasHook = function (key) {\n    return Hooks.getSingleton().has(key, instance) || Hooks.getSingleton().has(key);\n  };\n\n  /**\n   * Adds listener to specified hook name (only for this Handsontable instance). After the listener is triggered,\n   * it will be automatically removed.\n   *\n   * @memberof Core#\n   * @function addHookOnce\n   * @see Hooks#once\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHookOnce('beforeInit', myCallback);\n   * ```\n   */\n  this.addHookOnce = function (key, callback) {\n    Hooks.getSingleton().once(key, callback, instance);\n  };\n\n  /**\n   * Removes the hook listener previously registered with {@link Core#addHook}.\n   *\n   * @memberof Core#\n   * @function removeHook\n   * @see Hooks#remove\n   * @param {string} key Hook name.\n   * @param {Function} callback Reference to the function which has been registered using {@link Core#addHook}.\n   *\n   * @example\n   * ```js\n   * hot.removeHook('beforeInit', myCallback);\n   * ```\n   */\n  this.removeHook = function (key, callback) {\n    Hooks.getSingleton().remove(key, callback, instance);\n  };\n\n  /**\n   * Run the callbacks for the hook provided in the `key` argument using the parameters given in the other arguments.\n   *\n   * @memberof Core#\n   * @function runHooks\n   * @see Hooks#run\n   * @param {string} key Hook name.\n   * @param {*} [p1] Argument passed to the callback.\n   * @param {*} [p2] Argument passed to the callback.\n   * @param {*} [p3] Argument passed to the callback.\n   * @param {*} [p4] Argument passed to the callback.\n   * @param {*} [p5] Argument passed to the callback.\n   * @param {*} [p6] Argument passed to the callback.\n   * @returns {*}\n   *\n   * @example\n   * ```js\n   * // Run built-in hook\n   * hot.runHooks('beforeInit');\n   * // Run custom hook\n   * hot.runHooks('customAction', 10, 'foo');\n   * ```\n   */\n  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {\n    return Hooks.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);\n  };\n\n  /**\n   * Get language phrase for specified dictionary key.\n   *\n   * @memberof Core#\n   * @function getTranslatedPhrase\n   * @since 0.35.0\n   * @param {string} dictionaryKey Constant which is dictionary key.\n   * @param {*} extraArguments Arguments which will be handled by formatters.\n   * @returns {string}\n   */\n  this.getTranslatedPhrase = function (dictionaryKey, extraArguments) {\n    return getTranslatedPhrase(tableMeta.language, dictionaryKey, extraArguments);\n  };\n\n  /**\n   * Converts instance into outerHTML of HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toHTML\n   * @since 7.1.0\n   * @returns {string}\n   */\n  this.toHTML = () => instanceToHTML(this);\n\n  /**\n   * Converts instance into HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toTableElement\n   * @since 7.1.0\n   * @returns {HTMLTableElement}\n   */\n  this.toTableElement = () => {\n    const tempElement = this.rootDocument.createElement('div');\n    tempElement.insertAdjacentHTML('afterbegin', instanceToHTML(this));\n    return tempElement.firstElementChild;\n  };\n  this.timeouts = [];\n\n  /**\n   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {number|Function} handle Handler returned from setTimeout or function to execute (it will be automatically wraped\n   *                                 by setTimeout function).\n   * @param {number} [delay=0] If first argument is passed as a function this argument set delay of the execution of that function.\n   * @private\n   */\n  this._registerTimeout = function (handle) {\n    let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let handleFunc = handle;\n    if (typeof handleFunc === 'function') {\n      handleFunc = setTimeout(handleFunc, delay);\n    }\n    this.timeouts.push(handleFunc);\n  };\n\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n  this._clearTimeouts = function () {\n    arrayEach(this.timeouts, handler => {\n      clearTimeout(handler);\n    });\n  };\n  this.immediates = [];\n\n  /**\n   * Execute function execution to the next event loop cycle. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {Function} callback Function to be delayed in execution.\n   * @private\n   */\n  this._registerImmediate = function (callback) {\n    this.immediates.push(setImmediate(callback));\n  };\n\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n  this._clearImmediates = function () {\n    arrayEach(this.immediates, handler => {\n      clearImmediate(handler);\n    });\n  };\n\n  /**\n   * Refresh selection borders. This is temporary method relic after selection rewrite.\n   *\n   * @private\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n  this._refreshBorders = function () {\n    let revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    editorManager.destroyEditor(revertOriginal);\n    instance.view.render();\n    if (prepareEditorIfNeeded && selection.isSelected()) {\n      editorManager.prepareEditor();\n    }\n  };\n\n  /**\n   * Gets the instance of the EditorManager.\n   *\n   * @private\n   * @returns {EditorManager}\n   */\n  this._getEditorManager = function () {\n    return editorManager;\n  };\n\n  /**\n   * Check if currently it is RTL direction.\n   *\n   * @private\n   * @memberof Core#\n   * @function isRtl\n   * @returns {boolean} True if RTL.\n   */\n  this.isRtl = function () {\n    return instance.rootWindow.getComputedStyle(instance.rootElement).direction === 'rtl';\n  };\n\n  /**\n   * Check if currently it is LTR direction.\n   *\n   * @private\n   * @memberof Core#\n   * @function isLtr\n   * @returns {boolean} True if LTR.\n   */\n  this.isLtr = function () {\n    return !instance.isRtl();\n  };\n\n  /**\n   * Returns 1 for LTR; -1 for RTL. Useful for calculations.\n   *\n   * @private\n   * @memberof Core#\n   * @function getDirectionFactor\n   * @returns {number} Returns 1 for LTR; -1 for RTL.\n   */\n  this.getDirectionFactor = function () {\n    return instance.isLtr() ? 1 : -1;\n  };\n  const shortcutManager = createShortcutManager({\n    handleEvent() {\n      return instance.isListening();\n    },\n    beforeKeyDown: event => {\n      return this.runHooks('beforeKeyDown', event);\n    },\n    afterKeyDown: event => {\n      if (this.isDestroyed) {\n        // Handsontable could be destroyed after performing action (executing a callback).\n        return;\n      }\n      instance.runHooks('afterDocumentKeyDown', event);\n    },\n    ownerWindow: this.rootWindow\n  });\n  this.addHook('beforeOnCellMouseDown', event => {\n    // Releasing keys as some browser/system shortcuts break events sequence (thus the `keyup` event isn't triggered).\n    if (event.ctrlKey === false && event.metaKey === false) {\n      shortcutManager.releasePressedKeys();\n    }\n  });\n\n  /**\n   * Returns instance of a manager responsible for handling shortcuts stored in some contexts. It run actions after\n   * pressing key combination in active Handsontable instance.\n   *\n   * @memberof Core#\n   * @since 12.0.0\n   * @function getShortcutManager\n   * @returns {ShortcutManager} Instance of {@link ShortcutManager}\n   */\n  this.getShortcutManager = function () {\n    return shortcutManager;\n  };\n\n  /**\n   * Return the Focus Manager responsible for managing the browser's focus in the table.\n   *\n   * @memberof Core#\n   * @since 14.0.0\n   * @function getFocusManager\n   * @returns {FocusManager}\n   */\n  this.getFocusManager = function () {\n    return focusManager;\n  };\n  getPluginsNames().forEach(pluginName => {\n    const PluginClass = getPlugin(pluginName);\n    pluginsRegistry.addItem(pluginName, new PluginClass(this));\n  });\n  registerAllShortcutContexts(instance);\n  shortcutManager.setActiveContextName('grid');\n  Hooks.getSingleton().run(instance, 'construct');\n}","map":{"version":3,"names":["addClass","empty","observeVisibilityChangeOnce","removeClass","isFunction","isDefined","isUndefined","isRegExp","_injectProductInfo","isEmpty","isMobileBrowser","isIpadOS","EditorManager","EventManager","deepClone","duckSchema","isObjectEqual","isObject","deepObjectSize","hasOwnProperty","createObjectPropListener","objectEach","FocusManager","arrayMap","arrayEach","arrayReduce","getDifferenceOfArrays","stringToArray","pivot","instanceToHTML","getPlugin","getPluginsNames","getRenderer","getEditor","getValidator","randomString","toUpperCaseFirst","rangeEach","rangeEachReverse","isNumericLike","TableView","DataSource","spreadsheetColumnLabel","IndexMapper","registerAsRootInstance","hasValidParameter","isRootInstance","ViewportColumnsCalculator","Hooks","hasLanguageDictionary","getValidLanguageCode","getTranslatedPhrase","warnUserAboutLanguageRegistration","normalizeLanguageCode","Selection","MetaManager","DynamicCellMetaMod","ExtendMetaPropertiesMod","replaceData","installFocusCatcher","createUniqueMap","createShortcutManager","registerAllShortcutContexts","activeGuid","foreignHotInstances","Map","deprecationWarns","Set","Core","rootElement","userSettings","_userSettings$layoutD","_this","rootInstanceSymbol","arguments","length","undefined","preventScrollingToCell","instance","eventManager","datamap","dataSource","grid","editorManager","focusManager","firstRun","rootDocument","ownerDocument","rootWindow","defaultView","isDestroyed","renderSuspendedCounter","executionSuspendedCounter","layoutDirection","rootElementDirection","includes","getComputedStyle","direction","setAttribute","isRtl","isLtr","getDirectionFactor","language","metaManager","tableMeta","getTableMeta","globalMeta","getGlobalMeta","pluginsRegistry","container","createElement","renderCall","insertBefore","firstChild","licenseKey","guid","set","columnIndexMapper","rowIndexMapper","addLocalHook","source","runHooks","id","substring","visualToRenderableCoords","coords","row","visualRow","col","visualColumn","_createCellCoords","getRenderableFromVisualIndex","renderableToVisualCoords","renderableRow","renderableColumn","getVisualFromRenderableIndex","selection","countCols","countRows","propToCol","prop","isEditorOpened","getActiveEditor","isOpened","countRenderableColumns","view","countRenderableRows","countRowHeaders","countColHeaders","getShortcutManager","createCellCoords","column","createCellRange","highlight","from","to","_createCellRange","isDisabledCellSelection","getSettings","disableVisualSelection","getCellMeta","onIndexMapperCacheUpdate","_ref","hiddenIndexesChanged","refresh","cellCoords","preventScrolling","selectionRange","getSelectedRange","current","selectionLayerLevel","size","colToProp","scrollToCell","isTouched","value","currentSelectedRange","selectedRange","isSelectedByAnyHeader","isSelectedByRowHeader","isSelectedByColumnHeader","isMultiple","scrollViewportTo","toObject","_refreshBorders","cellRanges","changedIsMultiple","destroyEditor","_len","args","Array","_key","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","_len7","_key7","_len8","_key8","_len9","_key9","_len10","_key10","_len11","_key11","_len12","_key12","_len13","_key13","totalRows","alter","totalCols","action","index","_index","_index2","amount","keepEmptyRows","normalizeIndexesGroup","indexes","sortedIndexes","sort","_ref2","_ref3","indexA","indexB","normalizedIndexes","acc","_ref4","groupIndex","groupAmount","previousItem","prevIndex","prevAmount","prevLastIndex","amountToAdd","Math","max","push","numberOfSourceRows","countSourceRows","maxRows","insertRowMode","delta","rowDelta","startPhysicalIndex","startRowPhysicalIndex","createRow","mode","currentFromRange","currentFromRow","startVisualRowIndex","toVisualRow","isSelectedByCorner","selectAll","disableHeadersHighlight","currentToRow","currentToColumn","currentFromColumn","pop","setRangeStartOnly","setRangeEnd","insertColumnMode","countSourceCols","colDelta","startColumnPhysicalIndex","createCol","isArray","colHeaders","spliceArray","toVisualColumn","prototype","splice","apply","startVisualColumnIndex","removeRow","offset","_ref5","calcIndex","Number","isInteger","wasRemoved","fixedRowsTop","min","fixedRowsBottom","adjustRowsAndCols","removeCol","_ref6","physicalColumnIndex","toPhysicalColumn","fixedColumnsStart","Error","minRows","minSpareRows","minCols","minSpareCols","deselect","nrOfRows","emptyRows","countEmptyRows","emptyRowsMissing","rowsToCreate","emptyCols","countEmptyCols","nrOfColumns","columns","colsToCreate","dataType","emptyColsMissing","maxCols","isSelected","rowCount","colCount","range","selectionChanged","fromRow","fromCol","toRow","toCol","selectRows","selectColumns","selectCell","adjustElementsSize","populateFromArray","start","input","end","method","r","rlen","c","clen","setData","newDataByColumns","startRow","startColumn","columnsPopulationEnd","rowsPopulationEnd","populatedDataByColumns","numberOfDataColumns","numberOfColumnsToPopulate","pushedDownDataByRows","getData","slice","pushedDownDataByColumns","concat","fill","numberOfDataRows","numberOfRowsToPopulate","pushedRightDataByRows","map","rowData","i","skippedRow","skippedColumn","pushData","cellMeta","getInputValue","rowValue","rowInputLength","rowSelectionLength","allowInsertRow","colInputLength","colSelectionLength","skipRowOnPaste","allowInsertColumn","skipColumnOnPaste","readOnly","orgValue","getDataAtCell","orgValueSchema","valueSchema","setDataAtCell","setLanguage","languageCode","normalizedLanguageCode","setClassName","className","classSettings","element","table","globalMetaSettingsArray","settingsArray","classNameToRemove","classNameToAdd","init","data","updateSettings","getInstance","forceFullRender","render","offsetParent","_wt","wtOverlays","updateLastSpreaderSize","ValidatorsQueue","resolved","validatorsInQueue","valid","addValidatorToQueue","removeValidatorFormQueue","checkIfQueueIsEmpty","onQueueEmpty","getParsedNumber","numericData","unifiedNumericData","replace","isNaN","parseFloat","validateChanges","changes","callback","activeEditor","waitingForValidator","shouldBeCanceled","isValid","cancelChanges","newValue","cellProperties","type","getCellValidator","validateCell","cellPropertiesReference","result","allowInvalid","cell","getCell","visualCol","invalidCellClassName","applyChanges","skipThisChange","numberOfCreatedRows","numberOfCreatedColumns","lockEditor","unlockEditor","refreshValue","validator","done","canBeValidated","hidden","td","nodeName","getSetting","expression","cellValue","validatorCallback","test","_registerImmediate","call","setDataInputToArray","propOrCol","processChanges","beforeChangeResult","filteredChanges","filter","change","changeSource","ilen","getAtCell","toPhysicalRow","processedChanges","setDataAtRowProp","listen","isListening","forEach","foreignHot","unlisten","revertOriginal","prepareEditorIfNeeded","endRow","endCol","spliceCol","_len14","elements","_key14","spliceRow","_len15","_key15","getSelected","_ref7","getSelectedLast","selected","getSelectedRangeLast","emptySelectedCells","cellRange","isSingleHeader","topStart","getTopStartCorner","bottomEnd","getBottomEndCorner","isRenderSuspended","suspendRender","resumeRender","nextValue","batchRender","wrappedOperations","isExecutionSuspended","suspendExecution","suspendOperations","resumeExecution","forceFlushChanges","resumeOperations","batchExecution","batch","refreshDimensions","width","lastWidth","height","lastHeight","getLastSize","getBoundingClientRect","isSizeChanged","isResizeBlocked","scrollableElement","setLastSize","updateData","newDataMap","fitToLength","getInitialColumnCount","hotInstance","dataMap","internalSource","loadData","clearCellsCache","initIndexMappers","columnsSettings","finalNrOfColumns","nrOfSourceColumns","columnIndex","colToPropCache","dataSchema","schema","getSchema","initToLength","row2","column2","getAll","getRange","DESTINATION_RENDERER","getCopyableText","startCol","getCopyableData","getCopyable","settings","dataUpdateFunction","bind","columnsAsFunc","j","rows","cols","ganttChart","tableClassName","syncOverlayTableClassNames","getSingleton","isRegistered","isDeprecated","initialHook","addHook","createMap","columnSetting","cells","clearCache","updateColumnMeta","setCellMetaObject","currentHeight","style","parseInt","initialStyle","getAttribute","indexOf","overflow","wtViewport","resetHasOversizedColumnHeadersMarked","exportSettingsAsClassNames","updateMainScrollableElements","getValue","sel","clear","topmost","renderableColumnIndex","renderableRowIndex","isHidden","getCellAtCoords","getCoords","renderableCoords","wtTable","getVisualFromPhysicalIndex","getPhysicalFromVisualIndex","get","getDataAtRowProp","getDataAtCol","columnData","dataByRows","getDataAtProp","getSourceData","getByRange","getSourceDataArray","getSourceDataAtCol","getAtColumn","setSourceDataAtCell","isThereAnySetSourceListener","hasHook","changesForHook","_ref8","changeRow","changeProp","changeValue","_ref9","setAtCell","getSourceDataAtRow","getAtRow","getSourceDataAtCell","getDataAtRow","getDataType","rowFrom","columnFrom","rowTo","columnTo","rowStart","columnStart","rowEnd","columnEnd","previousType","currentType","isTypeEqual","cellType","removeCellMeta","key","physicalRow","physicalColumn","cachedValue","getCellMetaKeyValue","hookResult","spliceCellsMeta","visualIndex","deleteAmount","_len16","cellMetaRows","_key16","reverse","cellMetaRow","setCellMeta","allowSetCellMeta","getCellsMeta","getCellMetaAtRow","getCellsMetaAtRow","isColumnModificationAllowed","getCellRenderer","rowOrMeta","cellRenderer","renderer","getCellEditor","cellEditor","editor","cellValidator","validateCells","_validateCells","validateRows","validateColumns","getRowHeader","rowHeader","rowHeaders","hasRowHeaders","hasColHeaders","getColHeader","headerLevel","out","translateVisualIndexToColumns","visualColumnIndex","arr","columnsLen","title","_getColWidthFromSettings","colWidths","getColWidth","DEFAULT_WIDTH","_getRowHeightFromSettings","rowHeights","getRowHeight","countFirstRowKeys","getLength","dataLen","getNotTrimmedIndexesLength","countRenderedRows","drawn","getRenderedRowsCount","countVisibleRows","getVisibleRowsCount","countRenderedCols","getRenderedColumnsCount","countVisibleCols","getVisibleColumnsCount","getRowHeadersCount","getColumnHeadersCount","ending","isEmptyRow","emptyColumns","isEmptyCol","endColumn","changeListener","selectCells","wasSelected","focusPosition","deselectCell","includeRowHeaders","includeColumnHeaders","options","getIndexToScroll","indexMapper","getNearestNotHiddenIndex","_options","_arguments$","verticalSnap","horizontalSnap","considerHiddenIndexes","snapToTop","snapToBottom","snapToInlineStart","snapToInlineEnd","isValidRowGrid","isValidColumnGrid","visualRowToScroll","visualColumnToScroll","isRowInteger","isColumnInteger","scrollViewport","scrollViewportVertically","scrollViewportHorizontally","scrollToFocusedCell","addHookOnce","isScrolled","removeHook","destroy","_clearTimeouts","_clearImmediates","delete","licenseInfo","querySelector","parentNode","removeChild","unregisterAll","getItems","_ref10","plugin","property","obj","postMortem","pluginName","unifiedPluginName","undoRedo","getItem","getPluginName","constructor","PLUGIN_KEY","getId","add","has","once","remove","p1","p2","p3","p4","p5","p6","run","dictionaryKey","extraArguments","toHTML","toTableElement","tempElement","insertAdjacentHTML","firstElementChild","timeouts","_registerTimeout","handle","delay","handleFunc","setTimeout","handler","clearTimeout","immediates","setImmediate","clearImmediate","prepareEditor","_getEditorManager","shortcutManager","handleEvent","beforeKeyDown","event","afterKeyDown","ownerWindow","ctrlKey","metaKey","releasePressedKeys","getFocusManager","PluginClass","addItem","setActiveContextName"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/core.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/web.immediate.js\";\nimport { addClass, empty, observeVisibilityChangeOnce, removeClass } from \"./helpers/dom/element.mjs\";\nimport { isFunction } from \"./helpers/function.mjs\";\nimport { isDefined, isUndefined, isRegExp, _injectProductInfo, isEmpty } from \"./helpers/mixed.mjs\";\nimport { isMobileBrowser, isIpadOS } from \"./helpers/browser.mjs\";\nimport EditorManager from \"./editorManager.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { deepClone, duckSchema, isObjectEqual, isObject, deepObjectSize, hasOwnProperty, createObjectPropListener, objectEach } from \"./helpers/object.mjs\";\nimport { FocusManager } from \"./focusManager.mjs\";\nimport { arrayMap, arrayEach, arrayReduce, getDifferenceOfArrays, stringToArray, pivot } from \"./helpers/array.mjs\";\nimport { instanceToHTML } from \"./utils/parseTable.mjs\";\nimport { getPlugin, getPluginsNames } from \"./plugins/registry.mjs\";\nimport { getRenderer } from \"./renderers/registry.mjs\";\nimport { getEditor } from \"./editors/registry.mjs\";\nimport { getValidator } from \"./validators/registry.mjs\";\nimport { randomString, toUpperCaseFirst } from \"./helpers/string.mjs\";\nimport { rangeEach, rangeEachReverse, isNumericLike } from \"./helpers/number.mjs\";\nimport TableView from \"./tableView.mjs\";\nimport DataSource from \"./dataMap/dataSource.mjs\";\nimport { spreadsheetColumnLabel } from \"./helpers/data.mjs\";\nimport { IndexMapper } from \"./translations/index.mjs\";\nimport { registerAsRootInstance, hasValidParameter, isRootInstance } from \"./utils/rootInstance.mjs\";\nimport { ViewportColumnsCalculator } from \"./3rdparty/walkontable/src/index.mjs\";\nimport Hooks from \"./pluginHooks.mjs\";\nimport { hasLanguageDictionary, getValidLanguageCode, getTranslatedPhrase } from \"./i18n/registry.mjs\";\nimport { warnUserAboutLanguageRegistration, normalizeLanguageCode } from \"./i18n/utils.mjs\";\nimport { Selection } from \"./selection/index.mjs\";\nimport { MetaManager, DynamicCellMetaMod, ExtendMetaPropertiesMod, replaceData } from \"./dataMap/index.mjs\";\nimport { installFocusCatcher } from \"./core/index.mjs\";\nimport { createUniqueMap } from \"./utils/dataStructures/uniqueMap.mjs\";\nimport { createShortcutManager } from \"./shortcuts/index.mjs\";\nimport { registerAllShortcutContexts } from \"./shortcutContexts/index.mjs\";\nlet activeGuid = null;\n\n/**\n * Keeps the collection of the all Handsontable instances created on the same page. The\n * list is then used to trigger the \"afterUnlisten\" hook when the \"listen()\" method was\n * called on another instance.\n *\n * @type {Map<string, Core>}\n */\nconst foreignHotInstances = new Map();\n\n/**\n * A set of deprecated feature names.\n *\n * @type {Set<string>}\n */\n// eslint-disable-next-line no-unused-vars\nconst deprecationWarns = new Set();\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * Handsontable constructor.\n *\n * @core\n * @class Core\n * @description\n *\n * The `Handsontable` class (known as the `Core`) lets you modify the grid's behavior by using Handsontable's public API methods.\n *\n * ::: only-for react\n * To use these methods, associate a Handsontable instance with your instance\n * of the [`HotTable` component](@/guides/getting-started/installation.md#_4-use-the-hottable-component),\n * by using React's `ref` feature (read more on the [Instance methods](@/guides/getting-started/react-methods.md) page).\n * :::\n *\n * ## How to call a method\n *\n * ::: only-for javascript\n * ```js\n * // create a Handsontable instance\n * const hot = new Handsontable(document.getElementById('example'), options);\n *\n * // call a method\n * hot.setDataAtCell(0, 0, 'new value');\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * import { useRef } from 'react';\n *\n * const hotTableComponent = useRef(null);\n *\n * <HotTable\n *   // associate your `HotTable` component with a Handsontable instance\n *   ref={hotTableComponent}\n *   settings={options}\n * />\n *\n * // access the Handsontable instance, under the `.current.hotInstance` property\n * // call a method\n * hotTableComponent.current.hotInstance.setDataAtCell(0, 0, 'new value');\n * ```\n * :::\n *\n * @param {HTMLElement} rootElement The element to which the Handsontable instance is injected.\n * @param {object} userSettings The user defined options.\n * @param {boolean} [rootInstanceSymbol=false] Indicates if the instance is root of all later instances created.\n */\nexport default function Core(rootElement, userSettings) {\n  var _userSettings$layoutD,\n    _this = this;\n  let rootInstanceSymbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let preventScrollingToCell = false;\n  let instance = this;\n  const eventManager = new EventManager(instance);\n  let datamap;\n  let dataSource;\n  let grid;\n  let editorManager;\n  let focusManager;\n  let firstRun = true;\n  if (hasValidParameter(rootInstanceSymbol)) {\n    registerAsRootInstance(this);\n  }\n\n  // TODO: check if references to DOM elements should be move to UI layer (Walkontable)\n  /**\n   * Reference to the container element.\n   *\n   * @private\n   * @type {HTMLElement}\n   */\n  this.rootElement = rootElement;\n  /**\n   * The nearest document over container.\n   *\n   * @private\n   * @type {Document}\n   */\n  this.rootDocument = rootElement.ownerDocument;\n  /**\n   * Window object over container's document.\n   *\n   * @private\n   * @type {Window}\n   */\n  this.rootWindow = this.rootDocument.defaultView;\n  /**\n   * A boolean to tell if the Handsontable has been fully destroyed. This is set to `true`\n   * after `afterDestroy` hook is called.\n   *\n   * @memberof Core#\n   * @member isDestroyed\n   * @type {boolean}\n   */\n  this.isDestroyed = false;\n  /**\n   * The counter determines how many times the render suspending was called. It allows\n   * tracking the nested suspending calls. For each render suspend resuming call the\n   * counter is decremented. The value equal to 0 means the render suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n  this.renderSuspendedCounter = 0;\n  /**\n   * The counter determines how many times the execution suspending was called. It allows\n   * tracking the nested suspending calls. For each execution suspend resuming call the\n   * counter is decremented. The value equal to 0 means the execution suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n  this.executionSuspendedCounter = 0;\n  const layoutDirection = (_userSettings$layoutD = userSettings === null || userSettings === void 0 ? void 0 : userSettings.layoutDirection) !== null && _userSettings$layoutD !== void 0 ? _userSettings$layoutD : 'inherit';\n  const rootElementDirection = ['rtl', 'ltr'].includes(layoutDirection) ? layoutDirection : this.rootWindow.getComputedStyle(this.rootElement).direction;\n  this.rootElement.setAttribute('dir', rootElementDirection);\n\n  /**\n   * Checks if the grid is rendered using the right-to-left layout direction.\n   *\n   * @since 12.0.0\n   * @memberof Core#\n   * @function isRtl\n   * @returns {boolean} True if RTL.\n   */\n  this.isRtl = function () {\n    return rootElementDirection === 'rtl';\n  };\n\n  /**\n   * Checks if the grid is rendered using the left-to-right layout direction.\n   *\n   * @since 12.0.0\n   * @memberof Core#\n   * @function isLtr\n   * @returns {boolean} True if LTR.\n   */\n  this.isLtr = function () {\n    return !instance.isRtl();\n  };\n\n  /**\n   * Returns 1 for LTR; -1 for RTL. Useful for calculations.\n   *\n   * @since 12.0.0\n   * @memberof Core#\n   * @function getDirectionFactor\n   * @returns {number} Returns 1 for LTR; -1 for RTL.\n   */\n  this.getDirectionFactor = function () {\n    return instance.isLtr() ? 1 : -1;\n  };\n  userSettings.language = getValidLanguageCode(userSettings.language);\n  const metaManager = new MetaManager(instance, userSettings, [DynamicCellMetaMod, ExtendMetaPropertiesMod]);\n  const tableMeta = metaManager.getTableMeta();\n  const globalMeta = metaManager.getGlobalMeta();\n  const pluginsRegistry = createUniqueMap();\n  this.container = this.rootDocument.createElement('div');\n  this.renderCall = false;\n  rootElement.insertBefore(this.container, rootElement.firstChild);\n  if (isRootInstance(this)) {\n    _injectProductInfo(userSettings.licenseKey, rootElement);\n  }\n  this.guid = `ht_${randomString()}`; // this is the namespace for global events\n\n  foreignHotInstances.set(this.guid, this);\n\n  /**\n   * Instance of index mapper which is responsible for managing the column indexes.\n   *\n   * @memberof Core#\n   * @member columnIndexMapper\n   * @type {IndexMapper}\n   */\n  this.columnIndexMapper = new IndexMapper();\n  /**\n   * Instance of index mapper which is responsible for managing the row indexes.\n   *\n   * @memberof Core#\n   * @member rowIndexMapper\n   * @type {IndexMapper}\n   */\n  this.rowIndexMapper = new IndexMapper();\n  this.columnIndexMapper.addLocalHook('indexesSequenceChange', source => {\n    instance.runHooks('afterColumnSequenceChange', source);\n  });\n  this.rowIndexMapper.addLocalHook('indexesSequenceChange', source => {\n    instance.runHooks('afterRowSequenceChange', source);\n  });\n  dataSource = new DataSource(instance);\n  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {\n    this.rootElement.id = this.guid; // if root element does not have an id, assign a random id\n  }\n  const visualToRenderableCoords = coords => {\n    const {\n      row: visualRow,\n      col: visualColumn\n    } = coords;\n    return instance._createCellCoords(\n    // We just store indexes for rows and columns without headers.\n    visualRow >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : visualRow, visualColumn >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : visualColumn);\n  };\n  const renderableToVisualCoords = coords => {\n    const {\n      row: renderableRow,\n      col: renderableColumn\n    } = coords;\n    return instance._createCellCoords(\n    // We just store indexes for rows and columns without headers.\n    renderableRow >= 0 ? instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow, renderableColumn >= 0 ? instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn // eslint-disable-line max-len\n    );\n  };\n  let selection = new Selection(tableMeta, {\n    rowIndexMapper: instance.rowIndexMapper,\n    columnIndexMapper: instance.columnIndexMapper,\n    countCols: () => instance.countCols(),\n    countRows: () => instance.countRows(),\n    propToCol: prop => datamap.propToCol(prop),\n    isEditorOpened: () => instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false,\n    countRenderableColumns: () => this.view.countRenderableColumns(),\n    countRenderableRows: () => this.view.countRenderableRows(),\n    countRowHeaders: () => this.countRowHeaders(),\n    countColHeaders: () => this.countColHeaders(),\n    getShortcutManager: () => instance.getShortcutManager(),\n    createCellCoords: (row, column) => instance._createCellCoords(row, column),\n    createCellRange: (highlight, from, to) => instance._createCellRange(highlight, from, to),\n    visualToRenderableCoords,\n    renderableToVisualCoords,\n    isDisabledCellSelection: (visualRow, visualColumn) => {\n      if (visualRow < 0 || visualColumn < 0) {\n        return instance.getSettings().disableVisualSelection;\n      }\n      return instance.getCellMeta(visualRow, visualColumn).disableVisualSelection;\n    }\n  });\n  this.selection = selection;\n  const onIndexMapperCacheUpdate = _ref => {\n    let {\n      hiddenIndexesChanged\n    } = _ref;\n    if (hiddenIndexesChanged) {\n      this.selection.refresh();\n    }\n  };\n  this.columnIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.rowIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.selection.addLocalHook('afterSetRangeEnd', cellCoords => {\n    const preventScrolling = createObjectPropListener(false);\n    const selectionRange = this.selection.getSelectedRange();\n    const {\n      from,\n      to\n    } = selectionRange.current();\n    const selectionLayerLevel = selectionRange.size() - 1;\n    this.runHooks('afterSelection', from.row, from.col, to.row, to.col, preventScrolling, selectionLayerLevel);\n    this.runHooks('afterSelectionByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel); // eslint-disable-line max-len\n\n    let scrollToCell = true;\n    if (preventScrollingToCell) {\n      scrollToCell = false;\n    }\n    if (preventScrolling.isTouched()) {\n      scrollToCell = !preventScrolling.value;\n    }\n    const currentSelectedRange = this.selection.selectedRange.current();\n    const isSelectedByAnyHeader = this.selection.isSelectedByAnyHeader();\n    const isSelectedByRowHeader = this.selection.isSelectedByRowHeader();\n    const isSelectedByColumnHeader = this.selection.isSelectedByColumnHeader();\n    if (scrollToCell !== false) {\n      if (!isSelectedByAnyHeader) {\n        if (currentSelectedRange && !this.selection.isMultiple()) {\n          const {\n            row,\n            col\n          } = currentSelectedRange.from;\n          if (row < 0 && col >= 0) {\n            this.scrollViewportTo({\n              col\n            });\n          } else if (col < 0 && row >= 0) {\n            this.scrollViewportTo({\n              row\n            });\n          } else {\n            this.scrollViewportTo({\n              row,\n              col\n            });\n          }\n        } else {\n          this.scrollViewportTo(cellCoords.toObject());\n        }\n      } else if (isSelectedByRowHeader) {\n        this.scrollViewportTo({\n          row: cellCoords.row\n        });\n      } else if (isSelectedByColumnHeader) {\n        this.scrollViewportTo({\n          col: cellCoords.col\n        });\n      }\n    }\n\n    // @TODO: These CSS classes are no longer needed anymore. They are used only as a indicator of the selected\n    // rows/columns in the MergedCells plugin (via border.js#L520 in the walkontable module). After fixing\n    // the Border class this should be removed.\n    if (isSelectedByRowHeader && isSelectedByColumnHeader) {\n      addClass(this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    } else if (isSelectedByRowHeader) {\n      removeClass(this.rootElement, 'ht__selection--columns');\n      addClass(this.rootElement, 'ht__selection--rows');\n    } else if (isSelectedByColumnHeader) {\n      removeClass(this.rootElement, 'ht__selection--rows');\n      addClass(this.rootElement, 'ht__selection--columns');\n    } else {\n      removeClass(this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    }\n    this._refreshBorders(null);\n  });\n  this.selection.addLocalHook('afterSelectionFinished', cellRanges => {\n    const selectionLayerLevel = cellRanges.length - 1;\n    const {\n      from,\n      to\n    } = cellRanges[selectionLayerLevel];\n    this.runHooks('afterSelectionEnd', from.row, from.col, to.row, to.col, selectionLayerLevel);\n    this.runHooks('afterSelectionEndByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), selectionLayerLevel);\n  });\n  this.selection.addLocalHook('afterIsMultipleSelection', isMultiple => {\n    const changedIsMultiple = this.runHooks('afterIsMultipleSelection', isMultiple.value);\n    if (isMultiple.value) {\n      isMultiple.value = changedIsMultiple;\n    }\n  });\n  this.selection.addLocalHook('afterDeselect', () => {\n    editorManager.destroyEditor();\n    this._refreshBorders();\n    removeClass(this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    this.runHooks('afterDeselect');\n  });\n  this.selection.addLocalHook('beforeHighlightSet', () => this.runHooks('beforeSelectionHighlightSet')).addLocalHook('beforeSetRangeStart', function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _this.runHooks('beforeSetRangeStart', ...args);\n  }).addLocalHook('beforeSetRangeStartOnly', function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return _this.runHooks('beforeSetRangeStartOnly', ...args);\n  }).addLocalHook('beforeSetRangeEnd', function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return _this.runHooks('beforeSetRangeEnd', ...args);\n  }).addLocalHook('beforeSelectColumns', function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return _this.runHooks('beforeSelectColumns', ...args);\n  }).addLocalHook('afterSelectColumns', function () {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    return _this.runHooks('afterSelectColumns', ...args);\n  }).addLocalHook('beforeSelectRows', function () {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    return _this.runHooks('beforeSelectRows', ...args);\n  }).addLocalHook('afterSelectRows', function () {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    return _this.runHooks('afterSelectRows', ...args);\n  }).addLocalHook('beforeModifyTransformStart', function () {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    return _this.runHooks('modifyTransformStart', ...args);\n  }).addLocalHook('afterModifyTransformStart', function () {\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    return _this.runHooks('afterModifyTransformStart', ...args);\n  }).addLocalHook('beforeModifyTransformEnd', function () {\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n    return _this.runHooks('modifyTransformEnd', ...args);\n  }).addLocalHook('afterModifyTransformEnd', function () {\n    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      args[_key11] = arguments[_key11];\n    }\n    return _this.runHooks('afterModifyTransformEnd', ...args);\n  }).addLocalHook('beforeRowWrap', function () {\n    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      args[_key12] = arguments[_key12];\n    }\n    return _this.runHooks('beforeRowWrap', ...args);\n  }).addLocalHook('beforeColumnWrap', function () {\n    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      args[_key13] = arguments[_key13];\n    }\n    return _this.runHooks('beforeColumnWrap', ...args);\n  }).addLocalHook('insertRowRequire', totalRows => this.alter('insert_row_above', totalRows, 1, 'auto')).addLocalHook('insertColRequire', totalCols => this.alter('insert_col_start', totalCols, 1, 'auto'));\n  grid = {\n    /**\n     * Inserts or removes rows and columns.\n     *\n     * @private\n     * @param {string} action Possible values: \"insert_row_above\", \"insert_row_below\", \"insert_col_start\", \"insert_col_end\",\n     *                        \"remove_row\", \"remove_col\".\n     * @param {number|Array} index Row or column visual index which from the alter action will be triggered.\n     *                             Alter actions such as \"remove_row\" and \"remove_col\" support array indexes in the\n     *                             format `[[index, amount], [index, amount]...]` this can be used to remove\n     *                             non-consecutive columns or rows in one call.\n     * @param {number} [amount=1] Amount of rows or columns to remove.\n     * @param {string} [source] Optional. Source of hook runner.\n     * @param {boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n     */\n    alter(action, index) {\n      var _index, _index2;\n      let amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      let source = arguments.length > 3 ? arguments[3] : undefined;\n      let keepEmptyRows = arguments.length > 4 ? arguments[4] : undefined;\n      const normalizeIndexesGroup = indexes => {\n        if (indexes.length === 0) {\n          return [];\n        }\n        const sortedIndexes = [...indexes];\n\n        // Sort the indexes in ascending order.\n        sortedIndexes.sort((_ref2, _ref3) => {\n          let [indexA] = _ref2;\n          let [indexB] = _ref3;\n          if (indexA === indexB) {\n            return 0;\n          }\n          return indexA > indexB ? 1 : -1;\n        });\n\n        // Normalize the {index, amount} groups into bigger groups.\n        const normalizedIndexes = arrayReduce(sortedIndexes, (acc, _ref4) => {\n          let [groupIndex, groupAmount] = _ref4;\n          const previousItem = acc[acc.length - 1];\n          const [prevIndex, prevAmount] = previousItem;\n          const prevLastIndex = prevIndex + prevAmount;\n          if (groupIndex <= prevLastIndex) {\n            const amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);\n            previousItem[1] += amountToAdd;\n          } else {\n            acc.push([groupIndex, groupAmount]);\n          }\n          return acc;\n        }, [sortedIndexes[0]]);\n        return normalizedIndexes;\n      };\n\n      /* eslint-disable no-case-declarations */\n      switch (action) {\n        case 'insert_row_below':\n        case 'insert_row_above':\n          const numberOfSourceRows = instance.countSourceRows();\n          if (tableMeta.maxRows === numberOfSourceRows) {\n            return;\n          }\n\n          // `above` is the default behavior for creating new rows\n          const insertRowMode = action === 'insert_row_below' ? 'below' : 'above';\n\n          // Calling the `insert_row_above` action adds a new row at the beginning of the data set.\n          // eslint-disable-next-line no-param-reassign\n          index = (_index = index) !== null && _index !== void 0 ? _index : insertRowMode === 'below' ? numberOfSourceRows : 0;\n          const {\n            delta: rowDelta,\n            startPhysicalIndex: startRowPhysicalIndex\n          } = datamap.createRow(index, amount, {\n            source,\n            mode: insertRowMode\n          });\n          if (rowDelta) {\n            const currentSelectedRange = selection.selectedRange.current();\n            const currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;\n            const currentFromRow = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.row;\n            const startVisualRowIndex = instance.toVisualRow(startRowPhysicalIndex);\n            if (selection.isSelectedByCorner()) {\n              selection.selectAll(true, true, {\n                disableHeadersHighlight: true\n              });\n            } else if (isDefined(currentFromRow) && currentFromRow >= startVisualRowIndex) {\n              // Moving the selection (if it exists) downward – it should be applied to the \"old\" row.\n              // TODO: The logic here should be handled by selection module.\n              const {\n                row: currentToRow,\n                col: currentToColumn\n              } = currentSelectedRange.to;\n              let currentFromColumn = currentFromRange.col;\n\n              // Workaround: headers are not stored inside selection.\n              if (selection.isSelectedByRowHeader()) {\n                currentFromColumn = -1;\n              }\n\n              // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n              selection.getSelectedRange().pop();\n              // I can't use transforms as they don't work in negative indexes.\n              selection.setRangeStartOnly(instance._createCellCoords(currentFromRow + rowDelta, currentFromColumn), true);\n              selection.setRangeEnd(instance._createCellCoords(currentToRow + rowDelta, currentToColumn)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n            }\n          }\n          break;\n        case 'insert_col_start':\n        case 'insert_col_end':\n          // \"start\" is a default behavior for creating new columns\n          const insertColumnMode = action === 'insert_col_end' ? 'end' : 'start';\n\n          // Calling the `insert_col_start` action adds a new column to the left of the data set.\n          // eslint-disable-next-line no-param-reassign\n          index = (_index2 = index) !== null && _index2 !== void 0 ? _index2 : insertColumnMode === 'end' ? instance.countSourceCols() : 0;\n          const {\n            delta: colDelta,\n            startPhysicalIndex: startColumnPhysicalIndex\n          } = datamap.createCol(index, amount, {\n            source,\n            mode: insertColumnMode\n          });\n          if (colDelta) {\n            if (Array.isArray(tableMeta.colHeaders)) {\n              const spliceArray = [instance.toVisualColumn(startColumnPhysicalIndex), 0];\n              spliceArray.length += colDelta; // inserts empty (undefined) elements at the end of an array\n              Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray); // inserts empty (undefined) elements into the colHeader array\n            }\n            const currentSelectedRange = selection.selectedRange.current();\n            const currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;\n            const currentFromColumn = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.col;\n            const startVisualColumnIndex = instance.toVisualColumn(startColumnPhysicalIndex);\n            if (selection.isSelectedByCorner()) {\n              selection.selectAll(true, true, {\n                disableHeadersHighlight: true\n              });\n            } else if (isDefined(currentFromColumn) && currentFromColumn >= startVisualColumnIndex) {\n              // Moving the selection (if it exists) rightward – it should be applied to the \"old\" column.\n              // TODO: The logic here should be handled by selection module.\n              const {\n                row: currentToRow,\n                col: currentToColumn\n              } = currentSelectedRange.to;\n              let currentFromRow = currentFromRange.row;\n\n              // Workaround: headers are not stored inside selection.\n              if (selection.isSelectedByColumnHeader()) {\n                currentFromRow = -1;\n              }\n\n              // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n              selection.getSelectedRange().pop();\n\n              // I can't use transforms as they don't work in negative indexes.\n              selection.setRangeStartOnly(instance._createCellCoords(currentFromRow, currentFromColumn + colDelta), true);\n              selection.setRangeEnd(instance._createCellCoords(currentToRow, currentToColumn + colDelta)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n            }\n          }\n          break;\n        case 'remove_row':\n          const removeRow = indexes => {\n            let offset = 0;\n\n            // Normalize the {index, amount} groups into bigger groups.\n            arrayEach(indexes, _ref5 => {\n              let [groupIndex, groupAmount] = _ref5;\n              const calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset, 0);\n\n              // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              }\n\n              // TODO: for datamap.removeRow index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeRow breaks the removing functionality.\n              const wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);\n              if (!wasRemoved) {\n                return;\n              }\n              const totalRows = instance.countRows();\n              const fixedRowsTop = tableMeta.fixedRowsTop;\n              if (fixedRowsTop >= calcIndex + 1) {\n                tableMeta.fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);\n              }\n              const fixedRowsBottom = tableMeta.fixedRowsBottom;\n              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {\n                tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);\n              }\n              offset += groupAmount;\n            });\n          };\n          if (Array.isArray(index)) {\n            removeRow(normalizeIndexesGroup(index));\n          } else {\n            removeRow([[index, amount]]);\n          }\n          grid.adjustRowsAndCols();\n          instance._refreshBorders(); // it will call render and prepare methods\n          break;\n        case 'remove_col':\n          const removeCol = indexes => {\n            let offset = 0;\n\n            // Normalize the {index, amount} groups into bigger groups.\n            arrayEach(indexes, _ref6 => {\n              let [groupIndex, groupAmount] = _ref6;\n              const calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset, 0);\n              let physicalColumnIndex = instance.toPhysicalColumn(calcIndex);\n\n              // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              }\n\n              // TODO: for datamap.removeCol index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeCol breaks the removing functionality.\n              const wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);\n              if (!wasRemoved) {\n                return;\n              }\n              const fixedColumnsStart = tableMeta.fixedColumnsStart;\n              if (fixedColumnsStart >= calcIndex + 1) {\n                tableMeta.fixedColumnsStart -= Math.min(groupAmount, fixedColumnsStart - calcIndex);\n              }\n              if (Array.isArray(tableMeta.colHeaders)) {\n                if (typeof physicalColumnIndex === 'undefined') {\n                  physicalColumnIndex = -1;\n                }\n                tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);\n              }\n              offset += groupAmount;\n            });\n          };\n          if (Array.isArray(index)) {\n            removeCol(normalizeIndexesGroup(index));\n          } else {\n            removeCol([[index, amount]]);\n          }\n          grid.adjustRowsAndCols();\n          instance._refreshBorders(); // it will call render and prepare methods\n\n          break;\n        default:\n          throw new Error(`There is no such action \"${action}\"`);\n      }\n      if (!keepEmptyRows) {\n        grid.adjustRowsAndCols(); // makes sure that we did not add rows that will be removed in next refresh\n      }\n    },\n    /**\n     * Makes sure there are empty rows at the bottom of the table.\n     *\n     * @private\n     */\n    adjustRowsAndCols() {\n      const minRows = tableMeta.minRows;\n      const minSpareRows = tableMeta.minSpareRows;\n      const minCols = tableMeta.minCols;\n      const minSpareCols = tableMeta.minSpareCols;\n      if (instance.countRows() === 0 && instance.countCols() === 0) {\n        selection.deselect();\n      }\n      if (minRows) {\n        // should I add empty rows to data source to meet minRows?\n        const nrOfRows = instance.countRows();\n        if (nrOfRows < minRows) {\n          // The synchronization with cell meta is not desired here. For `minRows` option,\n          // we don't want to touch/shift cell meta objects.\n          datamap.createRow(nrOfRows, minRows - nrOfRows, {\n            source: 'auto'\n          });\n        }\n      }\n      if (minSpareRows) {\n        const emptyRows = instance.countEmptyRows(true);\n\n        // should I add empty rows to meet minSpareRows?\n        if (emptyRows < minSpareRows) {\n          const emptyRowsMissing = minSpareRows - emptyRows;\n          const rowsToCreate = Math.min(emptyRowsMissing, tableMeta.maxRows - instance.countSourceRows());\n\n          // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n          datamap.createRow(instance.countRows(), rowsToCreate, {\n            source: 'auto'\n          });\n        }\n      }\n      {\n        let emptyCols;\n\n        // count currently empty cols\n        if (minCols || minSpareCols) {\n          emptyCols = instance.countEmptyCols(true);\n        }\n        let nrOfColumns = instance.countCols();\n\n        // should I add empty cols to meet minCols?\n        if (minCols && !tableMeta.columns && nrOfColumns < minCols) {\n          // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n          const colsToCreate = minCols - nrOfColumns;\n          emptyCols += colsToCreate;\n          datamap.createCol(nrOfColumns, colsToCreate, {\n            source: 'auto'\n          });\n        }\n        // should I add empty cols to meet minSpareCols?\n        if (minSpareCols && !tableMeta.columns && instance.dataType === 'array' && emptyCols < minSpareCols) {\n          nrOfColumns = instance.countCols();\n          const emptyColsMissing = minSpareCols - emptyCols;\n          const colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns);\n\n          // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n          datamap.createCol(nrOfColumns, colsToCreate, {\n            source: 'auto'\n          });\n        }\n      }\n      if (selection.isSelected()) {\n        const rowCount = instance.countRows();\n        const colCount = instance.countCols();\n        arrayEach(selection.selectedRange, range => {\n          let selectionChanged = false;\n          let fromRow = range.from.row;\n          let fromCol = range.from.col;\n          let toRow = range.to.row;\n          let toCol = range.to.col;\n\n          // if selection is outside, move selection to last row\n          if (fromRow > rowCount - 1) {\n            fromRow = rowCount - 1;\n            selectionChanged = true;\n            if (toRow > fromRow) {\n              toRow = fromRow;\n            }\n          } else if (toRow > rowCount - 1) {\n            toRow = rowCount - 1;\n            selectionChanged = true;\n            if (fromRow > toRow) {\n              fromRow = toRow;\n            }\n          }\n          // if selection is outside, move selection to last row\n          if (fromCol > colCount - 1) {\n            fromCol = colCount - 1;\n            selectionChanged = true;\n            if (toCol > fromCol) {\n              toCol = fromCol;\n            }\n          } else if (toCol > colCount - 1) {\n            toCol = colCount - 1;\n            selectionChanged = true;\n            if (fromCol > toCol) {\n              fromCol = toCol;\n            }\n          }\n          if (selectionChanged) {\n            if (fromCol < 0) {\n              instance.selectRows(fromRow, toRow, fromCol);\n            } else if (fromRow < 0) {\n              instance.selectColumns(fromCol, toCol, fromRow);\n            } else {\n              instance.selectCell(fromRow, fromCol, toRow, toCol);\n            }\n          }\n        });\n      }\n      if (instance.view) {\n        instance.view.adjustElementsSize();\n      }\n    },\n    /**\n     * Populate the data from the provided 2d array from the given cell coordinates.\n     *\n     * @private\n     * @param {object} start Start selection position. Visual indexes.\n     * @param {Array} input 2d data array.\n     * @param {object} [end] End selection position (only for drag-down mode). Visual indexes.\n     * @param {string} [source=\"populateFromArray\"] Source information string.\n     * @param {string} [method=\"overwrite\"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.\n     * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n     */\n    populateFromArray(start, input, end, source, method) {\n      let r;\n      let rlen;\n      let c;\n      let clen;\n      const setData = [];\n      const current = {};\n      const newDataByColumns = [];\n      const startRow = start.row;\n      const startColumn = start.col;\n      rlen = input.length;\n      if (rlen === 0) {\n        return false;\n      }\n      let columnsPopulationEnd = 0;\n      let rowsPopulationEnd = 0;\n      if (isObject(end)) {\n        columnsPopulationEnd = end.col - startColumn + 1;\n        rowsPopulationEnd = end.row - startRow + 1;\n      }\n\n      // insert data with specified pasteMode method\n      switch (method) {\n        case 'shift_down':\n          // translate data from a list of rows to a list of columns\n          const populatedDataByColumns = pivot(input);\n          const numberOfDataColumns = populatedDataByColumns.length;\n          // method's argument can extend the range of data population (data would be repeated)\n          const numberOfColumnsToPopulate = Math.max(numberOfDataColumns, columnsPopulationEnd);\n          const pushedDownDataByRows = instance.getData().slice(startRow);\n\n          // translate data from a list of rows to a list of columns\n          const pushedDownDataByColumns = pivot(pushedDownDataByRows).slice(startColumn, startColumn + numberOfColumnsToPopulate);\n          for (c = 0; c < numberOfColumnsToPopulate; c += 1) {\n            if (c < numberOfDataColumns) {\n              for (r = 0, rlen = populatedDataByColumns[c].length; r < rowsPopulationEnd - rlen; r += 1) {\n                // repeating data for rows\n                populatedDataByColumns[c].push(populatedDataByColumns[c][r % rlen]);\n              }\n              if (c < pushedDownDataByColumns.length) {\n                newDataByColumns.push(populatedDataByColumns[c].concat(pushedDownDataByColumns[c]));\n              } else {\n                // if before data population, there was no data in the column\n                // we fill the required rows' newly-created cells with `null` values\n                newDataByColumns.push(populatedDataByColumns[c].concat(new Array(pushedDownDataByRows.length).fill(null)));\n              }\n            } else {\n              // Repeating data for columns.\n              newDataByColumns.push(populatedDataByColumns[c % numberOfDataColumns].concat(pushedDownDataByColumns[c]));\n            }\n          }\n          instance.populateFromArray(startRow, startColumn, pivot(newDataByColumns));\n          break;\n        case 'shift_right':\n          const numberOfDataRows = input.length;\n          // method's argument can extend the range of data population (data would be repeated)\n          const numberOfRowsToPopulate = Math.max(numberOfDataRows, rowsPopulationEnd);\n          const pushedRightDataByRows = instance.getData().slice(startRow).map(rowData => rowData.slice(startColumn));\n          for (r = 0; r < numberOfRowsToPopulate; r += 1) {\n            if (r < numberOfDataRows) {\n              for (c = 0, clen = input[r].length; c < columnsPopulationEnd - clen; c += 1) {\n                // repeating data for rows\n                input[r].push(input[r][c % clen]);\n              }\n              if (r < pushedRightDataByRows.length) {\n                for (let i = 0; i < pushedRightDataByRows[r].length; i += 1) {\n                  input[r].push(pushedRightDataByRows[r][i]);\n                }\n              } else {\n                // if before data population, there was no data in the row\n                // we fill the required columns' newly-created cells with `null` values\n                input[r].push(...new Array(pushedRightDataByRows[0].length).fill(null));\n              }\n            } else {\n              // Repeating data for columns.\n              input.push(input[r % rlen].slice(0, numberOfRowsToPopulate).concat(pushedRightDataByRows[r]));\n            }\n          }\n          instance.populateFromArray(startRow, startColumn, input);\n          break;\n        case 'overwrite':\n        default:\n          // overwrite and other not specified options\n          current.row = start.row;\n          current.col = start.col;\n          let skippedRow = 0;\n          let skippedColumn = 0;\n          let pushData = true;\n          let cellMeta;\n          const getInputValue = function getInputValue(row) {\n            let col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            const rowValue = input[row % input.length];\n            if (col !== null) {\n              return rowValue[col % rowValue.length];\n            }\n            return rowValue;\n          };\n          const rowInputLength = input.length;\n          const rowSelectionLength = end ? end.row - start.row + 1 : 0;\n          if (end) {\n            rlen = rowSelectionLength;\n          } else {\n            rlen = Math.max(rowInputLength, rowSelectionLength);\n          }\n          for (r = 0; r < rlen; r++) {\n            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= tableMeta.maxRows) {\n              break;\n            }\n            const visualRow = r - skippedRow;\n            const colInputLength = getInputValue(visualRow).length;\n            const colSelectionLength = end ? end.col - start.col + 1 : 0;\n            if (end) {\n              clen = colSelectionLength;\n            } else {\n              clen = Math.max(colInputLength, colSelectionLength);\n            }\n            current.col = start.col;\n            cellMeta = instance.getCellMeta(current.row, current.col);\n            if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipRowOnPaste) {\n              skippedRow += 1;\n              current.row += 1;\n              rlen += 1;\n              /* eslint-disable no-continue */\n              continue;\n            }\n            skippedColumn = 0;\n            for (c = 0; c < clen; c++) {\n              if (end && current.col > end.col && colSelectionLength > colInputLength || !tableMeta.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= tableMeta.maxCols) {\n                break;\n              }\n              cellMeta = instance.getCellMeta(current.row, current.col);\n              if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipColumnOnPaste) {\n                skippedColumn += 1;\n                current.col += 1;\n                clen += 1;\n                continue;\n              }\n              if (cellMeta.readOnly && source !== 'UndoRedo.undo') {\n                current.col += 1;\n                /* eslint-disable no-continue */\n                continue;\n              }\n              const visualColumn = c - skippedColumn;\n              let value = getInputValue(visualRow, visualColumn);\n              let orgValue = instance.getDataAtCell(current.row, current.col);\n              if (value !== null && typeof value === 'object') {\n                // when 'value' is array and 'orgValue' is null, set 'orgValue' to\n                // an empty array so that the null value can be compared to 'value'\n                // as an empty value for the array context\n                if (Array.isArray(value) && orgValue === null) orgValue = [];\n                if (orgValue === null || typeof orgValue !== 'object') {\n                  pushData = false;\n                } else {\n                  const orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);\n                  const valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);\n\n                  // Allow overwriting values with the same object-based schema or any array-based schema.\n                  if (isObjectEqual(orgValueSchema, valueSchema) || Array.isArray(orgValueSchema) && Array.isArray(valueSchema)) {\n                    value = deepClone(value);\n                  } else {\n                    pushData = false;\n                  }\n                }\n              } else if (orgValue !== null && typeof orgValue === 'object') {\n                pushData = false;\n              }\n              if (pushData) {\n                setData.push([current.row, current.col, value]);\n              }\n              pushData = true;\n              current.col += 1;\n            }\n            current.row += 1;\n          }\n          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');\n          break;\n      }\n    }\n  };\n\n  /**\n   * Internal function to set `language` key of settings.\n   *\n   * @private\n   * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n   * @fires Hooks#afterLanguageChange\n   */\n  function setLanguage(languageCode) {\n    const normalizedLanguageCode = normalizeLanguageCode(languageCode);\n    if (hasLanguageDictionary(normalizedLanguageCode)) {\n      instance.runHooks('beforeLanguageChange', normalizedLanguageCode);\n      globalMeta.language = normalizedLanguageCode;\n      instance.runHooks('afterLanguageChange', normalizedLanguageCode);\n    } else {\n      warnUserAboutLanguageRegistration(languageCode);\n    }\n  }\n\n  /**\n   * Internal function to set `className` or `tableClassName`, depending on the key from the settings object.\n   *\n   * @private\n   * @param {string} className `className` or `tableClassName` from the key in the settings object.\n   * @param {string|string[]} classSettings String or array of strings. Contains class name(s) from settings object.\n   */\n  function setClassName(className, classSettings) {\n    const element = className === 'className' ? instance.rootElement : instance.table;\n    if (firstRun) {\n      addClass(element, classSettings);\n    } else {\n      let globalMetaSettingsArray = [];\n      let settingsArray = [];\n      if (globalMeta[className]) {\n        globalMetaSettingsArray = Array.isArray(globalMeta[className]) ? globalMeta[className] : stringToArray(globalMeta[className]);\n      }\n      if (classSettings) {\n        settingsArray = Array.isArray(classSettings) ? classSettings : stringToArray(classSettings);\n      }\n      const classNameToRemove = getDifferenceOfArrays(globalMetaSettingsArray, settingsArray);\n      const classNameToAdd = getDifferenceOfArrays(settingsArray, globalMetaSettingsArray);\n      if (classNameToRemove.length) {\n        removeClass(element, classNameToRemove);\n      }\n      if (classNameToAdd.length) {\n        addClass(element, classNameToAdd);\n      }\n    }\n    globalMeta[className] = classSettings;\n  }\n  this.init = function () {\n    dataSource.setData(tableMeta.data);\n    instance.runHooks('beforeInit');\n    if (isMobileBrowser() || isIpadOS()) {\n      addClass(instance.rootElement, 'mobile');\n    }\n    this.updateSettings(tableMeta, true);\n    this.view = new TableView(this);\n    editorManager = EditorManager.getInstance(instance, tableMeta, selection);\n    focusManager = new FocusManager(instance);\n    if (isRootInstance(this)) {\n      installFocusCatcher(instance);\n    }\n    instance.runHooks('init');\n    this.forceFullRender = true; // used when data was changed\n    this.view.render();\n\n    // Run the logic only if it's the table's initialization and the root element is not visible.\n    if (!!firstRun && instance.rootElement.offsetParent === null) {\n      observeVisibilityChangeOnce(instance.rootElement, () => {\n        // Update the spreader size cache before rendering.\n        instance.view._wt.wtOverlays.updateLastSpreaderSize();\n        instance.render();\n        instance.view.adjustElementsSize();\n      });\n    }\n    if (typeof firstRun === 'object') {\n      instance.runHooks('afterChange', firstRun[0], firstRun[1]);\n      firstRun = false;\n    }\n    instance.runHooks('afterInit');\n  };\n\n  /**\n   * @ignore\n   * @returns {object}\n   */\n  function ValidatorsQueue() {\n    // moved this one level up so it can be used in any function here. Probably this should be moved to a separate file\n    let resolved = false;\n    return {\n      validatorsInQueue: 0,\n      valid: true,\n      addValidatorToQueue() {\n        this.validatorsInQueue += 1;\n        resolved = false;\n      },\n      removeValidatorFormQueue() {\n        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;\n        this.checkIfQueueIsEmpty();\n      },\n      onQueueEmpty() {},\n      checkIfQueueIsEmpty() {\n        if (this.validatorsInQueue === 0 && resolved === false) {\n          resolved = true;\n          this.onQueueEmpty(this.valid);\n        }\n      }\n    };\n  }\n\n  /**\n   * Get parsed number from numeric string.\n   *\n   * @private\n   * @param {string} numericData Float (separated by a dot or a comma) or integer.\n   * @returns {number} Number if we get data in parsable format, not changed value otherwise.\n   */\n  function getParsedNumber(numericData) {\n    // Unifying \"float like\" string. Change from value with comma determiner to value with dot determiner,\n    // for example from `450,65` to `450.65`.\n    const unifiedNumericData = numericData.replace(',', '.');\n    if (isNaN(parseFloat(unifiedNumericData)) === false) {\n      return parseFloat(unifiedNumericData);\n    }\n    return numericData;\n  }\n\n  /**\n   * @ignore\n   * @param {Array} changes The 2D array containing information about each of the edited cells.\n   * @param {string} source The string that identifies source of validation.\n   * @param {Function} callback The callback function fot async validation.\n   */\n  function validateChanges(changes, source, callback) {\n    if (!changes.length) {\n      return;\n    }\n    const activeEditor = instance.getActiveEditor();\n    const waitingForValidator = new ValidatorsQueue();\n    let shouldBeCanceled = true;\n    waitingForValidator.onQueueEmpty = isValid => {\n      if (activeEditor && shouldBeCanceled) {\n        activeEditor.cancelChanges();\n      }\n      callback(isValid); // called when async validators are resolved and beforeChange was not async\n    };\n    for (let i = changes.length - 1; i >= 0; i--) {\n      const [row, prop,, newValue] = changes[i];\n      const col = datamap.propToCol(prop);\n      const cellProperties = instance.getCellMeta(row, col);\n      if (cellProperties.type === 'numeric' && typeof newValue === 'string' && isNumericLike(newValue)) {\n        changes[i][3] = getParsedNumber(newValue);\n      }\n\n      /* eslint-disable no-loop-func */\n      if (instance.getCellValidator(cellProperties)) {\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(changes[i][3], cellProperties, function (index, cellPropertiesReference) {\n          return function (result) {\n            if (typeof result !== 'boolean') {\n              throw new Error('Validation error: result is not boolean');\n            }\n            if (result === false && cellPropertiesReference.allowInvalid === false) {\n              shouldBeCanceled = false;\n              changes.splice(index, 1); // cancel the change\n              cellPropertiesReference.valid = true; // we cancelled the change, so cell value is still valid\n\n              const cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);\n              if (cell !== null) {\n                removeClass(cell, tableMeta.invalidCellClassName);\n              }\n            }\n            waitingForValidator.removeValidatorFormQueue();\n          };\n        }(i, cellProperties), source);\n      }\n    }\n    waitingForValidator.checkIfQueueIsEmpty();\n  }\n\n  /**\n   * Internal function to apply changes. Called after validateChanges.\n   *\n   * @private\n   * @param {Array} changes Array in form of [row, prop, oldValue, newValue].\n   * @param {string} source String that identifies how this change will be described in changes array (useful in onChange callback).\n   * @fires Hooks#beforeChangeRender\n   * @fires Hooks#afterChange\n   */\n  function applyChanges(changes, source) {\n    let i = changes.length - 1;\n    if (i < 0) {\n      return;\n    }\n    for (; i >= 0; i--) {\n      let skipThisChange = false;\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n        /* eslint-disable no-continue */\n        continue;\n      }\n      if ((changes[i][2] === null || changes[i][2] === undefined) && (changes[i][3] === null || changes[i][3] === undefined)) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      if (tableMeta.allowInsertRow) {\n        while (changes[i][0] > instance.countRows() - 1) {\n          const {\n            delta: numberOfCreatedRows\n          } = datamap.createRow(undefined, undefined, {\n            source\n          });\n          if (numberOfCreatedRows === 0) {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n      if (instance.dataType === 'array' && (!tableMeta.columns || tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {\n        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {\n          const {\n            delta: numberOfCreatedColumns\n          } = datamap.createCol(undefined, undefined, {\n            source\n          });\n          if (numberOfCreatedColumns === 0) {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n      if (skipThisChange) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      datamap.set(changes[i][0], changes[i][1], changes[i][3]);\n    }\n    instance.forceFullRender = true; // used when data was changed\n    grid.adjustRowsAndCols();\n    instance.runHooks('beforeChangeRender', changes, source);\n    editorManager.lockEditor();\n    instance._refreshBorders(null);\n    editorManager.unlockEditor();\n    instance.view.adjustElementsSize();\n    instance.runHooks('afterChange', changes, source || 'edit');\n    const activeEditor = instance.getActiveEditor();\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  }\n\n  /**\n   * Creates and returns the CellCoords object.\n   *\n   * @private\n   * @memberof Core#\n   * @function _createCellCoords\n   * @param {number} row The row index.\n   * @param {number} column The column index.\n   * @returns {CellCoords}\n   */\n  this._createCellCoords = function (row, column) {\n    return instance.view._wt.createCellCoords(row, column);\n  };\n\n  /**\n   * Creates and returns the CellRange object.\n   *\n   * @private\n   * @memberof Core#\n   * @function _createCellRange\n   * @param {CellCoords} highlight Defines the border around a cell where selection was started and to edit the cell\n   *                               when you press Enter. The highlight cannot point to headers (negative values).\n   * @param {CellCoords} from Initial coordinates.\n   * @param {CellCoords} to Final coordinates.\n   * @returns {CellRange}\n   */\n  this._createCellRange = function (highlight, from, to) {\n    return instance.view._wt.createCellRange(highlight, from, to);\n  };\n\n  /**\n   * Validate a single cell.\n   *\n   * @memberof Core#\n   * @function validateCell\n   * @param {string|number} value The value to validate.\n   * @param {object} cellProperties The cell meta which corresponds with the value.\n   * @param {Function} callback The callback function.\n   * @param {string} source The string that identifies source of the validation.\n   */\n  this.validateCell = function (value, cellProperties, callback, source) {\n    let validator = instance.getCellValidator(cellProperties);\n\n    // the `canBeValidated = false` argument suggests, that the cell passes validation by default.\n    /**\n     * @private\n     * @function done\n     * @param {boolean} valid Indicates if the validation was successful.\n     * @param {boolean} [canBeValidated=true] Flag which controls the validation process.\n     */\n    function done(valid) {\n      let canBeValidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      // Fixes GH#3903\n      if (!canBeValidated || cellProperties.hidden === true) {\n        callback(valid);\n        return;\n      }\n      const col = cellProperties.visualCol;\n      const row = cellProperties.visualRow;\n      const td = instance.getCell(row, col, true);\n      if (td && td.nodeName !== 'TH') {\n        const renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);\n        const renderableColumn = instance.columnIndexMapper.getRenderableFromVisualIndex(col);\n        instance.view._wt.getSetting('cellRenderer', renderableRow, renderableColumn, td);\n      }\n      callback(valid);\n    }\n    if (isRegExp(validator)) {\n      validator = function (expression) {\n        return function (cellValue, validatorCallback) {\n          validatorCallback(expression.test(cellValue));\n        };\n      }(validator);\n    }\n    if (isFunction(validator)) {\n      // eslint-disable-next-line no-param-reassign\n      value = instance.runHooks('beforeValidate', value, cellProperties.visualRow, cellProperties.prop, source);\n\n      // To provide consistent behaviour, validation should be always asynchronous\n      instance._registerImmediate(() => {\n        validator.call(cellProperties, value, valid => {\n          if (!instance) {\n            return;\n          }\n          // eslint-disable-next-line no-param-reassign\n          valid = instance.runHooks('afterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n          cellProperties.valid = valid;\n          done(valid);\n          instance.runHooks('postAfterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n        });\n      });\n    } else {\n      // resolve callback even if validator function was not found\n      instance._registerImmediate(() => {\n        cellProperties.valid = true;\n        done(cellProperties.valid, false);\n      });\n    }\n  };\n\n  /**\n   * @ignore\n   * @param {number} row The visual row index.\n   * @param {string|number} propOrCol The visual prop or column index.\n   * @param {*} value The cell value.\n   * @returns {Array}\n   */\n  function setDataInputToArray(row, propOrCol, value) {\n    if (Array.isArray(row)) {\n      // it's an array of changes\n      return row;\n    }\n    return [[row, propOrCol, value]];\n  }\n\n  /**\n   * Process changes prepared for applying to the dataset (unifying list of changes, closing an editor - when needed,\n   * calling a hook).\n   *\n   * @private\n   * @param {Array} changes Array of changes in format `[[row, col, value],...]`.\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   * @returns {Array} List of changes finally applied to the dataset.\n   */\n  function processChanges(changes, source) {\n    const activeEditor = instance.getActiveEditor();\n    const beforeChangeResult = instance.runHooks('beforeChange', changes, source || 'edit');\n    // The `beforeChange` hook could add a `null` for purpose of cancelling some dataset's change.\n    const filteredChanges = changes.filter(change => change !== null);\n    if (beforeChangeResult === false || filteredChanges.length === 0) {\n      if (activeEditor) {\n        activeEditor.cancelChanges();\n      }\n      return [];\n    }\n    return filteredChanges;\n  }\n\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, col, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtCell\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, col, value],...]`.\n   * @param {number} [column] Visual column index.\n   * @param {string} [value] New value.\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   */\n  this.setDataAtCell = function (row, column, value, source) {\n    const input = setDataInputToArray(row, column, value);\n    const changes = [];\n    let changeSource = source;\n    let i;\n    let ilen;\n    let prop;\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      if (typeof input[i] !== 'object') {\n        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');\n      }\n      if (typeof input[i][1] !== 'number') {\n        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`'); // eslint-disable-line max-len\n      }\n      if (input[i][1] >= this.countCols()) {\n        prop = input[i][1];\n      } else {\n        prop = datamap.colToProp(input[i][1]);\n      }\n      changes.push([input[i][0], prop, dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n    if (!changeSource && typeof row === 'object') {\n      changeSource = column;\n    }\n    const processedChanges = processChanges(changes, source);\n    instance.runHooks('afterSetDataAtCell', processedChanges, changeSource);\n    validateChanges(processedChanges, changeSource, () => {\n      applyChanges(processedChanges, changeSource);\n    });\n  };\n\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, prop, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtRowProp\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {string} prop Property name or the source string (e.g. `'first.name'` or `'0'`).\n   * @param {string} value Value to be set.\n   * @param {string} [source] String that identifies how this change will be described in changes array (useful in onChange callback).\n   */\n  this.setDataAtRowProp = function (row, prop, value, source) {\n    const input = setDataInputToArray(row, prop, value);\n    const changes = [];\n    let changeSource = source;\n    let i;\n    let ilen;\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      changes.push([input[i][0], input[i][1], dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n    if (!changeSource && typeof row === 'object') {\n      changeSource = prop;\n    }\n    const processedChanges = processChanges(changes, source);\n    instance.runHooks('afterSetDataAtRowProp', processedChanges, changeSource);\n    validateChanges(processedChanges, changeSource, () => {\n      applyChanges(processedChanges, changeSource);\n    });\n  };\n\n  /**\n   * Listen to the keyboard input on document body. This allows Handsontable to capture keyboard events and respond\n   * in the right way.\n   *\n   * @memberof Core#\n   * @function listen\n   * @fires Hooks#afterListen\n   */\n  this.listen = function () {\n    if (instance && !instance.isListening()) {\n      foreignHotInstances.forEach(foreignHot => {\n        if (instance !== foreignHot) {\n          foreignHot.unlisten();\n        }\n      });\n      activeGuid = instance.guid;\n      instance.runHooks('afterListen');\n    }\n  };\n\n  /**\n   * Stop listening to keyboard input on the document body. Calling this method makes the Handsontable inactive for\n   * any keyboard events.\n   *\n   * @memberof Core#\n   * @function unlisten\n   */\n  this.unlisten = function () {\n    if (this.isListening()) {\n      activeGuid = null;\n      instance.runHooks('afterUnlisten');\n    }\n  };\n\n  /**\n   * Returns `true` if the current Handsontable instance is listening to keyboard input on document body.\n   *\n   * @memberof Core#\n   * @function isListening\n   * @returns {boolean} `true` if the instance is listening, `false` otherwise.\n   */\n  this.isListening = function () {\n    return activeGuid === instance.guid;\n  };\n\n  /**\n   * Destroys the current editor, render the table and prepares the editor of the newly selected cell.\n   *\n   * @memberof Core#\n   * @function destroyEditor\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n  this.destroyEditor = function () {\n    let revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);\n  };\n\n  /**\n   * Populates cells at position with 2D input array (e.g. `[[1, 2], [3, 4]]`). Use `endRow`, `endCol` when you\n   * want to cut input when a certain row is reached.\n   *\n   * The `populateFromArray()` method can't change [`readOnly`](@/api/options.md#readonly) cells.\n   *\n   * Optional `method` argument has the same effect as pasteMode option (see {@link Options#pasteMode}).\n   *\n   * @memberof Core#\n   * @function populateFromArray\n   * @param {number} row Start visual row index.\n   * @param {number} column Start visual column index.\n   * @param {Array} input 2d array.\n   * @param {number} [endRow] End visual row index (use when you want to cut input when certain row is reached).\n   * @param {number} [endCol] End visual column index (use when you want to cut input when certain column is reached).\n   * @param {string} [source=populateFromArray] Used to identify this call in the resulting events (beforeChange, afterChange).\n   * @param {string} [method=overwrite] Populate method, possible values: `'shift_down'`, `'shift_right'`, `'overwrite'`.\n   * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n   */\n  this.populateFromArray = function (row, column, input, endRow, endCol, source, method) {\n    if (!(typeof input === 'object' && typeof input[0] === 'object')) {\n      throw new Error('populateFromArray parameter `input` must be an array of arrays'); // API changed in 0.9-beta2, let's check if you use it correctly\n    }\n    const c = typeof endRow === 'number' ? instance._createCellCoords(endRow, endCol) : null;\n    return grid.populateFromArray(instance._createCellCoords(row, column), input, c, source, method);\n  };\n\n  /**\n   * Adds/removes data from the column. This method works the same as Array.splice for arrays.\n   *\n   * @memberof Core#\n   * @function spliceCol\n   * @param {number} column Index of the column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of columns.\n   */\n  this.spliceCol = function (column, index, amount) {\n    for (var _len14 = arguments.length, elements = new Array(_len14 > 3 ? _len14 - 3 : 0), _key14 = 3; _key14 < _len14; _key14++) {\n      elements[_key14 - 3] = arguments[_key14];\n    }\n    return datamap.spliceCol(column, index, amount, ...elements);\n  };\n\n  /**\n   * Adds/removes data from the row. This method works the same as Array.splice for arrays.\n   *\n   * @memberof Core#\n   * @function spliceRow\n   * @param {number} row Index of column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of rows.\n   */\n  this.spliceRow = function (row, index, amount) {\n    for (var _len15 = arguments.length, elements = new Array(_len15 > 3 ? _len15 - 3 : 0), _key15 = 3; _key15 < _len15; _key15++) {\n      elements[_key15 - 3] = arguments[_key15];\n    }\n    return datamap.spliceRow(row, index, amount, ...elements);\n  };\n\n  /**\n   * Returns indexes of the currently selected cells as an array of arrays `[[startRow, startCol, endRow, endCol],...]`.\n   *\n   * Start row and start column are the coordinates of the active cell (where the selection was started).\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedLast` method.\n   *\n   * @memberof Core#\n   * @function getSelected\n   * @returns {Array[]|undefined} An array of arrays of the selection's coordinates.\n   */\n  this.getSelected = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return arrayMap(selection.getSelectedRange(), _ref7 => {\n        let {\n          from,\n          to\n        } = _ref7;\n        return [from.row, from.col, to.row, to.col];\n      });\n    }\n  };\n\n  /**\n   * Returns the last coordinates applied to the table as a an array `[startRow, startCol, endRow, endCol]`.\n   *\n   * @since 0.36.0\n   * @memberof Core#\n   * @function getSelectedLast\n   * @returns {Array|undefined} An array of the selection's coordinates.\n   */\n  this.getSelectedLast = function () {\n    const selected = this.getSelected();\n    let result;\n    if (selected && selected.length > 0) {\n      result = selected[selected.length - 1];\n    }\n    return result;\n  };\n\n  /**\n   * Returns the current selection as an array of CellRange objects.\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedRangeLast` method.\n   *\n   * @memberof Core#\n   * @function getSelectedRange\n   * @returns {CellRange[]|undefined} Selected range object or undefined if there is no selection.\n   */\n  this.getSelectedRange = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return Array.from(selection.getSelectedRange());\n    }\n  };\n\n  /**\n   * Returns the last coordinates applied to the table as a CellRange object.\n   *\n   * @memberof Core#\n   * @function getSelectedRangeLast\n   * @since 0.36.0\n   * @returns {CellRange|undefined} Selected range object or undefined` if there is no selection.\n   */\n  this.getSelectedRangeLast = function () {\n    const selectedRange = this.getSelectedRange();\n    let result;\n    if (selectedRange && selectedRange.length > 0) {\n      result = selectedRange[selectedRange.length - 1];\n    }\n    return result;\n  };\n\n  /**\n   * Erases content from cells that have been selected in the table.\n   *\n   * @memberof Core#\n   * @function emptySelectedCells\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   * @since 0.36.0\n   */\n  this.emptySelectedCells = function (source) {\n    if (!selection.isSelected() || this.countRows() === 0 || this.countCols() === 0) {\n      return;\n    }\n    const changes = [];\n    arrayEach(selection.getSelectedRange(), cellRange => {\n      if (cellRange.isSingleHeader()) {\n        return;\n      }\n      const topStart = cellRange.getTopStartCorner();\n      const bottomEnd = cellRange.getBottomEndCorner();\n      rangeEach(topStart.row, bottomEnd.row, row => {\n        rangeEach(topStart.col, bottomEnd.col, column => {\n          if (!this.getCellMeta(row, column).readOnly) {\n            changes.push([row, column, null]);\n          }\n        });\n      });\n    });\n    if (changes.length > 0) {\n      this.setDataAtCell(changes, source);\n    }\n  };\n\n  /**\n   * Checks if the table rendering process was suspended. See explanation in {@link Core#suspendRender}.\n   *\n   * @memberof Core#\n   * @function isRenderSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n  this.isRenderSuspended = function () {\n    return this.renderSuspendedCounter > 0;\n  };\n\n  /**\n   * Suspends the rendering process. It's helpful to wrap the table render\n   * cycles triggered by API calls or UI actions (or both) and call the \"render\"\n   * once in the end. As a result, it improves the performance of wrapped operations.\n   * When the table is in the suspend state, most operations will have no visual\n   * effect until the rendering state is resumed. Resuming the state automatically\n   * invokes the table rendering. To make sure that after executing all operations,\n   * the table will be rendered, it's highly recommended to use the {@link Core#batchRender}\n   * method or {@link Core#batch}, which additionally aggregates the logic execution\n   * that happens behind the table.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * Every [`suspendRender()`](@/api/core.md#suspendrender) call needs to correspond with one [`resumeRender()`](@/api/core.md#resumerender) call.\n   * For example, if you call [`suspendRender()`](@/api/core.md#suspendrender) 5 times, you need to call [`resumeRender()`](@/api/core.md#resumerender) 5 times as well.\n   *\n   * @memberof Core#\n   * @function suspendRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row_above', 5, 45);\n   * hot.alter('insert_col_start', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n  this.suspendRender = function () {\n    this.renderSuspendedCounter += 1;\n  };\n\n  /**\n   * Resumes the rendering process. In combination with the {@link Core#suspendRender}\n   * method it allows aggregating the table render cycles triggered by API calls or UI\n   * actions (or both) and calls the \"render\" once in the end. When the table is in\n   * the suspend state, most operations will have no visual effect until the rendering\n   * state is resumed. Resuming the state automatically invokes the table rendering.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * Every [`suspendRender()`](@/api/core.md#suspendrender) call needs to correspond with one [`resumeRender()`](@/api/core.md#resumerender) call.\n   * For example, if you call [`suspendRender()`](@/api/core.md#suspendrender) 5 times, you need to call [`resumeRender()`](@/api/core.md#resumerender) 5 times as well.\n   *\n   * @memberof Core#\n   * @function resumeRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row_above', 5, 45);\n   * hot.alter('insert_col_start', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n  this.resumeRender = function () {\n    const nextValue = this.renderSuspendedCounter - 1;\n    this.renderSuspendedCounter = Math.max(nextValue, 0);\n    if (!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {\n      if (this.renderCall) {\n        this.render();\n      } else {\n        this._refreshBorders(null);\n      }\n    }\n  };\n\n  /**\n   * Rerender the table. Calling this method starts the process of recalculating, redrawing and applying the changes\n   * to the DOM. While rendering the table all cell renderers are recalled.\n   *\n   * Calling this method manually is not recommended. Handsontable tries to render itself by choosing the most\n   * optimal moments in its lifecycle.\n   *\n   * @memberof Core#\n   * @function render\n   */\n  this.render = function () {\n    if (this.view) {\n      this.renderCall = true;\n      this.forceFullRender = true; // used when data was changed\n\n      if (!this.isRenderSuspended()) {\n        editorManager.lockEditor();\n        this._refreshBorders(null);\n        editorManager.unlockEditor();\n      }\n    }\n  };\n\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table rendering process. After the execution of the operations, the table is\n   * rendered once. As a result, it improves the performance of wrapped operations.\n   * Without batching, a similar case could trigger multiple table render calls.\n   *\n   * @memberof Core#\n   * @function batchRender\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchRender(() => {\n   *   hot.alter('insert_row_above', 5, 45);\n   *   hot.alter('insert_col_start', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'John');\n   *   hot.setDataAtCell(2, 2, 'Mark');\n   *   hot.setDataAtCell(3, 3, 'Ann');\n   *   hot.setDataAtCell(4, 4, 'Sophia');\n   *   hot.setDataAtCell(5, 5, 'Mia');\n   *   hot.selectCell(0, 0);\n   *   // The table will be rendered once after executing the callback\n   * });\n   * ```\n   */\n  this.batchRender = function (wrappedOperations) {\n    this.suspendRender();\n    const result = wrappedOperations();\n    this.resumeRender();\n    return result;\n  };\n\n  /**\n   * Checks if the table indexes recalculation process was suspended. See explanation\n   * in {@link Core#suspendExecution}.\n   *\n   * @memberof Core#\n   * @function isExecutionSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n  this.isExecutionSuspended = function () {\n    return this.executionSuspendedCounter > 0;\n  };\n\n  /**\n   * Suspends the execution process. It's helpful to wrap the table logic changes\n   * such as index changes into one call after which the cache is updated. As a result,\n   * it improves the performance of wrapped operations.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function suspendExecution\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n  this.suspendExecution = function () {\n    this.executionSuspendedCounter += 1;\n    this.columnIndexMapper.suspendOperations();\n    this.rowIndexMapper.suspendOperations();\n  };\n\n  /**\n   * Resumes the execution process. In combination with the {@link Core#suspendExecution}\n   * method it allows aggregating the table logic changes after which the cache is\n   * updated. Resuming the state automatically invokes the table cache updating process.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function resumeExecution\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested\n   * {@link Core#batchExecution} calls, it can be desire to recalculate the table\n   * after each batch.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n  this.resumeExecution = function () {\n    let forceFlushChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const nextValue = this.executionSuspendedCounter - 1;\n    this.executionSuspendedCounter = Math.max(nextValue, 0);\n    if (!this.isExecutionSuspended() && nextValue === this.executionSuspendedCounter || forceFlushChanges) {\n      this.columnIndexMapper.resumeOperations();\n      this.rowIndexMapper.resumeOperations();\n    }\n  };\n\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table execution process. After the execution of the operations, the internal table\n   * cache is recalculated once. As a result, it improves the performance of wrapped\n   * operations. Without batching, a similar case could trigger multiple table cache rebuilds.\n   *\n   * @memberof Core#\n   * @function batchExecution\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested calls,\n   * it can be a desire to recalculate the table after each batch.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchExecution(() => {\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n  this.batchExecution = function (wrappedOperations) {\n    let forceFlushChanges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.suspendExecution();\n    const result = wrappedOperations();\n    this.resumeExecution(forceFlushChanges);\n    return result;\n  };\n\n  /**\n   * It batches the rendering process and index recalculations. The method aggregates\n   * multi-line API calls into a callback and postpones the table rendering process\n   * as well aggregates the table logic changes such as index changes into one call\n   * after which the cache is updated. After the execution of the operations, the\n   * table is rendered, and the cache is updated once. As a result, it improves the\n   * performance of wrapped operations.\n   *\n   * @memberof Core#\n   * @function batch\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batch(() => {\n   *   hot.alter('insert_row_above', 5, 45);\n   *   hot.alter('insert_col_start', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'x');\n   *   hot.setDataAtCell(2, 2, 'c');\n   *   hot.setDataAtCell(3, 3, 'v');\n   *   hot.setDataAtCell(4, 4, 'b');\n   *   hot.setDataAtCell(5, 5, 'n');\n   *   hot.selectCell(0, 0);\n   *\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table will be re-rendered and cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n  this.batch = function (wrappedOperations) {\n    this.suspendRender();\n    this.suspendExecution();\n    const result = wrappedOperations();\n    this.resumeExecution();\n    this.resumeRender();\n    return result;\n  };\n\n  /**\n   * Updates dimensions of the table. The method compares previous dimensions with the current ones and updates accordingly.\n   *\n   * @memberof Core#\n   * @function refreshDimensions\n   * @fires Hooks#beforeRefreshDimensions\n   * @fires Hooks#afterRefreshDimensions\n   */\n  this.refreshDimensions = function () {\n    if (!instance.view) {\n      return;\n    }\n    const {\n      width: lastWidth,\n      height: lastHeight\n    } = instance.view.getLastSize();\n    const {\n      width,\n      height\n    } = instance.rootElement.getBoundingClientRect();\n    const isSizeChanged = width !== lastWidth || height !== lastHeight;\n    const isResizeBlocked = instance.runHooks('beforeRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width,\n      height\n    }, isSizeChanged) === false;\n    if (isResizeBlocked) {\n      return;\n    }\n    if (isSizeChanged || instance.view._wt.wtOverlays.scrollableElement === instance.rootWindow) {\n      instance.view.setLastSize(width, height);\n      instance.render();\n    }\n    instance.runHooks('afterRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width,\n      height\n    }, isSizeChanged);\n  };\n\n  /**\n   * The `updateData()` method replaces Handsontable's [`data`](@/api/options.md#data) with a new dataset.\n   *\n   * The `updateData()` method:\n   * - Keeps cells' states (e.g. cells' [formatting](@/guides/cell-features/formatting-cells.md) and cells' [`readOnly`](@/api/options.md#readonly) states)\n   * - Keeps rows' states (e.g. row order)\n   * - Keeps columns' states (e.g. column order)\n   *\n   * To replace Handsontable's [`data`](@/api/options.md#data) and reset states, use the [`loadData()`](#loaddata) method.\n   *\n   * Read more:\n   * - [Binding to data](@/guides/getting-started/binding-to-data.md)\n   * - [Saving data](@/guides/getting-started/saving-data.md)\n   *\n   * @memberof Core#\n   * @function updateData\n   * @since 11.1.0\n   * @param {Array} data An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data\n   * @param {string} [source] The source of the `updateData()` call\n   * @fires Hooks#beforeUpdateData\n   * @fires Hooks#afterUpdateData\n   * @fires Hooks#afterChange\n   */\n  this.updateData = function (data, source) {\n    replaceData(data, newDataMap => {\n      datamap = newDataMap;\n    }, newDataMap => {\n      datamap = newDataMap;\n      instance.columnIndexMapper.fitToLength(this.getInitialColumnCount());\n      instance.rowIndexMapper.fitToLength(this.countSourceRows());\n      grid.adjustRowsAndCols();\n    }, {\n      hotInstance: instance,\n      dataMap: datamap,\n      dataSource,\n      internalSource: 'updateData',\n      source,\n      metaManager,\n      firstRun\n    });\n  };\n\n  /**\n   * The `loadData()` method replaces Handsontable's [`data`](@/api/options.md#data) with a new dataset.\n   *\n   * Additionally, the `loadData()` method:\n   * - Resets cells' states (e.g. cells' [formatting](@/guides/cell-features/formatting-cells.md) and cells' [`readOnly`](@/api/options.md#readonly) states)\n   * - Resets rows' states (e.g. row order)\n   * - Resets columns' states (e.g. column order)\n   *\n   * To replace Handsontable's [`data`](@/api/options.md#data) without resetting states, use the [`updateData()`](#updatedata) method.\n   *\n   * Read more:\n   * - [Binding to data](@/guides/getting-started/binding-to-data.md)\n   * - [Saving data](@/guides/getting-started/saving-data.md)\n   *\n   * @memberof Core#\n   * @function loadData\n   * @param {Array} data An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data\n   * @param {string} [source] The source of the `loadData()` call\n   * @fires Hooks#beforeLoadData\n   * @fires Hooks#afterLoadData\n   * @fires Hooks#afterChange\n   */\n  this.loadData = function (data, source) {\n    replaceData(data, newDataMap => {\n      datamap = newDataMap;\n    }, () => {\n      metaManager.clearCellsCache();\n      instance.initIndexMappers();\n      grid.adjustRowsAndCols();\n      if (firstRun) {\n        firstRun = [null, 'loadData'];\n      }\n    }, {\n      hotInstance: instance,\n      dataMap: datamap,\n      dataSource,\n      internalSource: 'loadData',\n      source,\n      metaManager,\n      firstRun\n    });\n  };\n\n  /**\n   * Gets the initial column count, calculated based on the `columns` setting.\n   *\n   * @private\n   * @returns {number} The calculated number of columns.\n   */\n  this.getInitialColumnCount = function () {\n    const columnsSettings = tableMeta.columns;\n    let finalNrOfColumns = 0;\n\n    // We will check number of columns when the `columns` property was defined as an array. Columns option may\n    // narrow down or expand displayed dataset in that case.\n    if (Array.isArray(columnsSettings)) {\n      finalNrOfColumns = columnsSettings.length;\n    } else if (isFunction(columnsSettings)) {\n      if (instance.dataType === 'array') {\n        const nrOfSourceColumns = this.countSourceCols();\n        for (let columnIndex = 0; columnIndex < nrOfSourceColumns; columnIndex += 1) {\n          if (columnsSettings(columnIndex)) {\n            finalNrOfColumns += 1;\n          }\n        }\n\n        // Extended dataset by the `columns` property? Moved code right from the refactored `countCols` method.\n      } else if (instance.dataType === 'object' || instance.dataType === 'function') {\n        finalNrOfColumns = datamap.colToPropCache.length;\n      }\n\n      // In some cases we need to check columns length from the schema, i.e. `data` may be empty.\n    } else if (isDefined(tableMeta.dataSchema)) {\n      const schema = datamap.getSchema();\n\n      // Schema may be defined as an array of objects. Each object will define column.\n      finalNrOfColumns = Array.isArray(schema) ? schema.length : deepObjectSize(schema);\n    } else {\n      // We init index mappers by length of source data to provide indexes also for skipped indexes.\n      finalNrOfColumns = this.countSourceCols();\n    }\n    return finalNrOfColumns;\n  };\n\n  /**\n   * Init index mapper which manage indexes assigned to the data.\n   *\n   * @private\n   */\n  this.initIndexMappers = function () {\n    this.columnIndexMapper.initToLength(this.getInitialColumnCount());\n    this.rowIndexMapper.initToLength(this.countSourceRows());\n  };\n\n  /**\n   * Returns the current data object (the same one that was passed by `data` configuration option or `loadData` method,\n   * unless some modifications have been applied (i.e. Sequence of rows/columns was changed, some row/column was skipped).\n   * If that's the case - use the {@link Core#getSourceData} method.).\n   *\n   * Optionally you can provide cell range by defining `row`, `column`, `row2`, `column2` to get only a fragment of table data.\n   *\n   * @memberof Core#\n   * @function getData\n   * @param {number} [row] From visual row index.\n   * @param {number} [column] From visual column index.\n   * @param {number} [row2] To visual row index.\n   * @param {number} [column2] To visual column index.\n   * @returns {Array[]} Array with the data.\n   * @example\n   * ```js\n   * // Get all data (in order how it is rendered in the table).\n   * hot.getData();\n   * // Get data fragment (from top-left 0, 0 to bottom-right 3, 3).\n   * hot.getData(3, 3);\n   * // Get data fragment (from top-left 2, 1 to bottom-right 3, 3).\n   * hot.getData(2, 1, 3, 3);\n   * ```\n   */\n  this.getData = function (row, column, row2, column2) {\n    if (isUndefined(row)) {\n      return datamap.getAll();\n    }\n    return datamap.getRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2), datamap.DESTINATION_RENDERER);\n  };\n\n  /**\n   * Returns a string value of the selected range. Each column is separated by tab, each row is separated by a new\n   * line character.\n   *\n   * @memberof Core#\n   * @function getCopyableText\n   * @param {number} startRow From visual row index.\n   * @param {number} startCol From visual column index.\n   * @param {number} endRow To visual row index.\n   * @param {number} endCol To visual column index.\n   * @returns {string}\n   */\n  this.getCopyableText = function (startRow, startCol, endRow, endCol) {\n    return datamap.getCopyableText(instance._createCellCoords(startRow, startCol), instance._createCellCoords(endRow, endCol));\n  };\n\n  /**\n   * Returns the data's copyable value at specified `row` and `column` index.\n   *\n   * @memberof Core#\n   * @function getCopyableData\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {string}\n   */\n  this.getCopyableData = function (row, column) {\n    return datamap.getCopyable(row, datamap.colToProp(column));\n  };\n\n  /**\n   * Returns schema provided by constructor settings. If it doesn't exist then it returns the schema based on the data\n   * structure in the first row.\n   *\n   * @memberof Core#\n   * @function getSchema\n   * @returns {object} Schema object.\n   */\n  this.getSchema = function () {\n    return datamap.getSchema();\n  };\n\n  /**\n   * Use it if you need to change configuration after initialization. The `settings` argument is an object containing the changed\n   * settings, declared the same way as in the initial settings object.\n   *\n   * __Note__, that although the `updateSettings` method doesn't overwrite the previously declared settings, it might reset\n   * the settings made post-initialization. (for example - ignore changes made using the columnResize feature).\n   *\n   * Since 8.0.0 passing `columns` or `data` inside `settings` objects will result in resetting states corresponding to rows and columns\n   * (for example, row/column sequence, column width, row height, frozen columns etc.).\n   *\n   * Since 12.0.0 passing `data` inside `settings` objects no longer results in resetting states corresponding to rows and columns\n   * (for example, row/column sequence, column width, row height, frozen columns etc.).\n   *\n   * @memberof Core#\n   * @function updateSettings\n   * @param {object} settings A settings object (see {@link Options}). Only provide the settings that are changed, not the whole settings object that was used for initialization.\n   * @param {boolean} [init=false] Internally used for in initialization mode.\n   * @example\n   * ```js\n   * hot.updateSettings({\n   *    contextMenu: true,\n   *    colHeaders: true,\n   *    fixedRowsTop: 2\n   * });\n   * ```\n   * @fires Hooks#afterCellMetaReset\n   * @fires Hooks#afterUpdateSettings\n   */\n  this.updateSettings = function (settings) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const dataUpdateFunction = (firstRun ? instance.loadData : instance.updateData).bind(this);\n    let columnsAsFunc = false;\n    let i;\n    let j;\n    if (isDefined(settings.rows)) {\n      throw new Error('The \"rows\" setting is no longer supported. Do you mean startRows, minRows or maxRows?');\n    }\n    if (isDefined(settings.cols)) {\n      throw new Error('The \"cols\" setting is no longer supported. Do you mean startCols, minCols or maxCols?');\n    }\n    if (isDefined(settings.ganttChart)) {\n      throw new Error('Since 8.0.0 the \"ganttChart\" setting is no longer supported.');\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (i in settings) {\n      if (i === 'data') {\n        // Do nothing. loadData will be triggered later\n      } else if (i === 'language') {\n        setLanguage(settings.language);\n      } else if (i === 'className') {\n        setClassName('className', settings.className);\n      } else if (i === 'tableClassName' && instance.table) {\n        setClassName('tableClassName', settings.tableClassName);\n        instance.view._wt.wtOverlays.syncOverlayTableClassNames();\n      } else if (Hooks.getSingleton().isRegistered(i) || Hooks.getSingleton().isDeprecated(i)) {\n        if (isFunction(settings[i]) || Array.isArray(settings[i])) {\n          settings[i].initialHook = true;\n          instance.addHook(i, settings[i]);\n        }\n      } else if (!init && hasOwnProperty(settings, i)) {\n        // Update settings\n        globalMeta[i] = settings[i];\n      }\n    }\n\n    // Load data or create data map\n    if (settings.data === undefined && tableMeta.data === undefined) {\n      dataUpdateFunction(null, 'updateSettings'); // data source created just now\n    } else if (settings.data !== undefined) {\n      dataUpdateFunction(settings.data, 'updateSettings'); // data source given as option\n    } else if (settings.columns !== undefined) {\n      datamap.createMap();\n\n      // The `column` property has changed - dataset may be expanded or narrowed down. The `loadData` do the same.\n      instance.initIndexMappers();\n    }\n    const clen = instance.countCols();\n    const columnSetting = tableMeta.columns;\n\n    // Init columns constructors configuration\n    if (columnSetting && isFunction(columnSetting)) {\n      columnsAsFunc = true;\n    }\n\n    // Clear cell meta cache\n    if (settings.cell !== undefined || settings.cells !== undefined || settings.columns !== undefined) {\n      metaManager.clearCache();\n    }\n    if (clen > 0) {\n      for (i = 0, j = 0; i < clen; i++) {\n        // Use settings provided by user\n        if (columnSetting) {\n          const column = columnsAsFunc ? columnSetting(i) : columnSetting[j];\n          if (column) {\n            metaManager.updateColumnMeta(j, column);\n          }\n        }\n        j += 1;\n      }\n    }\n    if (isDefined(settings.cell)) {\n      objectEach(settings.cell, cell => {\n        instance.setCellMetaObject(cell.row, cell.col, cell);\n      });\n    }\n    instance.runHooks('afterCellMetaReset');\n    let currentHeight = instance.rootElement.style.height;\n    if (currentHeight !== '') {\n      currentHeight = parseInt(instance.rootElement.style.height, 10);\n    }\n    let height = settings.height;\n    if (isFunction(height)) {\n      height = height();\n    }\n    if (init) {\n      const initialStyle = instance.rootElement.getAttribute('style');\n      if (initialStyle) {\n        instance.rootElement.setAttribute('data-initialstyle', instance.rootElement.getAttribute('style'));\n      }\n    }\n    if (height === null) {\n      const initialStyle = instance.rootElement.getAttribute('data-initialstyle');\n      if (initialStyle && (initialStyle.indexOf('height') > -1 || initialStyle.indexOf('overflow') > -1)) {\n        instance.rootElement.setAttribute('style', initialStyle);\n      } else {\n        instance.rootElement.style.height = '';\n        instance.rootElement.style.overflow = '';\n      }\n    } else if (height !== undefined) {\n      instance.rootElement.style.height = isNaN(height) ? `${height}` : `${height}px`;\n      instance.rootElement.style.overflow = 'hidden';\n    }\n    if (typeof settings.width !== 'undefined') {\n      let width = settings.width;\n      if (isFunction(width)) {\n        width = width();\n      }\n      instance.rootElement.style.width = isNaN(width) ? `${width}` : `${width}px`;\n    }\n    if (!init) {\n      if (instance.view) {\n        instance.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();\n        instance.view._wt.exportSettingsAsClassNames();\n      }\n      instance.runHooks('afterUpdateSettings', settings);\n    }\n    grid.adjustRowsAndCols();\n    if (instance.view && !firstRun) {\n      instance.forceFullRender = true; // used when data was changed\n      editorManager.lockEditor();\n      instance._refreshBorders(null);\n      instance.view._wt.wtOverlays.adjustElementsSize();\n      editorManager.unlockEditor();\n    }\n    if (!init && instance.view && (currentHeight === '' || height === '' || height === undefined) && currentHeight !== height) {\n      instance.view._wt.wtOverlays.updateMainScrollableElements();\n    }\n  };\n\n  /**\n   * Gets the value of the currently focused cell.\n   *\n   * For column headers and row headers, returns `null`.\n   *\n   * @memberof Core#\n   * @function getValue\n   * @returns {*} The value of the focused cell.\n   */\n  this.getValue = function () {\n    const sel = instance.getSelectedLast();\n    if (tableMeta.getValue) {\n      if (isFunction(tableMeta.getValue)) {\n        return tableMeta.getValue.call(instance);\n      } else if (sel) {\n        return instance.getData()[sel[0][0]][tableMeta.getValue];\n      }\n    } else if (sel) {\n      return instance.getDataAtCell(sel[0], sel[1]);\n    }\n  };\n\n  /**\n   * Returns the object settings.\n   *\n   * @memberof Core#\n   * @function getSettings\n   * @returns {TableMeta} Object containing the current table settings.\n   */\n  this.getSettings = function () {\n    return tableMeta;\n  };\n\n  /**\n   * Clears the data from the table (the table settings remain intact).\n   *\n   * @memberof Core#\n   * @function clear\n   */\n  this.clear = function () {\n    this.selectAll();\n    this.emptySelectedCells();\n  };\n\n  /**\n   * The `alter()` method lets you alter the grid's structure\n   * by adding or removing rows and columns at specified positions.\n   *\n   * ::: tip\n   * The `alter()` method works only when your [`data`](@/api/options.md#data)\n   * is an [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).\n   * :::\n   *\n   * ```js\n   * // above row 10 (by visual index), insert 1 new row\n   * hot.alter('insert_row_above', 10);\n   * ```\n   *\n   *  | Action               | With `index` | Without `index` |\n   *  | -------------------- | ------------ | --------------- |\n   *  | `'insert_row_above'` | Inserts rows above the `index` row. | Inserts rows above the first row. |\n   *  | `'insert_row_below'` | Inserts rows below the `index` row. | Inserts rows below the last row. |\n   *  | `'remove_row'`       | Removes rows, starting from the `index` row. | Removes rows, starting from the last row. |\n   *  | `'insert_col_start'` | Inserts columns before the `index` column. | Inserts columns before the first column. |\n   *  | `'insert_col_end'`   | Inserts columns after the `index` column. | Inserts columns after the last column. |\n   *  | `'remove_col'`       | Removes columns, starting from the `index` column. | Removes columns, starting from the last column. |\n   *\n   * Additional information about `'insert_col_start'` and `'insert_col_end'`:\n   * - Their behavior depends on your [`layoutDirection`](@/api/options.md#layoutdirection).\n   * - If the provided `index` is higher than the actual number of columns, Handsontable doesn't generate\n   * the columns missing in between. Instead, the new columns are inserted next to the last column.\n   *\n   * @memberof Core#\n   * @function alter\n   * @param {string} action Available operations:\n   * <ul>\n   *    <li> `'insert_row_above'` </li>\n   *    <li> `'insert_row_below'` </li>\n   *    <li> `'remove_row'` </li> </li>\n   *    <li> `'insert_col_start'` </li>\n   *    <li> `'insert_col_end'` </li>\n   *    <li> `'remove_col'` </li>\n   * </ul>\n   * @param {number|number[]} [index] A visual index of the row/column before or after which the new row/column will be\n   *                                inserted or removed. Can also be an array of arrays, in format `[[index, amount],...]`.\n   * @param {number} [amount] The amount of rows or columns to be inserted or removed (default: `1`).\n   * @param {string} [source] Source indicator.\n   * @param {boolean} [keepEmptyRows] If set to `true`: prevents removing empty rows.\n   * @example\n   * ```js\n   * // above row 10 (by visual index), insert 1 new row\n   * hot.alter('insert_row_above', 10);\n   *\n   * // below row 10 (by visual index), insert 3 new rows\n   * hot.alter('insert_row_below', 10, 3);\n   *\n   * // in the LTR layout direction: to the left of column 10 (by visual index), insert 3 new columns\n   * // in the RTL layout direction: to the right of column 10 (by visual index), insert 3 new columns\n   * hot.alter('insert_col_start', 10, 3);\n   *\n   * // in the LTR layout direction: to the right of column 10 (by visual index), insert 1 new column\n   * // in the RTL layout direction: to the left of column 10 (by visual index), insert 1 new column\n   * hot.alter('insert_col_end', 10);\n   *\n   * // remove 2 rows, starting from row 10 (by visual index)\n   * hot.alter('remove_row', 10, 2);\n   *\n   * // remove 3 rows, starting from row 1 (by visual index)\n   * // remove 2 rows, starting from row 5 (by visual index)\n   * hot.alter('remove_row', [[1, 3], [5, 2]]);\n   * ```\n   */\n  this.alter = function (action, index, amount, source, keepEmptyRows) {\n    grid.alter(action, index, amount, source, keepEmptyRows);\n  };\n\n  /**\n   * Returns a TD element for the given `row` and `column` arguments, if it is rendered on screen.\n   * Returns `null` if the TD is not rendered on screen (probably because that part of the table is not visible).\n   *\n   * @memberof Core#\n   * @function getCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   * if the wanted cell is in the range of fixed rows, it will return a TD element from the `top` overlay.\n   * @returns {HTMLTableCellElement|null} The cell's TD element.\n   */\n  this.getCell = function (row, column) {\n    let topmost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let renderableColumnIndex = column; // Handling also column headers.\n    let renderableRowIndex = row; // Handling also row headers.\n\n    if (column >= 0) {\n      if (this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {\n        return null;\n      }\n      renderableColumnIndex = this.columnIndexMapper.getRenderableFromVisualIndex(column);\n    }\n    if (row >= 0) {\n      if (this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {\n        return null;\n      }\n      renderableRowIndex = this.rowIndexMapper.getRenderableFromVisualIndex(row);\n    }\n    if (renderableRowIndex === null || renderableColumnIndex === null) {\n      return null;\n    }\n    return instance.view.getCellAtCoords(instance._createCellCoords(renderableRowIndex, renderableColumnIndex), topmost);\n  };\n\n  /**\n   * Returns the coordinates of the cell, provided as a HTML table cell element.\n   *\n   * @memberof Core#\n   * @function getCoords\n   * @param {HTMLTableCellElement} element The HTML Element representing the cell.\n   * @returns {CellCoords|null} Visual coordinates object.\n   * @example\n   * ```js\n   * hot.getCoords(hot.getCell(1, 1));\n   * // it returns CellCoords object instance with props row: 1 and col: 1.\n   * ```\n   */\n  this.getCoords = function (element) {\n    const renderableCoords = this.view._wt.wtTable.getCoords(element);\n    if (renderableCoords === null) {\n      return null;\n    }\n    const {\n      row: renderableRow,\n      col: renderableColumn\n    } = renderableCoords;\n    let visualRow = renderableRow;\n    let visualColumn = renderableColumn;\n    if (renderableRow >= 0) {\n      visualRow = this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);\n    }\n    if (renderableColumn >= 0) {\n      visualColumn = this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);\n    }\n    return instance._createCellCoords(visualRow, visualColumn);\n  };\n\n  /**\n   * Returns the property name that corresponds with the given column index.\n   * If the data source is an array of arrays, it returns the columns index.\n   *\n   * @memberof Core#\n   * @function colToProp\n   * @param {number} column Visual column index.\n   * @returns {string|number} Column property or physical column index.\n   */\n  this.colToProp = function (column) {\n    return datamap.colToProp(column);\n  };\n\n  /**\n   * Returns column index that corresponds with the given property.\n   *\n   * @memberof Core#\n   * @function propToCol\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {number} Visual column index.\n   */\n  this.propToCol = function (prop) {\n    return datamap.propToCol(prop);\n  };\n\n  /**\n   * Translate physical row index into visual.\n   *\n   * This method is useful when you want to retrieve visual row index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualRow\n   * @param {number} row Physical row index.\n   * @returns {number} Returns visual row index.\n   */\n  this.toVisualRow = row => this.rowIndexMapper.getVisualFromPhysicalIndex(row);\n\n  /**\n   * Translate physical column index into visual.\n   *\n   * This method is useful when you want to retrieve visual column index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualColumn\n   * @param {number} column Physical column index.\n   * @returns {number} Returns visual column index.\n   */\n  this.toVisualColumn = column => this.columnIndexMapper.getVisualFromPhysicalIndex(column);\n\n  /**\n   * Translate visual row index into physical.\n   *\n   * This method is useful when you want to retrieve physical row index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalRow\n   * @param {number} row Visual row index.\n   * @returns {number} Returns physical row index.\n   */\n  this.toPhysicalRow = row => this.rowIndexMapper.getPhysicalFromVisualIndex(row);\n\n  /**\n   * Translate visual column index into physical.\n   *\n   * This method is useful when you want to retrieve physical column index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalColumn\n   * @param {number} column Visual column index.\n   * @returns {number} Returns physical column index.\n   */\n  this.toPhysicalColumn = column => this.columnIndexMapper.getPhysicalFromVisualIndex(column);\n\n  /**\n   * @description\n   * Returns the cell value at `row`, `column`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Data at cell.\n   */\n  this.getDataAtCell = function (row, column) {\n    return datamap.get(row, datamap.colToProp(column));\n  };\n\n  /**\n   * Returns value at visual `row` and `prop` indexes.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRowProp\n   * @param {number} row Visual row index.\n   * @param {string} prop Property name.\n   * @returns {*} Cell value.\n   */\n  this.getDataAtRowProp = function (row, prop) {\n    return datamap.get(row, prop);\n  };\n\n  /**\n   * @description\n   * Returns array of column values from the data source.\n   *\n   * __Note__: If columns were reordered or sorted, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of cell values.\n   */\n  this.getDataAtCol = function (column) {\n    const columnData = [];\n    const dataByRows = datamap.getRange(instance._createCellCoords(0, column), instance._createCellCoords(tableMeta.data.length - 1, column), datamap.DESTINATION_RENDERER);\n    for (let i = 0; i < dataByRows.length; i += 1) {\n      for (let j = 0; j < dataByRows[i].length; j += 1) {\n        columnData.push(dataByRows[i][j]);\n      }\n    }\n    return columnData;\n  };\n\n  /**\n   * Given the object property name (e.g. `'first.name'` or `'0'`), returns an array of column's values from the table data.\n   * You can also provide a column index as the first argument.\n   *\n   * @memberof Core#\n   * @function getDataAtProp\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {Array} Array of cell values.\n   */\n  // TODO: Getting data from `datamap` should work on visual indexes.\n  this.getDataAtProp = function (prop) {\n    const columnData = [];\n    const dataByRows = datamap.getRange(instance._createCellCoords(0, datamap.propToCol(prop)), instance._createCellCoords(tableMeta.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);\n    for (let i = 0; i < dataByRows.length; i += 1) {\n      for (let j = 0; j < dataByRows[i].length; j += 1) {\n        columnData.push(dataByRows[i][j]);\n      }\n    }\n    return columnData;\n  };\n\n  /**\n   * Returns a clone of the source data object.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * __Note__: This method may return incorrect values for cells that contain\n   * [formulas](@/guides/formulas/formula-calculation.md). This is because `getSourceData()`\n   * operates on source data ([physical indexes](@/api/indexMapper.md)),\n   * whereas formulas operate on visual data (visual indexes).\n   *\n   * @memberof Core#\n   * @function getSourceData\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array[]|object[]} The table data.\n   */\n  this.getSourceData = function (row, column, row2, column2) {\n    let data;\n    if (row === undefined) {\n      data = dataSource.getData();\n    } else {\n      data = dataSource.getByRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2));\n    }\n    return data;\n  };\n\n  /**\n   * Returns the source data object as an arrays of arrays format even when source data was provided in another format.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataArray\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array} An array of arrays.\n   */\n  this.getSourceDataArray = function (row, column, row2, column2) {\n    let data;\n    if (row === undefined) {\n      data = dataSource.getData(true);\n    } else {\n      data = dataSource.getByRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2), true);\n    }\n    return data;\n  };\n\n  /**\n   * Returns an array of column values from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of the column's cell values.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n  this.getSourceDataAtCol = function (column) {\n    return dataSource.getAtColumn(column);\n  };\n\n  /* eslint-disable jsdoc/require-param */\n  /**\n   * Set the provided value in the source data set at the provided coordinates.\n   *\n   * @memberof Core#\n   * @function setSourceDataAtCell\n   * @param {number|Array} row Physical row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {number|string} column Physical column index / prop name.\n   * @param {*} value The value to be set at the provided coordinates.\n   * @param {string} [source] Source of the change as a string.\n   */\n  /* eslint-enable jsdoc/require-param */\n  this.setSourceDataAtCell = function (row, column, value, source) {\n    const input = setDataInputToArray(row, column, value);\n    const isThereAnySetSourceListener = this.hasHook('afterSetSourceDataAtCell');\n    const changesForHook = [];\n    if (isThereAnySetSourceListener) {\n      arrayEach(input, _ref8 => {\n        let [changeRow, changeProp, changeValue] = _ref8;\n        changesForHook.push([changeRow, changeProp, dataSource.getAtCell(changeRow, changeProp),\n        // The previous value.\n        changeValue]);\n      });\n    }\n    arrayEach(input, _ref9 => {\n      let [changeRow, changeProp, changeValue] = _ref9;\n      dataSource.setAtCell(changeRow, changeProp, changeValue);\n    });\n    if (isThereAnySetSourceListener) {\n      this.runHooks('afterSetSourceDataAtCell', changesForHook, source);\n    }\n    this.render();\n    const activeEditor = instance.getActiveEditor();\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  };\n\n  /**\n   * Returns a single row of the data (array or object, depending on what data format you use).\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array|object} Single row of data.\n   */\n  this.getSourceDataAtRow = function (row) {\n    return dataSource.getAtRow(row);\n  };\n\n  /**\n   * Returns a single value from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCell\n   * @param {number} row Physical row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Cell data.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n  this.getSourceDataAtCell = function (row, column) {\n    return dataSource.getAtCell(row, column);\n  };\n\n  /**\n   * @description\n   * Returns a single row of the data.\n   *\n   * __Note__: If rows were reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRow\n   * @param {number} row Visual row index.\n   * @returns {Array} Array of row's cell data.\n   */\n  this.getDataAtRow = function (row) {\n    const data = datamap.getRange(instance._createCellCoords(row, 0), instance._createCellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);\n    return data[0] || [];\n  };\n\n  /**\n   * @description\n   * Returns a data type defined in the Handsontable settings under the `type` key ({@link Options#type}).\n   * If there are cells with different types in the selected range, it returns `'mixed'`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataType\n   * @param {number} rowFrom From visual row index.\n   * @param {number} columnFrom From visual column index.\n   * @param {number} rowTo To visual row index.\n   * @param {number} columnTo To visual column index.\n   * @returns {string} Cell type (e.q: `'mixed'`, `'text'`, `'numeric'`, `'autocomplete'`).\n   */\n  this.getDataType = function (rowFrom, columnFrom, rowTo, columnTo) {\n    const coords = rowFrom === undefined ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];\n    const [rowStart, columnStart] = coords;\n    let [,, rowEnd, columnEnd] = coords;\n    let previousType = null;\n    let currentType = null;\n    if (rowEnd === undefined) {\n      rowEnd = rowStart;\n    }\n    if (columnEnd === undefined) {\n      columnEnd = columnStart;\n    }\n    let type = 'mixed';\n    rangeEach(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, rowEnd), row => {\n      let isTypeEqual = true;\n      rangeEach(Math.max(Math.min(columnStart, columnEnd), 0), Math.max(columnStart, columnEnd), column => {\n        const cellType = this.getCellMeta(row, column);\n        currentType = cellType.type;\n        if (previousType) {\n          isTypeEqual = previousType === currentType;\n        } else {\n          previousType = currentType;\n        }\n        return isTypeEqual;\n      });\n      type = isTypeEqual ? currentType : 'mixed';\n      return isTypeEqual;\n    });\n    return type;\n  };\n\n  /**\n   * Remove a property defined by the `key` argument from the cell meta object for the provided `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function removeCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @fires Hooks#beforeRemoveCellMeta\n   * @fires Hooks#afterRemoveCellMeta\n   */\n  this.removeCellMeta = function (row, column, key) {\n    const [physicalRow, physicalColumn] = [this.toPhysicalRow(row), this.toPhysicalColumn(column)];\n    let cachedValue = metaManager.getCellMetaKeyValue(physicalRow, physicalColumn, key);\n    const hookResult = instance.runHooks('beforeRemoveCellMeta', row, column, key, cachedValue);\n    if (hookResult !== false) {\n      metaManager.removeCellMeta(physicalRow, physicalColumn, key);\n      instance.runHooks('afterRemoveCellMeta', row, column, key, cachedValue);\n    }\n    cachedValue = null;\n  };\n\n  /**\n   * Removes or adds one or more rows of the cell meta objects to the cell meta collections.\n   *\n   * @since 0.30.0\n   * @memberof Core#\n   * @function spliceCellsMeta\n   * @param {number} visualIndex A visual index that specifies at what position to add/remove items.\n   * @param {number} [deleteAmount=0] The number of items to be removed. If set to 0, no cell meta objects will be removed.\n   * @param {...object} [cellMetaRows] The new cell meta row objects to be added to the cell meta collection.\n   */\n  this.spliceCellsMeta = function (visualIndex) {\n    let deleteAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    for (var _len16 = arguments.length, cellMetaRows = new Array(_len16 > 2 ? _len16 - 2 : 0), _key16 = 2; _key16 < _len16; _key16++) {\n      cellMetaRows[_key16 - 2] = arguments[_key16];\n    }\n    if (cellMetaRows.length > 0 && !Array.isArray(cellMetaRows[0])) {\n      throw new Error('The 3rd argument (cellMetaRows) has to be passed as an array of cell meta objects array.');\n    }\n    if (deleteAmount > 0) {\n      metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);\n    }\n    if (cellMetaRows.length > 0) {\n      arrayEach(cellMetaRows.reverse(), cellMetaRow => {\n        metaManager.createRow(this.toPhysicalRow(visualIndex));\n        arrayEach(cellMetaRow, (cellMeta, columnIndex) => this.setCellMetaObject(visualIndex, columnIndex, cellMeta));\n      });\n    }\n    instance.render();\n  };\n\n  /**\n   * Set cell meta data object defined by `prop` to the corresponding params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMetaObject\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} prop Meta object.\n   */\n  this.setCellMetaObject = function (row, column, prop) {\n    if (typeof prop === 'object') {\n      objectEach(prop, (value, key) => {\n        this.setCellMeta(row, column, key, value);\n      });\n    }\n  };\n\n  /**\n   * Sets a property defined by the `key` property to the meta object of a cell corresponding to params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @param {string} value Property value.\n   * @fires Hooks#beforeSetCellMeta\n   * @fires Hooks#afterSetCellMeta\n   */\n  this.setCellMeta = function (row, column, key, value) {\n    const allowSetCellMeta = instance.runHooks('beforeSetCellMeta', row, column, key, value);\n    if (allowSetCellMeta === false) {\n      return;\n    }\n    let physicalRow = row;\n    let physicalColumn = column;\n    if (row < this.countRows()) {\n      physicalRow = this.toPhysicalRow(row);\n    }\n    if (column < this.countCols()) {\n      physicalColumn = this.toPhysicalColumn(column);\n    }\n    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);\n    instance.runHooks('afterSetCellMeta', row, column, key, value);\n  };\n\n  /**\n   * Get all the cells meta settings at least once generated in the table (in order of cell initialization).\n   *\n   * @memberof Core#\n   * @function getCellsMeta\n   * @returns {Array} Returns an array of ColumnSettings object instances.\n   */\n  this.getCellsMeta = function () {\n    return metaManager.getCellsMeta();\n  };\n\n  /**\n   * Returns the cell properties object for the given `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function getCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {object} The cell properties object.\n   * @fires Hooks#beforeGetCellMeta\n   * @fires Hooks#afterGetCellMeta\n   */\n  this.getCellMeta = function (row, column) {\n    let physicalRow = this.toPhysicalRow(row);\n    let physicalColumn = this.toPhysicalColumn(column);\n    if (physicalRow === null) {\n      physicalRow = row;\n    }\n    if (physicalColumn === null) {\n      physicalColumn = column;\n    }\n    return metaManager.getCellMeta(physicalRow, physicalColumn, {\n      visualRow: row,\n      visualColumn: column\n    });\n  };\n\n  /**\n   * Returns an array of cell meta objects for specified physical row index.\n   *\n   * @memberof Core#\n   * @function getCellMetaAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array}\n   */\n  this.getCellMetaAtRow = function (row) {\n    return metaManager.getCellsMetaAtRow(row);\n  };\n\n  /**\n   * Checks if your [data format](@/guides/getting-started/binding-to-data.md#compatible-data-types)\n   * and [configuration options](@/guides/getting-started/configuration-options.md)\n   * allow for changing the number of columns.\n   *\n   * Returns `false` when your data is an array of objects,\n   * or when you use the [`columns`](@/api/options.md#columns) option.\n   * Otherwise, returns `true`.\n   *\n   * @memberof Core#\n   * @function isColumnModificationAllowed\n   * @returns {boolean}\n   */\n  this.isColumnModificationAllowed = function () {\n    return !(instance.dataType === 'object' || tableMeta.columns);\n  };\n\n  /**\n   * Returns the cell renderer function by given `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellRenderer\n   * @param {number|object} rowOrMeta Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function} Returns the renderer function.\n   * @example\n   * ```js\n   * // Get cell renderer using `row` and `column` coordinates.\n   * hot.getCellRenderer(1, 1);\n   * // Get cell renderer using cell meta object.\n   * hot.getCellRenderer(hot.getCellMeta(1, 1));\n   * ```\n   */\n  this.getCellRenderer = function (rowOrMeta, column) {\n    const cellRenderer = typeof rowOrMeta === 'number' ? instance.getCellMeta(rowOrMeta, column).renderer : rowOrMeta.renderer;\n    if (typeof cellRenderer === 'string') {\n      return getRenderer(cellRenderer);\n    }\n    return isUndefined(cellRenderer) ? getRenderer('text') : cellRenderer;\n  };\n\n  /**\n   * Returns the cell editor class by the provided `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellEditor\n   * @param {number} rowOrMeta Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function|boolean} Returns the editor class or `false` is cell editor is disabled.\n   * @example\n   * ```js\n   * // Get cell editor class using `row` and `column` coordinates.\n   * hot.getCellEditor(1, 1);\n   * // Get cell editor class using cell meta object.\n   * hot.getCellEditor(hot.getCellMeta(1, 1));\n   * ```\n   */\n  this.getCellEditor = function (rowOrMeta, column) {\n    const cellEditor = typeof rowOrMeta === 'number' ? instance.getCellMeta(rowOrMeta, column).editor : rowOrMeta.editor;\n    if (typeof cellEditor === 'string') {\n      return getEditor(cellEditor);\n    }\n    return isUndefined(cellEditor) ? getEditor('text') : cellEditor;\n  };\n\n  /**\n   * Returns the cell validator by `row` and `column`.\n   *\n   * @memberof Core#\n   * @function getCellValidator\n   * @param {number|object} rowOrMeta Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function|RegExp|undefined} The validator function.\n   * @example\n   * ```js\n   * // Get cell validator using `row` and `column` coordinates.\n   * hot.getCellValidator(1, 1);\n   * // Get cell validator using cell meta object.\n   * hot.getCellValidator(hot.getCellMeta(1, 1));\n   * ```\n   */\n  this.getCellValidator = function (rowOrMeta, column) {\n    const cellValidator = typeof rowOrMeta === 'number' ? instance.getCellMeta(rowOrMeta, column).validator : rowOrMeta.validator;\n    if (typeof cellValidator === 'string') {\n      return getValidator(cellValidator);\n    }\n    return cellValidator;\n  };\n\n  /**\n   * Validates every cell in the data set,\n   * using a [validator function](@/guides/cell-functions/cell-validator.md) configured for each cell.\n   *\n   * Doesn't validate cells that are currently [trimmed](@/guides/rows/row-trimming.md),\n   * [hidden](@/guides/rows/row-hiding.md), or [filtered](@/guides/columns/column-filter.md),\n   * as such cells are not included in the data set until you bring them back again.\n   *\n   * After the validation, the `callback` function is fired, with the `valid` argument set to:\n   * - `true` for valid cells\n   * - `false` for invalid cells\n   *\n   * @memberof Core#\n   * @function validateCells\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateCells((valid) => {\n   *   if (valid) {\n   *     // ... code for validated cells\n   *   }\n   * })\n   * ```\n   */\n  this.validateCells = function (callback) {\n    this._validateCells(callback);\n  };\n\n  /**\n   * Validates rows using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateRows\n   * @param {Array} [rows] Array of validation target visual row indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateRows([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated rows\n   *   }\n   * })\n   * ```\n   */\n  this.validateRows = function (rows, callback) {\n    if (!Array.isArray(rows)) {\n      throw new Error('validateRows parameter `rows` must be an array');\n    }\n    this._validateCells(callback, rows);\n  };\n\n  /**\n   * Validates columns using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateColumns\n   * @param {Array} [columns] Array of validation target visual columns indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateColumns([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated columns\n   *   }\n   * })\n   * ```\n   */\n  this.validateColumns = function (columns, callback) {\n    if (!Array.isArray(columns)) {\n      throw new Error('validateColumns parameter `columns` must be an array');\n    }\n    this._validateCells(callback, undefined, columns);\n  };\n\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it would equal `true`.\n   *\n   * Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _validateCells\n   * @param {Function} [callback] The callback function.\n   * @param {Array} [rows] An array of validation target visual row indexes.\n   * @param {Array} [columns] An array of validation target visual column indexes.\n   */\n  this._validateCells = function (callback, rows, columns) {\n    const waitingForValidator = new ValidatorsQueue();\n    if (callback) {\n      waitingForValidator.onQueueEmpty = callback;\n    }\n    let i = instance.countRows() - 1;\n    while (i >= 0) {\n      if (rows !== undefined && rows.indexOf(i) === -1) {\n        i -= 1;\n        continue;\n      }\n      let j = instance.countCols() - 1;\n      while (j >= 0) {\n        if (columns !== undefined && columns.indexOf(j) === -1) {\n          j -= 1;\n          continue;\n        }\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), result => {\n          if (typeof result !== 'boolean') {\n            throw new Error('Validation error: result is not boolean');\n          }\n          if (result === false) {\n            waitingForValidator.valid = false;\n          }\n          waitingForValidator.removeValidatorFormQueue();\n        }, 'validateCells');\n        j -= 1;\n      }\n      i -= 1;\n    }\n    waitingForValidator.checkIfQueueIsEmpty();\n  };\n\n  /**\n   * Returns an array of row headers' values (if they are enabled). If param `row` was given, it returns the header of the given row as a string.\n   *\n   * @memberof Core#\n   * @function getRowHeader\n   * @param {number} [row] Visual row index.\n   * @fires Hooks#modifyRowHeader\n   * @returns {Array|string|number} Array of header values / single header value.\n   */\n  this.getRowHeader = function (row) {\n    let rowHeader = tableMeta.rowHeaders;\n    let physicalRow = row;\n    if (physicalRow !== undefined) {\n      physicalRow = instance.runHooks('modifyRowHeader', physicalRow);\n    }\n    if (physicalRow === undefined) {\n      rowHeader = [];\n      rangeEach(instance.countRows() - 1, i => {\n        rowHeader.push(instance.getRowHeader(i));\n      });\n    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== undefined) {\n      rowHeader = rowHeader[physicalRow];\n    } else if (isFunction(rowHeader)) {\n      rowHeader = rowHeader(physicalRow);\n    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {\n      rowHeader = physicalRow + 1;\n    }\n    return rowHeader;\n  };\n\n  /**\n   * Returns information about if this table is configured to display row headers.\n   *\n   * @memberof Core#\n   * @function hasRowHeaders\n   * @returns {boolean} `true` if the instance has the row headers enabled, `false` otherwise.\n   */\n  this.hasRowHeaders = function () {\n    return !!tableMeta.rowHeaders;\n  };\n\n  /**\n   * Returns information about if this table is configured to display column headers.\n   *\n   * @memberof Core#\n   * @function hasColHeaders\n   * @returns {boolean} `true` if the instance has the column headers enabled, `false` otherwise.\n   */\n  this.hasColHeaders = function () {\n    if (tableMeta.colHeaders !== undefined && tableMeta.colHeaders !== null) {\n      // Polymer has empty value = null\n      return !!tableMeta.colHeaders;\n    }\n    for (let i = 0, ilen = instance.countCols(); i < ilen; i++) {\n      if (instance.getColHeader(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Gets the values of column headers (if column headers are [enabled](@/api/options.md#colheaders)).\n   *\n   * To get an array with the values of all\n   * [bottom-most](@/guides/cell-features/clipboard.md#copy-with-headers) column headers,\n   * call `getColHeader()` with no arguments.\n   *\n   * To get the value of the bottom-most header of a specific column, use the `column` parameter.\n   *\n   * To get the value of a [specific-level](@/guides/columns/column-groups.md) header\n   * of a specific column, use the `column` and `headerLevel` parameters.\n   *\n   * Read more:\n   * - [Guides: Column groups](@/guides/columns/column-groups.md)\n   * - [Options: `colHeaders`](@/api/options.md#colheaders)\n   * - [Guides: Copy with headers](@/guides/cell-features/clipboard.md#copy-with-headers)\n   *\n   * ```js\n   * // get the contents of all bottom-most column headers\n   * hot.getColHeader();\n   *\n   * // get the contents of the bottom-most header of a specific column\n   * hot.getColHeader(5);\n   *\n   * // get the contents of a specific column header at a specific level\n   * hot.getColHeader(5, -2);\n   * ```\n   *\n   * @memberof Core#\n   * @function getColHeader\n   * @param {number} [column] A visual column index.\n   * @param {number} [headerLevel=-1] (Since 12.3.0) Header level index. Accepts positive (0 to n)\n   *                                  and negative (-1 to -n) values. For positive values, 0 points to the\n   *                                  topmost header. For negative values, -1 points to the bottom-most\n   *                                  header (the header closest to the cells).\n   * @fires Hooks#modifyColHeader\n   * @fires Hooks#modifyColumnHeaderValue\n   * @returns {Array|string|number} Column header values.\n   */\n  this.getColHeader = function (column) {\n    let headerLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    const columnIndex = instance.runHooks('modifyColHeader', column);\n    if (columnIndex === undefined) {\n      const out = [];\n      const ilen = instance.countCols();\n      for (let i = 0; i < ilen; i++) {\n        out.push(instance.getColHeader(i));\n      }\n      return out;\n    }\n    let result = tableMeta.colHeaders;\n    const translateVisualIndexToColumns = function (visualColumnIndex) {\n      const arr = [];\n      const columnsLen = instance.countCols();\n      let index = 0;\n      for (; index < columnsLen; index++) {\n        if (isFunction(tableMeta.columns) && tableMeta.columns(index)) {\n          arr.push(index);\n        }\n      }\n      return arr[visualColumnIndex];\n    };\n    const physicalColumn = instance.toPhysicalColumn(columnIndex);\n    const prop = translateVisualIndexToColumns(physicalColumn);\n    if (tableMeta.colHeaders === false) {\n      result = null;\n    } else if (tableMeta.columns && isFunction(tableMeta.columns) && tableMeta.columns(prop) && tableMeta.columns(prop).title) {\n      result = tableMeta.columns(prop).title;\n    } else if (tableMeta.columns && tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) {\n      result = tableMeta.columns[physicalColumn].title;\n    } else if (Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] !== undefined) {\n      result = tableMeta.colHeaders[physicalColumn];\n    } else if (isFunction(tableMeta.colHeaders)) {\n      result = tableMeta.colHeaders(physicalColumn);\n    } else if (tableMeta.colHeaders && typeof tableMeta.colHeaders !== 'string' && typeof tableMeta.colHeaders !== 'number') {\n      result = spreadsheetColumnLabel(columnIndex); // see #1458\n    }\n    result = instance.runHooks('modifyColumnHeaderValue', result, column, headerLevel);\n    return result;\n  };\n\n  /**\n   * Return column width from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getColWidthFromSettings\n   * @param {number} col Visual col index.\n   * @returns {number}\n   */\n  this._getColWidthFromSettings = function (col) {\n    let width;\n\n    // We currently don't support cell meta objects for headers (negative values)\n    if (col >= 0) {\n      const cellProperties = instance.getCellMeta(0, col);\n      width = cellProperties.width;\n    }\n    if (width === undefined || width === tableMeta.width) {\n      width = tableMeta.colWidths;\n    }\n    if (width !== undefined && width !== null) {\n      switch (typeof width) {\n        case 'object':\n          // array\n          width = width[col];\n          break;\n        case 'function':\n          width = width(col);\n          break;\n        default:\n          break;\n      }\n      if (typeof width === 'string') {\n        width = parseInt(width, 10);\n      }\n    }\n    return width;\n  };\n\n  /**\n   * Returns the width of the requested column.\n   *\n   * @memberof Core#\n   * @function getColWidth\n   * @param {number} column Visual column index.\n   * @returns {number} Column width.\n   * @fires Hooks#modifyColWidth\n   */\n  this.getColWidth = function (column) {\n    let width = instance._getColWidthFromSettings(column);\n    width = instance.runHooks('modifyColWidth', width, column);\n    if (width === undefined) {\n      width = ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n    return width;\n  };\n\n  /**\n   * Return row height from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getRowHeightFromSettings\n   * @param {number} row Visual row index.\n   * @returns {number}\n   */\n  this._getRowHeightFromSettings = function (row) {\n    // let cellProperties = instance.getCellMeta(row, 0);\n    // let height = cellProperties.height;\n    //\n    // if (height === undefined || height === tableMeta.height) {\n    //  height = cellProperties.rowHeights;\n    // }\n    let height = tableMeta.rowHeights;\n    if (height !== undefined && height !== null) {\n      switch (typeof height) {\n        case 'object':\n          // array\n          height = height[row];\n          break;\n        case 'function':\n          height = height(row);\n          break;\n        default:\n          break;\n      }\n      if (typeof height === 'string') {\n        height = parseInt(height, 10);\n      }\n    }\n    return height;\n  };\n\n  /**\n   * Returns a row's height, as recognized by Handsontable.\n   *\n   * Depending on your configuration, the method returns (in order of priority):\n   *   1. The row height set by the [`ManualRowResize`](@/api/manualRowResize.md) plugin\n   *     (if the plugin is enabled).\n   *   2. The row height set by the [`rowHeights`](@/api/options.md#rowheights) configuration option\n   *     (if the option is set).\n   *   3. The row height as measured in the DOM by the [`AutoRowSize`](@/api/autoRowSize.md) plugin\n   *     (if the plugin is enabled).\n   *   4. `undefined`, if neither [`ManualRowResize`](@/api/manualRowResize.md),\n   *     nor [`rowHeights`](@/api/options.md#rowheights),\n   *     nor [`AutoRowSize`](@/api/autoRowSize.md) is used.\n   *\n   * The height returned includes 1 px of the row's bottom border.\n   *\n   * Mind that this method is different from the\n   * [`getRowHeight()`](@/api/autoRowSize.md#getrowheight) method\n   * of the [`AutoRowSize`](@/api/autoRowSize.md) plugin.\n   *\n   * @memberof Core#\n   * @function getRowHeight\n   * @param {number} row A visual row index.\n   * @returns {number|undefined} The height of the specified row, in pixels.\n   * @fires Hooks#modifyRowHeight\n   */\n  this.getRowHeight = function (row) {\n    let height = instance._getRowHeightFromSettings(row);\n    height = instance.runHooks('modifyRowHeight', height, row);\n    return height;\n  };\n\n  /**\n   * Returns the total number of rows in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceRows\n   * @returns {number} Total number of rows.\n   */\n  this.countSourceRows = function () {\n    return dataSource.countRows();\n  };\n\n  /**\n   * Returns the total number of columns in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceCols\n   * @returns {number} Total number of columns.\n   */\n  this.countSourceCols = function () {\n    return dataSource.countFirstRowKeys();\n  };\n\n  /**\n   * Returns the total number of visual rows in the table.\n   *\n   * @memberof Core#\n   * @function countRows\n   * @returns {number} Total number of rows.\n   */\n  this.countRows = function () {\n    return datamap.getLength();\n  };\n\n  /**\n   * Returns the total number of visible columns in the table.\n   *\n   * @memberof Core#\n   * @function countCols\n   * @returns {number} Total number of columns.\n   */\n  this.countCols = function () {\n    const maxCols = tableMeta.maxCols;\n    const dataLen = this.columnIndexMapper.getNotTrimmedIndexesLength();\n    return Math.min(maxCols, dataLen);\n  };\n\n  /**\n   * Returns the number of rendered rows including rows that are partially or fully rendered\n   * outside the table viewport.\n   *\n   * @memberof Core#\n   * @function countRenderedRows\n   * @returns {number} Returns -1 if table is not visible.\n   */\n  this.countRenderedRows = function () {\n    return instance.view._wt.drawn ? instance.view._wt.wtTable.getRenderedRowsCount() : -1;\n  };\n\n  /**\n   * Returns the number of rendered rows that are only visible in the table viewport.\n   * The rows that are partially visible are not counted.\n   *\n   * @memberof Core#\n   * @function countVisibleRows\n   * @returns {number} Number of visible rows or -1.\n   */\n  this.countVisibleRows = function () {\n    return instance.view._wt.drawn ? instance.view._wt.wtTable.getVisibleRowsCount() : -1;\n  };\n\n  /**\n   * Returns the number of rendered rows including columns that are partially or fully rendered\n   * outside the table viewport.\n   *\n   * @memberof Core#\n   * @function countRenderedCols\n   * @returns {number} Returns -1 if table is not visible.\n   */\n  this.countRenderedCols = function () {\n    return instance.view._wt.drawn ? instance.view._wt.wtTable.getRenderedColumnsCount() : -1;\n  };\n\n  /**\n   * Returns the number of rendered columns that are only visible in the table viewport.\n   * The columns that are partially visible are not counted.\n   *\n   * @memberof Core#\n   * @function countVisibleCols\n   * @returns {number} Number of visible columns or -1.\n   */\n  this.countVisibleCols = function () {\n    return instance.view._wt.drawn ? instance.view._wt.wtTable.getVisibleColumnsCount() : -1;\n  };\n\n  /**\n   * Returns the number of rendered row headers.\n   *\n   * @since 14.0.0\n   * @memberof Core#\n   * @function countRowHeaders\n   * @returns {number} Number of row headers.\n   */\n  this.countRowHeaders = function () {\n    return this.view.getRowHeadersCount();\n  };\n\n  /**\n   * Returns the number of rendered column headers.\n   *\n   * @since 14.0.0\n   * @memberof Core#\n   * @function countColHeaders\n   * @returns {number} Number of column headers.\n   */\n  this.countColHeaders = function () {\n    return this.view.getColumnHeadersCount();\n  };\n\n  /**\n   * Returns the number of empty rows. If the optional ending parameter is `true`, returns the\n   * number of empty rows at the bottom of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyRows\n   * @param {boolean} [ending=false] If `true`, will only count empty rows at the end of the data source.\n   * @returns {number} Count empty rows.\n   */\n  this.countEmptyRows = function () {\n    let ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let emptyRows = 0;\n    rangeEachReverse(instance.countRows() - 1, visualIndex => {\n      if (instance.isEmptyRow(visualIndex)) {\n        emptyRows += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyRows;\n  };\n\n  /**\n   * Returns the number of empty columns. If the optional ending parameter is `true`, returns the number of empty\n   * columns at right hand edge of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyCols\n   * @param {boolean} [ending=false] If `true`, will only count empty columns at the end of the data source row.\n   * @returns {number} Count empty cols.\n   */\n  this.countEmptyCols = function () {\n    let ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let emptyColumns = 0;\n    rangeEachReverse(instance.countCols() - 1, visualIndex => {\n      if (instance.isEmptyCol(visualIndex)) {\n        emptyColumns += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyColumns;\n  };\n\n  /**\n   * Check if all cells in the row declared by the `row` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyRow\n   * @param {number} row Visual row index.\n   * @returns {boolean} `true` if the row at the given `row` is empty, `false` otherwise.\n   */\n  this.isEmptyRow = function (row) {\n    return tableMeta.isEmptyRow.call(instance, row);\n  };\n\n  /**\n   * Check if all cells in the the column declared by the `column` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyCol\n   * @param {number} column Column index.\n   * @returns {boolean} `true` if the column at the given `col` is empty, `false` otherwise.\n   */\n  this.isEmptyCol = function (column) {\n    return tableMeta.isEmptyCol.call(instance, column);\n  };\n\n  /**\n   * Select a single cell, or a single range of adjacent cells.\n   *\n   * To select a cell, pass its visual row and column indexes, for example: `selectCell(2, 4)`.\n   *\n   * To select a range, pass the visual indexes of the first and last cell in the range, for example: `selectCell(2, 4, 3, 5)`.\n   *\n   * If your columns have properties, you can pass those properties' values instead of column indexes, for example: `selectCell(2, 'first_name')`.\n   *\n   * By default, `selectCell()` also:\n   *  - Scrolls the viewport to the newly-selected cells.\n   *  - Switches the keyboard focus to Handsontable (by calling Handsontable's [`listen()`](#listen) method).\n   *\n   * @example\n   * ```js\n   * // select a single cell\n   * hot.selectCell(2, 4);\n   *\n   * // select a range of cells\n   * hot.selectCell(2, 4, 3, 5);\n   *\n   * // select a single cell, using a column property\n   * hot.selectCell(2, 'first_name');\n   *\n   * // select a range of cells, using column properties\n   * hot.selectCell(2, 'first_name', 3, 'last_name');\n   *\n   * // select a range of cells, without scrolling to them\n   * hot.selectCell(2, 4, 3, 5, false);\n   *\n   * // select a range of cells, without switching the keyboard focus to Handsontable\n   * hot.selectCell(2, 4, 3, 5, null, false);\n   * ```\n   *\n   * @memberof Core#\n   * @function selectCell\n   * @param {number} row A visual row index.\n   * @param {number|string} column A visual column index (`number`), or a column property's value (`string`).\n   * @param {number} [endRow] If selecting a range: the visual row index of the last cell in the range.\n   * @param {number|string} [endColumn] If selecting a range: the visual column index (or a column property's value) of the last cell in the range.\n   * @param {boolean} [scrollToCell=true] `true`: scroll the viewport to the newly-selected cells. `false`: keep the previous viewport.\n   * @param {boolean} [changeListener=true] `true`: switch the keyboard focus to Handsontable. `false`: keep the previous keyboard focus.\n   * @returns {boolean} `true`: the selection was successful, `false`: the selection failed.\n   */\n  this.selectCell = function (row, column, endRow, endColumn) {\n    let scrollToCell = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let changeListener = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    if (isUndefined(row) || isUndefined(column)) {\n      return false;\n    }\n    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);\n  };\n\n  /**\n   * Select multiple cells or ranges of cells, adjacent or non-adjacent.\n   *\n   * You can pass one of the below:\n   * - An array of arrays (which matches the output of Handsontable's [`getSelected()`](#getselected) method).\n   * - An array of [`CellRange`](@/api/cellRange.md) objects (which matches the output of Handsontable's [`getSelectedRange()`](#getselectedrange) method).\n   *\n   * To select multiple cells, pass the visual row and column indexes of each cell, for example: `hot.selectCells([[1, 1], [5, 5]])`.\n   *\n   * To select multiple ranges, pass the visual indexes of the first and last cell in each range, for example: `hot.selectCells([[1, 1, 2, 2], [6, 2, 0, 2]])`.\n   *\n   * If your columns have properties, you can pass those properties' values instead of column indexes, for example: `hot.selectCells([[1, 'first_name'], [5, 'last_name']])`.\n   *\n   * By default, `selectCell()` also:\n   *  - Scrolls the viewport to the newly-selected cells.\n   *  - Switches the keyboard focus to Handsontable (by calling Handsontable's [`listen()`](#listen) method).\n   *\n   * @example\n   * ```js\n   * // select non-adjacent cells\n   * hot.selectCells([[1, 1], [5, 5], [10, 10]]);\n   *\n   * // select non-adjacent ranges of cells\n   * hot.selectCells([[1, 1, 2, 2], [10, 10, 20, 20]]);\n   *\n   * // select cells and ranges of cells\n   * hot.selectCells([[1, 1, 2, 2], [3, 3], [6, 2, 0, 2]]);\n   *\n   * // select cells, using column properties\n   * hot.selectCells([[1, 'id', 2, 'first_name'], [3, 'full_name'], [6, 'last_name', 0, 'first_name']]);\n   *\n   * // select multiple ranges, using an array of `CellRange` objects\n   * const selected = hot.getSelectedRange();\n   *\n   * selected[0].from.row = 0;\n   * selected[0].from.col = 0;\n   * selected[0].to.row = 5;\n   * selected[0].to.col = 5;\n   *\n   * selected[1].from.row = 10;\n   * selected[1].from.col = 10;\n   * selected[1].to.row = 20;\n   * selected[1].to.col = 20;\n   *\n   * hot.selectCells(selected);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectCells\n   * @param {Array[]|CellRange[]} coords Visual coordinates,\n   * passed either as an array of arrays (`[[rowStart, columnStart, rowEnd, columnEnd], ...]`)\n   * or as an array of [`CellRange`](@/api/cellRange.md) objects.\n   * @param {boolean} [scrollToCell=true] `true`: scroll the viewport to the newly-selected cells. `false`: keep the previous viewport.\n   * @param {boolean} [changeListener=true] `true`: switch the keyboard focus to Handsontable. `false`: keep the previous keyboard focus.\n   * @returns {boolean} `true`: the selection was successful, `false`: the selection failed.\n   */\n  this.selectCells = function () {\n    let coords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[]];\n    let scrollToCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let changeListener = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (scrollToCell === false) {\n      preventScrollingToCell = true;\n    }\n    const wasSelected = selection.selectCells(coords);\n    if (wasSelected && changeListener) {\n      instance.listen();\n    }\n    preventScrollingToCell = false;\n    return wasSelected;\n  };\n\n  /**\n   * Select column specified by `startColumn` visual index, column property or a range of columns finishing at `endColumn`.\n   *\n   * @example\n   * ```js\n   * // Select column using visual index.\n   * hot.selectColumns(1);\n   * // Select column using column property.\n   * hot.selectColumns('id');\n   * // Select range of columns using visual indexes.\n   * hot.selectColumns(1, 4);\n   * // Select range of columns using visual indexes and mark the first header as highlighted.\n   * hot.selectColumns(1, 2, -1);\n   * // Select range of columns using visual indexes and mark the second cell as highlighted.\n   * hot.selectColumns(2, 1, 1);\n   * // Select range of columns using column properties.\n   * hot.selectColumns('id', 'last_name');\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectColumns\n   * @param {number} startColumn The visual column index from which the selection starts.\n   * @param {number} [endColumn=startColumn] The visual column index to which the selection finishes. If `endColumn`\n   *                                         is not defined the column defined by `startColumn` will be selected.\n   * @param {number} [focusPosition=0] The argument allows changing the cell/header focus position.\n   *                                   The value can take visual row index from -N to N, where negative values\n   *                                   point to the headers and positive values point to the cell range.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n  this.selectColumns = function (startColumn) {\n    let endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    let focusPosition = arguments.length > 2 ? arguments[2] : undefined;\n    return selection.selectColumns(startColumn, endColumn, focusPosition);\n  };\n\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @example\n   * ```js\n   * // Select row using visual index.\n   * hot.selectRows(1);\n   * // select a range of rows, using visual indexes.\n   * hot.selectRows(1, 4);\n   * // select a range of rows, using visual indexes, and mark the header as highlighted.\n   * hot.selectRows(1, 2, -1);\n   * // Select range of rows using visual indexes and mark the second cell as highlighted.\n   * hot.selectRows(2, 1, 1);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectRows\n   * @param {number} startRow The visual row index from which the selection starts.\n   * @param {number} [endRow=startRow] The visual row index to which the selection finishes. If `endRow`\n   *                                   is not defined the row defined by `startRow` will be selected.\n   * @param {number} [focusPosition=0] The argument allows changing the cell/header focus position.\n   *                                   The value can take visual column index from -N to N, where negative values\n   *                                   point to the headers and positive values point to the cell range.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n  this.selectRows = function (startRow) {\n    let endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    let focusPosition = arguments.length > 2 ? arguments[2] : undefined;\n    return selection.selectRows(startRow, endRow, focusPosition);\n  };\n\n  /**\n   * Deselects the current cell selection on the table.\n   *\n   * @memberof Core#\n   * @function deselectCell\n   */\n  this.deselectCell = function () {\n    selection.deselect();\n  };\n\n  /**\n   * Select all cells in the table excluding headers and corner elements.\n   *\n   * The previous selection is overwritten.\n   *\n   * ```js\n   * // Select all cells in the table along with row headers, including all headers and the corner cell.\n   * // Doesn't select column headers and corner elements.\n   * hot.selectAll();\n   *\n   * // Select all cells in the table, including row headers but excluding the corner cell and column headers.\n   * hot.selectAll(true, false);\n   *\n   * // Select all cells in the table, including all headers and the corner cell, but move the focus.\n   * // highlight to position 2, 1\n   * hot.selectAll(-2, -1, {\n   *    focusPosition: { row: 2, col: 1 }\n   * });\n   *\n   * // Select all cells in the table, without headers and corner elements.\n   * hot.selectAll(false);\n   * ```\n   *\n   * @since 0.38.2\n   * @memberof Core#\n   * @function selectAll\n   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers,\n   * `false` otherwise.\n   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column\n   * headers, `false` otherwise.\n   *\n   * @param {object} [options] Additional object with options. Since 14.0.0\n   * @param {{row: number, col: number} | boolean} [options.focusPosition] The argument allows changing the cell/header\n   * focus position. The value takes an object with a `row` and `col` properties from -N to N, where\n   * negative values point to the headers and positive values point to the cell range. If `false`, the focus\n   * position won't be changed. Example:\n   * ```js\n   * hot.selectAll(0, 0, {\n   * focusPosition: { row: 0, col: 1 },\n   * disableHeadersHighlight: true\n   * })\n   * ```\n   *\n   * @param {boolean} [options.disableHeadersHighlight] If `true`, disables highlighting the headers even when\n   * the logical coordinates points on them.\n   */\n  this.selectAll = function () {\n    let includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : includeRowHeaders;\n    let options = arguments.length > 2 ? arguments[2] : undefined;\n    preventScrollingToCell = true;\n    selection.selectAll(includeRowHeaders, includeColumnHeaders, options);\n    preventScrollingToCell = false;\n  };\n  const getIndexToScroll = (indexMapper, visualIndex) => {\n    // Looking for a visual index on the right and then (when not found) on the left.\n    return indexMapper.getNearestNotHiddenIndex(visualIndex, 1, true);\n  };\n\n  /**\n   * Scroll viewport to coordinates specified by the `row` and/or `col` object properties.\n   *\n   * ```js\n   * // scroll the viewport to the visual row index (leave the horizontal scroll untouched)\n   * hot.scrollViewportTo({ row: 50 });\n   *\n   * // scroll the viewport to the passed coordinates so that the cell at 50, 50 will be snapped to\n   * // the bottom-end table's edge.\n   * hot.scrollViewportTo({\n   *   row: 50,\n   *   col: 50,\n   *   verticalSnap: 'bottom',\n   *   horizontalSnap: 'end',\n   * });\n   * ```\n   *\n   * @memberof Core#\n   * @function scrollViewportTo\n   * @param {object} options A dictionary containing the following parameters:\n   * @param {number} [options.row] Specifies the number of visual rows along the Y axis to scroll the viewport.\n   * @param {number} [options.col] Specifies the number of visual columns along the X axis to scroll the viewport.\n   * @param {'top' | 'bottom'} [options.verticalSnap] Determines to which edge of the table the viewport will be scrolled based on the passed coordinates.\n   * This option is a string which must take one of the following values:\n   * - `top`: The viewport will be scrolled to a row in such a way that it will be positioned on the top of the viewport;\n   * - `bottom`: The viewport will be scrolled to a row in such a way that it will be positioned on the bottom of the viewport;\n   * - If the property is not defined the vertical auto-snapping is enabled. Depending on where the viewport is scrolled from, a row will\n   * be positioned at the top or bottom of the viewport.\n   * @param {'start' | 'end'} [options.horizontalSnap] Determines to which edge of the table the viewport will be scrolled based on the passed coordinates.\n   * This option is a string which must take one of the following values:\n   * - `start`: The viewport will be scrolled to a column in such a way that it will be positioned on the start (left edge or right, if the layout direction is set to `rtl`) of the viewport;\n   * - `end`: The viewport will be scrolled to a column in such a way that it will be positioned on the end (right edge or left, if the layout direction is set to `rtl`) of the viewport;\n   * - If the property is not defined the horizontal auto-snapping is enabled. Depending on where the viewport is scrolled from, a column will\n   * be positioned at the start or end of the viewport.\n   * @param {boolean} [options.considerHiddenIndexes=true] If `true`, we handle visual indexes, otherwise we handle only indexes which\n   * may be rendered when they are in the viewport (we don't consider hidden indexes as they aren't rendered).\n   * @returns {boolean} `true` if viewport was scrolled, `false` otherwise.\n   */\n  this.scrollViewportTo = function (options) {\n    var _options;\n    // Support for backward compatibility arguments: (row, col, snapToBottom, snapToRight, considerHiddenIndexes)\n    if (typeof options === 'number') {\n      var _arguments$;\n      /* eslint-disable prefer-rest-params */\n      options = {\n        row: arguments[0],\n        col: arguments[1],\n        verticalSnap: arguments[2] ? 'bottom' : 'top',\n        horizontalSnap: arguments[3] ? 'end' : 'start',\n        considerHiddenIndexes: (_arguments$ = arguments[4]) !== null && _arguments$ !== void 0 ? _arguments$ : true\n      };\n      /* eslint-enable prefer-rest-params */\n    }\n    const {\n      row,\n      col,\n      verticalSnap,\n      horizontalSnap,\n      considerHiddenIndexes\n    } = (_options = options) !== null && _options !== void 0 ? _options : {};\n    let snapToTop;\n    let snapToBottom;\n    let snapToInlineStart;\n    let snapToInlineEnd;\n    if (verticalSnap !== undefined) {\n      snapToTop = verticalSnap === 'top';\n      snapToBottom = !snapToTop;\n    }\n    if (horizontalSnap !== undefined) {\n      snapToInlineStart = horizontalSnap === 'start';\n      snapToInlineEnd = !snapToInlineStart;\n    }\n    let renderableRow = row;\n    let renderableColumn = col;\n    if (considerHiddenIndexes === undefined || considerHiddenIndexes) {\n      const isValidRowGrid = Number.isInteger(row) && row >= 0;\n      const isValidColumnGrid = Number.isInteger(col) && col >= 0;\n      const visualRowToScroll = isValidRowGrid ? getIndexToScroll(this.rowIndexMapper, row) : undefined;\n      const visualColumnToScroll = isValidColumnGrid ? getIndexToScroll(this.columnIndexMapper, col) : undefined;\n      if (visualRowToScroll === null || visualColumnToScroll === null) {\n        return false;\n      }\n      renderableRow = isValidRowGrid ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : row;\n      renderableColumn = isValidColumnGrid ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) : col;\n    }\n    const isRowInteger = Number.isInteger(renderableRow);\n    const isColumnInteger = Number.isInteger(renderableColumn);\n    if (isRowInteger && renderableRow >= 0 && isColumnInteger && renderableColumn >= 0) {\n      return instance.view.scrollViewport(instance._createCellCoords(renderableRow, renderableColumn), snapToTop, snapToInlineEnd, snapToBottom, snapToInlineStart);\n    }\n    if (isRowInteger && renderableRow >= 0 && (isColumnInteger && renderableColumn < 0 || !isColumnInteger)) {\n      return instance.view.scrollViewportVertically(renderableRow, snapToTop, snapToBottom);\n    }\n    if (isColumnInteger && renderableColumn >= 0 && (isRowInteger && renderableRow < 0 || !isRowInteger)) {\n      return instance.view.scrollViewportHorizontally(renderableColumn, snapToInlineEnd, snapToInlineStart);\n    }\n    return false;\n  };\n\n  /**\n   * Scrolls the viewport to coordinates specified by the currently focused cell.\n   *\n   * @since 14.0.0\n   * @memberof Core#\n   * @fires Hooks#afterScroll\n   * @function scrollToFocusedCell\n   * @param {Function} callback The callback function to call after the viewport is scrolled.\n   */\n  this.scrollToFocusedCell = function () {\n    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n    if (!this.selection.isSelected()) {\n      return;\n    }\n    this.addHookOnce('afterScroll', callback);\n    const {\n      highlight\n    } = this.getSelectedRangeLast();\n    const isScrolled = this.scrollViewportTo(highlight.toObject());\n    if (isScrolled) {\n      this.view.render();\n    } else {\n      this.removeHook('afterScroll', callback);\n      this._registerImmediate(() => callback());\n    }\n  };\n\n  /**\n   * Removes the table from the DOM and destroys the instance of the Handsontable.\n   *\n   * @memberof Core#\n   * @function destroy\n   * @fires Hooks#afterDestroy\n   */\n  this.destroy = function () {\n    instance._clearTimeouts();\n    instance._clearImmediates();\n    if (instance.view) {\n      // in case HT is destroyed before initialization has finished\n      instance.view.destroy();\n    }\n    if (dataSource) {\n      dataSource.destroy();\n    }\n    dataSource = null;\n    this.getShortcutManager().destroy();\n    metaManager.clearCache();\n    foreignHotInstances.delete(this.guid);\n    if (isRootInstance(instance)) {\n      const licenseInfo = this.rootDocument.querySelector('.hot-display-license-info');\n      if (licenseInfo) {\n        licenseInfo.parentNode.removeChild(licenseInfo);\n      }\n    }\n    empty(instance.rootElement);\n    eventManager.destroy();\n    if (editorManager) {\n      editorManager.destroy();\n    }\n\n    // The plugin's `destroy` method is called as a consequence and it should handle\n    // unregistration of plugin's maps. Some unregistered maps reset the cache.\n    instance.batchExecution(() => {\n      instance.rowIndexMapper.unregisterAll();\n      instance.columnIndexMapper.unregisterAll();\n      pluginsRegistry.getItems().forEach(_ref10 => {\n        let [, plugin] = _ref10;\n        plugin.destroy();\n      });\n      pluginsRegistry.clear();\n      instance.runHooks('afterDestroy');\n    }, true);\n    Hooks.getSingleton().destroy(instance);\n    objectEach(instance, (property, key, obj) => {\n      // replace instance methods with post mortem\n      if (isFunction(property)) {\n        obj[key] = postMortem(key);\n      } else if (key !== 'guid') {\n        // replace instance properties with null (restores memory)\n        // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n        obj[key] = null;\n      }\n    });\n    instance.isDestroyed = true;\n\n    // replace private properties with null (restores memory)\n    // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n    if (datamap) {\n      datamap.destroy();\n    }\n    datamap = null;\n    grid = null;\n    selection = null;\n    editorManager = null;\n    instance = null;\n  };\n\n  /**\n   * Replacement for all methods after the Handsontable was destroyed.\n   *\n   * @private\n   * @param {string} method The method name.\n   * @returns {Function}\n   */\n  function postMortem(method) {\n    return () => {\n      throw new Error(`The \"${method}\" method cannot be called because this Handsontable instance has been destroyed`);\n    };\n  }\n\n  /**\n   * Returns the active editor class instance.\n   *\n   * @memberof Core#\n   * @function getActiveEditor\n   * @returns {BaseEditor} The active editor instance.\n   */\n  this.getActiveEditor = function () {\n    return editorManager.getActiveEditor();\n  };\n\n  /**\n   * Returns plugin instance by provided its name.\n   *\n   * @memberof Core#\n   * @function getPlugin\n   * @param {string} pluginName The plugin name.\n   * @returns {BasePlugin|undefined} The plugin instance or undefined if there is no plugin.\n   */\n  this.getPlugin = function (pluginName) {\n    const unifiedPluginName = toUpperCaseFirst(pluginName);\n\n    // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n    if (unifiedPluginName === 'UndoRedo') {\n      return this.undoRedo;\n    }\n    return pluginsRegistry.getItem(unifiedPluginName);\n  };\n\n  /**\n   * Returns name of the passed plugin.\n   *\n   * @private\n   * @memberof Core#\n   * @param {BasePlugin} plugin The plugin instance.\n   * @returns {string}\n   */\n  this.getPluginName = function (plugin) {\n    // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n    if (plugin === this.undoRedo) {\n      return this.undoRedo.constructor.PLUGIN_KEY;\n    }\n    return pluginsRegistry.getId(plugin);\n  };\n\n  /**\n   * Returns the Handsontable instance.\n   *\n   * @memberof Core#\n   * @function getInstance\n   * @returns {Handsontable} The Handsontable instance.\n   */\n  this.getInstance = function () {\n    return instance;\n  };\n\n  /**\n   * Adds listener to the specified hook name (only for this Handsontable instance).\n   *\n   * @memberof Core#\n   * @function addHook\n   * @see Hooks#add\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHook('beforeInit', myCallback);\n   * ```\n   */\n  this.addHook = function (key, callback) {\n    Hooks.getSingleton().add(key, callback, instance);\n  };\n\n  /**\n   * Check if for a specified hook name there are added listeners (only for this Handsontable instance). All available\n   * hooks you will find {@link Hooks}.\n   *\n   * @memberof Core#\n   * @function hasHook\n   * @see Hooks#has\n   * @param {string} key Hook name.\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * const hasBeforeInitListeners = hot.hasHook('beforeInit');\n   * ```\n   */\n  this.hasHook = function (key) {\n    return Hooks.getSingleton().has(key, instance) || Hooks.getSingleton().has(key);\n  };\n\n  /**\n   * Adds listener to specified hook name (only for this Handsontable instance). After the listener is triggered,\n   * it will be automatically removed.\n   *\n   * @memberof Core#\n   * @function addHookOnce\n   * @see Hooks#once\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHookOnce('beforeInit', myCallback);\n   * ```\n   */\n  this.addHookOnce = function (key, callback) {\n    Hooks.getSingleton().once(key, callback, instance);\n  };\n\n  /**\n   * Removes the hook listener previously registered with {@link Core#addHook}.\n   *\n   * @memberof Core#\n   * @function removeHook\n   * @see Hooks#remove\n   * @param {string} key Hook name.\n   * @param {Function} callback Reference to the function which has been registered using {@link Core#addHook}.\n   *\n   * @example\n   * ```js\n   * hot.removeHook('beforeInit', myCallback);\n   * ```\n   */\n  this.removeHook = function (key, callback) {\n    Hooks.getSingleton().remove(key, callback, instance);\n  };\n\n  /**\n   * Run the callbacks for the hook provided in the `key` argument using the parameters given in the other arguments.\n   *\n   * @memberof Core#\n   * @function runHooks\n   * @see Hooks#run\n   * @param {string} key Hook name.\n   * @param {*} [p1] Argument passed to the callback.\n   * @param {*} [p2] Argument passed to the callback.\n   * @param {*} [p3] Argument passed to the callback.\n   * @param {*} [p4] Argument passed to the callback.\n   * @param {*} [p5] Argument passed to the callback.\n   * @param {*} [p6] Argument passed to the callback.\n   * @returns {*}\n   *\n   * @example\n   * ```js\n   * // Run built-in hook\n   * hot.runHooks('beforeInit');\n   * // Run custom hook\n   * hot.runHooks('customAction', 10, 'foo');\n   * ```\n   */\n  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {\n    return Hooks.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);\n  };\n\n  /**\n   * Get language phrase for specified dictionary key.\n   *\n   * @memberof Core#\n   * @function getTranslatedPhrase\n   * @since 0.35.0\n   * @param {string} dictionaryKey Constant which is dictionary key.\n   * @param {*} extraArguments Arguments which will be handled by formatters.\n   * @returns {string}\n   */\n  this.getTranslatedPhrase = function (dictionaryKey, extraArguments) {\n    return getTranslatedPhrase(tableMeta.language, dictionaryKey, extraArguments);\n  };\n\n  /**\n   * Converts instance into outerHTML of HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toHTML\n   * @since 7.1.0\n   * @returns {string}\n   */\n  this.toHTML = () => instanceToHTML(this);\n\n  /**\n   * Converts instance into HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toTableElement\n   * @since 7.1.0\n   * @returns {HTMLTableElement}\n   */\n  this.toTableElement = () => {\n    const tempElement = this.rootDocument.createElement('div');\n    tempElement.insertAdjacentHTML('afterbegin', instanceToHTML(this));\n    return tempElement.firstElementChild;\n  };\n  this.timeouts = [];\n\n  /**\n   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {number|Function} handle Handler returned from setTimeout or function to execute (it will be automatically wraped\n   *                                 by setTimeout function).\n   * @param {number} [delay=0] If first argument is passed as a function this argument set delay of the execution of that function.\n   * @private\n   */\n  this._registerTimeout = function (handle) {\n    let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let handleFunc = handle;\n    if (typeof handleFunc === 'function') {\n      handleFunc = setTimeout(handleFunc, delay);\n    }\n    this.timeouts.push(handleFunc);\n  };\n\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n  this._clearTimeouts = function () {\n    arrayEach(this.timeouts, handler => {\n      clearTimeout(handler);\n    });\n  };\n  this.immediates = [];\n\n  /**\n   * Execute function execution to the next event loop cycle. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {Function} callback Function to be delayed in execution.\n   * @private\n   */\n  this._registerImmediate = function (callback) {\n    this.immediates.push(setImmediate(callback));\n  };\n\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n  this._clearImmediates = function () {\n    arrayEach(this.immediates, handler => {\n      clearImmediate(handler);\n    });\n  };\n\n  /**\n   * Refresh selection borders. This is temporary method relic after selection rewrite.\n   *\n   * @private\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n  this._refreshBorders = function () {\n    let revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    editorManager.destroyEditor(revertOriginal);\n    instance.view.render();\n    if (prepareEditorIfNeeded && selection.isSelected()) {\n      editorManager.prepareEditor();\n    }\n  };\n\n  /**\n   * Gets the instance of the EditorManager.\n   *\n   * @private\n   * @returns {EditorManager}\n   */\n  this._getEditorManager = function () {\n    return editorManager;\n  };\n\n  /**\n   * Check if currently it is RTL direction.\n   *\n   * @private\n   * @memberof Core#\n   * @function isRtl\n   * @returns {boolean} True if RTL.\n   */\n  this.isRtl = function () {\n    return instance.rootWindow.getComputedStyle(instance.rootElement).direction === 'rtl';\n  };\n\n  /**\n   * Check if currently it is LTR direction.\n   *\n   * @private\n   * @memberof Core#\n   * @function isLtr\n   * @returns {boolean} True if LTR.\n   */\n  this.isLtr = function () {\n    return !instance.isRtl();\n  };\n\n  /**\n   * Returns 1 for LTR; -1 for RTL. Useful for calculations.\n   *\n   * @private\n   * @memberof Core#\n   * @function getDirectionFactor\n   * @returns {number} Returns 1 for LTR; -1 for RTL.\n   */\n  this.getDirectionFactor = function () {\n    return instance.isLtr() ? 1 : -1;\n  };\n  const shortcutManager = createShortcutManager({\n    handleEvent() {\n      return instance.isListening();\n    },\n    beforeKeyDown: event => {\n      return this.runHooks('beforeKeyDown', event);\n    },\n    afterKeyDown: event => {\n      if (this.isDestroyed) {\n        // Handsontable could be destroyed after performing action (executing a callback).\n        return;\n      }\n      instance.runHooks('afterDocumentKeyDown', event);\n    },\n    ownerWindow: this.rootWindow\n  });\n  this.addHook('beforeOnCellMouseDown', event => {\n    // Releasing keys as some browser/system shortcuts break events sequence (thus the `keyup` event isn't triggered).\n    if (event.ctrlKey === false && event.metaKey === false) {\n      shortcutManager.releasePressedKeys();\n    }\n  });\n\n  /**\n   * Returns instance of a manager responsible for handling shortcuts stored in some contexts. It run actions after\n   * pressing key combination in active Handsontable instance.\n   *\n   * @memberof Core#\n   * @since 12.0.0\n   * @function getShortcutManager\n   * @returns {ShortcutManager} Instance of {@link ShortcutManager}\n   */\n  this.getShortcutManager = function () {\n    return shortcutManager;\n  };\n\n  /**\n   * Return the Focus Manager responsible for managing the browser's focus in the table.\n   *\n   * @memberof Core#\n   * @since 14.0.0\n   * @function getFocusManager\n   * @returns {FocusManager}\n   */\n  this.getFocusManager = function () {\n    return focusManager;\n  };\n  getPluginsNames().forEach(pluginName => {\n    const PluginClass = getPlugin(pluginName);\n    pluginsRegistry.addItem(pluginName, new PluginClass(this));\n  });\n  registerAllShortcutContexts(instance);\n  shortcutManager.setActiveContextName('grid');\n  Hooks.getSingleton().run(instance, 'construct');\n}"],"mappings":"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AAO,EAAE,CAAC0O,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC/d,SAAS,CAAC8d,QAAQ,CAAC;MAC1D;IACF,CAAC,MAAM,IAAIC,GAAG,EAAE;MACd,OAAOzf,QAAQ,CAAC0S,aAAa,CAAC+M,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;IAC/C;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACza,WAAW,GAAG,YAAY;IAC7B,OAAOtD,SAAS;EAClB,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACge,KAAK,GAAG,YAAY;IACvB,IAAI,CAACnU,SAAS,EAAE;IAChB,IAAI,CAACqO,kBAAkB,EAAE;EAC3B,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACjR,KAAK,GAAG,UAAUE,MAAM,EAAEC,KAAK,EAAEG,MAAM,EAAEvG,MAAM,EAAEwG,aAAa,EAAE;IACnE9I,IAAI,CAACuI,KAAK,CAACE,MAAM,EAAEC,KAAK,EAAEG,MAAM,EAAEvG,MAAM,EAAEwG,aAAa,CAAC;EAC1D,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACiN,OAAO,GAAG,UAAUnT,GAAG,EAAEyB,MAAM,EAAE;IACpC,IAAIkb,OAAO,GAAG/f,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CA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AAUziB,MAAM,EAAE;IAClC,OAAO/C,SAAS,CAACwlB,UAAU,CAACzP,IAAI,CAACzX,QAAQ,EAAEyE,MAAM,CAAC;EACpD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACiL,UAAU,GAAG,UAAU1M,GAAG,EAAEyB,MAAM,EAAEqU,MAAM,EAAEqO,SAAS,EAAE;IAC1D,IAAIphB,YAAY,GAAGnG,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;IAC3F,IAAIwnB,cAAc,GAAGxnB,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;IAC7F,IAAIpE,WAAW,CAACwH,GAAG,CAAC,IAAIxH,WAAW,CAACiJ,MAAM,CAAC,EAAE;MAC3C,OAAO,KAAK;IACd;IACA,OAAO,IAAI,CAAC4iB,WAAW,CAAC,CAAC,CAACrkB,GAAG,EAAEyB,MAAM,EAAEqU,MAAM,EAAEqO,SAAS,CAAC,CAAC,EAAEphB,YAAY,EAAEqhB,cAAc,CAAC;EAC3F,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,YAAY;IA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F;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACnW,WAAW,GAAG,YAAY;IAC7B,OAAO7T,QAAQ;EACjB,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACse,OAAO,GAAG,UAAUsE,GAAG,EAAExN,QAAQ,EAAE;IACtClX,KAAK,CAACggB,YAAY,EAAE,CAAC0M,GAAG,CAAChI,GAAG,EAAExN,QAAQ,EAAEpV,QAAQ,CAAC;EACnD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACkhB,OAAO,GAAG,UAAU0B,GAAG,EAAE;IAC5B,OAAO1kB,KAAK,CAACggB,YAAY,EAAE,CAAC2M,GAAG,CAACjI,GAAG,EAAE5iB,QAAQ,CAAC,IAAI9B,KAAK,CAACggB,YAAY,EAAE,CAAC2M,GAAG,CAACjI,GAAG,CAAC;EACjF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACsG,WAAW,GAAG,UAAUtG,GAAG,EAAExN,QAAQ,EAAE;IAC1ClX,KAAK,CAACggB,YAAY,EAAE,CAAC4M,IAAI,CAAClI,GAAG,EAAExN,QAAQ,EAAEpV,QAAQ,CAAC;EACpD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACopB,UAAU,GAAG,UAAUxG,GAAG,EAAExN,QAAQ,EAAE;IACzClX,KAAK,CAACggB,YAAY,EAAE,CAAC6M,MAAM,CAACnI,GAAG,EAAExN,QAAQ,EAAEpV,QAAQ,CAAC;EACtD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC2C,QAAQ,GAAG,UAAUigB,GAAG,EAAEoI,EAAE,EAAEC,EAAE,E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"},"metadata":{},"sourceType":"module","externalDependencies":[]}