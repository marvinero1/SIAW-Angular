{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n/**\n * Class responsible for all of the Selection-related operations on merged cells.\n *\n * @private\n * @class SelectionCalculations\n */\nclass SelectionCalculations {\n  constructor(plugin) {\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Class name used for fully selected merged cells.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"fullySelectedMergedCellClassName\", 'fullySelectedMergedCell');\n    this.plugin = plugin;\n    this.hot = plugin.hot;\n  }\n\n  /**\n   * \"Snap\" the delta value according to defined merged cells. (In other words, compensate the rowspan -\n   * e.g. Going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.).\n   *\n   * @param {object} delta The delta object containing `row` and `col` properties.\n   * @param {CellRange} selectionRange The selection range.\n   * @param {object} mergedCell A merged cell object.\n   */\n  snapDelta(delta, selectionRange, mergedCell) {\n    const cellCoords = selectionRange.to;\n    const newRow = cellCoords.row + delta.row;\n    const newColumn = cellCoords.col + delta.col;\n    if (delta.row) {\n      this.jumpOverMergedCell(delta, mergedCell, newRow);\n    } else if (delta.col) {\n      this.jumpOverMergedCell(delta, mergedCell, newColumn);\n    }\n  }\n\n  /**\n   * \"Jump\" over the merged cell (compensate for the indexes within the merged cell to get past it).\n   *\n   * @private\n   * @param {object} delta The delta object.\n   * @param {MergedCellCoords} mergedCell The merge cell object.\n   * @param {number} newIndex New row/column index, created with the delta.\n   */\n  jumpOverMergedCell(delta, mergedCell, newIndex) {\n    let flatDelta = delta.row || delta.col;\n    let includesIndex = null;\n    let firstIndex = null;\n    let lastIndex = null;\n    if (delta.row) {\n      includesIndex = mergedCell.includesVertically(newIndex);\n      firstIndex = mergedCell.row;\n      lastIndex = mergedCell.getLastRow();\n    } else if (delta.col) {\n      includesIndex = mergedCell.includesHorizontally(newIndex);\n      firstIndex = mergedCell.col;\n      lastIndex = mergedCell.getLastColumn();\n    }\n    if (flatDelta === 0) {\n      return;\n    } else if (flatDelta > 0) {\n      if (includesIndex && newIndex !== firstIndex) {\n        flatDelta += lastIndex - newIndex + 1;\n      }\n    } else if (includesIndex && newIndex !== lastIndex) {\n      flatDelta -= newIndex - firstIndex + 1;\n    }\n    if (delta.row) {\n      delta.row = flatDelta;\n    } else if (delta.col) {\n      delta.col = flatDelta;\n    }\n  }\n\n  /**\n   * Get a selection range with `to` property incremented by the provided delta.\n   *\n   * @param {CellRange} oldSelectionRange The base selection range.\n   * @param {object} delta The delta object with `row` and `col` properties.\n   * @returns {CellRange} A new `CellRange` object.\n   */\n  getUpdatedSelectionRange(oldSelectionRange, delta) {\n    return this.hot._createCellRange(oldSelectionRange.highlight, oldSelectionRange.from, this.hot._createCellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));\n  }\n\n  /**\n   * Generate an additional class name for the entirely-selected merged cells.\n   *\n   * @param {number} currentRow Visual row index of the currently processed cell.\n   * @param {number} currentColumn Visual column index of the currently cell.\n   * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n   * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n   * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n   */\n  getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n    const startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);\n    const startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);\n    const endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);\n    const endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);\n    if (layerLevel === undefined) {\n      return;\n    }\n    const isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn);\n\n    // We add extra classes just to the first renderable merged cell.\n    if (!isFirstRenderableMergedCell) {\n      return;\n    }\n    const mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n    if (!mergedCell) {\n      return;\n    }\n    const mergeRowEnd = mergedCell.getLastRow();\n    const mergeColumnEnd = mergedCell.getLastColumn();\n    const fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;\n    if (fullMergeAreaWithinSelection) {\n      return `${this.fullySelectedMergedCellClassName}-${layerLevel}`;\n    } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n      // eslint-disable-line max-len\n      return `${this.fullySelectedMergedCellClassName}-multiple`;\n    }\n  }\n\n  /**\n   * Check if the provided merged cell is fully selected (by one or many layers of selection).\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to be processed.\n   * @param {CellRange[]} selectionRangesArray Array of selection ranges.\n   * @returns {boolean}\n   */\n  isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n    const mergedCellIndividualCoords = [];\n    if (!selectionRangesArray || !mergedCell) {\n      return false;\n    }\n    for (let r = 0; r < mergedCell.rowspan; r += 1) {\n      for (let c = 0; c < mergedCell.colspan; c += 1) {\n        mergedCellIndividualCoords.push(this.hot._createCellCoords(mergedCell.row + r, mergedCell.col + c));\n      }\n    }\n    for (let i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n      const insideSelections = [];\n      for (let s = 0; s < selectionRangesArray.length; s += 1) {\n        insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n      }\n      if (!insideSelections.includes(true)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Generate an array of the entirely-selected merged cells' class names.\n   *\n   * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n   */\n  getSelectedMergedCellClassNameToRemove() {\n    const classNames = [];\n    for (let i = 0; i <= 7; i += 1) {\n      classNames.push(`${this.fullySelectedMergedCellClassName}-${i}`);\n    }\n    classNames.push(`${this.fullySelectedMergedCellClassName}-multiple`);\n    return classNames;\n  }\n}\nexport default SelectionCalculations;","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","SelectionCalculations","constructor","plugin","hot","snapDelta","delta","selectionRange","mergedCell","cellCoords","to","newRow","row","newColumn","col","jumpOverMergedCell","newIndex","flatDelta","includesIndex","firstIndex","lastIndex","includesVertically","getLastRow","includesHorizontally","getLastColumn","getUpdatedSelectionRange","oldSelectionRange","_createCellRange","highlight","from","_createCellCoords","getSelectedMergedCellClassName","currentRow","currentColumn","cornersOfSelection","layerLevel","startRow","Math","min","startColumn","endRow","max","endColumn","undefined","isFirstRenderableMergedCell","mergedCellsCollection","get","mergeRowEnd","mergeColumnEnd","fullMergeAreaWithinSelection","fullySelectedMergedCellClassName","selectionCalculations","isMergeCellFullySelected","getSelectedRange","selectionRangesArray","mergedCellIndividualCoords","rowspan","c","colspan","push","length","insideSelections","s","includes","getSelectedMergedCellClassNameToRemove","classNames"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/mergeCells/calculations/selection.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * Class responsible for all of the Selection-related operations on merged cells.\n *\n * @private\n * @class SelectionCalculations\n */\nclass SelectionCalculations {\n  constructor(plugin) {\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Class name used for fully selected merged cells.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"fullySelectedMergedCellClassName\", 'fullySelectedMergedCell');\n    this.plugin = plugin;\n    this.hot = plugin.hot;\n  }\n\n  /**\n   * \"Snap\" the delta value according to defined merged cells. (In other words, compensate the rowspan -\n   * e.g. Going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.).\n   *\n   * @param {object} delta The delta object containing `row` and `col` properties.\n   * @param {CellRange} selectionRange The selection range.\n   * @param {object} mergedCell A merged cell object.\n   */\n  snapDelta(delta, selectionRange, mergedCell) {\n    const cellCoords = selectionRange.to;\n    const newRow = cellCoords.row + delta.row;\n    const newColumn = cellCoords.col + delta.col;\n    if (delta.row) {\n      this.jumpOverMergedCell(delta, mergedCell, newRow);\n    } else if (delta.col) {\n      this.jumpOverMergedCell(delta, mergedCell, newColumn);\n    }\n  }\n\n  /**\n   * \"Jump\" over the merged cell (compensate for the indexes within the merged cell to get past it).\n   *\n   * @private\n   * @param {object} delta The delta object.\n   * @param {MergedCellCoords} mergedCell The merge cell object.\n   * @param {number} newIndex New row/column index, created with the delta.\n   */\n  jumpOverMergedCell(delta, mergedCell, newIndex) {\n    let flatDelta = delta.row || delta.col;\n    let includesIndex = null;\n    let firstIndex = null;\n    let lastIndex = null;\n    if (delta.row) {\n      includesIndex = mergedCell.includesVertically(newIndex);\n      firstIndex = mergedCell.row;\n      lastIndex = mergedCell.getLastRow();\n    } else if (delta.col) {\n      includesIndex = mergedCell.includesHorizontally(newIndex);\n      firstIndex = mergedCell.col;\n      lastIndex = mergedCell.getLastColumn();\n    }\n    if (flatDelta === 0) {\n      return;\n    } else if (flatDelta > 0) {\n      if (includesIndex && newIndex !== firstIndex) {\n        flatDelta += lastIndex - newIndex + 1;\n      }\n    } else if (includesIndex && newIndex !== lastIndex) {\n      flatDelta -= newIndex - firstIndex + 1;\n    }\n    if (delta.row) {\n      delta.row = flatDelta;\n    } else if (delta.col) {\n      delta.col = flatDelta;\n    }\n  }\n\n  /**\n   * Get a selection range with `to` property incremented by the provided delta.\n   *\n   * @param {CellRange} oldSelectionRange The base selection range.\n   * @param {object} delta The delta object with `row` and `col` properties.\n   * @returns {CellRange} A new `CellRange` object.\n   */\n  getUpdatedSelectionRange(oldSelectionRange, delta) {\n    return this.hot._createCellRange(oldSelectionRange.highlight, oldSelectionRange.from, this.hot._createCellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));\n  }\n\n  /**\n   * Generate an additional class name for the entirely-selected merged cells.\n   *\n   * @param {number} currentRow Visual row index of the currently processed cell.\n   * @param {number} currentColumn Visual column index of the currently cell.\n   * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n   * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n   * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n   */\n  getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n    const startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);\n    const startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);\n    const endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);\n    const endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);\n    if (layerLevel === undefined) {\n      return;\n    }\n    const isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn);\n\n    // We add extra classes just to the first renderable merged cell.\n    if (!isFirstRenderableMergedCell) {\n      return;\n    }\n    const mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n    if (!mergedCell) {\n      return;\n    }\n    const mergeRowEnd = mergedCell.getLastRow();\n    const mergeColumnEnd = mergedCell.getLastColumn();\n    const fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;\n    if (fullMergeAreaWithinSelection) {\n      return `${this.fullySelectedMergedCellClassName}-${layerLevel}`;\n    } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n      // eslint-disable-line max-len\n      return `${this.fullySelectedMergedCellClassName}-multiple`;\n    }\n  }\n\n  /**\n   * Check if the provided merged cell is fully selected (by one or many layers of selection).\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to be processed.\n   * @param {CellRange[]} selectionRangesArray Array of selection ranges.\n   * @returns {boolean}\n   */\n  isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n    const mergedCellIndividualCoords = [];\n    if (!selectionRangesArray || !mergedCell) {\n      return false;\n    }\n    for (let r = 0; r < mergedCell.rowspan; r += 1) {\n      for (let c = 0; c < mergedCell.colspan; c += 1) {\n        mergedCellIndividualCoords.push(this.hot._createCellCoords(mergedCell.row + r, mergedCell.col + c));\n      }\n    }\n    for (let i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n      const insideSelections = [];\n      for (let s = 0; s < selectionRangesArray.length; s += 1) {\n        insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n      }\n      if (!insideSelections.includes(true)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Generate an array of the entirely-selected merged cells' class names.\n   *\n   * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n   */\n  getSelectedMergedCellClassNameToRemove() {\n    const classNames = [];\n    for (let i = 0; i <= 7; i += 1) {\n      classNames.push(`${this.fullySelectedMergedCellClassName}-${i}`);\n    }\n    classNames.push(`${this.fullySelectedMergedCellClassName}-multiple`);\n    return classNames;\n  }\n}\nexport default SelectionCalculations;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}