{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { offset, outerHeight, outerWidth } from \"../../helpers/dom/element.mjs\";\nimport { arrayEach, arrayMap } from \"../../helpers/array.mjs\";\nimport { getDragDirectionAndRange, DIRECTIONS, getMappedFillHandleSetting } from \"./utils.mjs\";\nHooks.getSingleton().register('modifyAutofillRange');\nHooks.getSingleton().register('beforeAutofill');\nHooks.getSingleton().register('afterAutofill');\nexport const PLUGIN_KEY = 'autofill';\nexport const PLUGIN_PRIORITY = 20;\nconst SETTING_KEYS = ['fillHandle'];\nconst INSERT_ROW_ALTER_ACTION_NAME = 'insert_row_below';\nconst INTERVAL_FOR_ADDING_ROW = 200;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * This plugin provides \"drag-down\" and \"copy-down\" functionalities, both operated using the small square in the right\n * bottom of the cell selection.\n *\n * \"Drag-down\" expands the value of the selected cells to the neighbouring cells when you drag the small\n * square in the corner.\n *\n * \"Copy-down\" copies the value of the selection to all empty cells below when you double click the small square.\n *\n * @class Autofill\n * @plugin Autofill\n */\nvar _onCellCornerDblClick = /*#__PURE__*/new WeakSet();\nvar _onAfterCellCornerMouseDown = /*#__PURE__*/new WeakSet();\nvar _onBeforeCellMouseOver = /*#__PURE__*/new WeakSet();\nvar _onMouseUp = /*#__PURE__*/new WeakSet();\nvar _onMouseMove = /*#__PURE__*/new WeakSet();\nexport class Autofill extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * On mouse move listener.\n     *\n     * @param {MouseEvent} event `mousemove` event properties.\n     */\n    _classPrivateMethodInitSpec(this, _onMouseMove);\n    /**\n     * On mouse up listener.\n     */\n    _classPrivateMethodInitSpec(this, _onMouseUp);\n    /**\n     * On before cell mouse over listener.\n     *\n     * @param {CellCoords} coords `CellCoords` coord object.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeCellMouseOver);\n    /**\n     * On after cell corner mouse down listener.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCellCornerMouseDown);\n    /**\n     * On cell corner double click callback.\n     *\n     * @private\n     */\n    _classPrivateMethodInitSpec(this, _onCellCornerDblClick);\n    /**\n     * Specifies if adding new row started.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"addingStarted\", false);\n    /**\n     * Specifies if there was mouse down on the cell corner.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"mouseDownOnCellCorner\", false);\n    /**\n     * Specifies if mouse was dragged outside Handsontable.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"mouseDragOutside\", false);\n    /**\n     * Specifies how many cell levels were dragged using the handle.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"handleDraggedCells\", 0);\n    /**\n     * Specifies allowed directions of drag (`'horizontal'` or '`vertical`').\n     *\n     * @private\n     * @type {string[]}\n     */\n    _defineProperty(this, \"directions\", []);\n    /**\n     * Specifies if can insert new rows if needed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"autoInsertRow\", false);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  /**\n   * Checks if the plugin is enabled in the Handsontable settings.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return this.hot.getSettings().fillHandle;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.mapSettings();\n    this.registerEvents();\n    this.addHook('afterOnCellCornerMouseDown', event => _classPrivateMethodGet(this, _onAfterCellCornerMouseDown, _onAfterCellCornerMouseDown2).call(this, event));\n    this.addHook('afterOnCellCornerDblClick', event => _classPrivateMethodGet(this, _onCellCornerDblClick, _onCellCornerDblClick2).call(this, event));\n    this.addHook('beforeOnCellMouseOver', (_, coords) => _classPrivateMethodGet(this, _onBeforeCellMouseOver, _onBeforeCellMouseOver2).call(this, coords));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - `autofill`\n   *  - [`fillHandle`](@/api/options.md#fillhandle)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearMappedSettings();\n    super.disablePlugin();\n  }\n\n  /**\n   * Gets selection data.\n   *\n   * @private\n   * @returns {object[]} Ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n   */\n  getSelectionData() {\n    const selection = this.hot.getSelectedRangeLast();\n    const {\n      row: startRow,\n      col: startCol\n    } = selection.getTopStartCorner();\n    const {\n      row: endRow,\n      col: endCol\n    } = selection.getBottomEndCorner();\n    const copyableRanges = this.hot.runHooks('modifyCopyableRange', [{\n      startRow,\n      startCol,\n      endRow,\n      endCol\n    }]);\n    const copyableRows = [];\n    const copyableColumns = [];\n    const data = [];\n    arrayEach(copyableRanges, range => {\n      for (let visualRow = range.startRow; visualRow <= range.endRow; visualRow += 1) {\n        if (copyableRows.indexOf(visualRow) === -1) {\n          copyableRows.push(visualRow);\n        }\n      }\n      for (let visualColumn = range.startCol; visualColumn <= range.endCol; visualColumn += 1) {\n        if (copyableColumns.indexOf(visualColumn) === -1) {\n          copyableColumns.push(visualColumn);\n        }\n      }\n    });\n    arrayEach(copyableRows, row => {\n      const rowSet = [];\n      arrayEach(copyableColumns, column => {\n        rowSet.push(this.hot.getCopyableData(row, column));\n      });\n      data.push(rowSet);\n    });\n    return data;\n  }\n\n  /**\n   * Try to apply fill values to the area in fill border, omitting the selection border.\n   *\n   * @private\n   * @returns {boolean} Reports if fill was applied.\n   *\n   * @fires Hooks#modifyAutofillRange\n   * @fires Hooks#beforeAutofill\n   * @fires Hooks#afterAutofill\n   */\n  fillIn() {\n    if (this.hot.selection.highlight.getFill().isEmpty()) {\n      return false;\n    }\n\n    // Fill area may starts or ends with invisible cell. There won't be any information about it as highlighted\n    // selection store just renderable indexes (It's part of Walkontable). I extrapolate where the start or/and\n    // the end is.\n    const [fillStartRow, fillStartColumn, fillEndRow, fillEndColumn] = this.hot.selection.highlight.getFill().getVisualCorners();\n    const selectionRangeLast = this.hot.getSelectedRangeLast();\n    const topStartCorner = selectionRangeLast.getTopStartCorner();\n    const bottomEndCorner = selectionRangeLast.getBottomEndCorner();\n    this.resetSelectionOfDraggedArea();\n    const cornersOfSelectedCells = [topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col];\n    const cornersOfSelectionAndDragAreas = this.hot.runHooks('modifyAutofillRange', [Math.min(topStartCorner.row, fillStartRow), Math.min(topStartCorner.col, fillStartColumn), Math.max(bottomEndCorner.row, fillEndRow), Math.max(bottomEndCorner.col, fillEndColumn)], cornersOfSelectedCells);\n    const {\n      directionOfDrag,\n      startOfDragCoords,\n      endOfDragCoords\n    } = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas, (row, column) => this.hot._createCellCoords(row, column));\n    if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {\n      const selectionData = this.getSelectionData();\n      const sourceRange = selectionRangeLast.clone();\n      const targetRange = this.hot._createCellRange(startOfDragCoords, startOfDragCoords, endOfDragCoords);\n      const beforeAutofillHookResult = this.hot.runHooks('beforeAutofill', selectionData, sourceRange, targetRange, directionOfDrag);\n      if (beforeAutofillHookResult === false) {\n        this.hot.selection.highlight.getFill().clear();\n        this.hot.render();\n        return false;\n      }\n      let fillData = beforeAutofillHookResult;\n      const res = beforeAutofillHookResult;\n      if (['up', 'left'].indexOf(directionOfDrag) > -1 && !(res.length === 1 && res[0].length === 0)) {\n        fillData = [];\n        if (directionOfDrag === 'up') {\n          const dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;\n          const fillOffset = dragLength % res.length;\n          for (let i = 0; i < dragLength; i++) {\n            fillData.push(res[(i + (res.length - fillOffset)) % res.length]);\n          }\n        } else {\n          const dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;\n          const fillOffset = dragLength % res[0].length;\n          for (let i = 0; i < res.length; i++) {\n            fillData.push([]);\n            for (let j = 0; j < dragLength; j++) {\n              fillData[i].push(res[i][(j + (res[i].length - fillOffset)) % res[i].length]);\n            }\n          }\n        }\n      }\n      this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, `${this.pluginName}.fill`, null);\n      this.setSelection(cornersOfSelectionAndDragAreas);\n      this.hot.runHooks('afterAutofill', fillData, sourceRange, targetRange, directionOfDrag);\n      this.hot.render();\n    } else {\n      // reset to avoid some range bug\n      this.hot._refreshBorders();\n    }\n    return true;\n  }\n\n  /**\n   * Reduces the selection area if the handle was dragged outside of the table or on headers.\n   *\n   * @private\n   * @param {CellCoords} coords Indexes of selection corners.\n   * @returns {CellCoords}\n   */\n  reduceSelectionAreaIfNeeded(coords) {\n    if (coords.row < 0) {\n      coords.row = 0;\n    }\n    if (coords.col < 0) {\n      coords.col = 0;\n    }\n    return coords;\n  }\n\n  /**\n   * Gets the coordinates of the drag & drop borders.\n   *\n   * @private\n   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n   * @returns {CellCoords}\n   */\n  getCoordsOfDragAndDropBorders(coordsOfSelection) {\n    const currentSelection = this.hot.getSelectedRangeLast();\n    const bottomRightCorner = currentSelection.getBottomEndCorner();\n    let coords = coordsOfSelection;\n    if (this.directions.includes(DIRECTIONS.vertical) && this.directions.includes(DIRECTIONS.horizontal)) {\n      const topStartCorner = currentSelection.getTopStartCorner();\n      if (bottomRightCorner.col <= coordsOfSelection.col || topStartCorner.col >= coordsOfSelection.col) {\n        coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);\n      }\n      if (bottomRightCorner.row < coordsOfSelection.row || topStartCorner.row > coordsOfSelection.row) {\n        coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);\n      }\n    } else if (this.directions.includes(DIRECTIONS.vertical)) {\n      coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);\n    } else if (this.directions.includes(DIRECTIONS.horizontal)) {\n      coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);\n    } else {\n      // wrong direction\n      return;\n    }\n    return this.reduceSelectionAreaIfNeeded(coords);\n  }\n\n  /**\n   * Show the fill border.\n   *\n   * @private\n   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n   */\n  showBorder(coordsOfSelection) {\n    const coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);\n    if (coordsOfDragAndDropBorders) {\n      this.redrawBorders(coordsOfDragAndDropBorders);\n    }\n  }\n\n  /**\n   * Add new row.\n   *\n   * @private\n   */\n  addRow() {\n    this.hot._registerTimeout(() => {\n      this.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, undefined, 1, `${this.pluginName}.fill`);\n      this.addingStarted = false;\n    }, INTERVAL_FOR_ADDING_ROW);\n  }\n\n  /**\n   * Add new rows if they are needed to continue auto-filling values.\n   *\n   * @private\n   */\n  addNewRowIfNeeded() {\n    if (!this.hot.selection.highlight.getFill().isEmpty() && this.addingStarted === false && this.autoInsertRow) {\n      const cornersOfSelectedCells = this.hot.getSelectedLast();\n      const cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getVisualCorners();\n      const nrOfTableRows = this.hot.countRows();\n      if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {\n        this.addingStarted = true;\n        this.addRow();\n      }\n    }\n  }\n\n  /**\n   * Get index of last adjacent filled in row.\n   *\n   * @private\n   * @param {Array} cornersOfSelectedCells Indexes of selection corners.\n   * @returns {number} Gives number greater than or equal to zero when selection adjacent can be applied.\n   *                   Or -1 when selection adjacent can't be applied.\n   */\n  getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {\n    const data = this.hot.getData();\n    const nrOfTableRows = this.hot.countRows();\n    let lastFilledInRowIndex;\n    for (let rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {\n      for (let columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {\n        const dataInCell = data[rowIndex][columnIndex];\n        if (dataInCell) {\n          return -1;\n        }\n      }\n      const dataInNextLeftCell = data[rowIndex][cornersOfSelectedCells[1] - 1];\n      const dataInNextRightCell = data[rowIndex][cornersOfSelectedCells[3] + 1];\n      if (!!dataInNextLeftCell || !!dataInNextRightCell) {\n        lastFilledInRowIndex = rowIndex;\n      }\n    }\n    return lastFilledInRowIndex;\n  }\n\n  /**\n   * Adds a selection from the start area to the specific row index.\n   *\n   * @private\n   * @param {Array} selectStartArea Selection area from which we start to create more comprehensive selection.\n   * @param {number} rowIndex The row index into the selection will be added.\n   */\n  addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {\n    this.hot.selection.highlight.getFill().clear().add(this.hot._createCellCoords(selectStartArea[0], selectStartArea[1])).add(this.hot._createCellCoords(rowIndex, selectStartArea[3])).commit();\n  }\n\n  /**\n   * Sets selection based on passed corners.\n   *\n   * @private\n   * @param {Array} cornersOfArea An array witch defines selection.\n   */\n  setSelection(cornersOfArea) {\n    this.hot.selectCell(...arrayMap(cornersOfArea, index => Math.max(index, 0)), false, false);\n  }\n\n  /**\n   * Try to select cells down to the last row in the left column and then returns if selection was applied.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  selectAdjacent() {\n    const cornersOfSelectedCells = this.hot.getSelectedLast();\n    const lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);\n    if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === undefined) {\n      return false;\n    }\n    this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);\n    return true;\n  }\n\n  /**\n   * Resets selection of dragged area.\n   *\n   * @private\n   */\n  resetSelectionOfDraggedArea() {\n    this.handleDraggedCells = 0;\n    this.hot.selection.highlight.getFill().clear();\n  }\n\n  /**\n   * Redraws borders.\n   *\n   * @private\n   * @param {CellCoords} coords `CellCoords` coord object.\n   */\n  redrawBorders(coords) {\n    this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords).commit();\n    this.hot.view.render();\n  }\n\n  /**\n   * Get if mouse was dragged outside.\n   *\n   * @private\n   * @param {MouseEvent} event `mousemove` event properties.\n   * @returns {boolean}\n   */\n  getIfMouseWasDraggedOutside(event) {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    const tableBottom = offset(this.hot.table).top - (this.hot.rootWindow.pageYOffset || documentElement.scrollTop) + outerHeight(this.hot.table);\n    const tableRight = offset(this.hot.table).left - (this.hot.rootWindow.pageXOffset || documentElement.scrollLeft) + outerWidth(this.hot.table);\n    return event.clientY > tableBottom && event.clientX <= tableRight;\n  }\n\n  /**\n   * Bind the events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    this.eventManager.addEventListener(documentElement, 'mouseup', () => _classPrivateMethodGet(this, _onMouseUp, _onMouseUp2).call(this));\n    this.eventManager.addEventListener(documentElement, 'mousemove', event => _classPrivateMethodGet(this, _onMouseMove, _onMouseMove2).call(this, event));\n  }\n  /**\n   * Clears mapped settings.\n   *\n   * @private\n   */\n  clearMappedSettings() {\n    this.directions.length = 0;\n    this.autoInsertRow = false;\n  }\n\n  /**\n   * Map settings.\n   *\n   * @private\n   */\n  mapSettings() {\n    const mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);\n    this.directions = mappedSettings.directions;\n    this.autoInsertRow = mappedSettings.autoInsertRow;\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onCellCornerDblClick2() {\n  const selectionApplied = this.selectAdjacent();\n  if (selectionApplied) {\n    this.fillIn();\n  }\n}\nfunction _onAfterCellCornerMouseDown2() {\n  this.handleDraggedCells = 1;\n  this.mouseDownOnCellCorner = true;\n}\nfunction _onBeforeCellMouseOver2(coords) {\n  if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {\n    this.handleDraggedCells += 1;\n    this.showBorder(coords);\n    this.addNewRowIfNeeded();\n  }\n}\nfunction _onMouseUp2() {\n  if (this.handleDraggedCells) {\n    if (this.handleDraggedCells > 1) {\n      this.fillIn();\n    }\n    this.handleDraggedCells = 0;\n    this.mouseDownOnCellCorner = false;\n  }\n}\nfunction _onMouseMove2(event) {\n  const mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event);\n  if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {\n    this.mouseDragOutside = true;\n    this.addingStarted = true;\n  } else {\n    this.mouseDragOutside = false;\n  }\n  if (this.mouseDragOutside && this.autoInsertRow) {\n    this.addRow();\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","privateCollection","has","TypeError","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateMethodGet","receiver","fn","BasePlugin","Hooks","offset","outerHeight","outerWidth","arrayEach","arrayMap","getDragDirectionAndRange","DIRECTIONS","getMappedFillHandleSetting","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","SETTING_KEYS","INSERT_ROW_ALTER_ACTION_NAME","INTERVAL_FOR_ADDING_ROW","_onCellCornerDblClick","WeakSet","_onAfterCellCornerMouseDown","_onBeforeCellMouseOver","_onMouseUp","_onMouseMove","Autofill","constructor","arguments","isEnabled","hot","getSettings","fillHandle","enablePlugin","enabled","mapSettings","registerEvents","addHook","event","_onAfterCellCornerMouseDown2","_onCellCornerDblClick2","_","coords","_onBeforeCellMouseOver2","updatePlugin","disablePlugin","clearMappedSettings","getSelectionData","selection","getSelectedRangeLast","row","startRow","col","startCol","getTopStartCorner","endRow","endCol","getBottomEndCorner","copyableRanges","runHooks","copyableRows","copyableColumns","data","range","visualRow","indexOf","push","visualColumn","rowSet","column","getCopyableData","fillIn","highlight","getFill","isEmpty","fillStartRow","fillStartColumn","fillEndRow","fillEndColumn","getVisualCorners","selectionRangeLast","topStartCorner","bottomEndCorner","resetSelectionOfDraggedArea","cornersOfSelectedCells","cornersOfSelectionAndDragAreas","Math","min","max","directionOfDrag","startOfDragCoords","endOfDragCoords","_createCellCoords","selectionData","sourceRange","clone","targetRange","_createCellRange","beforeAutofillHookResult","clear","render","fillData","res","length","dragLength","fillOffset","j","populateFromArray","pluginName","setSelection","_refreshBorders","reduceSelectionAreaIfNeeded","getCoordsOfDragAndDropBorders","coordsOfSelection","currentSelection","bottomRightCorner","directions","includes","vertical","horizontal","showBorder","coordsOfDragAndDropBorders","redrawBorders","addRow","_registerTimeout","alter","undefined","addingStarted","addNewRowIfNeeded","autoInsertRow","getSelectedLast","cornersOfSelectedDragArea","nrOfTableRows","countRows","getIndexOfLastAdjacentFilledInRow","getData","lastFilledInRowIndex","rowIndex","columnIndex","dataInCell","dataInNextLeftCell","dataInNextRightCell","addSelectionFromStartAreaToSpecificRowIndex","selectStartArea","commit","cornersOfArea","selectCell","index","selectAdjacent","handleDraggedCells","from","to","view","getIfMouseWasDraggedOutside","documentElement","rootDocument","tableBottom","table","top","rootWindow","pageYOffset","scrollTop","tableRight","left","pageXOffset","scrollLeft","clientY","clientX","eventManager","addEventListener","_onMouseUp2","_onMouseMove2","mappedSettings","destroy","selectionApplied","mouseDownOnCellCorner","isMouseDown","mouseWasDraggedOutside","mouseDragOutside"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/autofill/autofill.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { offset, outerHeight, outerWidth } from \"../../helpers/dom/element.mjs\";\nimport { arrayEach, arrayMap } from \"../../helpers/array.mjs\";\nimport { getDragDirectionAndRange, DIRECTIONS, getMappedFillHandleSetting } from \"./utils.mjs\";\nHooks.getSingleton().register('modifyAutofillRange');\nHooks.getSingleton().register('beforeAutofill');\nHooks.getSingleton().register('afterAutofill');\nexport const PLUGIN_KEY = 'autofill';\nexport const PLUGIN_PRIORITY = 20;\nconst SETTING_KEYS = ['fillHandle'];\nconst INSERT_ROW_ALTER_ACTION_NAME = 'insert_row_below';\nconst INTERVAL_FOR_ADDING_ROW = 200;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * This plugin provides \"drag-down\" and \"copy-down\" functionalities, both operated using the small square in the right\n * bottom of the cell selection.\n *\n * \"Drag-down\" expands the value of the selected cells to the neighbouring cells when you drag the small\n * square in the corner.\n *\n * \"Copy-down\" copies the value of the selection to all empty cells below when you double click the small square.\n *\n * @class Autofill\n * @plugin Autofill\n */\nvar _onCellCornerDblClick = /*#__PURE__*/new WeakSet();\nvar _onAfterCellCornerMouseDown = /*#__PURE__*/new WeakSet();\nvar _onBeforeCellMouseOver = /*#__PURE__*/new WeakSet();\nvar _onMouseUp = /*#__PURE__*/new WeakSet();\nvar _onMouseMove = /*#__PURE__*/new WeakSet();\nexport class Autofill extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * On mouse move listener.\n     *\n     * @param {MouseEvent} event `mousemove` event properties.\n     */\n    _classPrivateMethodInitSpec(this, _onMouseMove);\n    /**\n     * On mouse up listener.\n     */\n    _classPrivateMethodInitSpec(this, _onMouseUp);\n    /**\n     * On before cell mouse over listener.\n     *\n     * @param {CellCoords} coords `CellCoords` coord object.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeCellMouseOver);\n    /**\n     * On after cell corner mouse down listener.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCellCornerMouseDown);\n    /**\n     * On cell corner double click callback.\n     *\n     * @private\n     */\n    _classPrivateMethodInitSpec(this, _onCellCornerDblClick);\n    /**\n     * Specifies if adding new row started.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"addingStarted\", false);\n    /**\n     * Specifies if there was mouse down on the cell corner.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"mouseDownOnCellCorner\", false);\n    /**\n     * Specifies if mouse was dragged outside Handsontable.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"mouseDragOutside\", false);\n    /**\n     * Specifies how many cell levels were dragged using the handle.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"handleDraggedCells\", 0);\n    /**\n     * Specifies allowed directions of drag (`'horizontal'` or '`vertical`').\n     *\n     * @private\n     * @type {string[]}\n     */\n    _defineProperty(this, \"directions\", []);\n    /**\n     * Specifies if can insert new rows if needed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"autoInsertRow\", false);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  /**\n   * Checks if the plugin is enabled in the Handsontable settings.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return this.hot.getSettings().fillHandle;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.mapSettings();\n    this.registerEvents();\n    this.addHook('afterOnCellCornerMouseDown', event => _classPrivateMethodGet(this, _onAfterCellCornerMouseDown, _onAfterCellCornerMouseDown2).call(this, event));\n    this.addHook('afterOnCellCornerDblClick', event => _classPrivateMethodGet(this, _onCellCornerDblClick, _onCellCornerDblClick2).call(this, event));\n    this.addHook('beforeOnCellMouseOver', (_, coords) => _classPrivateMethodGet(this, _onBeforeCellMouseOver, _onBeforeCellMouseOver2).call(this, coords));\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - `autofill`\n   *  - [`fillHandle`](@/api/options.md#fillhandle)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearMappedSettings();\n    super.disablePlugin();\n  }\n\n  /**\n   * Gets selection data.\n   *\n   * @private\n   * @returns {object[]} Ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.\n   */\n  getSelectionData() {\n    const selection = this.hot.getSelectedRangeLast();\n    const {\n      row: startRow,\n      col: startCol\n    } = selection.getTopStartCorner();\n    const {\n      row: endRow,\n      col: endCol\n    } = selection.getBottomEndCorner();\n    const copyableRanges = this.hot.runHooks('modifyCopyableRange', [{\n      startRow,\n      startCol,\n      endRow,\n      endCol\n    }]);\n    const copyableRows = [];\n    const copyableColumns = [];\n    const data = [];\n    arrayEach(copyableRanges, range => {\n      for (let visualRow = range.startRow; visualRow <= range.endRow; visualRow += 1) {\n        if (copyableRows.indexOf(visualRow) === -1) {\n          copyableRows.push(visualRow);\n        }\n      }\n      for (let visualColumn = range.startCol; visualColumn <= range.endCol; visualColumn += 1) {\n        if (copyableColumns.indexOf(visualColumn) === -1) {\n          copyableColumns.push(visualColumn);\n        }\n      }\n    });\n    arrayEach(copyableRows, row => {\n      const rowSet = [];\n      arrayEach(copyableColumns, column => {\n        rowSet.push(this.hot.getCopyableData(row, column));\n      });\n      data.push(rowSet);\n    });\n    return data;\n  }\n\n  /**\n   * Try to apply fill values to the area in fill border, omitting the selection border.\n   *\n   * @private\n   * @returns {boolean} Reports if fill was applied.\n   *\n   * @fires Hooks#modifyAutofillRange\n   * @fires Hooks#beforeAutofill\n   * @fires Hooks#afterAutofill\n   */\n  fillIn() {\n    if (this.hot.selection.highlight.getFill().isEmpty()) {\n      return false;\n    }\n\n    // Fill area may starts or ends with invisible cell. There won't be any information about it as highlighted\n    // selection store just renderable indexes (It's part of Walkontable). I extrapolate where the start or/and\n    // the end is.\n    const [fillStartRow, fillStartColumn, fillEndRow, fillEndColumn] = this.hot.selection.highlight.getFill().getVisualCorners();\n    const selectionRangeLast = this.hot.getSelectedRangeLast();\n    const topStartCorner = selectionRangeLast.getTopStartCorner();\n    const bottomEndCorner = selectionRangeLast.getBottomEndCorner();\n    this.resetSelectionOfDraggedArea();\n    const cornersOfSelectedCells = [topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col];\n    const cornersOfSelectionAndDragAreas = this.hot.runHooks('modifyAutofillRange', [Math.min(topStartCorner.row, fillStartRow), Math.min(topStartCorner.col, fillStartColumn), Math.max(bottomEndCorner.row, fillEndRow), Math.max(bottomEndCorner.col, fillEndColumn)], cornersOfSelectedCells);\n    const {\n      directionOfDrag,\n      startOfDragCoords,\n      endOfDragCoords\n    } = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas, (row, column) => this.hot._createCellCoords(row, column));\n    if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {\n      const selectionData = this.getSelectionData();\n      const sourceRange = selectionRangeLast.clone();\n      const targetRange = this.hot._createCellRange(startOfDragCoords, startOfDragCoords, endOfDragCoords);\n      const beforeAutofillHookResult = this.hot.runHooks('beforeAutofill', selectionData, sourceRange, targetRange, directionOfDrag);\n      if (beforeAutofillHookResult === false) {\n        this.hot.selection.highlight.getFill().clear();\n        this.hot.render();\n        return false;\n      }\n      let fillData = beforeAutofillHookResult;\n      const res = beforeAutofillHookResult;\n      if (['up', 'left'].indexOf(directionOfDrag) > -1 && !(res.length === 1 && res[0].length === 0)) {\n        fillData = [];\n        if (directionOfDrag === 'up') {\n          const dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;\n          const fillOffset = dragLength % res.length;\n          for (let i = 0; i < dragLength; i++) {\n            fillData.push(res[(i + (res.length - fillOffset)) % res.length]);\n          }\n        } else {\n          const dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;\n          const fillOffset = dragLength % res[0].length;\n          for (let i = 0; i < res.length; i++) {\n            fillData.push([]);\n            for (let j = 0; j < dragLength; j++) {\n              fillData[i].push(res[i][(j + (res[i].length - fillOffset)) % res[i].length]);\n            }\n          }\n        }\n      }\n      this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, `${this.pluginName}.fill`, null);\n      this.setSelection(cornersOfSelectionAndDragAreas);\n      this.hot.runHooks('afterAutofill', fillData, sourceRange, targetRange, directionOfDrag);\n      this.hot.render();\n    } else {\n      // reset to avoid some range bug\n      this.hot._refreshBorders();\n    }\n    return true;\n  }\n\n  /**\n   * Reduces the selection area if the handle was dragged outside of the table or on headers.\n   *\n   * @private\n   * @param {CellCoords} coords Indexes of selection corners.\n   * @returns {CellCoords}\n   */\n  reduceSelectionAreaIfNeeded(coords) {\n    if (coords.row < 0) {\n      coords.row = 0;\n    }\n    if (coords.col < 0) {\n      coords.col = 0;\n    }\n    return coords;\n  }\n\n  /**\n   * Gets the coordinates of the drag & drop borders.\n   *\n   * @private\n   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n   * @returns {CellCoords}\n   */\n  getCoordsOfDragAndDropBorders(coordsOfSelection) {\n    const currentSelection = this.hot.getSelectedRangeLast();\n    const bottomRightCorner = currentSelection.getBottomEndCorner();\n    let coords = coordsOfSelection;\n    if (this.directions.includes(DIRECTIONS.vertical) && this.directions.includes(DIRECTIONS.horizontal)) {\n      const topStartCorner = currentSelection.getTopStartCorner();\n      if (bottomRightCorner.col <= coordsOfSelection.col || topStartCorner.col >= coordsOfSelection.col) {\n        coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);\n      }\n      if (bottomRightCorner.row < coordsOfSelection.row || topStartCorner.row > coordsOfSelection.row) {\n        coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);\n      }\n    } else if (this.directions.includes(DIRECTIONS.vertical)) {\n      coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);\n    } else if (this.directions.includes(DIRECTIONS.horizontal)) {\n      coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);\n    } else {\n      // wrong direction\n      return;\n    }\n    return this.reduceSelectionAreaIfNeeded(coords);\n  }\n\n  /**\n   * Show the fill border.\n   *\n   * @private\n   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.\n   */\n  showBorder(coordsOfSelection) {\n    const coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);\n    if (coordsOfDragAndDropBorders) {\n      this.redrawBorders(coordsOfDragAndDropBorders);\n    }\n  }\n\n  /**\n   * Add new row.\n   *\n   * @private\n   */\n  addRow() {\n    this.hot._registerTimeout(() => {\n      this.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, undefined, 1, `${this.pluginName}.fill`);\n      this.addingStarted = false;\n    }, INTERVAL_FOR_ADDING_ROW);\n  }\n\n  /**\n   * Add new rows if they are needed to continue auto-filling values.\n   *\n   * @private\n   */\n  addNewRowIfNeeded() {\n    if (!this.hot.selection.highlight.getFill().isEmpty() && this.addingStarted === false && this.autoInsertRow) {\n      const cornersOfSelectedCells = this.hot.getSelectedLast();\n      const cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getVisualCorners();\n      const nrOfTableRows = this.hot.countRows();\n      if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {\n        this.addingStarted = true;\n        this.addRow();\n      }\n    }\n  }\n\n  /**\n   * Get index of last adjacent filled in row.\n   *\n   * @private\n   * @param {Array} cornersOfSelectedCells Indexes of selection corners.\n   * @returns {number} Gives number greater than or equal to zero when selection adjacent can be applied.\n   *                   Or -1 when selection adjacent can't be applied.\n   */\n  getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {\n    const data = this.hot.getData();\n    const nrOfTableRows = this.hot.countRows();\n    let lastFilledInRowIndex;\n    for (let rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {\n      for (let columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {\n        const dataInCell = data[rowIndex][columnIndex];\n        if (dataInCell) {\n          return -1;\n        }\n      }\n      const dataInNextLeftCell = data[rowIndex][cornersOfSelectedCells[1] - 1];\n      const dataInNextRightCell = data[rowIndex][cornersOfSelectedCells[3] + 1];\n      if (!!dataInNextLeftCell || !!dataInNextRightCell) {\n        lastFilledInRowIndex = rowIndex;\n      }\n    }\n    return lastFilledInRowIndex;\n  }\n\n  /**\n   * Adds a selection from the start area to the specific row index.\n   *\n   * @private\n   * @param {Array} selectStartArea Selection area from which we start to create more comprehensive selection.\n   * @param {number} rowIndex The row index into the selection will be added.\n   */\n  addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {\n    this.hot.selection.highlight.getFill().clear().add(this.hot._createCellCoords(selectStartArea[0], selectStartArea[1])).add(this.hot._createCellCoords(rowIndex, selectStartArea[3])).commit();\n  }\n\n  /**\n   * Sets selection based on passed corners.\n   *\n   * @private\n   * @param {Array} cornersOfArea An array witch defines selection.\n   */\n  setSelection(cornersOfArea) {\n    this.hot.selectCell(...arrayMap(cornersOfArea, index => Math.max(index, 0)), false, false);\n  }\n\n  /**\n   * Try to select cells down to the last row in the left column and then returns if selection was applied.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  selectAdjacent() {\n    const cornersOfSelectedCells = this.hot.getSelectedLast();\n    const lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);\n    if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === undefined) {\n      return false;\n    }\n    this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);\n    return true;\n  }\n\n  /**\n   * Resets selection of dragged area.\n   *\n   * @private\n   */\n  resetSelectionOfDraggedArea() {\n    this.handleDraggedCells = 0;\n    this.hot.selection.highlight.getFill().clear();\n  }\n\n  /**\n   * Redraws borders.\n   *\n   * @private\n   * @param {CellCoords} coords `CellCoords` coord object.\n   */\n  redrawBorders(coords) {\n    this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords).commit();\n    this.hot.view.render();\n  }\n\n  /**\n   * Get if mouse was dragged outside.\n   *\n   * @private\n   * @param {MouseEvent} event `mousemove` event properties.\n   * @returns {boolean}\n   */\n  getIfMouseWasDraggedOutside(event) {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    const tableBottom = offset(this.hot.table).top - (this.hot.rootWindow.pageYOffset || documentElement.scrollTop) + outerHeight(this.hot.table);\n    const tableRight = offset(this.hot.table).left - (this.hot.rootWindow.pageXOffset || documentElement.scrollLeft) + outerWidth(this.hot.table);\n    return event.clientY > tableBottom && event.clientX <= tableRight;\n  }\n\n  /**\n   * Bind the events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    this.eventManager.addEventListener(documentElement, 'mouseup', () => _classPrivateMethodGet(this, _onMouseUp, _onMouseUp2).call(this));\n    this.eventManager.addEventListener(documentElement, 'mousemove', event => _classPrivateMethodGet(this, _onMouseMove, _onMouseMove2).call(this, event));\n  }\n  /**\n   * Clears mapped settings.\n   *\n   * @private\n   */\n  clearMappedSettings() {\n    this.directions.length = 0;\n    this.autoInsertRow = false;\n  }\n\n  /**\n   * Map settings.\n   *\n   * @private\n   */\n  mapSettings() {\n    const mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);\n    this.directions = mappedSettings.directions;\n    this.autoInsertRow = mappedSettings.autoInsertRow;\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onCellCornerDblClick2() {\n  const selectionApplied = this.selectAdjacent();\n  if (selectionApplied) {\n    this.fillIn();\n  }\n}\nfunction _onAfterCellCornerMouseDown2() {\n  this.handleDraggedCells = 1;\n  this.mouseDownOnCellCorner = true;\n}\nfunction _onBeforeCellMouseOver2(coords) {\n  if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {\n    this.handleDraggedCells += 1;\n    this.showBorder(coords);\n    this.addNewRowIfNeeded();\n  }\n}\nfunction _onMouseUp2() {\n  if (this.handleDraggedCells) {\n    if (this.handleDraggedCells > 1) {\n      this.fillIn();\n    }\n    this.handleDraggedCells = 0;\n    this.mouseDownOnCellCorner = false;\n  }\n}\nfunction _onMouseMove2(event) {\n  const mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event);\n  if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {\n    this.mouseDragOutside = true;\n    this.addingStarted = true;\n  } else {\n    this.mouseDragOutside = false;\n  }\n  if (this.mouseDragOutside && this.autoInsertRow) {\n    this.addRow();\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}