{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport CellCoords from \"./../cell/coords.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n *\n * The `CellRange` class holds a set of cell coordinates ([`CellCoords`](@/api/cellCoords.md) instances)\n * that form a [selection range](@/guides/cell-features/selection.md#select-ranges).\n *\n * A single `CellRange` instance represents a single unit of selection\n * that contains either a single cell or multiple adjacent cells.\n *\n * To import the `CellRange` class:\n *\n * ```js\n * import Handsontable, { CellRange } from '/handsontable';\n *\n * // or, using modules\n * import Handsontable, { CellRange } from '/handsontable/base';\n * ```\n */\nvar _isRtl = /*#__PURE__*/new WeakMap();\nclass CellRange {\n  constructor(highlight) {\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n    let isRtl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    /**\n     * Used to draw bold border around a cell where selection was started and to edit the cell\n     * when you press Enter. The highlight cannot point to headers (negative values) so its\n     * coordinates object is normalized while assigning.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"highlight\", null);\n    /**\n     * Usually the same as highlight, but in Excel there is distinction - one can change\n     * highlight within a selection.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"from\", null);\n    /**\n     * End selection.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"to\", null);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isRtl, {\n      writable: true,\n      value: false\n    });\n    this.highlight = highlight.clone();\n    this.from = from.clone();\n    this.to = to.clone();\n    _classPrivateFieldSet(this, _isRtl, isRtl);\n  }\n\n  /**\n   * Highlights cell selection at the `coords` coordinates.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setHighlight(coords) {\n    this.highlight = coords.clone();\n    return this;\n  }\n\n  /**\n   * Sets the `coords` coordinates as the start of your range.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setFrom(coords) {\n    this.from = coords.clone();\n    return this;\n  }\n\n  /**\n   * Sets the `coords` coordinates as the end of your range.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setTo(coords) {\n    this.to = coords.clone();\n    return this;\n  }\n\n  /**\n   * Checks if the coordinates in your `CellRange` instance are valid\n   * in the context of given table parameters.\n   *\n   * See the [`isValid()`](@/api/cellCoords.md#isvalid) method of the [`CellCoords`](@/api/cellCoords.md) class.\n   *\n   * @param {object} tableParams An object with a defined table size.\n   * @param {number} tableParams.countRows The total number of rows.\n   * @param {number} tableParams.countCols The total number of columns.\n   * @param {number} tableParams.countRowHeaders A number of row headers.\n   * @param {number} tableParams.countColHeaders A number of column headers.\n   * @returns {boolean}\n   */\n  isValid(tableParams) {\n    return this.from.isValid(tableParams) && this.to.isValid(tableParams);\n  }\n\n  /**\n   * Checks if your range is just a single cell or header.\n   *\n   * @returns {boolean}\n   */\n  isSingle() {\n    return this.isSingleCell() || this.isSingleHeader();\n  }\n\n  /**\n   * Checks if your range is just a single cell.\n   *\n   * @returns {boolean}\n   */\n  isSingleCell() {\n    return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;\n  }\n\n  /**\n   * Checks if your range is just a single header.\n   *\n   * @returns {boolean}\n   */\n  isSingleHeader() {\n    return (this.from.row < 0 || this.from.col < 0) && this.from.row === this.to.row && this.from.col === this.to.col;\n  }\n\n  /**\n   * Checks if your range overlaps headers range (negative coordinates).\n   *\n   * @returns {boolean}\n   */\n  containsHeaders() {\n    return this.from.isHeader() || this.to.isHeader();\n  }\n\n  /**\n   * Returns the height of your range (as a number of rows, including row headers).\n   *\n   * @returns {number}\n   */\n  getOuterHeight() {\n    return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n  }\n\n  /**\n   * Returns the width of your range (as a number of columns, including column headers).\n   *\n   * @returns {number}\n   */\n  getOuterWidth() {\n    return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n  }\n\n  /**\n   * Returns the height of your range (as a number of rows, excluding row headers).\n   *\n   * @returns {number}\n   */\n  getHeight() {\n    // if the selection contains only row headers, return 0\n    if (this.from.row < 0 && this.to.row < 0) {\n      return 0;\n    }\n    const fromRow = Math.max(this.from.row, 0);\n    const toRow = Math.max(this.to.row, 0);\n    return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;\n  }\n\n  /**\n   * Returns the width of your range (as a number of columns, excluding column headers).\n   *\n   * @returns {number}\n   */\n  getWidth() {\n    // if the selection contains only column headers, return 0\n    if (this.from.col < 0 && this.to.col < 0) {\n      return 0;\n    }\n    const fromCol = Math.max(this.from.col, 0);\n    const toCol = Math.max(this.to.col, 0);\n    return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\n  }\n\n  /**\n   * Returns the number of cells within your range (excluding column and row headers).\n   *\n   * @returns {number}\n   */\n  getCellsCount() {\n    return this.getWidth() * this.getHeight();\n  }\n\n  /**\n   * Checks if another set of coordinates (`cellCoords`)\n   * is within the `from` and `to` coordinates of your range.\n   *\n   * @param {CellCoords} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  includes(cellCoords) {\n    const {\n      row,\n      col\n    } = cellCoords;\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    return topStart.row <= row && bottomEnd.row >= row && topStart.col <= col && bottomEnd.col >= col;\n  }\n\n  /**\n   * Checks if another range (`cellRange`) is within your range.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  includesRange(cellRange) {\n    return this.includes(cellRange.getOuterTopStartCorner()) && this.includes(cellRange.getOuterBottomEndCorner());\n  }\n\n  /**\n   * Checks if another range (`cellRange`) is equal to your range.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isEqual(cellRange) {\n    return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range.\n   *\n   * Range A overlaps range B if the intersection of A and B (or B and A) is not empty.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  overlaps(cellRange) {\n    return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\n  }\n\n  /**\n   * Checks if coordinates point is south-east of your range.\n   *\n   * @param {CellCoords} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  isSouthEastOf(cellCoords) {\n    return this.getOuterTopLeftCorner().isSouthEastOf(cellCoords) || this.getOuterBottomRightCorner().isSouthEastOf(cellCoords);\n  }\n\n  /**\n   * Checks if coordinates point is north-west of your range.\n   *\n   * @param {CellRange} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  isNorthWestOf(cellCoords) {\n    return this.getOuterTopLeftCorner().isNorthWestOf(cellCoords) || this.getOuterBottomRightCorner().isNorthWestOf(cellCoords);\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range horizontally.\n   *\n   * For example: returns `true` if the last column of your range is `5`\n   * and the first column of the `cellRange` range is `3`.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isOverlappingHorizontally(cellRange) {\n    return this.getOuterTopEndCorner().col >= cellRange.getOuterTopStartCorner().col && this.getOuterTopEndCorner().col <= cellRange.getOuterTopEndCorner().col || this.getOuterTopStartCorner().col <= cellRange.getOuterTopEndCorner().col && this.getOuterTopStartCorner().col >= cellRange.getOuterTopStartCorner().col;\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range vertically.\n   *\n   * For example: returns `true` if the last row of your range is `5`\n   * and the first row of the `cellRange` range is `3`.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isOverlappingVertically(cellRange) {\n    return this.getOuterBottomStartCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomStartCorner().row <= cellRange.getOuterBottomStartCorner().row || this.getOuterTopEndCorner().row <= cellRange.getOuterBottomStartCorner().row && this.getOuterTopEndCorner().row >= cellRange.getOuterTopRightCorner().row;\n  }\n\n  /**\n   * Adds a cell to your range, at `cellCoords` coordinates.\n   *\n   * The `cellCoords` coordinates must exceed a corner of your range.\n   *\n   * @param {CellCoords} cellCoords A new cell's coordinates.\n   * @returns {boolean}\n   */\n  expand(cellCoords) {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    if (cellCoords.row < topStart.row || cellCoords.col < topStart.col || cellCoords.row > bottomEnd.row || cellCoords.col > bottomEnd.col) {\n      this.from = this._createCellCoords(Math.min(topStart.row, cellCoords.row), Math.min(topStart.col, cellCoords.col));\n      this.to = this._createCellCoords(Math.max(bottomEnd.row, cellCoords.row), Math.max(bottomEnd.col, cellCoords.col));\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Expand your range with another range (`expandingRange`).\n   *\n   * @param {CellRange} expandingRange A new range.\n   * @returns {boolean}\n   */\n  expandByRange(expandingRange) {\n    if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n      return false;\n    }\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const initialDirection = this.getDirection();\n    const expandingTopStart = expandingRange.getOuterTopStartCorner();\n    const expandingBottomEnd = expandingRange.getOuterBottomEndCorner();\n    const resultTopRow = Math.min(topStart.row, expandingTopStart.row);\n    const resultTopCol = Math.min(topStart.col, expandingTopStart.col);\n    const resultBottomRow = Math.max(bottomEnd.row, expandingBottomEnd.row);\n    const resultBottomCol = Math.max(bottomEnd.col, expandingBottomEnd.col);\n    const finalFrom = this._createCellCoords(resultTopRow, resultTopCol);\n    const finalTo = this._createCellCoords(resultBottomRow, resultBottomCol);\n    this.from = finalFrom;\n    this.to = finalTo;\n    this.setDirection(initialDirection);\n    if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n      this.flipDirectionVertically();\n    }\n    if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n      this.flipDirectionHorizontally();\n    }\n    return true;\n  }\n\n  /**\n   * Gets the direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n   */\n  getDirection() {\n    if (this.from.isNorthWestOf(this.to)) {\n      // NorthWest - SouthEast\n      return 'NW-SE';\n    } else if (this.from.isNorthEastOf(this.to)) {\n      // NorthEast - SouthWest\n      return 'NE-SW';\n    } else if (this.from.isSouthEastOf(this.to)) {\n      // SouthEast - NorthWest\n      return 'SE-NW';\n    } else if (this.from.isSouthWestOf(this.to)) {\n      // SouthWest - NorthEast\n      return 'SW-NE';\n    }\n  }\n\n  /**\n   * Sets the direction of the selection.\n   *\n   * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n   */\n  setDirection(direction) {\n    switch (direction) {\n      case 'NW-SE':\n        [this.from, this.to] = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\n        break;\n      case 'NE-SW':\n        [this.from, this.to] = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\n        break;\n      case 'SE-NW':\n        [this.from, this.to] = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\n        break;\n      case 'SW-NE':\n        [this.from, this.to] = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Gets the vertical direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n   */\n  getVerticalDirection() {\n    return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n  }\n\n  /**\n   * Gets the horizontal direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n   */\n  getHorizontalDirection() {\n    return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n  }\n\n  /**\n   * Flips the direction of your range vertically (e.g., `NW-SE` changes to `SW-NE`).\n   */\n  flipDirectionVertically() {\n    const direction = this.getDirection();\n    switch (direction) {\n      case 'NW-SE':\n        this.setDirection('SW-NE');\n        break;\n      case 'NE-SW':\n        this.setDirection('SE-NW');\n        break;\n      case 'SE-NW':\n        this.setDirection('NE-SW');\n        break;\n      case 'SW-NE':\n        this.setDirection('NW-SE');\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Flips the direction of your range horizontally (e.g., `NW-SE` changes to `NE-SW`).\n   */\n  flipDirectionHorizontally() {\n    const direction = this.getDirection();\n    switch (direction) {\n      case 'NW-SE':\n        this.setDirection('NE-SW');\n        break;\n      case 'NE-SW':\n        this.setDirection('NW-SE');\n        break;\n      case 'SE-NW':\n        this.setDirection('SW-NE');\n        break;\n      case 'SW-NE':\n        this.setDirection('SE-NW');\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Gets the top-left (in LTR) or top-right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopStartCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the top-left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopLeftCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getTopEndCorner() : this.getTopStartCorner();\n  }\n\n  /**\n   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomEndCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the bottom right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomRightCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getBottomStartCorner() : this.getBottomEndCorner();\n  }\n\n  /**\n   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopEndCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the top right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopRightCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getTopStartCorner() : this.getTopEndCorner();\n  }\n\n  /**\n   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomStartCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the bottom left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomLeftCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getBottomEndCorner() : this.getBottomStartCorner();\n  }\n\n  /**\n   * Gets the top left (in LTR) or top right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopStartCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the top left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopLeftCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getOuterTopEndCorner() : this.getOuterTopStartCorner();\n  }\n\n  /**\n   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomEndCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the bottom right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomRightCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getOuterBottomStartCorner() : this.getOuterBottomEndCorner();\n  }\n\n  /**\n   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopEndCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the top right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopRightCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getOuterTopStartCorner() : this.getOuterTopEndCorner();\n  }\n\n  /**\n   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomStartCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the bottom left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomLeftCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getOuterBottomEndCorner() : this.getOuterBottomStartCorner();\n  }\n\n  /**\n   * Checks if a set of coordinates (`coords`) matches one of the 4 corners of your range.\n   *\n   * @param {CellCoords} coords Coordinates to check.\n   * @returns {boolean}\n   */\n  isCorner(coords) {\n    return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());\n  }\n\n  /**\n   * Gets the coordinates of a range corner opposite to the provided `coords`.\n   *\n   * For example: if the `coords` coordinates match the bottom-right corner of your range,\n   * the coordinates of the top-left corner of your range are returned.\n   *\n   * @param {CellCoords} coords Coordinates to check.\n   * @returns {CellCoords}\n   */\n  getOppositeCorner(coords) {\n    if (!(coords instanceof CellCoords)) {\n      return false;\n    }\n    if (coords.isEqual(this.getOuterBottomEndCorner())) {\n      return this.getOuterTopStartCorner();\n    } else if (coords.isEqual(this.getOuterTopStartCorner())) {\n      return this.getOuterBottomEndCorner();\n    } else if (coords.isEqual(this.getOuterTopEndCorner())) {\n      return this.getOuterBottomStartCorner();\n    } else if (coords.isEqual(this.getOuterBottomStartCorner())) {\n      return this.getOuterTopEndCorner();\n    }\n  }\n\n  /**\n   * Indicates which borders (top, right, bottom, left) are shared between\n   * your `CellRange`instance and another `range` that's within your range.\n   *\n   * @param {CellRange} range A range to compare with.\n   * @returns {Array<'top' | 'right' | 'bottom' | 'left'>}\n   */\n  getBordersSharedWith(range) {\n    if (!this.includesRange(range)) {\n      return [];\n    }\n    const thisBorders = {\n      top: Math.min(this.from.row, this.to.row),\n      bottom: Math.max(this.from.row, this.to.row),\n      left: Math.min(this.from.col, this.to.col),\n      right: Math.max(this.from.col, this.to.col)\n    };\n    const rangeBorders = {\n      top: Math.min(range.from.row, range.to.row),\n      bottom: Math.max(range.from.row, range.to.row),\n      left: Math.min(range.from.col, range.to.col),\n      right: Math.max(range.from.col, range.to.col)\n    };\n    const result = [];\n    if (thisBorders.top === rangeBorders.top) {\n      result.push('top');\n    }\n    if (thisBorders.right === rangeBorders.right) {\n      result.push(_classPrivateFieldGet(this, _isRtl) ? 'left' : 'right');\n    }\n    if (thisBorders.bottom === rangeBorders.bottom) {\n      result.push('bottom');\n    }\n    if (thisBorders.left === rangeBorders.left) {\n      result.push(_classPrivateFieldGet(this, _isRtl) ? 'right' : 'left');\n    }\n    return result;\n  }\n\n  /**\n   * Gets the coordinates of the inner cells of your range.\n   *\n   * @returns {CellCoords[]}\n   */\n  getInner() {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const out = [];\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n          out.push(this._createCellCoords(r, c));\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Gets the coordinates of all cells of your range.\n   *\n   * @returns {CellCoords[]}\n   */\n  getAll() {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const out = [];\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        if (topStart.row === r && topStart.col === c) {\n          out.push(topStart);\n        } else if (bottomEnd.row === r && bottomEnd.col === c) {\n          out.push(bottomEnd);\n        } else {\n          out.push(this._createCellCoords(r, c));\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Runs a callback function on all cells within your range.\n   *\n   * You can break the iteration by returning `false` in the callback function.\n   *\n   * @param {function(number, number): boolean} callback A callback function.\n   */\n  forAll(callback) {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        const breakIteration = callback(r, c);\n        if (breakIteration === false) {\n          return;\n        }\n      }\n    }\n  }\n\n  /**\n   * Clones your `CellRange` instance.\n   *\n   * @returns {CellRange}\n   */\n  clone() {\n    return new CellRange(this.highlight, this.from, this.to, _classPrivateFieldGet(this, _isRtl));\n  }\n\n  /**\n   * Converts your `CellRange` instance into an object literal with the following properties:\n   *\n   * - `from`\n   *    - `row`\n   *    - `col`\n   * - `to`\n   *    - `row`\n   *    - `col`\n   *\n   * @returns {{from: {row: number, col: number}, to: {row: number, col: number}}} An object literal with `from` and `to` properties.\n   */\n  toObject() {\n    return {\n      from: this.from.toObject(),\n      to: this.to.toObject()\n    };\n  }\n\n  /**\n   * Creates and returns a new instance of the `CellCoords` class.\n   *\n   * The new `CellCoords` instance automatically inherits the LTR/RTL flag\n   * from your `CellRange` instance.\n   *\n   * @private\n   * @param {number} row A row index.\n   * @param {number} column A column index.\n   * @returns {CellCoords}\n   */\n  _createCellCoords(row, column) {\n    return new CellCoords(row, column, _classPrivateFieldGet(this, _isRtl));\n  }\n}\nexport default CellRange;","map":{"version":3,"names":["_classPrivateFieldInitSpec","obj","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","TypeError","_defineProperty","key","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateFieldGet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","_classPrivateFieldSet","_classApplyDescriptorSet","action","CellCoords","_isRtl","WeakMap","CellRange","constructor","highlight","from","arguments","length","undefined","to","isRtl","clone","setHighlight","coords","setFrom","setTo","isValid","tableParams","isSingle","isSingleCell","isSingleHeader","row","col","containsHeaders","isHeader","getOuterHeight","Math","max","min","getOuterWidth","getHeight","fromRow","toRow","getWidth","fromCol","toCol","getCellsCount","includes","cellCoords","topStart","getOuterTopStartCorner","bottomEnd","getOuterBottomEndCorner","includesRange","cellRange","isEqual","overlaps","isSouthEastOf","getOuterTopLeftCorner","isNorthWestOf","getOuterBottomRightCorner","isOverlappingHorizontally","getOuterTopEndCorner","isOverlappingVertically","getOuterBottomStartCorner","getOuterTopRightCorner","expand","_createCellCoords","expandByRange","expandingRange","initialDirection","getDirection","expandingTopStart","expandingBottomEnd","resultTopRow","resultTopCol","resultBottomRow","resultBottomCol","finalFrom","finalTo","setDirection","getVerticalDirection","flipDirectionVertically","getHorizontalDirection","flipDirectionHorizontally","isNorthEastOf","isSouthWestOf","direction","getOuterBottomLeftCorner","indexOf","getTopStartCorner","normalize","getTopLeftCorner","getTopEndCorner","getBottomEndCorner","getBottomRightCorner","getBottomStartCorner","getTopRightCorner","getBottomLeftCorner","isCorner","getOppositeCorner","getBordersSharedWith","range","thisBorders","top","bottom","left","right","rangeBorders","result","push","getInner","out","c","getAll","forAll","callback","breakIteration","toObject","column"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/3rdparty/walkontable/src/cell/range.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport CellCoords from \"./../cell/coords.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n *\n * The `CellRange` class holds a set of cell coordinates ([`CellCoords`](@/api/cellCoords.md) instances)\n * that form a [selection range](@/guides/cell-features/selection.md#select-ranges).\n *\n * A single `CellRange` instance represents a single unit of selection\n * that contains either a single cell or multiple adjacent cells.\n *\n * To import the `CellRange` class:\n *\n * ```js\n * import Handsontable, { CellRange } from '/handsontable';\n *\n * // or, using modules\n * import Handsontable, { CellRange } from '/handsontable/base';\n * ```\n */\nvar _isRtl = /*#__PURE__*/new WeakMap();\nclass CellRange {\n  constructor(highlight) {\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n    let isRtl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    /**\n     * Used to draw bold border around a cell where selection was started and to edit the cell\n     * when you press Enter. The highlight cannot point to headers (negative values) so its\n     * coordinates object is normalized while assigning.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"highlight\", null);\n    /**\n     * Usually the same as highlight, but in Excel there is distinction - one can change\n     * highlight within a selection.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"from\", null);\n    /**\n     * End selection.\n     *\n     * @private\n     * @type {CellCoords}\n     */\n    _defineProperty(this, \"to\", null);\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isRtl, {\n      writable: true,\n      value: false\n    });\n    this.highlight = highlight.clone();\n    this.from = from.clone();\n    this.to = to.clone();\n    _classPrivateFieldSet(this, _isRtl, isRtl);\n  }\n\n  /**\n   * Highlights cell selection at the `coords` coordinates.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setHighlight(coords) {\n    this.highlight = coords.clone();\n    return this;\n  }\n\n  /**\n   * Sets the `coords` coordinates as the start of your range.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setFrom(coords) {\n    this.from = coords.clone();\n    return this;\n  }\n\n  /**\n   * Sets the `coords` coordinates as the end of your range.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  setTo(coords) {\n    this.to = coords.clone();\n    return this;\n  }\n\n  /**\n   * Checks if the coordinates in your `CellRange` instance are valid\n   * in the context of given table parameters.\n   *\n   * See the [`isValid()`](@/api/cellCoords.md#isvalid) method of the [`CellCoords`](@/api/cellCoords.md) class.\n   *\n   * @param {object} tableParams An object with a defined table size.\n   * @param {number} tableParams.countRows The total number of rows.\n   * @param {number} tableParams.countCols The total number of columns.\n   * @param {number} tableParams.countRowHeaders A number of row headers.\n   * @param {number} tableParams.countColHeaders A number of column headers.\n   * @returns {boolean}\n   */\n  isValid(tableParams) {\n    return this.from.isValid(tableParams) && this.to.isValid(tableParams);\n  }\n\n  /**\n   * Checks if your range is just a single cell or header.\n   *\n   * @returns {boolean}\n   */\n  isSingle() {\n    return this.isSingleCell() || this.isSingleHeader();\n  }\n\n  /**\n   * Checks if your range is just a single cell.\n   *\n   * @returns {boolean}\n   */\n  isSingleCell() {\n    return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;\n  }\n\n  /**\n   * Checks if your range is just a single header.\n   *\n   * @returns {boolean}\n   */\n  isSingleHeader() {\n    return (this.from.row < 0 || this.from.col < 0) && this.from.row === this.to.row && this.from.col === this.to.col;\n  }\n\n  /**\n   * Checks if your range overlaps headers range (negative coordinates).\n   *\n   * @returns {boolean}\n   */\n  containsHeaders() {\n    return this.from.isHeader() || this.to.isHeader();\n  }\n\n  /**\n   * Returns the height of your range (as a number of rows, including row headers).\n   *\n   * @returns {number}\n   */\n  getOuterHeight() {\n    return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n  }\n\n  /**\n   * Returns the width of your range (as a number of columns, including column headers).\n   *\n   * @returns {number}\n   */\n  getOuterWidth() {\n    return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n  }\n\n  /**\n   * Returns the height of your range (as a number of rows, excluding row headers).\n   *\n   * @returns {number}\n   */\n  getHeight() {\n    // if the selection contains only row headers, return 0\n    if (this.from.row < 0 && this.to.row < 0) {\n      return 0;\n    }\n    const fromRow = Math.max(this.from.row, 0);\n    const toRow = Math.max(this.to.row, 0);\n    return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;\n  }\n\n  /**\n   * Returns the width of your range (as a number of columns, excluding column headers).\n   *\n   * @returns {number}\n   */\n  getWidth() {\n    // if the selection contains only column headers, return 0\n    if (this.from.col < 0 && this.to.col < 0) {\n      return 0;\n    }\n    const fromCol = Math.max(this.from.col, 0);\n    const toCol = Math.max(this.to.col, 0);\n    return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\n  }\n\n  /**\n   * Returns the number of cells within your range (excluding column and row headers).\n   *\n   * @returns {number}\n   */\n  getCellsCount() {\n    return this.getWidth() * this.getHeight();\n  }\n\n  /**\n   * Checks if another set of coordinates (`cellCoords`)\n   * is within the `from` and `to` coordinates of your range.\n   *\n   * @param {CellCoords} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  includes(cellCoords) {\n    const {\n      row,\n      col\n    } = cellCoords;\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    return topStart.row <= row && bottomEnd.row >= row && topStart.col <= col && bottomEnd.col >= col;\n  }\n\n  /**\n   * Checks if another range (`cellRange`) is within your range.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  includesRange(cellRange) {\n    return this.includes(cellRange.getOuterTopStartCorner()) && this.includes(cellRange.getOuterBottomEndCorner());\n  }\n\n  /**\n   * Checks if another range (`cellRange`) is equal to your range.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isEqual(cellRange) {\n    return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range.\n   *\n   * Range A overlaps range B if the intersection of A and B (or B and A) is not empty.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  overlaps(cellRange) {\n    return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\n  }\n\n  /**\n   * Checks if coordinates point is south-east of your range.\n   *\n   * @param {CellCoords} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  isSouthEastOf(cellCoords) {\n    return this.getOuterTopLeftCorner().isSouthEastOf(cellCoords) || this.getOuterBottomRightCorner().isSouthEastOf(cellCoords);\n  }\n\n  /**\n   * Checks if coordinates point is north-west of your range.\n   *\n   * @param {CellRange} cellCoords Coordinates to check.\n   * @returns {boolean}\n   */\n  isNorthWestOf(cellCoords) {\n    return this.getOuterTopLeftCorner().isNorthWestOf(cellCoords) || this.getOuterBottomRightCorner().isNorthWestOf(cellCoords);\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range horizontally.\n   *\n   * For example: returns `true` if the last column of your range is `5`\n   * and the first column of the `cellRange` range is `3`.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isOverlappingHorizontally(cellRange) {\n    return this.getOuterTopEndCorner().col >= cellRange.getOuterTopStartCorner().col && this.getOuterTopEndCorner().col <= cellRange.getOuterTopEndCorner().col || this.getOuterTopStartCorner().col <= cellRange.getOuterTopEndCorner().col && this.getOuterTopStartCorner().col >= cellRange.getOuterTopStartCorner().col;\n  }\n\n  /**\n   * Checks if another range (`cellRange`) overlaps your range vertically.\n   *\n   * For example: returns `true` if the last row of your range is `5`\n   * and the first row of the `cellRange` range is `3`.\n   *\n   * @param {CellRange} cellRange A range to check.\n   * @returns {boolean}\n   */\n  isOverlappingVertically(cellRange) {\n    return this.getOuterBottomStartCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomStartCorner().row <= cellRange.getOuterBottomStartCorner().row || this.getOuterTopEndCorner().row <= cellRange.getOuterBottomStartCorner().row && this.getOuterTopEndCorner().row >= cellRange.getOuterTopRightCorner().row;\n  }\n\n  /**\n   * Adds a cell to your range, at `cellCoords` coordinates.\n   *\n   * The `cellCoords` coordinates must exceed a corner of your range.\n   *\n   * @param {CellCoords} cellCoords A new cell's coordinates.\n   * @returns {boolean}\n   */\n  expand(cellCoords) {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    if (cellCoords.row < topStart.row || cellCoords.col < topStart.col || cellCoords.row > bottomEnd.row || cellCoords.col > bottomEnd.col) {\n      this.from = this._createCellCoords(Math.min(topStart.row, cellCoords.row), Math.min(topStart.col, cellCoords.col));\n      this.to = this._createCellCoords(Math.max(bottomEnd.row, cellCoords.row), Math.max(bottomEnd.col, cellCoords.col));\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Expand your range with another range (`expandingRange`).\n   *\n   * @param {CellRange} expandingRange A new range.\n   * @returns {boolean}\n   */\n  expandByRange(expandingRange) {\n    if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n      return false;\n    }\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const initialDirection = this.getDirection();\n    const expandingTopStart = expandingRange.getOuterTopStartCorner();\n    const expandingBottomEnd = expandingRange.getOuterBottomEndCorner();\n    const resultTopRow = Math.min(topStart.row, expandingTopStart.row);\n    const resultTopCol = Math.min(topStart.col, expandingTopStart.col);\n    const resultBottomRow = Math.max(bottomEnd.row, expandingBottomEnd.row);\n    const resultBottomCol = Math.max(bottomEnd.col, expandingBottomEnd.col);\n    const finalFrom = this._createCellCoords(resultTopRow, resultTopCol);\n    const finalTo = this._createCellCoords(resultBottomRow, resultBottomCol);\n    this.from = finalFrom;\n    this.to = finalTo;\n    this.setDirection(initialDirection);\n    if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n      this.flipDirectionVertically();\n    }\n    if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n      this.flipDirectionHorizontally();\n    }\n    return true;\n  }\n\n  /**\n   * Gets the direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n   */\n  getDirection() {\n    if (this.from.isNorthWestOf(this.to)) {\n      // NorthWest - SouthEast\n      return 'NW-SE';\n    } else if (this.from.isNorthEastOf(this.to)) {\n      // NorthEast - SouthWest\n      return 'NE-SW';\n    } else if (this.from.isSouthEastOf(this.to)) {\n      // SouthEast - NorthWest\n      return 'SE-NW';\n    } else if (this.from.isSouthWestOf(this.to)) {\n      // SouthWest - NorthEast\n      return 'SW-NE';\n    }\n  }\n\n  /**\n   * Sets the direction of the selection.\n   *\n   * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n   */\n  setDirection(direction) {\n    switch (direction) {\n      case 'NW-SE':\n        [this.from, this.to] = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\n        break;\n      case 'NE-SW':\n        [this.from, this.to] = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\n        break;\n      case 'SE-NW':\n        [this.from, this.to] = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\n        break;\n      case 'SW-NE':\n        [this.from, this.to] = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Gets the vertical direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n   */\n  getVerticalDirection() {\n    return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n  }\n\n  /**\n   * Gets the horizontal direction of the selection.\n   *\n   * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n   */\n  getHorizontalDirection() {\n    return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n  }\n\n  /**\n   * Flips the direction of your range vertically (e.g., `NW-SE` changes to `SW-NE`).\n   */\n  flipDirectionVertically() {\n    const direction = this.getDirection();\n    switch (direction) {\n      case 'NW-SE':\n        this.setDirection('SW-NE');\n        break;\n      case 'NE-SW':\n        this.setDirection('SE-NW');\n        break;\n      case 'SE-NW':\n        this.setDirection('NE-SW');\n        break;\n      case 'SW-NE':\n        this.setDirection('NW-SE');\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Flips the direction of your range horizontally (e.g., `NW-SE` changes to `NE-SW`).\n   */\n  flipDirectionHorizontally() {\n    const direction = this.getDirection();\n    switch (direction) {\n      case 'NW-SE':\n        this.setDirection('NE-SW');\n        break;\n      case 'NE-SW':\n        this.setDirection('NW-SE');\n        break;\n      case 'SE-NW':\n        this.setDirection('SW-NE');\n        break;\n      case 'SW-NE':\n        this.setDirection('SE-NW');\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Gets the top-left (in LTR) or top-right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopStartCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the top-left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopLeftCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getTopEndCorner() : this.getTopStartCorner();\n  }\n\n  /**\n   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomEndCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the bottom right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomRightCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getBottomStartCorner() : this.getBottomEndCorner();\n  }\n\n  /**\n   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopEndCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the top right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getTopRightCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getTopStartCorner() : this.getTopEndCorner();\n  }\n\n  /**\n   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomStartCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n  }\n\n  /**\n   * Gets the bottom left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the corner coordinates are normalized to `0`.\n   *\n   * @returns {CellCoords}\n   */\n  getBottomLeftCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getBottomEndCorner() : this.getBottomStartCorner();\n  }\n\n  /**\n   * Gets the top left (in LTR) or top right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopStartCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the top left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopLeftCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getOuterTopEndCorner() : this.getOuterTopStartCorner();\n  }\n\n  /**\n   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomEndCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the bottom right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomRightCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getOuterBottomStartCorner() : this.getOuterBottomEndCorner();\n  }\n\n  /**\n   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopEndCorner() {\n    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the top right corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterTopRightCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getOuterTopStartCorner() : this.getOuterTopEndCorner();\n  }\n\n  /**\n   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and start coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomStartCorner() {\n    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n  }\n\n  /**\n   * Gets the bottom left corner coordinates of your range,\n   * both in the LTR and RTL layout direction.\n   *\n   * If the corner contains header coordinates (negative values),\n   * the top and left coordinates are pointed to that header.\n   *\n   * @returns {CellCoords}\n   */\n  getOuterBottomLeftCorner() {\n    return _classPrivateFieldGet(this, _isRtl) ? this.getOuterBottomEndCorner() : this.getOuterBottomStartCorner();\n  }\n\n  /**\n   * Checks if a set of coordinates (`coords`) matches one of the 4 corners of your range.\n   *\n   * @param {CellCoords} coords Coordinates to check.\n   * @returns {boolean}\n   */\n  isCorner(coords) {\n    return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());\n  }\n\n  /**\n   * Gets the coordinates of a range corner opposite to the provided `coords`.\n   *\n   * For example: if the `coords` coordinates match the bottom-right corner of your range,\n   * the coordinates of the top-left corner of your range are returned.\n   *\n   * @param {CellCoords} coords Coordinates to check.\n   * @returns {CellCoords}\n   */\n  getOppositeCorner(coords) {\n    if (!(coords instanceof CellCoords)) {\n      return false;\n    }\n    if (coords.isEqual(this.getOuterBottomEndCorner())) {\n      return this.getOuterTopStartCorner();\n    } else if (coords.isEqual(this.getOuterTopStartCorner())) {\n      return this.getOuterBottomEndCorner();\n    } else if (coords.isEqual(this.getOuterTopEndCorner())) {\n      return this.getOuterBottomStartCorner();\n    } else if (coords.isEqual(this.getOuterBottomStartCorner())) {\n      return this.getOuterTopEndCorner();\n    }\n  }\n\n  /**\n   * Indicates which borders (top, right, bottom, left) are shared between\n   * your `CellRange`instance and another `range` that's within your range.\n   *\n   * @param {CellRange} range A range to compare with.\n   * @returns {Array<'top' | 'right' | 'bottom' | 'left'>}\n   */\n  getBordersSharedWith(range) {\n    if (!this.includesRange(range)) {\n      return [];\n    }\n    const thisBorders = {\n      top: Math.min(this.from.row, this.to.row),\n      bottom: Math.max(this.from.row, this.to.row),\n      left: Math.min(this.from.col, this.to.col),\n      right: Math.max(this.from.col, this.to.col)\n    };\n    const rangeBorders = {\n      top: Math.min(range.from.row, range.to.row),\n      bottom: Math.max(range.from.row, range.to.row),\n      left: Math.min(range.from.col, range.to.col),\n      right: Math.max(range.from.col, range.to.col)\n    };\n    const result = [];\n    if (thisBorders.top === rangeBorders.top) {\n      result.push('top');\n    }\n    if (thisBorders.right === rangeBorders.right) {\n      result.push(_classPrivateFieldGet(this, _isRtl) ? 'left' : 'right');\n    }\n    if (thisBorders.bottom === rangeBorders.bottom) {\n      result.push('bottom');\n    }\n    if (thisBorders.left === rangeBorders.left) {\n      result.push(_classPrivateFieldGet(this, _isRtl) ? 'right' : 'left');\n    }\n    return result;\n  }\n\n  /**\n   * Gets the coordinates of the inner cells of your range.\n   *\n   * @returns {CellCoords[]}\n   */\n  getInner() {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const out = [];\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n          out.push(this._createCellCoords(r, c));\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Gets the coordinates of all cells of your range.\n   *\n   * @returns {CellCoords[]}\n   */\n  getAll() {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    const out = [];\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        if (topStart.row === r && topStart.col === c) {\n          out.push(topStart);\n        } else if (bottomEnd.row === r && bottomEnd.col === c) {\n          out.push(bottomEnd);\n        } else {\n          out.push(this._createCellCoords(r, c));\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Runs a callback function on all cells within your range.\n   *\n   * You can break the iteration by returning `false` in the callback function.\n   *\n   * @param {function(number, number): boolean} callback A callback function.\n   */\n  forAll(callback) {\n    const topStart = this.getOuterTopStartCorner();\n    const bottomEnd = this.getOuterBottomEndCorner();\n    for (let r = topStart.row; r <= bottomEnd.row; r++) {\n      for (let c = topStart.col; c <= bottomEnd.col; c++) {\n        const breakIteration = callback(r, c);\n        if (breakIteration === false) {\n          return;\n        }\n      }\n    }\n  }\n\n  /**\n   * Clones your `CellRange` instance.\n   *\n   * @returns {CellRange}\n   */\n  clone() {\n    return new CellRange(this.highlight, this.from, this.to, _classPrivateFieldGet(this, _isRtl));\n  }\n\n  /**\n   * Converts your `CellRange` instance into an object literal with the following properties:\n   *\n   * - `from`\n   *    - `row`\n   *    - `col`\n   * - `to`\n   *    - `row`\n   *    - `col`\n   *\n   * @returns {{from: {row: number, col: number}, to: {row: number, col: number}}} An object literal with `from` and `to` properties.\n   */\n  toObject() {\n    return {\n      from: this.from.toObject(),\n      to: this.to.toObject()\n    };\n  }\n\n  /**\n   * Creates and returns a new instance of the `CellCoords` class.\n   *\n   * The new `CellCoords` instance automatically inherits the LTR/RTL flag\n   * from your `CellRange` instance.\n   *\n   * @private\n   * @param {number} row A row index.\n   * @param {number} column A column index.\n   * @returns {CellCoords}\n   */\n  _createCellCoords(row, column) {\n    return new CellCoords(row, column, _classPrivateFieldGet(this, _isRtl));\n  }\n}\nexport default CellRange;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}