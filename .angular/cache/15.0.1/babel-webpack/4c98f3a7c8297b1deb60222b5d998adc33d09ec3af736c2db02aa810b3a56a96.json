{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport { addClass, clearTextSelection, empty, fastInnerHTML, fastInnerText, getScrollbarWidth, hasClass, isChildOf, isInput, isOutsideInput, isVisible, setAttribute } from \"./helpers/dom/element.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { isImmediatePropagationStopped, isRightClick, isLeftClick } from \"./helpers/dom/event.mjs\";\nimport Walkontable from \"./3rdparty/walkontable/src/index.mjs\";\nimport { handleMouseEvent } from \"./selection/mouseEventHandler.mjs\";\nimport { isRootInstance } from \"./utils/rootInstance.mjs\";\nimport { A11Y_COLCOUNT, A11Y_MULTISELECTABLE, A11Y_PRESENTATION, A11Y_ROWCOUNT, A11Y_TREEGRID } from \"./helpers/a11y.mjs\";\n/**\n * @class TableView\n * @private\n */\nvar _columnHeadersCount = /*#__PURE__*/new WeakMap();\nvar _rowHeadersCount = /*#__PURE__*/new WeakMap();\nvar _selectionMouseDown = /*#__PURE__*/new WeakMap();\nvar _mouseDown = /*#__PURE__*/new WeakMap();\nvar _table = /*#__PURE__*/new WeakMap();\nvar _lastWidth = /*#__PURE__*/new WeakMap();\nvar _lastHeight = /*#__PURE__*/new WeakMap();\nvar _getAriaColcount = /*#__PURE__*/new WeakSet();\nvar _updateAriaColcount = /*#__PURE__*/new WeakSet();\nclass TableView {\n  /**\n   * @param {Hanstontable} hotInstance Instance of {@link Handsontable}.\n   */\n  constructor(hotInstance) {\n    /**\n     * Update the `aria-colcount` attribute by the provided value.\n     *\n     * @param {number} delta The number of columns to add or remove to the aria tag.\n     */\n    _classPrivateMethodInitSpec(this, _updateAriaColcount);\n    /**\n     * Return the value of the `aria-colcount` attribute.\n     *\n     * @returns {number} The value of the `aria-colcount` attribute.\n     */\n    _classPrivateMethodInitSpec(this, _getAriaColcount);\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Instance of {@link EventManager}.\n     *\n     * @private\n     * @type {EventManager}\n     */\n    _defineProperty(this, \"eventManager\", void 0);\n    /**\n     * Current Handsontable's GridSettings object.\n     *\n     * @private\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * Main <THEAD> element.\n     *\n     * @private\n     * @type {HTMLTableSectionElement}\n     */\n    _defineProperty(this, \"THEAD\", void 0);\n    /**\n     * Main <TBODY> element.\n     *\n     * @private\n     * @type {HTMLTableSectionElement}\n     */\n    _defineProperty(this, \"TBODY\", void 0);\n    /**\n     * Main Walkontable instance.\n     *\n     * @private\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"_wt\", void 0);\n    /**\n     * Main Walkontable instance.\n     *\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"activeWt\", void 0);\n    /**\n     * The total number of the column header renderers applied to the table through the\n     * `afterGetColumnHeaderRenderers` hook.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _columnHeadersCount, {\n      writable: true,\n      value: 0\n    });\n    /**\n     * The total number of the row header renderers applied to the table through the\n     * `afterGetRowHeaderRenderers` hook.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _rowHeadersCount, {\n      writable: true,\n      value: 0\n    });\n    /**\n     * The flag determines if the `adjustElementsSize` method call was made during\n     * the render suspending. If true, the method has to be triggered once after render\n     * resuming.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"postponedAdjustElementsSize\", false);\n    /**\n     * Defines if the text should be selected during mousemove.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _selectionMouseDown, {\n      writable: true,\n      value: false\n    });\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _mouseDown, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Main <TABLE> element.\n     *\n     * @type {HTMLTableElement}\n     */\n    _classPrivateFieldInitSpec(this, _table, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Cached width of the rootElement.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _lastWidth, {\n      writable: true,\n      value: 0\n    });\n    /**\n     * Cached height of the rootElement.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _lastHeight, {\n      writable: true,\n      value: 0\n    });\n    this.hot = hotInstance;\n    this.eventManager = new EventManager(this.hot);\n    this.settings = this.hot.getSettings();\n    this.createElements();\n    this.registerEvents();\n    this.initializeWalkontable();\n  }\n\n  /**\n   * Renders WalkontableUI.\n   */\n  render() {\n    if (!this.hot.isRenderSuspended()) {\n      this.hot.runHooks('beforeRender', this.hot.forceFullRender);\n      if (this.postponedAdjustElementsSize) {\n        this.postponedAdjustElementsSize = false;\n        this.adjustElementsSize(true);\n      }\n      this._wt.draw(!this.hot.forceFullRender);\n      this.hot.runHooks('afterRender', this.hot.forceFullRender);\n      this.hot.forceFullRender = false;\n      this.hot.renderCall = false;\n    }\n  }\n\n  /**\n   * Adjust overlays elements size and master table size.\n   *\n   * @param {boolean} [force=false] When `true`, it adjust the DOM nodes sizes for all overlays.\n   */\n  adjustElementsSize() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.hot.isRenderSuspended()) {\n      this.postponedAdjustElementsSize = true;\n    } else {\n      this._wt.wtOverlays.adjustElementsSize(force);\n    }\n  }\n\n  /**\n   * Returns td object given coordinates.\n   *\n   * @param {CellCoords} coords Renderable cell coordinates.\n   * @param {boolean} topmost Indicates whether the cell should be calculated from the topmost.\n   * @returns {HTMLTableCellElement|null}\n   */\n  getCellAtCoords(coords, topmost) {\n    const td = this._wt.getCell(coords, topmost);\n    if (td < 0) {\n      // there was an exit code (cell is out of bounds)\n      return null;\n    }\n    return td;\n  }\n\n  /**\n   * Scroll viewport to a cell.\n   *\n   * @param {CellCoords} coords Renderable cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    return this._wt.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n  }\n\n  /**\n   * Scroll viewport to a column.\n   *\n   * @param {number} column Renderable column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    return this._wt.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n  }\n\n  /**\n   * Scroll viewport to a row.\n   *\n   * @param {number} row Renderable row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    return this._wt.scrollViewportVertically(row, snapToTop, snapToBottom);\n  }\n\n  /**\n   * Prepares DOMElements and adds correct className to the root element.\n   *\n   * @private\n   */\n  createElements() {\n    const {\n      rootElement,\n      rootDocument\n    } = this.hot;\n    const originalStyle = rootElement.getAttribute('style');\n    if (originalStyle) {\n      rootElement.setAttribute('data-originalstyle', originalStyle); // needed to retrieve original style in jsFiddle link generator in HT examples. may be removed in future versions\n    }\n\n    addClass(rootElement, 'handsontable');\n    _classPrivateFieldSet(this, _table, rootDocument.createElement('TABLE'));\n    addClass(_classPrivateFieldGet(this, _table), 'htCore');\n    if (this.hot.getSettings().tableClassName) {\n      addClass(_classPrivateFieldGet(this, _table), this.hot.getSettings().tableClassName);\n    }\n    if (this.settings.ariaTags) {\n      setAttribute(_classPrivateFieldGet(this, _table), [A11Y_PRESENTATION()]);\n      setAttribute(rootElement, [A11Y_TREEGRID(), A11Y_ROWCOUNT(-1), A11Y_COLCOUNT(this.hot.countCols()), A11Y_MULTISELECTABLE()]);\n    }\n    this.THEAD = rootDocument.createElement('THEAD');\n    _classPrivateFieldGet(this, _table).appendChild(this.THEAD);\n    this.TBODY = rootDocument.createElement('TBODY');\n    _classPrivateFieldGet(this, _table).appendChild(this.TBODY);\n    this.hot.table = _classPrivateFieldGet(this, _table);\n    this.hot.container.insertBefore(_classPrivateFieldGet(this, _table), this.hot.container.firstChild);\n  }\n\n  /**\n   * Attaches necessary listeners.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      rootElement,\n      rootDocument,\n      selection\n    } = this.hot;\n    const documentElement = rootDocument.documentElement;\n    this.eventManager.addEventListener(rootElement, 'mousedown', event => {\n      _classPrivateFieldSet(this, _selectionMouseDown, true);\n      if (!this.isTextSelectionAllowed(event.target)) {\n        const {\n          rootWindow\n        } = this.hot;\n        clearTextSelection(rootWindow);\n        event.preventDefault();\n        rootWindow.focus(); // make sure that window that contains HOT is active. Important when HOT is in iframe.\n      }\n    });\n\n    this.eventManager.addEventListener(rootElement, 'mouseup', () => {\n      _classPrivateFieldSet(this, _selectionMouseDown, false);\n    });\n    this.eventManager.addEventListener(rootElement, 'mousemove', event => {\n      if (_classPrivateFieldGet(this, _selectionMouseDown) && !this.isTextSelectionAllowed(event.target)) {\n        // Clear selection only when fragmentSelection is enabled, otherwise clearing selection breaks the IME editor.\n        if (this.settings.fragmentSelection) {\n          clearTextSelection(this.hot.rootWindow);\n        }\n        event.preventDefault();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'keyup', event => {\n      // TODO: is it the best place and way to finish cell selection?\n      if (selection.isInProgress() && !event.shiftKey) {\n        selection.finish();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'mouseup', event => {\n      if (selection.isInProgress() && isLeftClick(event)) {\n        selection.finish();\n      }\n      _classPrivateFieldSet(this, _mouseDown, false);\n      const isOutsideInputElement = isOutsideInput(rootDocument.activeElement);\n      if (isInput(rootDocument.activeElement) && !isOutsideInputElement) {\n        return;\n      }\n      if (isOutsideInputElement || !selection.isSelected() && !selection.isSelectedByAnyHeader() && !rootElement.contains(event.target) && !isRightClick(event)) {\n        this.hot.unlisten();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'contextmenu', event => {\n      if (selection.isInProgress() && isRightClick(event)) {\n        selection.finish();\n        _classPrivateFieldSet(this, _mouseDown, false);\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'touchend', () => {\n      if (selection.isInProgress()) {\n        selection.finish();\n      }\n      _classPrivateFieldSet(this, _mouseDown, false);\n    });\n    this.eventManager.addEventListener(documentElement, 'mousedown', event => {\n      const originalTarget = event.target;\n      const eventX = event.x || event.clientX;\n      const eventY = event.y || event.clientY;\n      let next = event.target;\n      if (_classPrivateFieldGet(this, _mouseDown) || !rootElement || !this.hot.view) {\n        return; // it must have been started in a cell\n      }\n\n      // immediate click on \"holder\" means click on the right side of vertical scrollbar\n      const {\n        holder\n      } = this.hot.view._wt.wtTable;\n      if (next === holder) {\n        const scrollbarWidth = getScrollbarWidth(rootDocument);\n        if (rootDocument.elementFromPoint(eventX + scrollbarWidth, eventY) !== holder || rootDocument.elementFromPoint(eventX, eventY + scrollbarWidth) !== holder) {\n          return;\n        }\n      } else {\n        while (next !== documentElement) {\n          if (next === null) {\n            if (event.isTargetWebComponent) {\n              break;\n            }\n\n            // click on something that was a row but now is detached (possibly because your click triggered a rerender)\n            return;\n          }\n          if (next === rootElement) {\n            // click inside container\n            return;\n          }\n          next = next.parentNode;\n        }\n      }\n\n      // function did not return until here, we have an outside click!\n      const outsideClickDeselects = typeof this.settings.outsideClickDeselects === 'function' ? this.settings.outsideClickDeselects(originalTarget) : this.settings.outsideClickDeselects;\n      if (outsideClickDeselects) {\n        this.hot.deselectCell();\n      } else {\n        this.hot.destroyEditor(false, false);\n      }\n    });\n    this.eventManager.addEventListener(_classPrivateFieldGet(this, _table), 'selectstart', event => {\n      if (this.settings.fragmentSelection || isInput(event.target)) {\n        return;\n      }\n      // https://github.com/handsontable/handsontable/issues/160\n      // Prevent text from being selected when performing drag down.\n      event.preventDefault();\n    });\n  }\n\n  /**\n   * Translate renderable cell coordinates to visual coordinates.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @returns {CellCoords}\n   */\n  translateFromRenderableToVisualCoords(_ref) {\n    let {\n      row,\n      col\n    } = _ref;\n    // TODO: To consider an idea to reusing the CellCoords instance instead creating new one.\n    return this.hot._createCellCoords(...this.translateFromRenderableToVisualIndex(row, col));\n  }\n\n  /**\n   * Translate renderable row and column indexes to visual row and column indexes.\n   *\n   * @param {number} renderableRow Renderable row index.\n   * @param {number} renderableColumn Renderable columnIndex.\n   * @returns {number[]}\n   */\n  translateFromRenderableToVisualIndex(renderableRow, renderableColumn) {\n    // TODO: Some helper may be needed.\n    // We perform translation for indexes (without headers).\n    let visualRow = renderableRow >= 0 ? this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow;\n    let visualColumn = renderableColumn >= 0 ? this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn;\n    if (visualRow === null) {\n      visualRow = renderableRow;\n    }\n    if (visualColumn === null) {\n      visualColumn = renderableColumn;\n    }\n    return [visualRow, visualColumn];\n  }\n\n  /**\n   * Returns the number of renderable indexes.\n   *\n   * @private\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} maxElements Maximum number of elements (rows or columns).\n   *\n   * @returns {number|*}\n   */\n  countRenderableIndexes(indexMapper, maxElements) {\n    const consideredElements = Math.min(indexMapper.getNotTrimmedIndexesLength(), maxElements);\n    // Don't take hidden indexes into account. We are looking just for renderable indexes.\n    const firstNotHiddenIndex = indexMapper.getNearestNotHiddenIndex(consideredElements - 1, -1);\n\n    // There are no renderable indexes.\n    if (firstNotHiddenIndex === null) {\n      return 0;\n    }\n    return indexMapper.getRenderableFromVisualIndex(firstNotHiddenIndex) + 1;\n  }\n\n  /**\n   * Returns the number of renderable columns.\n   *\n   * @returns {number}\n   */\n  countRenderableColumns() {\n    return this.countRenderableIndexes(this.hot.columnIndexMapper, this.settings.maxCols);\n  }\n\n  /**\n   * Returns the number of renderable rows.\n   *\n   * @returns {number}\n   */\n  countRenderableRows() {\n    return this.countRenderableIndexes(this.hot.rowIndexMapper, this.settings.maxRows);\n  }\n\n  /**\n   * Returns number of not hidden row indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @returns {number}\n   */\n  countNotHiddenRowIndexes(visualIndex, incrementBy) {\n    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.hot.rowIndexMapper, this.countRenderableRows());\n  }\n\n  /**\n   * Returns number of not hidden column indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @returns {number}\n   */\n  countNotHiddenColumnIndexes(visualIndex, incrementBy) {\n    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.hot.columnIndexMapper, this.countRenderableColumns());\n  }\n\n  /**\n   * Returns number of not hidden indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} renderableIndexesCount Total count of renderable indexes for specific axis.\n   * @returns {number}\n   */\n  countNotHiddenIndexes(visualIndex, incrementBy, indexMapper, renderableIndexesCount) {\n    if (isNaN(visualIndex) || visualIndex < 0) {\n      return 0;\n    }\n    const firstVisibleIndex = indexMapper.getNearestNotHiddenIndex(visualIndex, incrementBy);\n    const renderableIndex = indexMapper.getRenderableFromVisualIndex(firstVisibleIndex);\n    if (!Number.isInteger(renderableIndex)) {\n      return 0;\n    }\n    let notHiddenIndexes = 0;\n    if (incrementBy < 0) {\n      // Zero-based numbering for renderable indexes corresponds to a number of not hidden indexes.\n      notHiddenIndexes = renderableIndex + 1;\n    } else if (incrementBy > 0) {\n      notHiddenIndexes = renderableIndexesCount - renderableIndex;\n    }\n    return notHiddenIndexes;\n  }\n\n  /**\n   * The function returns the number of not hidden column indexes that fit between the first and\n   * last fixed column in the left (or right in RTL mode) overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedColumnsStart() {\n    const countCols = this.hot.countCols();\n    const visualFixedColumnsStart = Math.min(parseInt(this.settings.fixedColumnsStart, 10), countCols) - 1;\n    return this.countNotHiddenColumnIndexes(visualFixedColumnsStart, -1);\n  }\n\n  /**\n   * The function returns the number of not hidden row indexes that fit between the first and\n   * last fixed row in the top overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedRowsTop() {\n    const countRows = this.hot.countRows();\n    const visualFixedRowsTop = Math.min(parseInt(this.settings.fixedRowsTop, 10), countRows) - 1;\n    return this.countNotHiddenRowIndexes(visualFixedRowsTop, -1);\n  }\n\n  /**\n   * The function returns the number of not hidden row indexes that fit between the first and\n   * last fixed row in the bottom overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedRowsBottom() {\n    const countRows = this.hot.countRows();\n    const visualFixedRowsBottom = Math.max(countRows - parseInt(this.settings.fixedRowsBottom, 10), 0);\n    return this.countNotHiddenRowIndexes(visualFixedRowsBottom, 1);\n  }\n\n  /**\n   * The function returns the number of renderable column indexes within the passed range of the visual indexes.\n   *\n   * @param {number} columnStart The column visual start index.\n   * @param {number} columnEnd The column visual end index.\n   * @returns {number}\n   */\n  countRenderableColumnsInRange(columnStart, columnEnd) {\n    let count = 0;\n    for (let column = columnStart; column <= columnEnd; column++) {\n      if (this.hot.columnIndexMapper.getRenderableFromVisualIndex(column) !== null) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * The function returns the number of renderable row indexes within the passed range of the visual indexes.\n   *\n   * @param {number} rowStart The row visual start index.\n   * @param {number} rowEnd The row visual end index.\n   * @returns {number}\n   */\n  countRenderableRowsInRange(rowStart, rowEnd) {\n    let count = 0;\n    for (let row = rowStart; row <= rowEnd; row++) {\n      if (this.hot.rowIndexMapper.getRenderableFromVisualIndex(row) !== null) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Checks if at least one cell than belongs to the main table is not covered by the top, left or\n   * bottom overlay.\n   *\n   * @returns {boolean}\n   */\n  isMainTableNotFullyCoveredByOverlays() {\n    const fixedAllRows = this.countNotHiddenFixedRowsTop() + this.countNotHiddenFixedRowsBottom();\n    const fixedAllColumns = this.countNotHiddenFixedColumnsStart();\n    return this.hot.countRenderedRows() > fixedAllRows && this.hot.countRenderedCols() > fixedAllColumns;\n  }\n\n  /**\n   * Defines default configuration and initializes WalkOnTable instance.\n   *\n   * @private\n   */\n  initializeWalkontable() {\n    const walkontableConfig = {\n      ariaTags: this.settings.ariaTags,\n      rtlMode: this.hot.isRtl(),\n      externalRowCalculator: this.hot.getPlugin('autoRowSize') && this.hot.getPlugin('autoRowSize').isEnabled(),\n      table: _classPrivateFieldGet(this, _table),\n      isDataViewInstance: () => isRootInstance(this.hot),\n      preventOverflow: () => this.settings.preventOverflow,\n      preventWheel: () => this.settings.preventWheel,\n      stretchH: () => this.settings.stretchH,\n      data: (renderableRow, renderableColumn) => {\n        return this.hot.getDataAtCell(...this.translateFromRenderableToVisualIndex(renderableRow, renderableColumn));\n      },\n      totalRows: () => this.countRenderableRows(),\n      totalColumns: () => this.countRenderableColumns(),\n      // Number of renderable columns for the left overlay.\n      fixedColumnsStart: () => this.countNotHiddenFixedColumnsStart(),\n      // Number of renderable rows for the top overlay.\n      fixedRowsTop: () => this.countNotHiddenFixedRowsTop(),\n      // Number of renderable rows for the bottom overlay.\n      fixedRowsBottom: () => this.countNotHiddenFixedRowsBottom(),\n      // Enable the inline start overlay when conditions are met.\n      shouldRenderInlineStartOverlay: () => {\n        return this.settings.fixedColumnsStart > 0 || walkontableConfig.rowHeaders().length > 0;\n      },\n      // Enable the top overlay when conditions are met.\n      shouldRenderTopOverlay: () => {\n        return this.settings.fixedRowsTop > 0 || walkontableConfig.columnHeaders().length > 0;\n      },\n      // Enable the bottom overlay when conditions are met.\n      shouldRenderBottomOverlay: () => {\n        return this.settings.fixedRowsBottom > 0;\n      },\n      minSpareRows: () => this.settings.minSpareRows,\n      renderAllRows: this.settings.renderAllRows,\n      renderAllColumns: this.settings.renderAllColumns,\n      rowHeaders: () => {\n        const headerRenderers = [];\n        if (this.hot.hasRowHeaders()) {\n          headerRenderers.push((renderableRowIndex, TH) => {\n            // TODO: Some helper may be needed.\n            // We perform translation for row indexes (without row headers).\n            const visualRowIndex = renderableRowIndex >= 0 ? this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;\n            this.appendRowHeader(visualRowIndex, TH);\n          });\n        }\n        this.hot.runHooks('afterGetRowHeaderRenderers', headerRenderers);\n        _classPrivateFieldSet(this, _rowHeadersCount, headerRenderers.length);\n        if (this.hot.getSettings().ariaTags) {\n          // Update the aria-colcount attribute.\n          // Only needs to be done once after initialization/data update.\n          if (_classPrivateMethodGet(this, _getAriaColcount, _getAriaColcount2).call(this) === this.hot.countCols()) {\n            _classPrivateMethodGet(this, _updateAriaColcount, _updateAriaColcount2).call(this, _classPrivateFieldGet(this, _rowHeadersCount));\n          }\n        }\n        return headerRenderers;\n      },\n      columnHeaders: () => {\n        const headerRenderers = [];\n        if (this.hot.hasColHeaders()) {\n          headerRenderers.push((renderedColumnIndex, TH) => {\n            // TODO: Some helper may be needed.\n            // We perform translation for columns indexes (without column headers).\n            const visualColumnsIndex = renderedColumnIndex >= 0 ? this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex) : renderedColumnIndex;\n            this.appendColHeader(visualColumnsIndex, TH);\n          });\n        }\n        this.hot.runHooks('afterGetColumnHeaderRenderers', headerRenderers);\n        _classPrivateFieldSet(this, _columnHeadersCount, headerRenderers.length);\n        return headerRenderers;\n      },\n      columnWidth: renderedColumnIndex => {\n        const visualIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n\n        // It's not a bug that we can't find visual index for some handled by method indexes. The function is called also\n        // for indexes that are not displayed (indexes that are beyond the grid's boundaries), i.e. when `fixedColumnsStart` > `startCols` (wrong config?) or\n        // scrolling and dataset is empty (scroll should handle that?).\n        return this.hot.getColWidth(visualIndex === null ? renderedColumnIndex : visualIndex);\n      },\n      rowHeight: renderedRowIndex => {\n        const visualIndex = this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);\n        return this.hot.getRowHeight(visualIndex === null ? renderedRowIndex : visualIndex);\n      },\n      cellRenderer: (renderedRowIndex, renderedColumnIndex, TD) => {\n        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(renderedRowIndex, renderedColumnIndex);\n\n        // Coords may be modified. For example, by the `MergeCells` plugin. It should affect cell value and cell meta.\n        const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowIndex, visualColumnIndex);\n        let visualRowToCheck = visualRowIndex;\n        let visualColumnToCheck = visualColumnIndex;\n        if (Array.isArray(modifiedCellCoords)) {\n          [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;\n        }\n        const cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);\n        const prop = this.hot.colToProp(visualColumnToCheck);\n        let value = this.hot.getDataAtRowProp(visualRowToCheck, prop);\n        if (this.hot.hasHook('beforeValueRender')) {\n          value = this.hot.runHooks('beforeValueRender', value, cellProperties);\n        }\n        this.hot.runHooks('beforeRenderer', TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n        this.hot.getCellRenderer(cellProperties)(this.hot, TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n        this.hot.runHooks('afterRenderer', TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n      },\n      selections: this.hot.selection.highlight,\n      hideBorderOnMouseDownOver: () => this.settings.fragmentSelection,\n      onWindowResize: () => {\n        if (this.hot && !this.hot.isDestroyed) {\n          this.hot.refreshDimensions();\n        }\n      },\n      onContainerElementResize: () => {\n        if (this.hot && !this.hot.isDestroyed && isVisible(this.hot.rootElement)) {\n          this.hot.refreshDimensions();\n        }\n      },\n      onCellMouseDown: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        const controller = {\n          row: false,\n          column: false,\n          cell: false\n        };\n        this.hot.listen();\n        this.activeWt = wt;\n        _classPrivateFieldSet(this, _mouseDown, true);\n        this.hot.runHooks('beforeOnCellMouseDown', event, visualCoords, TD, controller);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        handleMouseEvent(event, {\n          coords: visualCoords,\n          selection: this.hot.selection,\n          controller,\n          cellCoordsFactory: (row, column) => this.hot._createCellCoords(row, column)\n        });\n        this.hot.runHooks('afterOnCellMouseDown', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellContextMenu: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        _classPrivateFieldSet(this, _mouseDown, false);\n        if (this.hot.selection.isInProgress()) {\n          this.hot.selection.finish();\n        }\n        this.hot.runHooks('beforeOnCellContextMenu', event, visualCoords, TD);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellContextMenu', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseOut: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseOut', event, visualCoords, TD);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellMouseOut', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseOver: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        const controller = {\n          row: false,\n          column: false,\n          cell: false\n        };\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseOver', event, visualCoords, TD, controller);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        if (_classPrivateFieldGet(this, _mouseDown)) {\n          handleMouseEvent(event, {\n            coords: visualCoords,\n            selection: this.hot.selection,\n            controller,\n            cellCoordsFactory: (row, column) => this.hot._createCellCoords(row, column)\n          });\n        }\n        this.hot.runHooks('afterOnCellMouseOver', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseUp: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseUp', event, visualCoords, TD);\n\n        // TODO: The second condition check is a workaround. Callback corresponding the method `updateSettings`\n        // disable plugin and enable it again. Disabling plugin closes the menu. Thus, calling the\n        // `updateSettings` in a body of any callback executed right after some context-menu action\n        // breaks the table (#7231).\n        if (isImmediatePropagationStopped(event) || this.hot.isDestroyed) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellMouseUp', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellCornerMouseDown: event => {\n        event.preventDefault();\n        this.hot.runHooks('afterOnCellCornerMouseDown', event);\n      },\n      onCellCornerDblClick: event => {\n        event.preventDefault();\n        this.hot.runHooks('afterOnCellCornerDblClick', event);\n      },\n      beforeDraw: (force, skipRender) => this.beforeRender(force, skipRender),\n      onDraw: force => this.afterRender(force),\n      onBeforeViewportScrollVertically: renderableRow => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const areColumnHeadersSelected = renderableRow < 0;\n        let visualRow = renderableRow;\n        if (!areColumnHeadersSelected) {\n          visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);\n\n          // for an empty data return index as is\n          if (visualRow === null) {\n            return renderableRow;\n          }\n        }\n        visualRow = this.hot.runHooks('beforeViewportScrollVertically', visualRow);\n        this.hot.runHooks('beforeViewportScroll');\n        if (!areColumnHeadersSelected) {\n          return rowMapper.getRenderableFromVisualIndex(visualRow);\n        }\n        return visualRow;\n      },\n      onBeforeViewportScrollHorizontally: renderableColumn => {\n        const columnMapper = this.hot.columnIndexMapper;\n        const areRowHeadersSelected = renderableColumn < 0;\n        let visualColumn = renderableColumn;\n        if (!areRowHeadersSelected) {\n          visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);\n\n          // for an empty data return index as is\n          if (visualColumn === null) {\n            return renderableColumn;\n          }\n        }\n        visualColumn = this.hot.runHooks('beforeViewportScrollHorizontally', visualColumn);\n        this.hot.runHooks('beforeViewportScroll');\n        if (!areRowHeadersSelected) {\n          return columnMapper.getRenderableFromVisualIndex(visualColumn);\n        }\n        return visualColumn;\n      },\n      onScrollVertically: () => {\n        this.hot.runHooks('afterScrollVertically');\n        this.hot.runHooks('afterScroll');\n      },\n      onScrollHorizontally: () => {\n        this.hot.runHooks('afterScrollHorizontally');\n        this.hot.runHooks('afterScroll');\n      },\n      onBeforeRemoveCellClassNames: () => this.hot.runHooks('beforeRemoveCellClassNames'),\n      onBeforeHighlightingRowHeader: (renderableRow, headerLevel, highlightMeta) => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const areColumnHeadersSelected = renderableRow < 0;\n        let visualRow = renderableRow;\n        if (!areColumnHeadersSelected) {\n          visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);\n        }\n        const newVisualRow = this.hot.runHooks('beforeHighlightingRowHeader', visualRow, headerLevel, highlightMeta);\n        if (!areColumnHeadersSelected) {\n          return rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(newVisualRow, 1));\n        }\n        return newVisualRow;\n      },\n      onBeforeHighlightingColumnHeader: (renderableColumn, headerLevel, highlightMeta) => {\n        const columnMapper = this.hot.columnIndexMapper;\n        const areRowHeadersSelected = renderableColumn < 0;\n        let visualColumn = renderableColumn;\n        if (!areRowHeadersSelected) {\n          visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);\n        }\n        const newVisualColumn = this.hot.runHooks('beforeHighlightingColumnHeader', visualColumn, headerLevel, highlightMeta);\n        if (!areRowHeadersSelected) {\n          return columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(newVisualColumn, 1));\n        }\n        return newVisualColumn;\n      },\n      onAfterDrawSelection: (currentRow, currentColumn, layerLevel) => {\n        let cornersOfSelection;\n        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(currentRow, currentColumn);\n        const selectedRange = this.hot.selection.getSelectedRange();\n        const selectionRangeSize = selectedRange.size();\n        if (selectionRangeSize > 0) {\n          const selectionForLayer = selectedRange.peekByIndex(layerLevel !== null && layerLevel !== void 0 ? layerLevel : 0);\n          cornersOfSelection = [selectionForLayer.from.row, selectionForLayer.from.col, selectionForLayer.to.row, selectionForLayer.to.col];\n        }\n        return this.hot.runHooks('afterDrawSelection', visualRowIndex, visualColumnIndex, cornersOfSelection, layerLevel);\n      },\n      onBeforeDrawBorders: (corners, borderClassName) => {\n        const [startRenderableRow, startRenderableColumn, endRenderableRow, endRenderableColumn] = corners;\n        const visualCorners = [this.hot.rowIndexMapper.getVisualFromRenderableIndex(startRenderableRow), this.hot.columnIndexMapper.getVisualFromRenderableIndex(startRenderableColumn), this.hot.rowIndexMapper.getVisualFromRenderableIndex(endRenderableRow), this.hot.columnIndexMapper.getVisualFromRenderableIndex(endRenderableColumn)];\n        return this.hot.runHooks('beforeDrawBorders', visualCorners, borderClassName);\n      },\n      onBeforeTouchScroll: () => this.hot.runHooks('beforeTouchScroll'),\n      onAfterMomentumScroll: () => this.hot.runHooks('afterMomentumScroll'),\n      onBeforeStretchingColumnWidth: (stretchedWidth, renderedColumnIndex) => {\n        const visualColumnIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n        return this.hot.runHooks('beforeStretchingColumnWidth', stretchedWidth, visualColumnIndex);\n      },\n      onModifyRowHeaderWidth: rowHeaderWidth => this.hot.runHooks('modifyRowHeaderWidth', rowHeaderWidth),\n      onModifyGetCellCoords: (renderableRowIndex, renderableColumnIndex, topmost) => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const columnMapper = this.hot.columnIndexMapper;\n\n        // Callback handle also headers. We shouldn't translate them.\n        const visualColumnIndex = renderableColumnIndex >= 0 ? columnMapper.getVisualFromRenderableIndex(renderableColumnIndex) : renderableColumnIndex;\n        const visualRowIndex = renderableRowIndex >= 0 ? rowMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;\n        const visualIndexes = this.hot.runHooks('modifyGetCellCoords', visualRowIndex, visualColumnIndex, topmost);\n        if (Array.isArray(visualIndexes)) {\n          const [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = visualIndexes;\n\n          // Result of the hook is handled by the Walkontable (renderable indexes).\n          return [visualRowFrom >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowFrom, 1)) : visualRowFrom, visualColumnFrom >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnFrom, 1)) : visualColumnFrom, visualRowTo >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowTo, -1)) : visualRowTo, visualColumnTo >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnTo, -1)) : visualColumnTo];\n        }\n      },\n      viewportRowCalculatorOverride: calc => {\n        let viewportOffset = this.settings.viewportRowRenderingOffset;\n        if (viewportOffset === 'auto' && this.settings.fixedRowsTop) {\n          viewportOffset = 10;\n        }\n        if (viewportOffset > 0 || viewportOffset === 'auto') {\n          const renderableRows = this.countRenderableRows();\n          const firstRenderedRow = calc.startRow;\n          const lastRenderedRow = calc.endRow;\n          if (typeof viewportOffset === 'number') {\n            calc.startRow = Math.max(firstRenderedRow - viewportOffset, 0);\n            calc.endRow = Math.min(lastRenderedRow + viewportOffset, renderableRows - 1);\n          } else if (viewportOffset === 'auto') {\n            const offset = Math.ceil(lastRenderedRow / renderableRows * 12);\n            calc.startRow = Math.max(firstRenderedRow - offset, 0);\n            calc.endRow = Math.min(lastRenderedRow + offset, renderableRows - 1);\n          }\n        }\n        this.hot.runHooks('afterViewportRowCalculatorOverride', calc);\n      },\n      viewportColumnCalculatorOverride: calc => {\n        let viewportOffset = this.settings.viewportColumnRenderingOffset;\n        if (viewportOffset === 'auto' && this.settings.fixedColumnsStart) {\n          viewportOffset = 10;\n        }\n        if (viewportOffset > 0 || viewportOffset === 'auto') {\n          const renderableColumns = this.countRenderableColumns();\n          const firstRenderedColumn = calc.startColumn;\n          const lastRenderedColumn = calc.endColumn;\n          if (typeof viewportOffset === 'number') {\n            calc.startColumn = Math.max(firstRenderedColumn - viewportOffset, 0);\n            calc.endColumn = Math.min(lastRenderedColumn + viewportOffset, renderableColumns - 1);\n          }\n          if (viewportOffset === 'auto') {\n            const offset = Math.ceil(lastRenderedColumn / renderableColumns * 6);\n            calc.startColumn = Math.max(firstRenderedColumn - offset, 0);\n            calc.endColumn = Math.min(lastRenderedColumn + offset, renderableColumns - 1);\n          }\n        }\n        this.hot.runHooks('afterViewportColumnCalculatorOverride', calc);\n      },\n      rowHeaderWidth: () => this.settings.rowHeaderWidth,\n      columnHeaderHeight: () => {\n        const columnHeaderHeight = this.hot.runHooks('modifyColumnHeaderHeight');\n        return this.settings.columnHeaderHeight || columnHeaderHeight;\n      }\n    };\n    this.hot.runHooks('beforeInitWalkontable', walkontableConfig);\n    this._wt = new Walkontable(walkontableConfig);\n    this.activeWt = this._wt;\n    const spreader = this._wt.wtTable.spreader;\n    // We have to cache width and height after Walkontable initialization.\n    const {\n      width,\n      height\n    } = this.hot.rootElement.getBoundingClientRect();\n    this.setLastSize(width, height);\n    this.eventManager.addEventListener(spreader, 'mousedown', event => {\n      // right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar\n      if (event.target === spreader && event.which === 3) {\n        event.stopPropagation();\n      }\n    });\n    this.eventManager.addEventListener(spreader, 'contextmenu', event => {\n      // right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar\n      if (event.target === spreader && event.which === 3) {\n        event.stopPropagation();\n      }\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'click', () => {\n      if (this.settings.observeDOMVisibility) {\n        if (this._wt.drawInterrupted) {\n          this.hot.forceFullRender = true;\n          this.render();\n        }\n      }\n    });\n  }\n\n  /**\n   * Checks if it's possible to create text selection in element.\n   *\n   * @private\n   * @param {HTMLElement} el The element to check.\n   * @returns {boolean}\n   */\n  isTextSelectionAllowed(el) {\n    if (isInput(el)) {\n      return true;\n    }\n    const isChildOfTableBody = isChildOf(el, this.hot.view._wt.wtTable.spreader);\n    if (this.settings.fragmentSelection === true && isChildOfTableBody) {\n      return true;\n    }\n    if (this.settings.fragmentSelection === 'cell' && this.isSelectedOnlyCell() && isChildOfTableBody) {\n      return true;\n    }\n    if (!this.settings.fragmentSelection && this.isCellEdited() && this.isSelectedOnlyCell()) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Checks if user's been called mousedown.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isMouseDown() {\n    return _classPrivateFieldGet(this, _mouseDown);\n  }\n\n  /**\n   * Check if selected only one cell.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isSelectedOnlyCell() {\n    var _this$hot$getSelected, _this$hot$getSelected2;\n    return (_this$hot$getSelected = (_this$hot$getSelected2 = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected2 === void 0 ? void 0 : _this$hot$getSelected2.isSingleCell()) !== null && _this$hot$getSelected !== void 0 ? _this$hot$getSelected : false;\n  }\n\n  /**\n   * Checks if active cell is editing.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isCellEdited() {\n    const activeEditor = this.hot.getActiveEditor();\n    return activeEditor && activeEditor.isOpened();\n  }\n\n  /**\n   * `beforeDraw` callback.\n   *\n   * @private\n   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if\n   *                        rendering was triggered by scrolling or moving selection.\n   * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering\n   *                            cycle will be skipped.\n   */\n  beforeRender(force, skipRender) {\n    if (force) {\n      // this.hot.forceFullRender = did Handsontable request full render?\n      this.hot.runHooks('beforeViewRender', this.hot.forceFullRender, skipRender);\n    }\n  }\n\n  /**\n   * `afterRender` callback.\n   *\n   * @private\n   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if\n   *                        rendering was triggered by scrolling or moving selection.\n   */\n  afterRender(force) {\n    if (force) {\n      // this.hot.forceFullRender = did Handsontable request full render?\n      this.hot.runHooks('afterViewRender', this.hot.forceFullRender);\n    }\n  }\n\n  /**\n   * Append row header to a TH element.\n   *\n   * @private\n   * @param {number} visualRowIndex The visual row index.\n   * @param {HTMLTableHeaderCellElement} TH The table header element.\n   */\n  appendRowHeader(visualRowIndex, TH) {\n    if (TH.firstChild) {\n      const container = TH.firstChild;\n      if (!hasClass(container, 'relative')) {\n        empty(TH);\n        this.appendRowHeader(visualRowIndex, TH);\n        return;\n      }\n      this.updateCellHeader(container.querySelector('.rowHeader'), visualRowIndex, this.hot.getRowHeader);\n    } else {\n      const {\n        rootDocument,\n        getRowHeader\n      } = this.hot;\n      const div = rootDocument.createElement('div');\n      const span = rootDocument.createElement('span');\n      div.className = 'relative';\n      span.className = 'rowHeader';\n      this.updateCellHeader(span, visualRowIndex, getRowHeader);\n      div.appendChild(span);\n      TH.appendChild(div);\n    }\n    this.hot.runHooks('afterGetRowHeader', visualRowIndex, TH);\n  }\n\n  /**\n   * Append column header to a TH element.\n   *\n   * @private\n   * @param {number} visualColumnIndex Visual column index.\n   * @param {HTMLTableCellElement} TH The table header element.\n   * @param {Function} [label] The function that returns the header label.\n   * @param {number} [headerLevel=0] The index of header level counting from the top (positive\n   *                                 values counting from 0 to N).\n   */\n  appendColHeader(visualColumnIndex, TH) {\n    let label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hot.getColHeader;\n    let headerLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (TH.firstChild) {\n      const container = TH.firstChild;\n      if (hasClass(container, 'relative')) {\n        this.updateCellHeader(container.querySelector('.colHeader'), visualColumnIndex, label, headerLevel);\n      } else {\n        empty(TH);\n        this.appendColHeader(visualColumnIndex, TH, label, headerLevel);\n      }\n    } else {\n      const {\n        rootDocument\n      } = this.hot;\n      const div = rootDocument.createElement('div');\n      const span = rootDocument.createElement('span');\n      div.className = 'relative';\n      span.className = 'colHeader';\n      if (this.settings.ariaTags) {\n        setAttribute(div, ...A11Y_PRESENTATION());\n        setAttribute(span, ...A11Y_PRESENTATION());\n      }\n      this.updateCellHeader(span, visualColumnIndex, label, headerLevel);\n      div.appendChild(span);\n      TH.appendChild(div);\n    }\n    this.hot.runHooks('afterGetColHeader', visualColumnIndex, TH, headerLevel);\n  }\n\n  /**\n   * Updates header cell content.\n   *\n   * @private\n   * @param {HTMLElement} element Element to update.\n   * @param {number} index Row index or column index.\n   * @param {Function} content Function which should be returns content for this cell.\n   * @param {number} [headerLevel=0] The index of header level counting from the top (positive\n   *                                 values counting from 0 to N).\n   */\n  updateCellHeader(element, index, content) {\n    let headerLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let renderedIndex = index;\n    const parentOverlay = this._wt.wtOverlays.getParentOverlay(element) || this._wt;\n\n    // prevent wrong calculations from SampleGenerator\n    if (element.parentNode) {\n      if (hasClass(element, 'colHeader')) {\n        renderedIndex = parentOverlay.wtTable.columnFilter.sourceToRendered(index);\n      } else if (hasClass(element, 'rowHeader')) {\n        renderedIndex = parentOverlay.wtTable.rowFilter.sourceToRendered(index);\n      }\n    }\n    if (renderedIndex > -1) {\n      fastInnerHTML(element, content(index, headerLevel));\n    } else {\n      // workaround for https://github.com/handsontable/handsontable/issues/1946\n      fastInnerText(element, String.fromCharCode(160));\n      addClass(element, 'cornerHeader');\n    }\n  }\n\n  /**\n   * Given a element's left (or right in RTL mode) position relative to the viewport, returns maximum\n   * element width until the right (or left) edge of the viewport (before scrollbar).\n   *\n   * @private\n   * @param {number} inlineOffset The left (or right in RTL mode) offset.\n   * @returns {number}\n   */\n  maximumVisibleElementWidth(inlineOffset) {\n    const workspaceWidth = this._wt.wtViewport.getWorkspaceWidth();\n    const maxWidth = workspaceWidth - inlineOffset;\n    return maxWidth > 0 ? maxWidth : 0;\n  }\n\n  /**\n   * Given a element's top position relative to the viewport, returns maximum element height until the bottom\n   * edge of the viewport (before scrollbar).\n   *\n   * @private\n   * @param {number} topOffset The top offset.\n   * @returns {number}\n   */\n  maximumVisibleElementHeight(topOffset) {\n    const workspaceHeight = this._wt.wtViewport.getWorkspaceHeight();\n    const maxHeight = workspaceHeight - topOffset;\n    return maxHeight > 0 ? maxHeight : 0;\n  }\n\n  /**\n   * Sets new dimensions of the container.\n   *\n   * @param {number} width The table width.\n   * @param {number} height The table height.\n   */\n  setLastSize(width, height) {\n    _classPrivateFieldSet(this, _lastWidth, width);\n    _classPrivateFieldSet(this, _lastHeight, height);\n  }\n\n  /**\n   * Returns cached dimensions.\n   *\n   * @returns {object}\n   */\n  getLastSize() {\n    return {\n      width: _classPrivateFieldGet(this, _lastWidth),\n      height: _classPrivateFieldGet(this, _lastHeight)\n    };\n  }\n\n  /**\n   * Returns the first fully visible row in the table viewport.\n   *\n   * @returns {number}\n   */\n  getFirstFullyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this.hot.view._wt.wtScroll.getFirstVisibleRow());\n  }\n\n  /**\n   * Returns the last fully visible row in the table viewport.\n   *\n   * @returns {number}\n   */\n  getLastFullyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this.hot.view._wt.wtScroll.getLastVisibleRow());\n  }\n\n  /**\n   * Returns the first fully visible column in the table viewport.\n   *\n   * @returns {number}\n   */\n  getFirstFullyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this.hot.view._wt.wtScroll.getFirstVisibleColumn());\n  }\n\n  /**\n   * Returns the last fully visible column in the table viewport.\n   *\n   * @returns {number}\n   */\n  getLastFullyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this.hot.view._wt.wtScroll.getLastVisibleColumn());\n  }\n\n  /**\n   * Returns the total count of the rendered column headers.\n   *\n   * @returns {number}\n   */\n  getColumnHeadersCount() {\n    return _classPrivateFieldGet(this, _columnHeadersCount);\n  }\n\n  /**\n   * Returns the total count of the rendered row headers.\n   *\n   * @returns {number}\n   */\n  getRowHeadersCount() {\n    return _classPrivateFieldGet(this, _rowHeadersCount);\n  }\n  /**\n   * Destroys internal WalkOnTable's instance. Detaches all of the bonded listeners.\n   *\n   * @private\n   */\n  destroy() {\n    this._wt.destroy();\n    this.eventManager.destroy();\n  }\n}\nfunction _getAriaColcount2() {\n  return parseInt(this.hot.rootElement.getAttribute(A11Y_COLCOUNT()[0]), 10);\n}\nfunction _updateAriaColcount2(delta) {\n  const colCount = _classPrivateMethodGet(this, _getAriaColcount, _getAriaColcount2).call(this) + delta;\n  setAttribute(this.hot.rootElement, ...A11Y_COLCOUNT(colCount));\n}\nexport default TableView;","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","privateMap","value","set","privateCollection","has","TypeError","_defineProperty","key","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateMethodGet","receiver","fn","_classPrivateFieldGet","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","_classPrivateFieldSet","_classApplyDescriptorSet","action","addClass","clearTextSelection","empty","fastInnerHTML","fastInnerText","getScrollbarWidth","hasClass","isChildOf","isInput","isOutsideInput","isVisible","setAttribute","EventManager","isImmediatePropagationStopped","isRightClick","isLeftClick","Walkontable","handleMouseEvent","isRootInstance","A11Y_COLCOUNT","A11Y_MULTISELECTABLE","A11Y_PRESENTATION","A11Y_ROWCOUNT","A11Y_TREEGRID","_columnHeadersCount","WeakMap","_rowHeadersCount","_selectionMouseDown","_mouseDown","_table","_lastWidth","_lastHeight","_getAriaColcount","WeakSet","_updateAriaColcount","TableView","constructor","hotInstance","hot","eventManager","settings","getSettings","createElements","registerEvents","initializeWalkontable","render","isRenderSuspended","runHooks","forceFullRender","postponedAdjustElementsSize","adjustElementsSize","_wt","draw","renderCall","force","arguments","length","undefined","wtOverlays","getCellAtCoords","coords","topmost","td","getCell","scrollViewport","snapToTop","snapToRight","snapToBottom","snapToLeft","scrollViewportHorizontally","column","scrollViewportVertically","row","rootElement","rootDocument","originalStyle","getAttribute","createElement","tableClassName","ariaTags","countCols","THEAD","appendChild","TBODY","table","container","insertBefore","firstChild","selection","documentElement","addEventListener","event","isTextSelectionAllowed","target","rootWindow","preventDefault","focus","fragmentSelection","isInProgress","shiftKey","finish","isOutsideInputElement","activeElement","isSelected","isSelectedByAnyHeader","contains","unlisten","originalTarget","eventX","x","clientX","eventY","y","clientY","next","view","holder","wtTable","scrollbarWidth","elementFromPoint","isTargetWebComponent","parentNode","outsideClickDeselects","deselectCell","destroyEditor","translateFromRenderableToVisualCoords","_ref","col","_createCellCoords","translateFromRenderableToVisualIndex","renderableRow","renderableColumn","visualRow","rowIndexMapper","getVisualFromRenderableIndex","visualColumn","columnIndexMapper","countRenderableIndexes","indexMapper","maxElements","consideredElements","Math","min","getNotTrimmedIndexesLength","firstNotHiddenIndex","getNearestNotHiddenIndex","getRenderableFromVisualIndex","countRenderableColumns","maxCols","countRenderableRows","maxRows","countNotHiddenRowIndexes","visualIndex","incrementBy","countNotHiddenIndexes","countNotHiddenColumnIndexes","renderableIndexesCount","isNaN","firstVisibleIndex","renderableIndex","isInteger","notHiddenIndexes","countNotHiddenFixedColumnsStart","visualFixedColumnsStart","parseInt","fixedColumnsStart","countNotHiddenFixedRowsTop","countRows","visualFixedRowsTop","fixedRowsTop","countNotHiddenFixedRowsBottom","visualFixedRowsBottom","max","fixedRowsBottom","countRenderableColumnsInRange","columnStart","columnEnd","count","countRenderableRowsInRange","rowStart","rowEnd","isMainTableNotFullyCoveredByOverlays","fixedAllRows","fixedAllColumns","countRenderedRows","countRenderedCols","walkontableConfig","rtlMode","isRtl","externalRowCalculator","getPlugin","isEnabled","isDataViewInstance","preventOverflow","preventWheel","stretchH","data","getDataAtCell","totalRows","totalColumns","shouldRenderInlineStartOverlay","rowHeaders","shouldRenderTopOverlay","columnHeaders","shouldRenderBottomOverlay","minSpareRows","renderAllRows","renderAllColumns","headerRenderers","hasRowHeaders","push","renderableRowIndex","TH","visualRowIndex","appendRowHeader","_getAriaColcount2","_updateAriaColcount2","hasColHeaders","renderedColumnIndex","visualColumnsIndex","appendColHeader","columnWidth","getColWidth","rowHeight","renderedRowIndex","getRowHeight","cellRenderer","TD","visualColumnIndex","modifiedCellCoords","visualRowToCheck","visualColumnToCheck","Array","isArray","cellProperties","getCellMeta","prop","colToProp","getDataAtRowProp","hasHook","getCellRenderer","selections","highlight","hideBorderOnMouseDownOver","onWindowResize","isDestroyed","refreshDimensions","onContainerElementResize","onCellMouseDown","wt","visualCoords","controller","cell","listen","activeWt","cellCoordsFactory","onCellContextMenu","onCellMouseOut","onCellMouseOver","onCellMouseUp","onCellCornerMouseDown","onCellCornerDblClick","beforeDraw","skipRender","beforeRender","onDraw","afterRender","onBeforeViewportScrollVertically","rowMapper","areColumnHeadersSelected","onBeforeViewportScrollHorizontally","columnMapper","areRowHeadersSelected","onScrollVertically","onScrollHorizontally","onBeforeRemoveCellClassNames","onBeforeHighlightingRowHeader","headerLevel","highlightMeta","newVisualRow","onBeforeHighlightingColumnHeader","newVisualColumn","onAfterDrawSelection","currentRow","currentColumn","layerLevel","cornersOfSelection","selectedRange","getSelectedRange","selectionRangeSize","size","selectionForLayer","peekByIndex","from","to","onBeforeDrawBorders","corners","borderClassName","startRenderableRow","startRenderableColumn","endRenderableRow","endRenderableColumn","visualCorners","onBeforeTouchScroll","onAfterMomentumScroll","onBeforeStretchingColumnWidth","stretchedWidth","onModifyRowHeaderWidth","rowHeaderWidth","onModifyGetCellCoords","renderableColumnIndex","visualIndexes","visualRowFrom","visualColumnFrom","visualRowTo","visualColumnTo","viewportRowCalculatorOverride","calc","viewportOffset","viewportRowRenderingOffset","renderableRows","firstRenderedRow","startRow","lastRenderedRow","endRow","offset","ceil","viewportColumnCalculatorOverride","viewportColumnRenderingOffset","renderableColumns","firstRenderedColumn","startColumn","lastRenderedColumn","endColumn","columnHeaderHeight","spreader","width","height","getBoundingClientRect","setLastSize","which","stopPropagation","observeDOMVisibility","drawInterrupted","el","isChildOfTableBody","isSelectedOnlyCell","isCellEdited","isMouseDown","_this$hot$getSelected","_this$hot$getSelected2","getSelectedRangeLast","isSingleCell","activeEditor","getActiveEditor","isOpened","updateCellHeader","querySelector","getRowHeader","div","span","className","label","getColHeader","element","index","content","renderedIndex","parentOverlay","getParentOverlay","columnFilter","sourceToRendered","rowFilter","fromCharCode","maximumVisibleElementWidth","inlineOffset","workspaceWidth","wtViewport","getWorkspaceWidth","maxWidth","maximumVisibleElementHeight","topOffset","workspaceHeight","getWorkspaceHeight","maxHeight","getLastSize","getFirstFullyVisibleRow","wtScroll","getFirstVisibleRow","getLastFullyVisibleRow","getLastVisibleRow","getFirstFullyVisibleColumn","getFirstVisibleColumn","getLastFullyVisibleColumn","getLastVisibleColumn","getColumnHeadersCount","getRowHeadersCount","destroy","delta","colCount"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/tableView.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { addClass, clearTextSelection, empty, fastInnerHTML, fastInnerText, getScrollbarWidth, hasClass, isChildOf, isInput, isOutsideInput, isVisible, setAttribute } from \"./helpers/dom/element.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { isImmediatePropagationStopped, isRightClick, isLeftClick } from \"./helpers/dom/event.mjs\";\nimport Walkontable from \"./3rdparty/walkontable/src/index.mjs\";\nimport { handleMouseEvent } from \"./selection/mouseEventHandler.mjs\";\nimport { isRootInstance } from \"./utils/rootInstance.mjs\";\nimport { A11Y_COLCOUNT, A11Y_MULTISELECTABLE, A11Y_PRESENTATION, A11Y_ROWCOUNT, A11Y_TREEGRID } from \"./helpers/a11y.mjs\";\n/**\n * @class TableView\n * @private\n */\nvar _columnHeadersCount = /*#__PURE__*/new WeakMap();\nvar _rowHeadersCount = /*#__PURE__*/new WeakMap();\nvar _selectionMouseDown = /*#__PURE__*/new WeakMap();\nvar _mouseDown = /*#__PURE__*/new WeakMap();\nvar _table = /*#__PURE__*/new WeakMap();\nvar _lastWidth = /*#__PURE__*/new WeakMap();\nvar _lastHeight = /*#__PURE__*/new WeakMap();\nvar _getAriaColcount = /*#__PURE__*/new WeakSet();\nvar _updateAriaColcount = /*#__PURE__*/new WeakSet();\nclass TableView {\n  /**\n   * @param {Hanstontable} hotInstance Instance of {@link Handsontable}.\n   */\n  constructor(hotInstance) {\n    /**\n     * Update the `aria-colcount` attribute by the provided value.\n     *\n     * @param {number} delta The number of columns to add or remove to the aria tag.\n     */\n    _classPrivateMethodInitSpec(this, _updateAriaColcount);\n    /**\n     * Return the value of the `aria-colcount` attribute.\n     *\n     * @returns {number} The value of the `aria-colcount` attribute.\n     */\n    _classPrivateMethodInitSpec(this, _getAriaColcount);\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Instance of {@link EventManager}.\n     *\n     * @private\n     * @type {EventManager}\n     */\n    _defineProperty(this, \"eventManager\", void 0);\n    /**\n     * Current Handsontable's GridSettings object.\n     *\n     * @private\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * Main <THEAD> element.\n     *\n     * @private\n     * @type {HTMLTableSectionElement}\n     */\n    _defineProperty(this, \"THEAD\", void 0);\n    /**\n     * Main <TBODY> element.\n     *\n     * @private\n     * @type {HTMLTableSectionElement}\n     */\n    _defineProperty(this, \"TBODY\", void 0);\n    /**\n     * Main Walkontable instance.\n     *\n     * @private\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"_wt\", void 0);\n    /**\n     * Main Walkontable instance.\n     *\n     * @type {Walkontable}\n     */\n    _defineProperty(this, \"activeWt\", void 0);\n    /**\n     * The total number of the column header renderers applied to the table through the\n     * `afterGetColumnHeaderRenderers` hook.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _columnHeadersCount, {\n      writable: true,\n      value: 0\n    });\n    /**\n     * The total number of the row header renderers applied to the table through the\n     * `afterGetRowHeaderRenderers` hook.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _rowHeadersCount, {\n      writable: true,\n      value: 0\n    });\n    /**\n     * The flag determines if the `adjustElementsSize` method call was made during\n     * the render suspending. If true, the method has to be triggered once after render\n     * resuming.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"postponedAdjustElementsSize\", false);\n    /**\n     * Defines if the text should be selected during mousemove.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _selectionMouseDown, {\n      writable: true,\n      value: false\n    });\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _mouseDown, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Main <TABLE> element.\n     *\n     * @type {HTMLTableElement}\n     */\n    _classPrivateFieldInitSpec(this, _table, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Cached width of the rootElement.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _lastWidth, {\n      writable: true,\n      value: 0\n    });\n    /**\n     * Cached height of the rootElement.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _lastHeight, {\n      writable: true,\n      value: 0\n    });\n    this.hot = hotInstance;\n    this.eventManager = new EventManager(this.hot);\n    this.settings = this.hot.getSettings();\n    this.createElements();\n    this.registerEvents();\n    this.initializeWalkontable();\n  }\n\n  /**\n   * Renders WalkontableUI.\n   */\n  render() {\n    if (!this.hot.isRenderSuspended()) {\n      this.hot.runHooks('beforeRender', this.hot.forceFullRender);\n      if (this.postponedAdjustElementsSize) {\n        this.postponedAdjustElementsSize = false;\n        this.adjustElementsSize(true);\n      }\n      this._wt.draw(!this.hot.forceFullRender);\n      this.hot.runHooks('afterRender', this.hot.forceFullRender);\n      this.hot.forceFullRender = false;\n      this.hot.renderCall = false;\n    }\n  }\n\n  /**\n   * Adjust overlays elements size and master table size.\n   *\n   * @param {boolean} [force=false] When `true`, it adjust the DOM nodes sizes for all overlays.\n   */\n  adjustElementsSize() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.hot.isRenderSuspended()) {\n      this.postponedAdjustElementsSize = true;\n    } else {\n      this._wt.wtOverlays.adjustElementsSize(force);\n    }\n  }\n\n  /**\n   * Returns td object given coordinates.\n   *\n   * @param {CellCoords} coords Renderable cell coordinates.\n   * @param {boolean} topmost Indicates whether the cell should be calculated from the topmost.\n   * @returns {HTMLTableCellElement|null}\n   */\n  getCellAtCoords(coords, topmost) {\n    const td = this._wt.getCell(coords, topmost);\n    if (td < 0) {\n      // there was an exit code (cell is out of bounds)\n      return null;\n    }\n    return td;\n  }\n\n  /**\n   * Scroll viewport to a cell.\n   *\n   * @param {CellCoords} coords Renderable cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.\n   * @returns {boolean}\n   */\n  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n    return this._wt.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n  }\n\n  /**\n   * Scroll viewport to a column.\n   *\n   * @param {number} column Renderable column index.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.\n   * @returns {boolean}\n   */\n  scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n    return this._wt.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n  }\n\n  /**\n   * Scroll viewport to a row.\n   *\n   * @param {number} row Renderable row index.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.\n   * @returns {boolean}\n   */\n  scrollViewportVertically(row, snapToTop, snapToBottom) {\n    return this._wt.scrollViewportVertically(row, snapToTop, snapToBottom);\n  }\n\n  /**\n   * Prepares DOMElements and adds correct className to the root element.\n   *\n   * @private\n   */\n  createElements() {\n    const {\n      rootElement,\n      rootDocument\n    } = this.hot;\n    const originalStyle = rootElement.getAttribute('style');\n    if (originalStyle) {\n      rootElement.setAttribute('data-originalstyle', originalStyle); // needed to retrieve original style in jsFiddle link generator in HT examples. may be removed in future versions\n    }\n    addClass(rootElement, 'handsontable');\n    _classPrivateFieldSet(this, _table, rootDocument.createElement('TABLE'));\n    addClass(_classPrivateFieldGet(this, _table), 'htCore');\n    if (this.hot.getSettings().tableClassName) {\n      addClass(_classPrivateFieldGet(this, _table), this.hot.getSettings().tableClassName);\n    }\n    if (this.settings.ariaTags) {\n      setAttribute(_classPrivateFieldGet(this, _table), [A11Y_PRESENTATION()]);\n      setAttribute(rootElement, [A11Y_TREEGRID(), A11Y_ROWCOUNT(-1), A11Y_COLCOUNT(this.hot.countCols()), A11Y_MULTISELECTABLE()]);\n    }\n    this.THEAD = rootDocument.createElement('THEAD');\n    _classPrivateFieldGet(this, _table).appendChild(this.THEAD);\n    this.TBODY = rootDocument.createElement('TBODY');\n    _classPrivateFieldGet(this, _table).appendChild(this.TBODY);\n    this.hot.table = _classPrivateFieldGet(this, _table);\n    this.hot.container.insertBefore(_classPrivateFieldGet(this, _table), this.hot.container.firstChild);\n  }\n\n  /**\n   * Attaches necessary listeners.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      rootElement,\n      rootDocument,\n      selection\n    } = this.hot;\n    const documentElement = rootDocument.documentElement;\n    this.eventManager.addEventListener(rootElement, 'mousedown', event => {\n      _classPrivateFieldSet(this, _selectionMouseDown, true);\n      if (!this.isTextSelectionAllowed(event.target)) {\n        const {\n          rootWindow\n        } = this.hot;\n        clearTextSelection(rootWindow);\n        event.preventDefault();\n        rootWindow.focus(); // make sure that window that contains HOT is active. Important when HOT is in iframe.\n      }\n    });\n    this.eventManager.addEventListener(rootElement, 'mouseup', () => {\n      _classPrivateFieldSet(this, _selectionMouseDown, false);\n    });\n    this.eventManager.addEventListener(rootElement, 'mousemove', event => {\n      if (_classPrivateFieldGet(this, _selectionMouseDown) && !this.isTextSelectionAllowed(event.target)) {\n        // Clear selection only when fragmentSelection is enabled, otherwise clearing selection breaks the IME editor.\n        if (this.settings.fragmentSelection) {\n          clearTextSelection(this.hot.rootWindow);\n        }\n        event.preventDefault();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'keyup', event => {\n      // TODO: is it the best place and way to finish cell selection?\n      if (selection.isInProgress() && !event.shiftKey) {\n        selection.finish();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'mouseup', event => {\n      if (selection.isInProgress() && isLeftClick(event)) {\n        selection.finish();\n      }\n      _classPrivateFieldSet(this, _mouseDown, false);\n      const isOutsideInputElement = isOutsideInput(rootDocument.activeElement);\n      if (isInput(rootDocument.activeElement) && !isOutsideInputElement) {\n        return;\n      }\n      if (isOutsideInputElement || !selection.isSelected() && !selection.isSelectedByAnyHeader() && !rootElement.contains(event.target) && !isRightClick(event)) {\n        this.hot.unlisten();\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'contextmenu', event => {\n      if (selection.isInProgress() && isRightClick(event)) {\n        selection.finish();\n        _classPrivateFieldSet(this, _mouseDown, false);\n      }\n    });\n    this.eventManager.addEventListener(documentElement, 'touchend', () => {\n      if (selection.isInProgress()) {\n        selection.finish();\n      }\n      _classPrivateFieldSet(this, _mouseDown, false);\n    });\n    this.eventManager.addEventListener(documentElement, 'mousedown', event => {\n      const originalTarget = event.target;\n      const eventX = event.x || event.clientX;\n      const eventY = event.y || event.clientY;\n      let next = event.target;\n      if (_classPrivateFieldGet(this, _mouseDown) || !rootElement || !this.hot.view) {\n        return; // it must have been started in a cell\n      }\n\n      // immediate click on \"holder\" means click on the right side of vertical scrollbar\n      const {\n        holder\n      } = this.hot.view._wt.wtTable;\n      if (next === holder) {\n        const scrollbarWidth = getScrollbarWidth(rootDocument);\n        if (rootDocument.elementFromPoint(eventX + scrollbarWidth, eventY) !== holder || rootDocument.elementFromPoint(eventX, eventY + scrollbarWidth) !== holder) {\n          return;\n        }\n      } else {\n        while (next !== documentElement) {\n          if (next === null) {\n            if (event.isTargetWebComponent) {\n              break;\n            }\n\n            // click on something that was a row but now is detached (possibly because your click triggered a rerender)\n            return;\n          }\n          if (next === rootElement) {\n            // click inside container\n            return;\n          }\n          next = next.parentNode;\n        }\n      }\n\n      // function did not return until here, we have an outside click!\n      const outsideClickDeselects = typeof this.settings.outsideClickDeselects === 'function' ? this.settings.outsideClickDeselects(originalTarget) : this.settings.outsideClickDeselects;\n      if (outsideClickDeselects) {\n        this.hot.deselectCell();\n      } else {\n        this.hot.destroyEditor(false, false);\n      }\n    });\n    this.eventManager.addEventListener(_classPrivateFieldGet(this, _table), 'selectstart', event => {\n      if (this.settings.fragmentSelection || isInput(event.target)) {\n        return;\n      }\n      // https://github.com/handsontable/handsontable/issues/160\n      // Prevent text from being selected when performing drag down.\n      event.preventDefault();\n    });\n  }\n\n  /**\n   * Translate renderable cell coordinates to visual coordinates.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @returns {CellCoords}\n   */\n  translateFromRenderableToVisualCoords(_ref) {\n    let {\n      row,\n      col\n    } = _ref;\n    // TODO: To consider an idea to reusing the CellCoords instance instead creating new one.\n    return this.hot._createCellCoords(...this.translateFromRenderableToVisualIndex(row, col));\n  }\n\n  /**\n   * Translate renderable row and column indexes to visual row and column indexes.\n   *\n   * @param {number} renderableRow Renderable row index.\n   * @param {number} renderableColumn Renderable columnIndex.\n   * @returns {number[]}\n   */\n  translateFromRenderableToVisualIndex(renderableRow, renderableColumn) {\n    // TODO: Some helper may be needed.\n    // We perform translation for indexes (without headers).\n    let visualRow = renderableRow >= 0 ? this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow;\n    let visualColumn = renderableColumn >= 0 ? this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn;\n    if (visualRow === null) {\n      visualRow = renderableRow;\n    }\n    if (visualColumn === null) {\n      visualColumn = renderableColumn;\n    }\n    return [visualRow, visualColumn];\n  }\n\n  /**\n   * Returns the number of renderable indexes.\n   *\n   * @private\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} maxElements Maximum number of elements (rows or columns).\n   *\n   * @returns {number|*}\n   */\n  countRenderableIndexes(indexMapper, maxElements) {\n    const consideredElements = Math.min(indexMapper.getNotTrimmedIndexesLength(), maxElements);\n    // Don't take hidden indexes into account. We are looking just for renderable indexes.\n    const firstNotHiddenIndex = indexMapper.getNearestNotHiddenIndex(consideredElements - 1, -1);\n\n    // There are no renderable indexes.\n    if (firstNotHiddenIndex === null) {\n      return 0;\n    }\n    return indexMapper.getRenderableFromVisualIndex(firstNotHiddenIndex) + 1;\n  }\n\n  /**\n   * Returns the number of renderable columns.\n   *\n   * @returns {number}\n   */\n  countRenderableColumns() {\n    return this.countRenderableIndexes(this.hot.columnIndexMapper, this.settings.maxCols);\n  }\n\n  /**\n   * Returns the number of renderable rows.\n   *\n   * @returns {number}\n   */\n  countRenderableRows() {\n    return this.countRenderableIndexes(this.hot.rowIndexMapper, this.settings.maxRows);\n  }\n\n  /**\n   * Returns number of not hidden row indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @returns {number}\n   */\n  countNotHiddenRowIndexes(visualIndex, incrementBy) {\n    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.hot.rowIndexMapper, this.countRenderableRows());\n  }\n\n  /**\n   * Returns number of not hidden column indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @returns {number}\n   */\n  countNotHiddenColumnIndexes(visualIndex, incrementBy) {\n    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.hot.columnIndexMapper, this.countRenderableColumns());\n  }\n\n  /**\n   * Returns number of not hidden indexes counting from the passed starting index.\n   * The counting direction can be controlled by `incrementBy` argument.\n   *\n   * @param {number} visualIndex The visual index from which the counting begins.\n   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} renderableIndexesCount Total count of renderable indexes for specific axis.\n   * @returns {number}\n   */\n  countNotHiddenIndexes(visualIndex, incrementBy, indexMapper, renderableIndexesCount) {\n    if (isNaN(visualIndex) || visualIndex < 0) {\n      return 0;\n    }\n    const firstVisibleIndex = indexMapper.getNearestNotHiddenIndex(visualIndex, incrementBy);\n    const renderableIndex = indexMapper.getRenderableFromVisualIndex(firstVisibleIndex);\n    if (!Number.isInteger(renderableIndex)) {\n      return 0;\n    }\n    let notHiddenIndexes = 0;\n    if (incrementBy < 0) {\n      // Zero-based numbering for renderable indexes corresponds to a number of not hidden indexes.\n      notHiddenIndexes = renderableIndex + 1;\n    } else if (incrementBy > 0) {\n      notHiddenIndexes = renderableIndexesCount - renderableIndex;\n    }\n    return notHiddenIndexes;\n  }\n\n  /**\n   * The function returns the number of not hidden column indexes that fit between the first and\n   * last fixed column in the left (or right in RTL mode) overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedColumnsStart() {\n    const countCols = this.hot.countCols();\n    const visualFixedColumnsStart = Math.min(parseInt(this.settings.fixedColumnsStart, 10), countCols) - 1;\n    return this.countNotHiddenColumnIndexes(visualFixedColumnsStart, -1);\n  }\n\n  /**\n   * The function returns the number of not hidden row indexes that fit between the first and\n   * last fixed row in the top overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedRowsTop() {\n    const countRows = this.hot.countRows();\n    const visualFixedRowsTop = Math.min(parseInt(this.settings.fixedRowsTop, 10), countRows) - 1;\n    return this.countNotHiddenRowIndexes(visualFixedRowsTop, -1);\n  }\n\n  /**\n   * The function returns the number of not hidden row indexes that fit between the first and\n   * last fixed row in the bottom overlay.\n   *\n   * @returns {number}\n   */\n  countNotHiddenFixedRowsBottom() {\n    const countRows = this.hot.countRows();\n    const visualFixedRowsBottom = Math.max(countRows - parseInt(this.settings.fixedRowsBottom, 10), 0);\n    return this.countNotHiddenRowIndexes(visualFixedRowsBottom, 1);\n  }\n\n  /**\n   * The function returns the number of renderable column indexes within the passed range of the visual indexes.\n   *\n   * @param {number} columnStart The column visual start index.\n   * @param {number} columnEnd The column visual end index.\n   * @returns {number}\n   */\n  countRenderableColumnsInRange(columnStart, columnEnd) {\n    let count = 0;\n    for (let column = columnStart; column <= columnEnd; column++) {\n      if (this.hot.columnIndexMapper.getRenderableFromVisualIndex(column) !== null) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * The function returns the number of renderable row indexes within the passed range of the visual indexes.\n   *\n   * @param {number} rowStart The row visual start index.\n   * @param {number} rowEnd The row visual end index.\n   * @returns {number}\n   */\n  countRenderableRowsInRange(rowStart, rowEnd) {\n    let count = 0;\n    for (let row = rowStart; row <= rowEnd; row++) {\n      if (this.hot.rowIndexMapper.getRenderableFromVisualIndex(row) !== null) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Checks if at least one cell than belongs to the main table is not covered by the top, left or\n   * bottom overlay.\n   *\n   * @returns {boolean}\n   */\n  isMainTableNotFullyCoveredByOverlays() {\n    const fixedAllRows = this.countNotHiddenFixedRowsTop() + this.countNotHiddenFixedRowsBottom();\n    const fixedAllColumns = this.countNotHiddenFixedColumnsStart();\n    return this.hot.countRenderedRows() > fixedAllRows && this.hot.countRenderedCols() > fixedAllColumns;\n  }\n\n  /**\n   * Defines default configuration and initializes WalkOnTable instance.\n   *\n   * @private\n   */\n  initializeWalkontable() {\n    const walkontableConfig = {\n      ariaTags: this.settings.ariaTags,\n      rtlMode: this.hot.isRtl(),\n      externalRowCalculator: this.hot.getPlugin('autoRowSize') && this.hot.getPlugin('autoRowSize').isEnabled(),\n      table: _classPrivateFieldGet(this, _table),\n      isDataViewInstance: () => isRootInstance(this.hot),\n      preventOverflow: () => this.settings.preventOverflow,\n      preventWheel: () => this.settings.preventWheel,\n      stretchH: () => this.settings.stretchH,\n      data: (renderableRow, renderableColumn) => {\n        return this.hot.getDataAtCell(...this.translateFromRenderableToVisualIndex(renderableRow, renderableColumn));\n      },\n      totalRows: () => this.countRenderableRows(),\n      totalColumns: () => this.countRenderableColumns(),\n      // Number of renderable columns for the left overlay.\n      fixedColumnsStart: () => this.countNotHiddenFixedColumnsStart(),\n      // Number of renderable rows for the top overlay.\n      fixedRowsTop: () => this.countNotHiddenFixedRowsTop(),\n      // Number of renderable rows for the bottom overlay.\n      fixedRowsBottom: () => this.countNotHiddenFixedRowsBottom(),\n      // Enable the inline start overlay when conditions are met.\n      shouldRenderInlineStartOverlay: () => {\n        return this.settings.fixedColumnsStart > 0 || walkontableConfig.rowHeaders().length > 0;\n      },\n      // Enable the top overlay when conditions are met.\n      shouldRenderTopOverlay: () => {\n        return this.settings.fixedRowsTop > 0 || walkontableConfig.columnHeaders().length > 0;\n      },\n      // Enable the bottom overlay when conditions are met.\n      shouldRenderBottomOverlay: () => {\n        return this.settings.fixedRowsBottom > 0;\n      },\n      minSpareRows: () => this.settings.minSpareRows,\n      renderAllRows: this.settings.renderAllRows,\n      renderAllColumns: this.settings.renderAllColumns,\n      rowHeaders: () => {\n        const headerRenderers = [];\n        if (this.hot.hasRowHeaders()) {\n          headerRenderers.push((renderableRowIndex, TH) => {\n            // TODO: Some helper may be needed.\n            // We perform translation for row indexes (without row headers).\n            const visualRowIndex = renderableRowIndex >= 0 ? this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;\n            this.appendRowHeader(visualRowIndex, TH);\n          });\n        }\n        this.hot.runHooks('afterGetRowHeaderRenderers', headerRenderers);\n        _classPrivateFieldSet(this, _rowHeadersCount, headerRenderers.length);\n        if (this.hot.getSettings().ariaTags) {\n          // Update the aria-colcount attribute.\n          // Only needs to be done once after initialization/data update.\n          if (_classPrivateMethodGet(this, _getAriaColcount, _getAriaColcount2).call(this) === this.hot.countCols()) {\n            _classPrivateMethodGet(this, _updateAriaColcount, _updateAriaColcount2).call(this, _classPrivateFieldGet(this, _rowHeadersCount));\n          }\n        }\n        return headerRenderers;\n      },\n      columnHeaders: () => {\n        const headerRenderers = [];\n        if (this.hot.hasColHeaders()) {\n          headerRenderers.push((renderedColumnIndex, TH) => {\n            // TODO: Some helper may be needed.\n            // We perform translation for columns indexes (without column headers).\n            const visualColumnsIndex = renderedColumnIndex >= 0 ? this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex) : renderedColumnIndex;\n            this.appendColHeader(visualColumnsIndex, TH);\n          });\n        }\n        this.hot.runHooks('afterGetColumnHeaderRenderers', headerRenderers);\n        _classPrivateFieldSet(this, _columnHeadersCount, headerRenderers.length);\n        return headerRenderers;\n      },\n      columnWidth: renderedColumnIndex => {\n        const visualIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n\n        // It's not a bug that we can't find visual index for some handled by method indexes. The function is called also\n        // for indexes that are not displayed (indexes that are beyond the grid's boundaries), i.e. when `fixedColumnsStart` > `startCols` (wrong config?) or\n        // scrolling and dataset is empty (scroll should handle that?).\n        return this.hot.getColWidth(visualIndex === null ? renderedColumnIndex : visualIndex);\n      },\n      rowHeight: renderedRowIndex => {\n        const visualIndex = this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);\n        return this.hot.getRowHeight(visualIndex === null ? renderedRowIndex : visualIndex);\n      },\n      cellRenderer: (renderedRowIndex, renderedColumnIndex, TD) => {\n        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(renderedRowIndex, renderedColumnIndex);\n\n        // Coords may be modified. For example, by the `MergeCells` plugin. It should affect cell value and cell meta.\n        const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowIndex, visualColumnIndex);\n        let visualRowToCheck = visualRowIndex;\n        let visualColumnToCheck = visualColumnIndex;\n        if (Array.isArray(modifiedCellCoords)) {\n          [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;\n        }\n        const cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);\n        const prop = this.hot.colToProp(visualColumnToCheck);\n        let value = this.hot.getDataAtRowProp(visualRowToCheck, prop);\n        if (this.hot.hasHook('beforeValueRender')) {\n          value = this.hot.runHooks('beforeValueRender', value, cellProperties);\n        }\n        this.hot.runHooks('beforeRenderer', TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n        this.hot.getCellRenderer(cellProperties)(this.hot, TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n        this.hot.runHooks('afterRenderer', TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);\n      },\n      selections: this.hot.selection.highlight,\n      hideBorderOnMouseDownOver: () => this.settings.fragmentSelection,\n      onWindowResize: () => {\n        if (this.hot && !this.hot.isDestroyed) {\n          this.hot.refreshDimensions();\n        }\n      },\n      onContainerElementResize: () => {\n        if (this.hot && !this.hot.isDestroyed && isVisible(this.hot.rootElement)) {\n          this.hot.refreshDimensions();\n        }\n      },\n      onCellMouseDown: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        const controller = {\n          row: false,\n          column: false,\n          cell: false\n        };\n        this.hot.listen();\n        this.activeWt = wt;\n        _classPrivateFieldSet(this, _mouseDown, true);\n        this.hot.runHooks('beforeOnCellMouseDown', event, visualCoords, TD, controller);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        handleMouseEvent(event, {\n          coords: visualCoords,\n          selection: this.hot.selection,\n          controller,\n          cellCoordsFactory: (row, column) => this.hot._createCellCoords(row, column)\n        });\n        this.hot.runHooks('afterOnCellMouseDown', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellContextMenu: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        _classPrivateFieldSet(this, _mouseDown, false);\n        if (this.hot.selection.isInProgress()) {\n          this.hot.selection.finish();\n        }\n        this.hot.runHooks('beforeOnCellContextMenu', event, visualCoords, TD);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellContextMenu', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseOut: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseOut', event, visualCoords, TD);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellMouseOut', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseOver: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        const controller = {\n          row: false,\n          column: false,\n          cell: false\n        };\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseOver', event, visualCoords, TD, controller);\n        if (isImmediatePropagationStopped(event)) {\n          return;\n        }\n        if (_classPrivateFieldGet(this, _mouseDown)) {\n          handleMouseEvent(event, {\n            coords: visualCoords,\n            selection: this.hot.selection,\n            controller,\n            cellCoordsFactory: (row, column) => this.hot._createCellCoords(row, column)\n          });\n        }\n        this.hot.runHooks('afterOnCellMouseOver', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellMouseUp: (event, coords, TD, wt) => {\n        const visualCoords = this.translateFromRenderableToVisualCoords(coords);\n        this.activeWt = wt;\n        this.hot.runHooks('beforeOnCellMouseUp', event, visualCoords, TD);\n\n        // TODO: The second condition check is a workaround. Callback corresponding the method `updateSettings`\n        // disable plugin and enable it again. Disabling plugin closes the menu. Thus, calling the\n        // `updateSettings` in a body of any callback executed right after some context-menu action\n        // breaks the table (#7231).\n        if (isImmediatePropagationStopped(event) || this.hot.isDestroyed) {\n          return;\n        }\n        this.hot.runHooks('afterOnCellMouseUp', event, visualCoords, TD);\n        this.activeWt = this._wt;\n      },\n      onCellCornerMouseDown: event => {\n        event.preventDefault();\n        this.hot.runHooks('afterOnCellCornerMouseDown', event);\n      },\n      onCellCornerDblClick: event => {\n        event.preventDefault();\n        this.hot.runHooks('afterOnCellCornerDblClick', event);\n      },\n      beforeDraw: (force, skipRender) => this.beforeRender(force, skipRender),\n      onDraw: force => this.afterRender(force),\n      onBeforeViewportScrollVertically: renderableRow => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const areColumnHeadersSelected = renderableRow < 0;\n        let visualRow = renderableRow;\n        if (!areColumnHeadersSelected) {\n          visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);\n\n          // for an empty data return index as is\n          if (visualRow === null) {\n            return renderableRow;\n          }\n        }\n        visualRow = this.hot.runHooks('beforeViewportScrollVertically', visualRow);\n        this.hot.runHooks('beforeViewportScroll');\n        if (!areColumnHeadersSelected) {\n          return rowMapper.getRenderableFromVisualIndex(visualRow);\n        }\n        return visualRow;\n      },\n      onBeforeViewportScrollHorizontally: renderableColumn => {\n        const columnMapper = this.hot.columnIndexMapper;\n        const areRowHeadersSelected = renderableColumn < 0;\n        let visualColumn = renderableColumn;\n        if (!areRowHeadersSelected) {\n          visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);\n\n          // for an empty data return index as is\n          if (visualColumn === null) {\n            return renderableColumn;\n          }\n        }\n        visualColumn = this.hot.runHooks('beforeViewportScrollHorizontally', visualColumn);\n        this.hot.runHooks('beforeViewportScroll');\n        if (!areRowHeadersSelected) {\n          return columnMapper.getRenderableFromVisualIndex(visualColumn);\n        }\n        return visualColumn;\n      },\n      onScrollVertically: () => {\n        this.hot.runHooks('afterScrollVertically');\n        this.hot.runHooks('afterScroll');\n      },\n      onScrollHorizontally: () => {\n        this.hot.runHooks('afterScrollHorizontally');\n        this.hot.runHooks('afterScroll');\n      },\n      onBeforeRemoveCellClassNames: () => this.hot.runHooks('beforeRemoveCellClassNames'),\n      onBeforeHighlightingRowHeader: (renderableRow, headerLevel, highlightMeta) => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const areColumnHeadersSelected = renderableRow < 0;\n        let visualRow = renderableRow;\n        if (!areColumnHeadersSelected) {\n          visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);\n        }\n        const newVisualRow = this.hot.runHooks('beforeHighlightingRowHeader', visualRow, headerLevel, highlightMeta);\n        if (!areColumnHeadersSelected) {\n          return rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(newVisualRow, 1));\n        }\n        return newVisualRow;\n      },\n      onBeforeHighlightingColumnHeader: (renderableColumn, headerLevel, highlightMeta) => {\n        const columnMapper = this.hot.columnIndexMapper;\n        const areRowHeadersSelected = renderableColumn < 0;\n        let visualColumn = renderableColumn;\n        if (!areRowHeadersSelected) {\n          visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);\n        }\n        const newVisualColumn = this.hot.runHooks('beforeHighlightingColumnHeader', visualColumn, headerLevel, highlightMeta);\n        if (!areRowHeadersSelected) {\n          return columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(newVisualColumn, 1));\n        }\n        return newVisualColumn;\n      },\n      onAfterDrawSelection: (currentRow, currentColumn, layerLevel) => {\n        let cornersOfSelection;\n        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(currentRow, currentColumn);\n        const selectedRange = this.hot.selection.getSelectedRange();\n        const selectionRangeSize = selectedRange.size();\n        if (selectionRangeSize > 0) {\n          const selectionForLayer = selectedRange.peekByIndex(layerLevel !== null && layerLevel !== void 0 ? layerLevel : 0);\n          cornersOfSelection = [selectionForLayer.from.row, selectionForLayer.from.col, selectionForLayer.to.row, selectionForLayer.to.col];\n        }\n        return this.hot.runHooks('afterDrawSelection', visualRowIndex, visualColumnIndex, cornersOfSelection, layerLevel);\n      },\n      onBeforeDrawBorders: (corners, borderClassName) => {\n        const [startRenderableRow, startRenderableColumn, endRenderableRow, endRenderableColumn] = corners;\n        const visualCorners = [this.hot.rowIndexMapper.getVisualFromRenderableIndex(startRenderableRow), this.hot.columnIndexMapper.getVisualFromRenderableIndex(startRenderableColumn), this.hot.rowIndexMapper.getVisualFromRenderableIndex(endRenderableRow), this.hot.columnIndexMapper.getVisualFromRenderableIndex(endRenderableColumn)];\n        return this.hot.runHooks('beforeDrawBorders', visualCorners, borderClassName);\n      },\n      onBeforeTouchScroll: () => this.hot.runHooks('beforeTouchScroll'),\n      onAfterMomentumScroll: () => this.hot.runHooks('afterMomentumScroll'),\n      onBeforeStretchingColumnWidth: (stretchedWidth, renderedColumnIndex) => {\n        const visualColumnIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n        return this.hot.runHooks('beforeStretchingColumnWidth', stretchedWidth, visualColumnIndex);\n      },\n      onModifyRowHeaderWidth: rowHeaderWidth => this.hot.runHooks('modifyRowHeaderWidth', rowHeaderWidth),\n      onModifyGetCellCoords: (renderableRowIndex, renderableColumnIndex, topmost) => {\n        const rowMapper = this.hot.rowIndexMapper;\n        const columnMapper = this.hot.columnIndexMapper;\n\n        // Callback handle also headers. We shouldn't translate them.\n        const visualColumnIndex = renderableColumnIndex >= 0 ? columnMapper.getVisualFromRenderableIndex(renderableColumnIndex) : renderableColumnIndex;\n        const visualRowIndex = renderableRowIndex >= 0 ? rowMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;\n        const visualIndexes = this.hot.runHooks('modifyGetCellCoords', visualRowIndex, visualColumnIndex, topmost);\n        if (Array.isArray(visualIndexes)) {\n          const [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = visualIndexes;\n\n          // Result of the hook is handled by the Walkontable (renderable indexes).\n          return [visualRowFrom >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowFrom, 1)) : visualRowFrom, visualColumnFrom >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnFrom, 1)) : visualColumnFrom, visualRowTo >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowTo, -1)) : visualRowTo, visualColumnTo >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnTo, -1)) : visualColumnTo];\n        }\n      },\n      viewportRowCalculatorOverride: calc => {\n        let viewportOffset = this.settings.viewportRowRenderingOffset;\n        if (viewportOffset === 'auto' && this.settings.fixedRowsTop) {\n          viewportOffset = 10;\n        }\n        if (viewportOffset > 0 || viewportOffset === 'auto') {\n          const renderableRows = this.countRenderableRows();\n          const firstRenderedRow = calc.startRow;\n          const lastRenderedRow = calc.endRow;\n          if (typeof viewportOffset === 'number') {\n            calc.startRow = Math.max(firstRenderedRow - viewportOffset, 0);\n            calc.endRow = Math.min(lastRenderedRow + viewportOffset, renderableRows - 1);\n          } else if (viewportOffset === 'auto') {\n            const offset = Math.ceil(lastRenderedRow / renderableRows * 12);\n            calc.startRow = Math.max(firstRenderedRow - offset, 0);\n            calc.endRow = Math.min(lastRenderedRow + offset, renderableRows - 1);\n          }\n        }\n        this.hot.runHooks('afterViewportRowCalculatorOverride', calc);\n      },\n      viewportColumnCalculatorOverride: calc => {\n        let viewportOffset = this.settings.viewportColumnRenderingOffset;\n        if (viewportOffset === 'auto' && this.settings.fixedColumnsStart) {\n          viewportOffset = 10;\n        }\n        if (viewportOffset > 0 || viewportOffset === 'auto') {\n          const renderableColumns = this.countRenderableColumns();\n          const firstRenderedColumn = calc.startColumn;\n          const lastRenderedColumn = calc.endColumn;\n          if (typeof viewportOffset === 'number') {\n            calc.startColumn = Math.max(firstRenderedColumn - viewportOffset, 0);\n            calc.endColumn = Math.min(lastRenderedColumn + viewportOffset, renderableColumns - 1);\n          }\n          if (viewportOffset === 'auto') {\n            const offset = Math.ceil(lastRenderedColumn / renderableColumns * 6);\n            calc.startColumn = Math.max(firstRenderedColumn - offset, 0);\n            calc.endColumn = Math.min(lastRenderedColumn + offset, renderableColumns - 1);\n          }\n        }\n        this.hot.runHooks('afterViewportColumnCalculatorOverride', calc);\n      },\n      rowHeaderWidth: () => this.settings.rowHeaderWidth,\n      columnHeaderHeight: () => {\n        const columnHeaderHeight = this.hot.runHooks('modifyColumnHeaderHeight');\n        return this.settings.columnHeaderHeight || columnHeaderHeight;\n      }\n    };\n    this.hot.runHooks('beforeInitWalkontable', walkontableConfig);\n    this._wt = new Walkontable(walkontableConfig);\n    this.activeWt = this._wt;\n    const spreader = this._wt.wtTable.spreader;\n    // We have to cache width and height after Walkontable initialization.\n    const {\n      width,\n      height\n    } = this.hot.rootElement.getBoundingClientRect();\n    this.setLastSize(width, height);\n    this.eventManager.addEventListener(spreader, 'mousedown', event => {\n      // right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar\n      if (event.target === spreader && event.which === 3) {\n        event.stopPropagation();\n      }\n    });\n    this.eventManager.addEventListener(spreader, 'contextmenu', event => {\n      // right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar\n      if (event.target === spreader && event.which === 3) {\n        event.stopPropagation();\n      }\n    });\n    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'click', () => {\n      if (this.settings.observeDOMVisibility) {\n        if (this._wt.drawInterrupted) {\n          this.hot.forceFullRender = true;\n          this.render();\n        }\n      }\n    });\n  }\n\n  /**\n   * Checks if it's possible to create text selection in element.\n   *\n   * @private\n   * @param {HTMLElement} el The element to check.\n   * @returns {boolean}\n   */\n  isTextSelectionAllowed(el) {\n    if (isInput(el)) {\n      return true;\n    }\n    const isChildOfTableBody = isChildOf(el, this.hot.view._wt.wtTable.spreader);\n    if (this.settings.fragmentSelection === true && isChildOfTableBody) {\n      return true;\n    }\n    if (this.settings.fragmentSelection === 'cell' && this.isSelectedOnlyCell() && isChildOfTableBody) {\n      return true;\n    }\n    if (!this.settings.fragmentSelection && this.isCellEdited() && this.isSelectedOnlyCell()) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Checks if user's been called mousedown.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isMouseDown() {\n    return _classPrivateFieldGet(this, _mouseDown);\n  }\n\n  /**\n   * Check if selected only one cell.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isSelectedOnlyCell() {\n    var _this$hot$getSelected, _this$hot$getSelected2;\n    return (_this$hot$getSelected = (_this$hot$getSelected2 = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected2 === void 0 ? void 0 : _this$hot$getSelected2.isSingleCell()) !== null && _this$hot$getSelected !== void 0 ? _this$hot$getSelected : false;\n  }\n\n  /**\n   * Checks if active cell is editing.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isCellEdited() {\n    const activeEditor = this.hot.getActiveEditor();\n    return activeEditor && activeEditor.isOpened();\n  }\n\n  /**\n   * `beforeDraw` callback.\n   *\n   * @private\n   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if\n   *                        rendering was triggered by scrolling or moving selection.\n   * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering\n   *                            cycle will be skipped.\n   */\n  beforeRender(force, skipRender) {\n    if (force) {\n      // this.hot.forceFullRender = did Handsontable request full render?\n      this.hot.runHooks('beforeViewRender', this.hot.forceFullRender, skipRender);\n    }\n  }\n\n  /**\n   * `afterRender` callback.\n   *\n   * @private\n   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if\n   *                        rendering was triggered by scrolling or moving selection.\n   */\n  afterRender(force) {\n    if (force) {\n      // this.hot.forceFullRender = did Handsontable request full render?\n      this.hot.runHooks('afterViewRender', this.hot.forceFullRender);\n    }\n  }\n\n  /**\n   * Append row header to a TH element.\n   *\n   * @private\n   * @param {number} visualRowIndex The visual row index.\n   * @param {HTMLTableHeaderCellElement} TH The table header element.\n   */\n  appendRowHeader(visualRowIndex, TH) {\n    if (TH.firstChild) {\n      const container = TH.firstChild;\n      if (!hasClass(container, 'relative')) {\n        empty(TH);\n        this.appendRowHeader(visualRowIndex, TH);\n        return;\n      }\n      this.updateCellHeader(container.querySelector('.rowHeader'), visualRowIndex, this.hot.getRowHeader);\n    } else {\n      const {\n        rootDocument,\n        getRowHeader\n      } = this.hot;\n      const div = rootDocument.createElement('div');\n      const span = rootDocument.createElement('span');\n      div.className = 'relative';\n      span.className = 'rowHeader';\n      this.updateCellHeader(span, visualRowIndex, getRowHeader);\n      div.appendChild(span);\n      TH.appendChild(div);\n    }\n    this.hot.runHooks('afterGetRowHeader', visualRowIndex, TH);\n  }\n\n  /**\n   * Append column header to a TH element.\n   *\n   * @private\n   * @param {number} visualColumnIndex Visual column index.\n   * @param {HTMLTableCellElement} TH The table header element.\n   * @param {Function} [label] The function that returns the header label.\n   * @param {number} [headerLevel=0] The index of header level counting from the top (positive\n   *                                 values counting from 0 to N).\n   */\n  appendColHeader(visualColumnIndex, TH) {\n    let label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hot.getColHeader;\n    let headerLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (TH.firstChild) {\n      const container = TH.firstChild;\n      if (hasClass(container, 'relative')) {\n        this.updateCellHeader(container.querySelector('.colHeader'), visualColumnIndex, label, headerLevel);\n      } else {\n        empty(TH);\n        this.appendColHeader(visualColumnIndex, TH, label, headerLevel);\n      }\n    } else {\n      const {\n        rootDocument\n      } = this.hot;\n      const div = rootDocument.createElement('div');\n      const span = rootDocument.createElement('span');\n      div.className = 'relative';\n      span.className = 'colHeader';\n      if (this.settings.ariaTags) {\n        setAttribute(div, ...A11Y_PRESENTATION());\n        setAttribute(span, ...A11Y_PRESENTATION());\n      }\n      this.updateCellHeader(span, visualColumnIndex, label, headerLevel);\n      div.appendChild(span);\n      TH.appendChild(div);\n    }\n    this.hot.runHooks('afterGetColHeader', visualColumnIndex, TH, headerLevel);\n  }\n\n  /**\n   * Updates header cell content.\n   *\n   * @private\n   * @param {HTMLElement} element Element to update.\n   * @param {number} index Row index or column index.\n   * @param {Function} content Function which should be returns content for this cell.\n   * @param {number} [headerLevel=0] The index of header level counting from the top (positive\n   *                                 values counting from 0 to N).\n   */\n  updateCellHeader(element, index, content) {\n    let headerLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let renderedIndex = index;\n    const parentOverlay = this._wt.wtOverlays.getParentOverlay(element) || this._wt;\n\n    // prevent wrong calculations from SampleGenerator\n    if (element.parentNode) {\n      if (hasClass(element, 'colHeader')) {\n        renderedIndex = parentOverlay.wtTable.columnFilter.sourceToRendered(index);\n      } else if (hasClass(element, 'rowHeader')) {\n        renderedIndex = parentOverlay.wtTable.rowFilter.sourceToRendered(index);\n      }\n    }\n    if (renderedIndex > -1) {\n      fastInnerHTML(element, content(index, headerLevel));\n    } else {\n      // workaround for https://github.com/handsontable/handsontable/issues/1946\n      fastInnerText(element, String.fromCharCode(160));\n      addClass(element, 'cornerHeader');\n    }\n  }\n\n  /**\n   * Given a element's left (or right in RTL mode) position relative to the viewport, returns maximum\n   * element width until the right (or left) edge of the viewport (before scrollbar).\n   *\n   * @private\n   * @param {number} inlineOffset The left (or right in RTL mode) offset.\n   * @returns {number}\n   */\n  maximumVisibleElementWidth(inlineOffset) {\n    const workspaceWidth = this._wt.wtViewport.getWorkspaceWidth();\n    const maxWidth = workspaceWidth - inlineOffset;\n    return maxWidth > 0 ? maxWidth : 0;\n  }\n\n  /**\n   * Given a element's top position relative to the viewport, returns maximum element height until the bottom\n   * edge of the viewport (before scrollbar).\n   *\n   * @private\n   * @param {number} topOffset The top offset.\n   * @returns {number}\n   */\n  maximumVisibleElementHeight(topOffset) {\n    const workspaceHeight = this._wt.wtViewport.getWorkspaceHeight();\n    const maxHeight = workspaceHeight - topOffset;\n    return maxHeight > 0 ? maxHeight : 0;\n  }\n\n  /**\n   * Sets new dimensions of the container.\n   *\n   * @param {number} width The table width.\n   * @param {number} height The table height.\n   */\n  setLastSize(width, height) {\n    _classPrivateFieldSet(this, _lastWidth, width);\n    _classPrivateFieldSet(this, _lastHeight, height);\n  }\n\n  /**\n   * Returns cached dimensions.\n   *\n   * @returns {object}\n   */\n  getLastSize() {\n    return {\n      width: _classPrivateFieldGet(this, _lastWidth),\n      height: _classPrivateFieldGet(this, _lastHeight)\n    };\n  }\n\n  /**\n   * Returns the first fully visible row in the table viewport.\n   *\n   * @returns {number}\n   */\n  getFirstFullyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this.hot.view._wt.wtScroll.getFirstVisibleRow());\n  }\n\n  /**\n   * Returns the last fully visible row in the table viewport.\n   *\n   * @returns {number}\n   */\n  getLastFullyVisibleRow() {\n    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this.hot.view._wt.wtScroll.getLastVisibleRow());\n  }\n\n  /**\n   * Returns the first fully visible column in the table viewport.\n   *\n   * @returns {number}\n   */\n  getFirstFullyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this.hot.view._wt.wtScroll.getFirstVisibleColumn());\n  }\n\n  /**\n   * Returns the last fully visible column in the table viewport.\n   *\n   * @returns {number}\n   */\n  getLastFullyVisibleColumn() {\n    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this.hot.view._wt.wtScroll.getLastVisibleColumn());\n  }\n\n  /**\n   * Returns the total count of the rendered column headers.\n   *\n   * @returns {number}\n   */\n  getColumnHeadersCount() {\n    return _classPrivateFieldGet(this, _columnHeadersCount);\n  }\n\n  /**\n   * Returns the total count of the rendered row headers.\n   *\n   * @returns {number}\n   */\n  getRowHeadersCount() {\n    return _classPrivateFieldGet(this, _rowHeadersCount);\n  }\n  /**\n   * Destroys internal WalkOnTable's instance. Detaches all of the bonded listeners.\n   *\n   * @private\n   */\n  destroy() {\n    this._wt.destroy();\n    this.eventManager.destroy();\n  }\n}\nfunction _getAriaColcount2() {\n  return parseInt(this.hot.rootElement.getAttribute(A11Y_COLCOUNT()[0]), 10);\n}\nfunction _updateAriaColcount2(delta) {\n  const colCount = _classPrivateMethodGet(this, _getAriaColcount, _getAriaColcount2).call(this) + delta;\n  setAttribute(this.hot.rootElement, ...A11Y_COLCOUNT(colCount));\n}\nexport default TableView;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}