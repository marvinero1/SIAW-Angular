{"ast":null,"code":"import \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression, isDate, isDateValid, getDateInHfFormat, getDateFromExcelDate, getDateInHotFormat, isFormula } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides, haveEngineSettingsChanged } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport IndexSyncer from \"./indexSyncer/index.mjs\";\nexport const PLUGIN_KEY = 'formulas';\nexport const SETTING_KEYS = ['maxRows', 'maxColumns', 'language'];\nexport const PLUGIN_PRIORITY = 260;\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate');\n\n// This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\nconst isBlockedSource = source => source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\nvar _engineListeners = /*#__PURE__*/new WeakMap();\nvar _onBeforeValidate = /*#__PURE__*/new WeakSet();\nvar _onBeforeAutofill = /*#__PURE__*/new WeakSet();\nvar _onBeforeLoadData = /*#__PURE__*/new WeakSet();\nvar _onAfterCellMetaReset = /*#__PURE__*/new WeakSet();\nvar _onAfterLoadData = /*#__PURE__*/new WeakSet();\nvar _onModifyData = /*#__PURE__*/new WeakSet();\nvar _onModifySourceData = /*#__PURE__*/new WeakSet();\nvar _onAfterSetDataAtCell = /*#__PURE__*/new WeakSet();\nvar _onAfterSetSourceDataAtCell = /*#__PURE__*/new WeakSet();\nvar _onBeforeCreateRow = /*#__PURE__*/new WeakSet();\nvar _onBeforeCreateCol = /*#__PURE__*/new WeakSet();\nvar _onBeforeRemoveRow = /*#__PURE__*/new WeakSet();\nvar _onBeforeRemoveCol = /*#__PURE__*/new WeakSet();\nvar _onAfterCreateRow = /*#__PURE__*/new WeakSet();\nvar _onAfterCreateCol = /*#__PURE__*/new WeakSet();\nvar _onAfterRemoveRow = /*#__PURE__*/new WeakSet();\nvar _onAfterRemoveCol = /*#__PURE__*/new WeakSet();\nvar _onAfterDetachChild = /*#__PURE__*/new WeakSet();\nvar _onEngineValuesUpdated = /*#__PURE__*/new WeakSet();\nvar _onEngineNamedExpressionsAdded = /*#__PURE__*/new WeakSet();\nvar _onEngineNamedExpressionsRemoved = /*#__PURE__*/new WeakSet();\nvar _onEngineSheetAdded = /*#__PURE__*/new WeakSet();\nvar _onEngineSheetRenamed = /*#__PURE__*/new WeakSet();\nvar _onEngineSheetRemoved = /*#__PURE__*/new WeakSet();\nexport class Formulas extends BasePlugin {\n  constructor() {\n    var _this;\n    super(...arguments);\n    _this = this;\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineSheetRemoved);\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineSheetRenamed);\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineSheetAdded);\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineNamedExpressionsRemoved);\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineNamedExpressionsAdded);\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineValuesUpdated);\n    /**\n     * `afterDetachChild` hook callback.\n     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n     *\n     * @param {object} parent An object representing the parent from which the element was detached.\n     * @param {object} element The detached element.\n     * @param {number} finalElementRowIndex The final row index of the detached element.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterDetachChild);\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterRemoveCol);\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterRemoveRow);\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @param {number} visualColumn Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCreateCol);\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @param {number} visualRow Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCreateRow);\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeRemoveCol);\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeRemoveRow);\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @param {number} visualColumn Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeCreateCol);\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @param {number} visualRow Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeCreateRow);\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterSetSourceDataAtCell);\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterSetDataAtCell);\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n    _classPrivateMethodInitSpec(this, _onModifySourceData);\n    /**\n     * `modifyData` hook callback.\n     *\n     * @param {number} physicalRow Physical row index.\n     * @param {number} visualColumn Visual column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n    _classPrivateMethodInitSpec(this, _onModifyData);\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterLoadData);\n    /**\n     * Callback to `afterCellMetaReset` hook which is triggered after setting cell meta.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCellMetaReset);\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeLoadData);\n    /**\n     * `onBeforeAutofill` hook callback.\n     *\n     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n     * @param {CellRange} sourceRange The range values will be filled from.\n     * @param {CellRange} targetRange The range new values will be filled into.\n     * @returns {boolean|*}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeAutofill);\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeValidate);\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _internalOperationPending, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Flag needed to mark if Handsontable was initialized with no data.\n     * (Required to work around the fact, that Handsontable auto-generates sample data, when no data is provided).\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _hotWasInitializedWithEmptyData, {\n      writable: true,\n      value: false\n    });\n    /**\n     * The list of the HyperFormula listeners.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _engineListeners, {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return _classPrivateMethodGet(_this, _onEngineValuesUpdated, _onEngineValuesUpdated2).call(_this, ...args);\n      }], ['namedExpressionAdded', function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return _classPrivateMethodGet(_this, _onEngineNamedExpressionsAdded, _onEngineNamedExpressionsAdded2).call(_this, ...args);\n      }], ['namedExpressionRemoved', function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        return _classPrivateMethodGet(_this, _onEngineNamedExpressionsRemoved, _onEngineNamedExpressionsRemoved2).call(_this, ...args);\n      }], ['sheetAdded', function () {\n        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n        return _classPrivateMethodGet(_this, _onEngineSheetAdded, _onEngineSheetAdded2).call(_this, ...args);\n      }], ['sheetRenamed', function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        return _classPrivateMethodGet(_this, _onEngineSheetRenamed, _onEngineSheetRenamed2).call(_this, ...args);\n      }], ['sheetRemoved', function () {\n        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          args[_key6] = arguments[_key6];\n        }\n        return _classPrivateMethodGet(_this, _onEngineSheetRemoved, _onEngineSheetRemoved2).call(_this, ...args);\n      }]]\n    });\n    /**\n     * Static register used to set up one global HyperFormula instance.\n     * TODO: currently used in tests, might be removed later.\n     *\n     * @private\n     * @type {object}\n     */\n    _defineProperty(this, \"staticRegister\", staticRegister('formulas'));\n    /**\n     * The engine instance that will be used for this instance of Handsontable.\n     *\n     * @type {HyperFormula|null}\n     */\n    _defineProperty(this, \"engine\", null);\n    /**\n     * HyperFormula's sheet name.\n     *\n     * @type {string|null}\n     */\n    _defineProperty(this, \"sheetName\", null);\n    /**\n     * Index synchronizer responsible for manipulating with some general options related to indexes synchronization.\n     *\n     * @type {IndexSyncer|null}\n     */\n    _defineProperty(this, \"indexSyncer\", null);\n    /**\n     * Index synchronizer responsible for syncing the order of HOT and HF's data for the axis of the rows.\n     *\n     * @type {AxisSyncer|null}\n     */\n    _defineProperty(this, \"rowAxisSyncer\", null);\n    /**\n     * Index synchronizer responsible for syncing the order of HOT and HF's data for the axis of the columns.\n     *\n     * @type {AxisSyncer|null}\n     */\n    _defineProperty(this, \"columnAxisSyncer\", null);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  /**\n   * HyperFormula's sheet id.\n   *\n   * @type {number|null}\n   */\n  get sheetId() {\n    return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link Formulas#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    /* eslint-disable no-unneeded-ternary */\n    return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _setupEngine,\n      _this2 = this;\n    if (this.enabled) {\n      return;\n    }\n    this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n    if (!this.engine) {\n      warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n      return;\n    }\n\n    // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n    if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n      const newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n      if (newSheetName !== false) {\n        this.sheetName = newSheetName;\n      }\n    }\n    this.addHook('beforeLoadData', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeLoadData, _onBeforeLoadData2).call(_this2, ...args);\n    });\n    this.addHook('afterLoadData', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterLoadData, _onAfterLoadData2).call(_this2, ...args);\n    });\n\n    // The `updateData` hooks utilize the same logic as the `loadData` hooks.\n    this.addHook('beforeUpdateData', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeLoadData, _onBeforeLoadData2).call(_this2, ...args);\n    });\n    this.addHook('afterUpdateData', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterLoadData, _onAfterLoadData2).call(_this2, ...args);\n    });\n    this.addHook('modifyData', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _classPrivateMethodGet(_this2, _onModifyData, _onModifyData2).call(_this2, ...args);\n    });\n    this.addHook('modifySourceData', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _classPrivateMethodGet(_this2, _onModifySourceData, _onModifySourceData2).call(_this2, ...args);\n    });\n    this.addHook('beforeValidate', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeValidate, _onBeforeValidate2).call(_this2, ...args);\n    });\n    this.addHook('afterSetSourceDataAtCell', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterSetSourceDataAtCell, _onAfterSetSourceDataAtCell2).call(_this2, ...args);\n    });\n    this.addHook('afterSetDataAtCell', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterSetDataAtCell, _onAfterSetDataAtCell2).call(_this2, ...args);\n    });\n    this.addHook('afterSetDataAtRowProp', function () {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterSetDataAtCell, _onAfterSetDataAtCell2).call(_this2, ...args);\n    });\n    this.addHook('beforeCreateRow', function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeCreateRow, _onBeforeCreateRow2).call(_this2, ...args);\n    });\n    this.addHook('beforeCreateCol', function () {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeCreateCol, _onBeforeCreateCol2).call(_this2, ...args);\n    });\n    this.addHook('afterCreateRow', function () {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterCreateRow, _onAfterCreateRow2).call(_this2, ...args);\n    });\n    this.addHook('afterCreateCol', function () {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterCreateCol, _onAfterCreateCol2).call(_this2, ...args);\n    });\n    this.addHook('beforeRemoveRow', function () {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeRemoveRow, _onBeforeRemoveRow2).call(_this2, ...args);\n    });\n    this.addHook('beforeRemoveCol', function () {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeRemoveCol, _onBeforeRemoveCol2).call(_this2, ...args);\n    });\n    this.addHook('afterRemoveRow', function () {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterRemoveRow, _onAfterRemoveRow2).call(_this2, ...args);\n    });\n    this.addHook('afterRemoveCol', function () {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterRemoveCol, _onAfterRemoveCol2).call(_this2, ...args);\n    });\n    this.indexSyncer = new IndexSyncer(this.hot.rowIndexMapper, this.hot.columnIndexMapper, postponedAction => {\n      this.hot.addHookOnce('init', () => {\n        // Engine is initialized after executing callback to `afterLoadData` hook. Thus, some actions on indexes should\n        // be postponed.\n        postponedAction();\n      });\n    });\n    this.rowAxisSyncer = this.indexSyncer.getForAxis('row');\n    this.columnAxisSyncer = this.indexSyncer.getForAxis('column');\n    this.hot.addHook('afterRowSequenceChange', this.rowAxisSyncer.getIndexesChangeSyncMethod());\n    this.hot.addHook('afterColumnSequenceChange', this.columnAxisSyncer.getIndexesChangeSyncMethod());\n    this.hot.addHook('beforeRowMove', (movedRows, finalIndex, _, movePossible) => {\n      this.rowAxisSyncer.storeMovesInformation(movedRows, finalIndex, movePossible);\n    });\n    this.hot.addHook('beforeColumnMove', (movedColumns, finalIndex, _, movePossible) => {\n      this.columnAxisSyncer.storeMovesInformation(movedColumns, finalIndex, movePossible);\n    });\n    this.hot.addHook('afterRowMove', (movedRows, finalIndex, dropIndex, movePossible, orderChanged) => {\n      this.rowAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);\n    });\n    this.hot.addHook('afterColumnMove', (movedColumns, finalIndex, dropIndex, movePossible, orderChanged) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);\n    });\n    this.hot.addHook('beforeColumnFreeze', (column, freezePerformed) => {\n      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart, freezePerformed);\n    });\n    this.hot.addHook('afterColumnFreeze', (_, freezePerformed) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(freezePerformed, freezePerformed);\n    });\n    this.hot.addHook('beforeColumnUnfreeze', (column, unfreezePerformed) => {\n      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart - 1, unfreezePerformed);\n    });\n    this.hot.addHook('afterColumnUnfreeze', (_, unfreezePerformed) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(unfreezePerformed, unfreezePerformed);\n    });\n\n    // TODO: Actions related to overwriting dates from HOT format to HF default format are done as callback to this\n    // hook, because some hooks, such as `afterLoadData` doesn't have information about composed cell properties.\n    // Another hooks are triggered to late for setting HF's engine data needed for some actions.\n    this.addHook('afterCellMetaReset', function () {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterCellMetaReset, _onAfterCellMetaReset2).call(_this2, ...args);\n    });\n\n    // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n    this.addHook('beforeUndo', () => {\n      this.indexSyncer.setPerformUndo(true);\n      this.engine.undo();\n    });\n\n    // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n    this.addHook('beforeRedo', () => {\n      this.indexSyncer.setPerformRedo(true);\n      this.engine.redo();\n    });\n    this.addHook('afterUndo', () => {\n      this.indexSyncer.setPerformUndo(false);\n    });\n    this.addHook('afterUndo', () => {\n      this.indexSyncer.setPerformRedo(false);\n    });\n    this.addHook('afterDetachChild', function () {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterDetachChild, _onAfterDetachChild2).call(_this2, ...args);\n    });\n    this.addHook('beforeAutofill', function () {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeAutofill, _onBeforeAutofill2).call(_this2, ...args);\n    });\n    _classPrivateFieldGet(this, _engineListeners).forEach(_ref => {\n      let [eventName, listener] = _ref;\n      return this.engine.on(eventName, listener);\n    });\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    _classPrivateFieldGet(this, _engineListeners).forEach(_ref2 => {\n      let [eventName, listener] = _ref2;\n      return this.engine.off(eventName, listener);\n    });\n    unregisterEngine(this.engine, this.hot);\n    this.engine = null;\n    super.disablePlugin();\n  }\n\n  /**\n   * Triggered on `updateSettings`.\n   *\n   * @private\n   * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n   */\n  updatePlugin(newSettings) {\n    const newEngineSettings = getEngineSettingsWithOverrides(this.hot.getSettings());\n    if (haveEngineSettingsChanged(this.engine.getConfig(), newEngineSettings)) {\n      this.engine.updateConfig(newEngineSettings);\n    }\n    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n    if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n      this.switchSheet(pluginSettings.sheetName);\n    }\n\n    // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n    // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n    if (!newSettings.data && this.sheetName === null) {\n      const sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n      if (sheetName && this.engine.doesSheetExist(sheetName)) {\n        this.switchSheet(this.sheetName);\n      } else {\n        this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : undefined, this.hot.getSourceDataArray());\n      }\n    }\n    super.updatePlugin(newSettings);\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldGet(this, _engineListeners).forEach(_ref3 => {\n      var _this$engine;\n      let [eventName, listener] = _ref3;\n      return (_this$engine = this.engine) === null || _this$engine === void 0 ? void 0 : _this$engine.off(eventName, listener);\n    });\n    _classPrivateFieldSet(this, _engineListeners, null);\n    unregisterEngine(this.engine, this.hot);\n    this.engine = null;\n    super.destroy();\n  }\n\n  /**\n   * Add a sheet to the shared HyperFormula instance.\n   *\n   * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n   * auto-generated by HyperFormula.\n   * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n   * arrays - array of objects is not supported in this scenario.\n   * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n   * engine, the created sheet name otherwise.\n   */\n  addSheet(sheetName, sheetData) {\n    if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n      warn('The provided data should be an array of arrays.');\n      return false;\n    }\n    if (sheetName !== undefined && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n      warn('Sheet with the provided name already exists.');\n      return false;\n    }\n    try {\n      const actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : undefined);\n      if (sheetData) {\n        this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n      }\n      return actualSheetName;\n    } catch (e) {\n      warn(e.message);\n      return false;\n    }\n  }\n\n  /**\n   * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n   * instance).\n   *\n   * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n   */\n  switchSheet(sheetName) {\n    if (!this.engine.doesSheetExist(sheetName)) {\n      error(`The sheet named \\`${sheetName}\\` does not exist, switch aborted.`);\n      return;\n    }\n    this.sheetName = sheetName;\n    const serialized = this.engine.getSheetSerialized(this.sheetId);\n    if (serialized.length > 0) {\n      this.hot.loadData(serialized, `${toUpperCaseFirst(PLUGIN_KEY)}.switchSheet`);\n    }\n  }\n\n  /**\n   * Get the cell type under specified visual coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n   * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n   */\n  getCellType(row, column) {\n    let sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n    const physicalRow = this.hot.toPhysicalRow(row);\n    const physicalColumn = this.hot.toPhysicalColumn(column);\n    if (physicalRow !== null && physicalColumn !== null) {\n      return this.engine.getCellType({\n        sheet,\n        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)\n      });\n    } else {\n      // Should return `EMPTY` when out of bounds (according to the test cases).\n      return 'EMPTY';\n    }\n  }\n\n  /**\n   * Returns `true` if under specified visual coordinates is formula.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n   * @returns {boolean}\n   */\n  isFormulaCellType(row, column) {\n    let sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n    return this.engine.doesCellHaveFormula({\n      sheet,\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)\n    });\n  }\n\n  /**\n   * Renders dependent sheets (handsontable instances) based on the changes - list of the\n   * recalculated dependent cells.\n   *\n   * @private\n   * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n   * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n   */\n  renderDependentSheets(dependentCells) {\n    let renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const affectedSheetIds = new Set();\n    dependentCells.forEach(change => {\n      var _change$address;\n      // For the Named expression the address is empty, hence the `sheetId` is undefined.\n      const sheetId = change === null || change === void 0 || (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n      if (sheetId !== undefined) {\n        if (!affectedSheetIds.has(sheetId)) {\n          affectedSheetIds.add(sheetId);\n        }\n      }\n    });\n    getRegisteredHotInstances(this.engine).forEach((relatedHot, sheetId) => {\n      if ((renderSelf || sheetId !== this.sheetId) && affectedSheetIds.has(sheetId)) {\n        var _relatedHot$view;\n        relatedHot.render();\n        (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 || _relatedHot$view.adjustElementsSize();\n      }\n    });\n  }\n\n  /**\n   * Validates dependent cells based on the cells that are modified by the change.\n   *\n   * @private\n   * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n   * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n   */\n  validateDependentCells(dependentCells) {\n    let changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const stringifyAddress = change => {\n      var _change$address2;\n      const {\n        row,\n        col,\n        sheet\n      } = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {};\n      return isDefined(sheet) ? `${sheet}:${row}x${col}` : '';\n    };\n    const changedCellsSet = new Set(changedCells.map(change => stringifyAddress(change)));\n    dependentCells.forEach(change => {\n      var _change$address3, _change$address4;\n      const {\n        row,\n        col\n      } = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {};\n\n      // Don't try to validate cells outside of the visual part of the table.\n      if (isDefined(row) === false || isDefined(col) === false || row >= this.hot.countRows() || col >= this.hot.countCols()) {\n        return;\n      }\n\n      // For the Named expression the address is empty, hence the `sheetId` is undefined.\n      const sheetId = change === null || change === void 0 || (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n      const addressId = stringifyAddress(change);\n\n      // Validate the cells that depend on the calculated formulas. Skip that cells\n      // where the user directly changes the values - the Core triggers those validators.\n      if (sheetId !== undefined && !changedCellsSet.has(addressId)) {\n        const boundHot = getRegisteredHotInstances(this.engine).get(sheetId);\n\n        // if `sheetId` is not bound to any Handsontable instance, skip the validation process\n        if (!boundHot) {\n          return;\n        }\n\n        // It will just re-render certain cell when necessary.\n        boundHot.validateCell(boundHot.getDataAtCell(row, col), boundHot.getCellMeta(row, col), () => {});\n      }\n    });\n  }\n\n  /**\n   * Sync a change from the change-related hooks with the engine.\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {Handsontable.CellValue} newValue New value.\n   * @returns {Array} Array of changes exported from the engine.\n   */\n  syncChangeWithEngine(row, column, newValue) {\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column),\n      sheet: this.sheetId\n    };\n    if (!this.engine.isItPossibleToSetCellContents(address)) {\n      warn(`Not possible to set cell data at ${JSON.stringify(address)}`);\n      return;\n    }\n    const cellMeta = this.hot.getCellMeta(row, column);\n    if (isDate(newValue, cellMeta.type)) {\n      if (isDateValid(newValue, cellMeta.dateFormat)) {\n        // Rewriting date in HOT format to HF format.\n        newValue = getDateInHfFormat(newValue, cellMeta.dateFormat);\n      } else if (isFormula(newValue) === false) {\n        // Escaping value from date parsing using \"'\" sign (HF feature).\n        newValue = `'${newValue}`;\n      }\n    }\n    return this.engine.setCellContents(address, newValue);\n  }\n}\nfunction _onBeforeValidate2(value, visualRow, prop) {\n  const visualColumn = this.hot.propToCol(prop);\n  if (this.isFormulaCellType(visualRow, visualColumn)) {\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n      sheet: this.sheetId\n    };\n    const cellMeta = this.hot.getCellMeta(visualRow, visualColumn);\n    let cellValue = this.engine.getCellValue(address); // Date as an integer (Excel-like date).\n\n    if (cellMeta.type === 'date' && isNumeric(cellValue)) {\n      cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);\n    }\n\n    // If `cellValue` is an object it is expected to be an error\n    return typeof cellValue === 'object' && cellValue !== null ? cellValue.value : cellValue;\n  }\n  return value;\n}\nfunction _onBeforeAutofill2(fillData, sourceRange, targetRange) {\n  const {\n    row: sourceTopStartRow,\n    col: sourceTopStartColumn\n  } = sourceRange.getTopStartCorner();\n  const {\n    row: sourceBottomEndRow,\n    col: sourceBottomEndColumn\n  } = sourceRange.getBottomEndCorner();\n  const {\n    row: targetTopStartRow,\n    col: targetTopStartColumn\n  } = targetRange.getTopStartCorner();\n  const {\n    row: targetBottomEndRow,\n    col: targetBottomEndColumn\n  } = targetRange.getBottomEndCorner();\n  const engineSourceRange = {\n    start: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartColumn),\n      sheet: this.sheetId\n    },\n    end: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndColumn),\n      sheet: this.sheetId\n    }\n  };\n  const engineTargetRange = {\n    start: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetTopStartRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetTopStartColumn),\n      sheet: this.sheetId\n    },\n    end: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndColumn),\n      sheet: this.sheetId\n    }\n  };\n\n  // Blocks the autofill operation if HyperFormula says that at least one of\n  // the underlying cell's contents cannot be set.\n  if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n    return false;\n  }\n  const fillRangeData = this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n  const {\n    row: sourceStartRow,\n    col: sourceStartColumn\n  } = engineSourceRange.start;\n  const {\n    row: sourceEndRow,\n    col: sourceEndColumn\n  } = engineSourceRange.end;\n  const populationRowLength = sourceEndRow - sourceStartRow + 1;\n  const populationColumnLength = sourceEndColumn - sourceStartColumn + 1;\n  for (let populatedRowIndex = 0; populatedRowIndex < fillRangeData.length; populatedRowIndex += 1) {\n    for (let populatedColumnIndex = 0; populatedColumnIndex < fillRangeData[populatedRowIndex].length; populatedColumnIndex += 1) {\n      const populatedValue = fillRangeData[populatedRowIndex][populatedColumnIndex];\n      const sourceRow = populatedRowIndex % populationRowLength;\n      const sourceColumn = populatedColumnIndex % populationColumnLength;\n      const sourceCellMeta = this.hot.getCellMeta(sourceRow, sourceColumn);\n      if (isDate(populatedValue, sourceCellMeta.type)) {\n        if (populatedValue.startsWith('\\'')) {\n          // Populating values on HOT side without apostrophe.\n          fillRangeData[populatedRowIndex][populatedColumnIndex] = populatedValue.slice(1);\n        } else if (this.isFormulaCellType(sourceRow, sourceColumn, this.sheetId) === false) {\n          // Populating date in proper format, coming from the source cell.\n          fillRangeData[populatedRowIndex][populatedColumnIndex] = getDateInHotFormat(populatedValue, sourceCellMeta.dateFormat);\n        }\n      }\n    }\n  }\n  return fillRangeData;\n}\nfunction _onBeforeLoadData2(sourceData, initialLoad) {\n  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n    return;\n  }\n\n  // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n  // initial dataset.\n  _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n}\nfunction _onAfterCellMetaReset2() {\n  const sourceDataArray = this.hot.getSourceDataArray();\n  let valueChanged = false;\n  sourceDataArray.forEach((rowData, rowIndex) => {\n    rowData.forEach((cellValue, columnIndex) => {\n      const cellMeta = this.hot.getCellMeta(rowIndex, columnIndex);\n      const dateFormat = cellMeta.dateFormat;\n      if (isDate(cellValue, cellMeta.type)) {\n        valueChanged = true;\n        if (isDateValid(cellValue, dateFormat)) {\n          // Rewriting date in HOT format to HF format.\n          sourceDataArray[rowIndex][columnIndex] = getDateInHfFormat(cellValue, dateFormat);\n        } else if (this.isFormulaCellType(rowIndex, columnIndex) === false) {\n          // Escaping value from date parsing using \"'\" sign (HF feature).\n          sourceDataArray[rowIndex][columnIndex] = `'${cellValue}`;\n        }\n      }\n    });\n  });\n  if (valueChanged === true) {\n    _classPrivateFieldSet(this, _internalOperationPending, true);\n    this.engine.setSheetContent(this.sheetId, sourceDataArray);\n    _classPrivateFieldSet(this, _internalOperationPending, false);\n  }\n}\nfunction _onAfterLoadData2(sourceData, initialLoad) {\n  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n    return;\n  }\n  this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n  if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n    const sourceDataArray = this.hot.getSourceDataArray();\n    if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n      _classPrivateFieldSet(this, _internalOperationPending, true);\n      const dependentCells = this.engine.setSheetContent(this.sheetId, sourceDataArray);\n      this.indexSyncer.setupSyncEndpoint(this.engine, this.sheetId);\n      this.renderDependentSheets(dependentCells);\n      _classPrivateFieldSet(this, _internalOperationPending, false);\n    }\n  } else {\n    this.switchSheet(this.sheetName);\n  }\n}\nfunction _onModifyData2(physicalRow, visualColumn, valueHolder, ioMode) {\n  if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n    return;\n  }\n  const visualRow = this.hot.toVisualRow(physicalRow);\n  if (visualRow === null || visualColumn === null) {\n    return;\n  }\n\n  // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n  const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n  if (!isFormulaCellType) {\n    const cellType = this.getCellType(visualRow, visualColumn);\n    if (cellType !== 'ARRAY') {\n      if (isEscapedFormulaExpression(valueHolder.value)) {\n        valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n      }\n      return;\n    }\n  }\n  const address = {\n    row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n    sheet: this.sheetId\n  };\n  let cellValue = this.engine.getCellValue(address); // Date as an integer (Excel like date).\n  const cellMeta = this.hot.getCellMeta(visualRow, visualColumn);\n  if (cellMeta.type === 'date' && isNumeric(cellValue)) {\n    cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);\n  }\n\n  // If `cellValue` is an object it is expected to be an error\n  const value = typeof cellValue === 'object' && cellValue !== null ? cellValue.value : cellValue;\n  valueHolder.value = value;\n}\nfunction _onModifySourceData2(row, columnOrProp, valueHolder, ioMode) {\n  if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n    return;\n  }\n  const visualRow = this.hot.toVisualRow(row);\n  const visualColumn = this.hot.propToCol(columnOrProp);\n  if (visualRow === null || visualColumn === null) {\n    return;\n  }\n\n  // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n  const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n  if (!isFormulaCellType) {\n    const cellType = this.getCellType(visualRow, visualColumn);\n    if (cellType !== 'ARRAY') {\n      return;\n    }\n  }\n  const dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));\n\n  // Don't actually change the source data if HyperFormula is not\n  // initialized yet. This is done to allow the `afterLoadData` hook to\n  // load the existing source data with `Handsontable#getSourceDataArray`\n  // properly.\n  if (dimensions.width === 0 && dimensions.height === 0) {\n    return;\n  }\n  const address = {\n    row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n    sheet: this.sheetId\n  };\n  valueHolder.value = this.engine.getCellSerialized(address);\n}\nfunction _onAfterSetDataAtCell2(changes, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const outOfBoundsChanges = [];\n  const changedCells = [];\n  const dependentCells = this.engine.batch(() => {\n    changes.forEach(_ref4 => {\n      let [visualRow, prop,, newValue] = _ref4;\n      const visualColumn = this.hot.propToCol(prop);\n      const physicalRow = this.hot.toPhysicalRow(visualRow);\n      const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n      const address = {\n        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n        sheet: this.sheetId\n      };\n      if (physicalRow !== null && physicalColumn !== null) {\n        this.syncChangeWithEngine(visualRow, visualColumn, newValue);\n      } else {\n        outOfBoundsChanges.push([visualRow, visualColumn, newValue]);\n      }\n      changedCells.push({\n        address\n      });\n    });\n  });\n  if (outOfBoundsChanges.length) {\n    // Workaround for rows/columns being created two times (by HOT and the engine).\n    // (unfortunately, this requires an extra re-render)\n    this.hot.addHookOnce('afterChange', () => {\n      const outOfBoundsDependentCells = this.engine.batch(() => {\n        outOfBoundsChanges.forEach(_ref5 => {\n          let [row, column, newValue] = _ref5;\n          this.syncChangeWithEngine(row, column, newValue);\n        });\n      });\n      this.renderDependentSheets(outOfBoundsDependentCells, true);\n    });\n  }\n  this.renderDependentSheets(dependentCells);\n  this.validateDependentCells(dependentCells, changedCells);\n}\nfunction _onAfterSetSourceDataAtCell2(changes, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const dependentCells = [];\n  const changedCells = [];\n  changes.forEach(_ref6 => {\n    let [visualRow, prop,, newValue] = _ref6;\n    const visualColumn = this.hot.propToCol(prop);\n    if (!isNumeric(visualColumn)) {\n      return;\n    }\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n      sheet: this.sheetId\n    };\n    if (!this.engine.isItPossibleToSetCellContents(address)) {\n      warn(`Not possible to set source cell data at ${JSON.stringify(address)}`);\n      return;\n    }\n    changedCells.push({\n      address\n    });\n    dependentCells.push(...this.engine.setCellContents(address, newValue));\n  });\n  this.renderDependentSheets(dependentCells);\n  this.validateDependentCells(dependentCells, changedCells);\n}\nfunction _onBeforeCreateRow2(visualRow, amount) {\n  let hfRowIndex = this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow);\n  if (visualRow >= this.hot.countRows()) {\n    hfRowIndex = visualRow; // Row beyond the table boundaries.\n  }\n\n  if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [hfRowIndex, amount])) {\n    return false;\n  }\n}\nfunction _onBeforeCreateCol2(visualColumn, amount) {\n  let hfColumnIndex = this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn);\n  if (visualColumn >= this.hot.countCols()) {\n    hfColumnIndex = visualColumn; // Column beyond the table boundaries.\n  }\n\n  if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [hfColumnIndex, amount])) {\n    return false;\n  }\n}\nfunction _onBeforeRemoveRow2(row, amount, physicalRows) {\n  const hfRows = this.rowAxisSyncer.setRemovedHfIndexes(physicalRows);\n  const possible = hfRows.every(hfRow => {\n    return this.engine.isItPossibleToRemoveRows(this.sheetId, [hfRow, 1]);\n  });\n  return possible === false ? false : undefined;\n}\nfunction _onBeforeRemoveCol2(col, amount, physicalColumns) {\n  const hfColumns = this.columnAxisSyncer.setRemovedHfIndexes(physicalColumns);\n  const possible = hfColumns.every(hfColumn => {\n    return this.engine.isItPossibleToRemoveColumns(this.sheetId, [hfColumn, 1]);\n  });\n  return possible === false ? false : undefined;\n}\nfunction _onAfterCreateRow2(visualRow, amount, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const changes = this.engine.addRows(this.sheetId, [this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow), amount]);\n  this.renderDependentSheets(changes);\n}\nfunction _onAfterCreateCol2(visualColumn, amount, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const changes = this.engine.addColumns(this.sheetId, [this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn), amount]);\n  this.renderDependentSheets(changes);\n}\nfunction _onAfterRemoveRow2(row, amount, physicalRows, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const descendingHfRows = this.rowAxisSyncer.getRemovedHfIndexes().sort().reverse();\n  const changes = this.engine.batch(() => {\n    descendingHfRows.forEach(hfRow => {\n      this.engine.removeRows(this.sheetId, [hfRow, 1]);\n    });\n  });\n  this.renderDependentSheets(changes);\n}\nfunction _onAfterRemoveCol2(col, amount, physicalColumns, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const descendingHfColumns = this.columnAxisSyncer.getRemovedHfIndexes().sort().reverse();\n  const changes = this.engine.batch(() => {\n    descendingHfColumns.forEach(hfColumn => {\n      this.engine.removeColumns(this.sheetId, [hfColumn, 1]);\n    });\n  });\n  this.renderDependentSheets(changes);\n}\nfunction _onAfterDetachChild2(parent, element, finalElementRowIndex) {\n  var _element$__children;\n  _classPrivateFieldSet(this, _internalOperationPending, true);\n  const rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n  _classPrivateFieldSet(this, _internalOperationPending, false);\n  rowsData.forEach((row, relativeRowIndex) => {\n    row.forEach((value, colIndex) => {\n      this.engine.setCellContents({\n        col: colIndex,\n        row: finalElementRowIndex + relativeRowIndex,\n        sheet: this.sheetId\n      }, [[value]]);\n    });\n  });\n}\nfunction _onEngineValuesUpdated2(changes) {\n  this.hot.runHooks('afterFormulasValuesUpdate', changes);\n}\nfunction _onEngineNamedExpressionsAdded2(namedExpressionName, changes) {\n  this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n}\nfunction _onEngineNamedExpressionsRemoved2(namedExpressionName, changes) {\n  this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n}\nfunction _onEngineSheetAdded2(addedSheetDisplayName) {\n  this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n}\nfunction _onEngineSheetRenamed2(oldDisplayName, newDisplayName) {\n  this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n}\nfunction _onEngineSheetRemoved2(removedSheetDisplayName, changes) {\n  this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","_classPrivateFieldInitSpec","privateMap","set","privateCollection","has","_classPrivateFieldSet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorSet","_classPrivateFieldGet","_classApplyDescriptorGet","action","get","_classPrivateMethodGet","fn","BasePlugin","staticRegister","error","warn","isNumeric","isDefined","isUndefined","setupEngine","setupSheet","unregisterEngine","getRegisteredHotInstances","isEscapedFormulaExpression","unescapeFormulaExpression","isDate","isDateValid","getDateInHfFormat","getDateFromExcelDate","getDateInHotFormat","isFormula","getEngineSettingsWithOverrides","haveEngineSettingsChanged","isArrayOfArrays","toUpperCaseFirst","Hooks","IndexSyncer","PLUGIN_KEY","SETTING_KEYS","PLUGIN_PRIORITY","getSingleton","register","isBlockedSource","source","_internalOperationPending","WeakMap","_hotWasInitializedWithEmptyData","_engineListeners","_onBeforeValidate","WeakSet","_onBeforeAutofill","_onBeforeLoadData","_onAfterCellMetaReset","_onAfterLoadData","_onModifyData","_onModifySourceData","_onAfterSetDataAtCell","_onAfterSetSourceDataAtCell","_onBeforeCreateRow","_onBeforeCreateCol","_onBeforeRemoveRow","_onBeforeRemoveCol","_onAfterCreateRow","_onAfterCreateCol","_onAfterRemoveRow","_onAfterRemoveCol","_onAfterDetachChild","_onEngineValuesUpdated","_onEngineNamedExpressionsAdded","_onEngineNamedExpressionsRemoved","_onEngineSheetAdded","_onEngineSheetRenamed","_onEngineSheetRemoved","Formulas","constructor","_this","arguments","_len","length","args","Array","_key","_onEngineValuesUpdated2","_len2","_key2","_onEngineNamedExpressionsAdded2","_len3","_key3","_onEngineNamedExpressionsRemoved2","_len4","_key4","_onEngineSheetAdded2","_len5","_key5","_onEngineSheetRenamed2","_len6","_key6","_onEngineSheetRemoved2","sheetId","sheetName","engine","getSheetId","isEnabled","hot","getSettings","enablePlugin","_setupEngine","_this2","enabled","doesSheetExist","newSheetName","addSheet","getSourceDataArray","addHook","_len7","_key7","_onBeforeLoadData2","_len8","_key8","_onAfterLoadData2","_len9","_key9","_len10","_key10","_len11","_key11","_onModifyData2","_len12","_key12","_onModifySourceData2","_len13","_key13","_onBeforeValidate2","_len14","_key14","_onAfterSetSourceDataAtCell2","_len15","_key15","_onAfterSetDataAtCell2","_len16","_key16","_len17","_key17","_onBeforeCreateRow2","_len18","_key18","_onBeforeCreateCol2","_len19","_key19","_onAfterCreateRow2","_len20","_key20","_onAfterCreateCol2","_len21","_key21","_onBeforeRemoveRow2","_len22","_key22","_onBeforeRemoveCol2","_len23","_key23","_onAfterRemoveRow2","_len24","_key24","_onAfterRemoveCol2","indexSyncer","rowIndexMapper","columnIndexMapper","postponedAction","addHookOnce","rowAxisSyncer","getForAxis","columnAxisSyncer","getIndexesChangeSyncMethod","movedRows","finalIndex","_","movePossible","storeMovesInformation","movedColumns","dropIndex","orderChanged","calculateAndSyncMoves","column","freezePerformed","fixedColumnsStart","unfreezePerformed","_len25","_key25","_onAfterCellMetaReset2","setPerformUndo","undo","setPerformRedo","redo","_len26","_key26","_onAfterDetachChild2","_len27","_key27","_onBeforeAutofill2","forEach","_ref","eventName","listener","on","disablePlugin","_ref2","off","updatePlugin","newSettings","newEngineSettings","getConfig","updateConfig","pluginSettings","switchSheet","data","undefined","destroy","_ref3","_this$engine","sheetData","actualSheetName","setSheetContent","message","serialized","getSheetSerialized","loadData","getCellType","row","sheet","physicalRow","toPhysicalRow","physicalColumn","toPhysicalColumn","getHfIndexFromVisualIndex","col","isFormulaCellType","doesCellHaveFormula","renderDependentSheets","dependentCells","renderSelf","affectedSheetIds","Set","change","_change$address","address","relatedHot","_relatedHot$view","render","view","adjustElementsSize","validateDependentCells","changedCells","stringifyAddress","_change$address2","changedCellsSet","map","_change$address3","_change$address4","countRows","countCols","addressId","boundHot","validateCell","getDataAtCell","getCellMeta","syncChangeWithEngine","newValue","isItPossibleToSetCellContents","JSON","stringify","cellMeta","type","dateFormat","setCellContents","visualRow","prop","visualColumn","propToCol","cellValue","getCellValue","fillData","sourceRange","targetRange","sourceTopStartRow","sourceTopStartColumn","getTopStartCorner","sourceBottomEndRow","sourceBottomEndColumn","getBottomEndCorner","targetTopStartRow","targetTopStartColumn","targetBottomEndRow","targetBottomEndColumn","engineSourceRange","start","end","engineTargetRange","fillRangeData","getFillRangeData","sourceStartRow","sourceStartColumn","sourceEndRow","sourceEndColumn","populationRowLength","populationColumnLength","populatedRowIndex","populatedColumnIndex","populatedValue","sourceRow","sourceColumn","sourceCellMeta","startsWith","slice","sourceData","initialLoad","includes","sourceDataArray","valueChanged","rowData","rowIndex","columnIndex","isItPossibleToReplaceSheetContent","setupSyncEndpoint","valueHolder","ioMode","toVisualRow","cellType","columnOrProp","dimensions","getSheetDimensions","width","height","getCellSerialized","changes","outOfBoundsChanges","batch","_ref4","push","outOfBoundsDependentCells","_ref5","_ref6","amount","hfRowIndex","isItPossibleToAddRows","hfColumnIndex","isItPossibleToAddColumns","physicalRows","hfRows","setRemovedHfIndexes","possible","every","hfRow","isItPossibleToRemoveRows","physicalColumns","hfColumns","hfColumn","isItPossibleToRemoveColumns","addRows","addColumns","descendingHfRows","getRemovedHfIndexes","sort","reverse","removeRows","descendingHfColumns","removeColumns","parent","element","finalElementRowIndex","_element$__children","rowsData","__children","countSourceCols","relativeRowIndex","colIndex","runHooks","namedExpressionName","addedSheetDisplayName","oldDisplayName","newDisplayName","removedSheetDisplayName"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/formulas/formulas.mjs"],"sourcesContent":["import \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression, isDate, isDateValid, getDateInHfFormat, getDateFromExcelDate, getDateInHotFormat, isFormula } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides, haveEngineSettingsChanged } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport IndexSyncer from \"./indexSyncer/index.mjs\";\nexport const PLUGIN_KEY = 'formulas';\nexport const SETTING_KEYS = ['maxRows', 'maxColumns', 'language'];\nexport const PLUGIN_PRIORITY = 260;\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate');\n\n// This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\nconst isBlockedSource = source => source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\nvar _engineListeners = /*#__PURE__*/new WeakMap();\nvar _onBeforeValidate = /*#__PURE__*/new WeakSet();\nvar _onBeforeAutofill = /*#__PURE__*/new WeakSet();\nvar _onBeforeLoadData = /*#__PURE__*/new WeakSet();\nvar _onAfterCellMetaReset = /*#__PURE__*/new WeakSet();\nvar _onAfterLoadData = /*#__PURE__*/new WeakSet();\nvar _onModifyData = /*#__PURE__*/new WeakSet();\nvar _onModifySourceData = /*#__PURE__*/new WeakSet();\nvar _onAfterSetDataAtCell = /*#__PURE__*/new WeakSet();\nvar _onAfterSetSourceDataAtCell = /*#__PURE__*/new WeakSet();\nvar _onBeforeCreateRow = /*#__PURE__*/new WeakSet();\nvar _onBeforeCreateCol = /*#__PURE__*/new WeakSet();\nvar _onBeforeRemoveRow = /*#__PURE__*/new WeakSet();\nvar _onBeforeRemoveCol = /*#__PURE__*/new WeakSet();\nvar _onAfterCreateRow = /*#__PURE__*/new WeakSet();\nvar _onAfterCreateCol = /*#__PURE__*/new WeakSet();\nvar _onAfterRemoveRow = /*#__PURE__*/new WeakSet();\nvar _onAfterRemoveCol = /*#__PURE__*/new WeakSet();\nvar _onAfterDetachChild = /*#__PURE__*/new WeakSet();\nvar _onEngineValuesUpdated = /*#__PURE__*/new WeakSet();\nvar _onEngineNamedExpressionsAdded = /*#__PURE__*/new WeakSet();\nvar _onEngineNamedExpressionsRemoved = /*#__PURE__*/new WeakSet();\nvar _onEngineSheetAdded = /*#__PURE__*/new WeakSet();\nvar _onEngineSheetRenamed = /*#__PURE__*/new WeakSet();\nvar _onEngineSheetRemoved = /*#__PURE__*/new WeakSet();\nexport class Formulas extends BasePlugin {\n  constructor() {\n    var _this;\n    super(...arguments);\n    _this = this;\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineSheetRemoved);\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineSheetRenamed);\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineSheetAdded);\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineNamedExpressionsRemoved);\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineNamedExpressionsAdded);\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n    _classPrivateMethodInitSpec(this, _onEngineValuesUpdated);\n    /**\n     * `afterDetachChild` hook callback.\n     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n     *\n     * @param {object} parent An object representing the parent from which the element was detached.\n     * @param {object} element The detached element.\n     * @param {number} finalElementRowIndex The final row index of the detached element.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterDetachChild);\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterRemoveCol);\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterRemoveRow);\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @param {number} visualColumn Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCreateCol);\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @param {number} visualRow Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCreateRow);\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeRemoveCol);\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeRemoveRow);\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @param {number} visualColumn Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeCreateCol);\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @param {number} visualRow Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeCreateRow);\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterSetSourceDataAtCell);\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n    _classPrivateMethodInitSpec(this, _onAfterSetDataAtCell);\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n    _classPrivateMethodInitSpec(this, _onModifySourceData);\n    /**\n     * `modifyData` hook callback.\n     *\n     * @param {number} physicalRow Physical row index.\n     * @param {number} visualColumn Visual column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n    _classPrivateMethodInitSpec(this, _onModifyData);\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterLoadData);\n    /**\n     * Callback to `afterCellMetaReset` hook which is triggered after setting cell meta.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterCellMetaReset);\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeLoadData);\n    /**\n     * `onBeforeAutofill` hook callback.\n     *\n     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n     * @param {CellRange} sourceRange The range values will be filled from.\n     * @param {CellRange} targetRange The range new values will be filled into.\n     * @returns {boolean|*}\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeAutofill);\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeValidate);\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _internalOperationPending, {\n      writable: true,\n      value: false\n    });\n    /**\n     * Flag needed to mark if Handsontable was initialized with no data.\n     * (Required to work around the fact, that Handsontable auto-generates sample data, when no data is provided).\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _hotWasInitializedWithEmptyData, {\n      writable: true,\n      value: false\n    });\n    /**\n     * The list of the HyperFormula listeners.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _engineListeners, {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return _classPrivateMethodGet(_this, _onEngineValuesUpdated, _onEngineValuesUpdated2).call(_this, ...args);\n      }], ['namedExpressionAdded', function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return _classPrivateMethodGet(_this, _onEngineNamedExpressionsAdded, _onEngineNamedExpressionsAdded2).call(_this, ...args);\n      }], ['namedExpressionRemoved', function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        return _classPrivateMethodGet(_this, _onEngineNamedExpressionsRemoved, _onEngineNamedExpressionsRemoved2).call(_this, ...args);\n      }], ['sheetAdded', function () {\n        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n        return _classPrivateMethodGet(_this, _onEngineSheetAdded, _onEngineSheetAdded2).call(_this, ...args);\n      }], ['sheetRenamed', function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        return _classPrivateMethodGet(_this, _onEngineSheetRenamed, _onEngineSheetRenamed2).call(_this, ...args);\n      }], ['sheetRemoved', function () {\n        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          args[_key6] = arguments[_key6];\n        }\n        return _classPrivateMethodGet(_this, _onEngineSheetRemoved, _onEngineSheetRemoved2).call(_this, ...args);\n      }]]\n    });\n    /**\n     * Static register used to set up one global HyperFormula instance.\n     * TODO: currently used in tests, might be removed later.\n     *\n     * @private\n     * @type {object}\n     */\n    _defineProperty(this, \"staticRegister\", staticRegister('formulas'));\n    /**\n     * The engine instance that will be used for this instance of Handsontable.\n     *\n     * @type {HyperFormula|null}\n     */\n    _defineProperty(this, \"engine\", null);\n    /**\n     * HyperFormula's sheet name.\n     *\n     * @type {string|null}\n     */\n    _defineProperty(this, \"sheetName\", null);\n    /**\n     * Index synchronizer responsible for manipulating with some general options related to indexes synchronization.\n     *\n     * @type {IndexSyncer|null}\n     */\n    _defineProperty(this, \"indexSyncer\", null);\n    /**\n     * Index synchronizer responsible for syncing the order of HOT and HF's data for the axis of the rows.\n     *\n     * @type {AxisSyncer|null}\n     */\n    _defineProperty(this, \"rowAxisSyncer\", null);\n    /**\n     * Index synchronizer responsible for syncing the order of HOT and HF's data for the axis of the columns.\n     *\n     * @type {AxisSyncer|null}\n     */\n    _defineProperty(this, \"columnAxisSyncer\", null);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get SETTING_KEYS() {\n    return [PLUGIN_KEY, ...SETTING_KEYS];\n  }\n  /**\n   * HyperFormula's sheet id.\n   *\n   * @type {number|null}\n   */\n  get sheetId() {\n    return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link Formulas#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    /* eslint-disable no-unneeded-ternary */\n    return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _setupEngine,\n      _this2 = this;\n    if (this.enabled) {\n      return;\n    }\n    this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n    if (!this.engine) {\n      warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n      return;\n    }\n\n    // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n    if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n      const newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n      if (newSheetName !== false) {\n        this.sheetName = newSheetName;\n      }\n    }\n    this.addHook('beforeLoadData', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeLoadData, _onBeforeLoadData2).call(_this2, ...args);\n    });\n    this.addHook('afterLoadData', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterLoadData, _onAfterLoadData2).call(_this2, ...args);\n    });\n\n    // The `updateData` hooks utilize the same logic as the `loadData` hooks.\n    this.addHook('beforeUpdateData', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeLoadData, _onBeforeLoadData2).call(_this2, ...args);\n    });\n    this.addHook('afterUpdateData', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterLoadData, _onAfterLoadData2).call(_this2, ...args);\n    });\n    this.addHook('modifyData', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _classPrivateMethodGet(_this2, _onModifyData, _onModifyData2).call(_this2, ...args);\n    });\n    this.addHook('modifySourceData', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _classPrivateMethodGet(_this2, _onModifySourceData, _onModifySourceData2).call(_this2, ...args);\n    });\n    this.addHook('beforeValidate', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeValidate, _onBeforeValidate2).call(_this2, ...args);\n    });\n    this.addHook('afterSetSourceDataAtCell', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterSetSourceDataAtCell, _onAfterSetSourceDataAtCell2).call(_this2, ...args);\n    });\n    this.addHook('afterSetDataAtCell', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterSetDataAtCell, _onAfterSetDataAtCell2).call(_this2, ...args);\n    });\n    this.addHook('afterSetDataAtRowProp', function () {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterSetDataAtCell, _onAfterSetDataAtCell2).call(_this2, ...args);\n    });\n    this.addHook('beforeCreateRow', function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeCreateRow, _onBeforeCreateRow2).call(_this2, ...args);\n    });\n    this.addHook('beforeCreateCol', function () {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeCreateCol, _onBeforeCreateCol2).call(_this2, ...args);\n    });\n    this.addHook('afterCreateRow', function () {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterCreateRow, _onAfterCreateRow2).call(_this2, ...args);\n    });\n    this.addHook('afterCreateCol', function () {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterCreateCol, _onAfterCreateCol2).call(_this2, ...args);\n    });\n    this.addHook('beforeRemoveRow', function () {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeRemoveRow, _onBeforeRemoveRow2).call(_this2, ...args);\n    });\n    this.addHook('beforeRemoveCol', function () {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeRemoveCol, _onBeforeRemoveCol2).call(_this2, ...args);\n    });\n    this.addHook('afterRemoveRow', function () {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterRemoveRow, _onAfterRemoveRow2).call(_this2, ...args);\n    });\n    this.addHook('afterRemoveCol', function () {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterRemoveCol, _onAfterRemoveCol2).call(_this2, ...args);\n    });\n    this.indexSyncer = new IndexSyncer(this.hot.rowIndexMapper, this.hot.columnIndexMapper, postponedAction => {\n      this.hot.addHookOnce('init', () => {\n        // Engine is initialized after executing callback to `afterLoadData` hook. Thus, some actions on indexes should\n        // be postponed.\n        postponedAction();\n      });\n    });\n    this.rowAxisSyncer = this.indexSyncer.getForAxis('row');\n    this.columnAxisSyncer = this.indexSyncer.getForAxis('column');\n    this.hot.addHook('afterRowSequenceChange', this.rowAxisSyncer.getIndexesChangeSyncMethod());\n    this.hot.addHook('afterColumnSequenceChange', this.columnAxisSyncer.getIndexesChangeSyncMethod());\n    this.hot.addHook('beforeRowMove', (movedRows, finalIndex, _, movePossible) => {\n      this.rowAxisSyncer.storeMovesInformation(movedRows, finalIndex, movePossible);\n    });\n    this.hot.addHook('beforeColumnMove', (movedColumns, finalIndex, _, movePossible) => {\n      this.columnAxisSyncer.storeMovesInformation(movedColumns, finalIndex, movePossible);\n    });\n    this.hot.addHook('afterRowMove', (movedRows, finalIndex, dropIndex, movePossible, orderChanged) => {\n      this.rowAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);\n    });\n    this.hot.addHook('afterColumnMove', (movedColumns, finalIndex, dropIndex, movePossible, orderChanged) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);\n    });\n    this.hot.addHook('beforeColumnFreeze', (column, freezePerformed) => {\n      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart, freezePerformed);\n    });\n    this.hot.addHook('afterColumnFreeze', (_, freezePerformed) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(freezePerformed, freezePerformed);\n    });\n    this.hot.addHook('beforeColumnUnfreeze', (column, unfreezePerformed) => {\n      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart - 1, unfreezePerformed);\n    });\n    this.hot.addHook('afterColumnUnfreeze', (_, unfreezePerformed) => {\n      this.columnAxisSyncer.calculateAndSyncMoves(unfreezePerformed, unfreezePerformed);\n    });\n\n    // TODO: Actions related to overwriting dates from HOT format to HF default format are done as callback to this\n    // hook, because some hooks, such as `afterLoadData` doesn't have information about composed cell properties.\n    // Another hooks are triggered to late for setting HF's engine data needed for some actions.\n    this.addHook('afterCellMetaReset', function () {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterCellMetaReset, _onAfterCellMetaReset2).call(_this2, ...args);\n    });\n\n    // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n    this.addHook('beforeUndo', () => {\n      this.indexSyncer.setPerformUndo(true);\n      this.engine.undo();\n    });\n\n    // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n    this.addHook('beforeRedo', () => {\n      this.indexSyncer.setPerformRedo(true);\n      this.engine.redo();\n    });\n    this.addHook('afterUndo', () => {\n      this.indexSyncer.setPerformUndo(false);\n    });\n    this.addHook('afterUndo', () => {\n      this.indexSyncer.setPerformRedo(false);\n    });\n    this.addHook('afterDetachChild', function () {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return _classPrivateMethodGet(_this2, _onAfterDetachChild, _onAfterDetachChild2).call(_this2, ...args);\n    });\n    this.addHook('beforeAutofill', function () {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return _classPrivateMethodGet(_this2, _onBeforeAutofill, _onBeforeAutofill2).call(_this2, ...args);\n    });\n    _classPrivateFieldGet(this, _engineListeners).forEach(_ref => {\n      let [eventName, listener] = _ref;\n      return this.engine.on(eventName, listener);\n    });\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    _classPrivateFieldGet(this, _engineListeners).forEach(_ref2 => {\n      let [eventName, listener] = _ref2;\n      return this.engine.off(eventName, listener);\n    });\n    unregisterEngine(this.engine, this.hot);\n    this.engine = null;\n    super.disablePlugin();\n  }\n\n  /**\n   * Triggered on `updateSettings`.\n   *\n   * @private\n   * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n   */\n  updatePlugin(newSettings) {\n    const newEngineSettings = getEngineSettingsWithOverrides(this.hot.getSettings());\n    if (haveEngineSettingsChanged(this.engine.getConfig(), newEngineSettings)) {\n      this.engine.updateConfig(newEngineSettings);\n    }\n    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n    if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n      this.switchSheet(pluginSettings.sheetName);\n    }\n\n    // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n    // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n    if (!newSettings.data && this.sheetName === null) {\n      const sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n      if (sheetName && this.engine.doesSheetExist(sheetName)) {\n        this.switchSheet(this.sheetName);\n      } else {\n        this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : undefined, this.hot.getSourceDataArray());\n      }\n    }\n    super.updatePlugin(newSettings);\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldGet(this, _engineListeners).forEach(_ref3 => {\n      var _this$engine;\n      let [eventName, listener] = _ref3;\n      return (_this$engine = this.engine) === null || _this$engine === void 0 ? void 0 : _this$engine.off(eventName, listener);\n    });\n    _classPrivateFieldSet(this, _engineListeners, null);\n    unregisterEngine(this.engine, this.hot);\n    this.engine = null;\n    super.destroy();\n  }\n\n  /**\n   * Add a sheet to the shared HyperFormula instance.\n   *\n   * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n   * auto-generated by HyperFormula.\n   * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n   * arrays - array of objects is not supported in this scenario.\n   * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n   * engine, the created sheet name otherwise.\n   */\n  addSheet(sheetName, sheetData) {\n    if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n      warn('The provided data should be an array of arrays.');\n      return false;\n    }\n    if (sheetName !== undefined && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n      warn('Sheet with the provided name already exists.');\n      return false;\n    }\n    try {\n      const actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : undefined);\n      if (sheetData) {\n        this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n      }\n      return actualSheetName;\n    } catch (e) {\n      warn(e.message);\n      return false;\n    }\n  }\n\n  /**\n   * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n   * instance).\n   *\n   * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n   */\n  switchSheet(sheetName) {\n    if (!this.engine.doesSheetExist(sheetName)) {\n      error(`The sheet named \\`${sheetName}\\` does not exist, switch aborted.`);\n      return;\n    }\n    this.sheetName = sheetName;\n    const serialized = this.engine.getSheetSerialized(this.sheetId);\n    if (serialized.length > 0) {\n      this.hot.loadData(serialized, `${toUpperCaseFirst(PLUGIN_KEY)}.switchSheet`);\n    }\n  }\n\n  /**\n   * Get the cell type under specified visual coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n   * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n   */\n  getCellType(row, column) {\n    let sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n    const physicalRow = this.hot.toPhysicalRow(row);\n    const physicalColumn = this.hot.toPhysicalColumn(column);\n    if (physicalRow !== null && physicalColumn !== null) {\n      return this.engine.getCellType({\n        sheet,\n        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)\n      });\n    } else {\n      // Should return `EMPTY` when out of bounds (according to the test cases).\n      return 'EMPTY';\n    }\n  }\n\n  /**\n   * Returns `true` if under specified visual coordinates is formula.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n   * @returns {boolean}\n   */\n  isFormulaCellType(row, column) {\n    let sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n    return this.engine.doesCellHaveFormula({\n      sheet,\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)\n    });\n  }\n\n  /**\n   * Renders dependent sheets (handsontable instances) based on the changes - list of the\n   * recalculated dependent cells.\n   *\n   * @private\n   * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n   * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n   */\n  renderDependentSheets(dependentCells) {\n    let renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const affectedSheetIds = new Set();\n    dependentCells.forEach(change => {\n      var _change$address;\n      // For the Named expression the address is empty, hence the `sheetId` is undefined.\n      const sheetId = change === null || change === void 0 || (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n      if (sheetId !== undefined) {\n        if (!affectedSheetIds.has(sheetId)) {\n          affectedSheetIds.add(sheetId);\n        }\n      }\n    });\n    getRegisteredHotInstances(this.engine).forEach((relatedHot, sheetId) => {\n      if ((renderSelf || sheetId !== this.sheetId) && affectedSheetIds.has(sheetId)) {\n        var _relatedHot$view;\n        relatedHot.render();\n        (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 || _relatedHot$view.adjustElementsSize();\n      }\n    });\n  }\n\n  /**\n   * Validates dependent cells based on the cells that are modified by the change.\n   *\n   * @private\n   * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n   * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n   */\n  validateDependentCells(dependentCells) {\n    let changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const stringifyAddress = change => {\n      var _change$address2;\n      const {\n        row,\n        col,\n        sheet\n      } = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {};\n      return isDefined(sheet) ? `${sheet}:${row}x${col}` : '';\n    };\n    const changedCellsSet = new Set(changedCells.map(change => stringifyAddress(change)));\n    dependentCells.forEach(change => {\n      var _change$address3, _change$address4;\n      const {\n        row,\n        col\n      } = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {};\n\n      // Don't try to validate cells outside of the visual part of the table.\n      if (isDefined(row) === false || isDefined(col) === false || row >= this.hot.countRows() || col >= this.hot.countCols()) {\n        return;\n      }\n\n      // For the Named expression the address is empty, hence the `sheetId` is undefined.\n      const sheetId = change === null || change === void 0 || (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n      const addressId = stringifyAddress(change);\n\n      // Validate the cells that depend on the calculated formulas. Skip that cells\n      // where the user directly changes the values - the Core triggers those validators.\n      if (sheetId !== undefined && !changedCellsSet.has(addressId)) {\n        const boundHot = getRegisteredHotInstances(this.engine).get(sheetId);\n\n        // if `sheetId` is not bound to any Handsontable instance, skip the validation process\n        if (!boundHot) {\n          return;\n        }\n\n        // It will just re-render certain cell when necessary.\n        boundHot.validateCell(boundHot.getDataAtCell(row, col), boundHot.getCellMeta(row, col), () => {});\n      }\n    });\n  }\n\n  /**\n   * Sync a change from the change-related hooks with the engine.\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {Handsontable.CellValue} newValue New value.\n   * @returns {Array} Array of changes exported from the engine.\n   */\n  syncChangeWithEngine(row, column, newValue) {\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column),\n      sheet: this.sheetId\n    };\n    if (!this.engine.isItPossibleToSetCellContents(address)) {\n      warn(`Not possible to set cell data at ${JSON.stringify(address)}`);\n      return;\n    }\n    const cellMeta = this.hot.getCellMeta(row, column);\n    if (isDate(newValue, cellMeta.type)) {\n      if (isDateValid(newValue, cellMeta.dateFormat)) {\n        // Rewriting date in HOT format to HF format.\n        newValue = getDateInHfFormat(newValue, cellMeta.dateFormat);\n      } else if (isFormula(newValue) === false) {\n        // Escaping value from date parsing using \"'\" sign (HF feature).\n        newValue = `'${newValue}`;\n      }\n    }\n    return this.engine.setCellContents(address, newValue);\n  }\n}\nfunction _onBeforeValidate2(value, visualRow, prop) {\n  const visualColumn = this.hot.propToCol(prop);\n  if (this.isFormulaCellType(visualRow, visualColumn)) {\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n      sheet: this.sheetId\n    };\n    const cellMeta = this.hot.getCellMeta(visualRow, visualColumn);\n    let cellValue = this.engine.getCellValue(address); // Date as an integer (Excel-like date).\n\n    if (cellMeta.type === 'date' && isNumeric(cellValue)) {\n      cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);\n    }\n\n    // If `cellValue` is an object it is expected to be an error\n    return typeof cellValue === 'object' && cellValue !== null ? cellValue.value : cellValue;\n  }\n  return value;\n}\nfunction _onBeforeAutofill2(fillData, sourceRange, targetRange) {\n  const {\n    row: sourceTopStartRow,\n    col: sourceTopStartColumn\n  } = sourceRange.getTopStartCorner();\n  const {\n    row: sourceBottomEndRow,\n    col: sourceBottomEndColumn\n  } = sourceRange.getBottomEndCorner();\n  const {\n    row: targetTopStartRow,\n    col: targetTopStartColumn\n  } = targetRange.getTopStartCorner();\n  const {\n    row: targetBottomEndRow,\n    col: targetBottomEndColumn\n  } = targetRange.getBottomEndCorner();\n  const engineSourceRange = {\n    start: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartColumn),\n      sheet: this.sheetId\n    },\n    end: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndColumn),\n      sheet: this.sheetId\n    }\n  };\n  const engineTargetRange = {\n    start: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetTopStartRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetTopStartColumn),\n      sheet: this.sheetId\n    },\n    end: {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndColumn),\n      sheet: this.sheetId\n    }\n  };\n\n  // Blocks the autofill operation if HyperFormula says that at least one of\n  // the underlying cell's contents cannot be set.\n  if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n    return false;\n  }\n  const fillRangeData = this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n  const {\n    row: sourceStartRow,\n    col: sourceStartColumn\n  } = engineSourceRange.start;\n  const {\n    row: sourceEndRow,\n    col: sourceEndColumn\n  } = engineSourceRange.end;\n  const populationRowLength = sourceEndRow - sourceStartRow + 1;\n  const populationColumnLength = sourceEndColumn - sourceStartColumn + 1;\n  for (let populatedRowIndex = 0; populatedRowIndex < fillRangeData.length; populatedRowIndex += 1) {\n    for (let populatedColumnIndex = 0; populatedColumnIndex < fillRangeData[populatedRowIndex].length; populatedColumnIndex += 1) {\n      const populatedValue = fillRangeData[populatedRowIndex][populatedColumnIndex];\n      const sourceRow = populatedRowIndex % populationRowLength;\n      const sourceColumn = populatedColumnIndex % populationColumnLength;\n      const sourceCellMeta = this.hot.getCellMeta(sourceRow, sourceColumn);\n      if (isDate(populatedValue, sourceCellMeta.type)) {\n        if (populatedValue.startsWith('\\'')) {\n          // Populating values on HOT side without apostrophe.\n          fillRangeData[populatedRowIndex][populatedColumnIndex] = populatedValue.slice(1);\n        } else if (this.isFormulaCellType(sourceRow, sourceColumn, this.sheetId) === false) {\n          // Populating date in proper format, coming from the source cell.\n          fillRangeData[populatedRowIndex][populatedColumnIndex] = getDateInHotFormat(populatedValue, sourceCellMeta.dateFormat);\n        }\n      }\n    }\n  }\n  return fillRangeData;\n}\nfunction _onBeforeLoadData2(sourceData, initialLoad) {\n  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n    return;\n  }\n\n  // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n  // initial dataset.\n  _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n}\nfunction _onAfterCellMetaReset2() {\n  const sourceDataArray = this.hot.getSourceDataArray();\n  let valueChanged = false;\n  sourceDataArray.forEach((rowData, rowIndex) => {\n    rowData.forEach((cellValue, columnIndex) => {\n      const cellMeta = this.hot.getCellMeta(rowIndex, columnIndex);\n      const dateFormat = cellMeta.dateFormat;\n      if (isDate(cellValue, cellMeta.type)) {\n        valueChanged = true;\n        if (isDateValid(cellValue, dateFormat)) {\n          // Rewriting date in HOT format to HF format.\n          sourceDataArray[rowIndex][columnIndex] = getDateInHfFormat(cellValue, dateFormat);\n        } else if (this.isFormulaCellType(rowIndex, columnIndex) === false) {\n          // Escaping value from date parsing using \"'\" sign (HF feature).\n          sourceDataArray[rowIndex][columnIndex] = `'${cellValue}`;\n        }\n      }\n    });\n  });\n  if (valueChanged === true) {\n    _classPrivateFieldSet(this, _internalOperationPending, true);\n    this.engine.setSheetContent(this.sheetId, sourceDataArray);\n    _classPrivateFieldSet(this, _internalOperationPending, false);\n  }\n}\nfunction _onAfterLoadData2(sourceData, initialLoad) {\n  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n    return;\n  }\n  this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n  if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n    const sourceDataArray = this.hot.getSourceDataArray();\n    if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n      _classPrivateFieldSet(this, _internalOperationPending, true);\n      const dependentCells = this.engine.setSheetContent(this.sheetId, sourceDataArray);\n      this.indexSyncer.setupSyncEndpoint(this.engine, this.sheetId);\n      this.renderDependentSheets(dependentCells);\n      _classPrivateFieldSet(this, _internalOperationPending, false);\n    }\n  } else {\n    this.switchSheet(this.sheetName);\n  }\n}\nfunction _onModifyData2(physicalRow, visualColumn, valueHolder, ioMode) {\n  if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n    return;\n  }\n  const visualRow = this.hot.toVisualRow(physicalRow);\n  if (visualRow === null || visualColumn === null) {\n    return;\n  }\n\n  // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n  const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n  if (!isFormulaCellType) {\n    const cellType = this.getCellType(visualRow, visualColumn);\n    if (cellType !== 'ARRAY') {\n      if (isEscapedFormulaExpression(valueHolder.value)) {\n        valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n      }\n      return;\n    }\n  }\n  const address = {\n    row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n    sheet: this.sheetId\n  };\n  let cellValue = this.engine.getCellValue(address); // Date as an integer (Excel like date).\n  const cellMeta = this.hot.getCellMeta(visualRow, visualColumn);\n  if (cellMeta.type === 'date' && isNumeric(cellValue)) {\n    cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);\n  }\n\n  // If `cellValue` is an object it is expected to be an error\n  const value = typeof cellValue === 'object' && cellValue !== null ? cellValue.value : cellValue;\n  valueHolder.value = value;\n}\nfunction _onModifySourceData2(row, columnOrProp, valueHolder, ioMode) {\n  if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n    return;\n  }\n  const visualRow = this.hot.toVisualRow(row);\n  const visualColumn = this.hot.propToCol(columnOrProp);\n  if (visualRow === null || visualColumn === null) {\n    return;\n  }\n\n  // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n  const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n  if (!isFormulaCellType) {\n    const cellType = this.getCellType(visualRow, visualColumn);\n    if (cellType !== 'ARRAY') {\n      return;\n    }\n  }\n  const dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));\n\n  // Don't actually change the source data if HyperFormula is not\n  // initialized yet. This is done to allow the `afterLoadData` hook to\n  // load the existing source data with `Handsontable#getSourceDataArray`\n  // properly.\n  if (dimensions.width === 0 && dimensions.height === 0) {\n    return;\n  }\n  const address = {\n    row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n    sheet: this.sheetId\n  };\n  valueHolder.value = this.engine.getCellSerialized(address);\n}\nfunction _onAfterSetDataAtCell2(changes, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const outOfBoundsChanges = [];\n  const changedCells = [];\n  const dependentCells = this.engine.batch(() => {\n    changes.forEach(_ref4 => {\n      let [visualRow, prop,, newValue] = _ref4;\n      const visualColumn = this.hot.propToCol(prop);\n      const physicalRow = this.hot.toPhysicalRow(visualRow);\n      const physicalColumn = this.hot.toPhysicalColumn(visualColumn);\n      const address = {\n        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n        sheet: this.sheetId\n      };\n      if (physicalRow !== null && physicalColumn !== null) {\n        this.syncChangeWithEngine(visualRow, visualColumn, newValue);\n      } else {\n        outOfBoundsChanges.push([visualRow, visualColumn, newValue]);\n      }\n      changedCells.push({\n        address\n      });\n    });\n  });\n  if (outOfBoundsChanges.length) {\n    // Workaround for rows/columns being created two times (by HOT and the engine).\n    // (unfortunately, this requires an extra re-render)\n    this.hot.addHookOnce('afterChange', () => {\n      const outOfBoundsDependentCells = this.engine.batch(() => {\n        outOfBoundsChanges.forEach(_ref5 => {\n          let [row, column, newValue] = _ref5;\n          this.syncChangeWithEngine(row, column, newValue);\n        });\n      });\n      this.renderDependentSheets(outOfBoundsDependentCells, true);\n    });\n  }\n  this.renderDependentSheets(dependentCells);\n  this.validateDependentCells(dependentCells, changedCells);\n}\nfunction _onAfterSetSourceDataAtCell2(changes, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const dependentCells = [];\n  const changedCells = [];\n  changes.forEach(_ref6 => {\n    let [visualRow, prop,, newValue] = _ref6;\n    const visualColumn = this.hot.propToCol(prop);\n    if (!isNumeric(visualColumn)) {\n      return;\n    }\n    const address = {\n      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),\n      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),\n      sheet: this.sheetId\n    };\n    if (!this.engine.isItPossibleToSetCellContents(address)) {\n      warn(`Not possible to set source cell data at ${JSON.stringify(address)}`);\n      return;\n    }\n    changedCells.push({\n      address\n    });\n    dependentCells.push(...this.engine.setCellContents(address, newValue));\n  });\n  this.renderDependentSheets(dependentCells);\n  this.validateDependentCells(dependentCells, changedCells);\n}\nfunction _onBeforeCreateRow2(visualRow, amount) {\n  let hfRowIndex = this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow);\n  if (visualRow >= this.hot.countRows()) {\n    hfRowIndex = visualRow; // Row beyond the table boundaries.\n  }\n  if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [hfRowIndex, amount])) {\n    return false;\n  }\n}\nfunction _onBeforeCreateCol2(visualColumn, amount) {\n  let hfColumnIndex = this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn);\n  if (visualColumn >= this.hot.countCols()) {\n    hfColumnIndex = visualColumn; // Column beyond the table boundaries.\n  }\n  if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [hfColumnIndex, amount])) {\n    return false;\n  }\n}\nfunction _onBeforeRemoveRow2(row, amount, physicalRows) {\n  const hfRows = this.rowAxisSyncer.setRemovedHfIndexes(physicalRows);\n  const possible = hfRows.every(hfRow => {\n    return this.engine.isItPossibleToRemoveRows(this.sheetId, [hfRow, 1]);\n  });\n  return possible === false ? false : undefined;\n}\nfunction _onBeforeRemoveCol2(col, amount, physicalColumns) {\n  const hfColumns = this.columnAxisSyncer.setRemovedHfIndexes(physicalColumns);\n  const possible = hfColumns.every(hfColumn => {\n    return this.engine.isItPossibleToRemoveColumns(this.sheetId, [hfColumn, 1]);\n  });\n  return possible === false ? false : undefined;\n}\nfunction _onAfterCreateRow2(visualRow, amount, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const changes = this.engine.addRows(this.sheetId, [this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow), amount]);\n  this.renderDependentSheets(changes);\n}\nfunction _onAfterCreateCol2(visualColumn, amount, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const changes = this.engine.addColumns(this.sheetId, [this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn), amount]);\n  this.renderDependentSheets(changes);\n}\nfunction _onAfterRemoveRow2(row, amount, physicalRows, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const descendingHfRows = this.rowAxisSyncer.getRemovedHfIndexes().sort().reverse();\n  const changes = this.engine.batch(() => {\n    descendingHfRows.forEach(hfRow => {\n      this.engine.removeRows(this.sheetId, [hfRow, 1]);\n    });\n  });\n  this.renderDependentSheets(changes);\n}\nfunction _onAfterRemoveCol2(col, amount, physicalColumns, source) {\n  if (isBlockedSource(source)) {\n    return;\n  }\n  const descendingHfColumns = this.columnAxisSyncer.getRemovedHfIndexes().sort().reverse();\n  const changes = this.engine.batch(() => {\n    descendingHfColumns.forEach(hfColumn => {\n      this.engine.removeColumns(this.sheetId, [hfColumn, 1]);\n    });\n  });\n  this.renderDependentSheets(changes);\n}\nfunction _onAfterDetachChild2(parent, element, finalElementRowIndex) {\n  var _element$__children;\n  _classPrivateFieldSet(this, _internalOperationPending, true);\n  const rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n  _classPrivateFieldSet(this, _internalOperationPending, false);\n  rowsData.forEach((row, relativeRowIndex) => {\n    row.forEach((value, colIndex) => {\n      this.engine.setCellContents({\n        col: colIndex,\n        row: finalElementRowIndex + relativeRowIndex,\n        sheet: this.sheetId\n      }, [[value]]);\n    });\n  });\n}\nfunction _onEngineValuesUpdated2(changes) {\n  this.hot.runHooks('afterFormulasValuesUpdate', changes);\n}\nfunction _onEngineNamedExpressionsAdded2(namedExpressionName, changes) {\n  this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n}\nfunction _onEngineNamedExpressionsRemoved2(namedExpressionName, changes) {\n  this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n}\nfunction _onEngineSheetAdded2(addedSheetDisplayName) {\n  this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n}\nfunction _onEngineSheetRenamed2(oldDisplayName, newDisplayName) {\n  this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n}\nfunction _onEngineSheetRemoved2(removedSheetDisplayName, changes) {\n  this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n}"],"mappings":"AAAA,OAAO,sCAAsC;AAC7C,OAAO,kCAAkC;AACzC,OAAO,mCAAmC;AAC1C,SAASA,2BAA2B,CAACC,GAAG,EAAEC,UAAU,EAAE;EAAEC,0BAA0B,CAACF,GAAG,EAAEC,UAAU,CAAC;EAAEA,UAAU,CAACE,GAAG,CAACH,GAAG,CAAC;AAAE;AAC1H,SAASI,eAAe,CAACJ,GAAG,EAAEK,GAAG,EAAEC,KAAK,EAAE;EAAED,GAAG,GAAGE,cAAc,CAACF,GAAG,CAAC;EAAE,IAAIA,GAAG,IAAIL,GAAG,EAAE;IAAEQ,MAAM,CAACC,cAAc,CAACT,GAAG,EAAEK,GAAG,EAAE;MAAEC,KAAK,EAAEA,KAAK;MAAEI,UAAU,EAAE,IAAI;MAAEC,YAAY,EAAE,IAAI;MAAEC,QAAQ,EAAE;IAAK,CAAC,CAAC;EAAE,CAAC,MAAM;IAAEZ,GAAG,CAACK,GAAG,CAAC,GAAGC,KAAK;EAAE;EAAE,OAAON,GAAG;AAAE;AAC3O,SAASO,cAAc,CAACM,CAAC,EAAE;EAAE,IAAIC,CAAC,GAAGC,YAAY,CAACF,CAAC,EAAE,QAAQ,CAAC;EAAE,OAAO,QAAQ,IAAI,OAAOC,CAAC,GAAGA,CAAC,GAAGE,MAAM,CAACF,CAAC,CAAC;AAAE;AAC7G,SAASC,YAAY,CAACF,CAAC,EAAEI,CAAC,EAAE;EAAE,IAAI,QAAQ,IAAI,OAAOJ,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EAAE,IAAIK,CAAC,GAAGL,CAAC,CAACM,MAAM,CAACC,WAAW,CAAC;EAAE,IAAI,KAAK,CAAC,KAAKF,CAAC,EAAE;IAAE,IAAIJ,CAAC,GAAGI,CAAC,CAACG,IAAI,CAACR,CAAC,EAAEI,CAAC,IAAI,SAAS,CAAC;IAAE,IAAI,QAAQ,IAAI,OAAOH,CAAC,EAAE,OAAOA,CAAC;IAAE,MAAM,IAAIQ,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAAC,QAAQ,KAAKL,CAAC,GAAGD,MAAM,GAAGO,MAAM,EAAEV,CAAC,CAAC;AAAE;AACvT,SAASW,0BAA0B,CAACxB,GAAG,EAAEyB,UAAU,EAAEnB,KAAK,EAAE;EAAEJ,0BAA0B,CAACF,GAAG,EAAEyB,UAAU,CAAC;EAAEA,UAAU,CAACC,GAAG,CAAC1B,GAAG,EAAEM,KAAK,CAAC;AAAE;AACvI,SAASJ,0BAA0B,CAACF,GAAG,EAAE2B,iBAAiB,EAAE;EAAE,IAAIA,iBAAiB,CAACC,GAAG,CAAC5B,GAAG,CAAC,EAAE;IAAE,MAAM,IAAIsB,SAAS,CAAC,gEAAgE,CAAC;EAAE;AAAE;AACzL,SAASO,qBAAqB,CAACC,QAAQ,EAAEL,UAAU,EAAEnB,KAAK,EAAE;EAAE,IAAIyB,UAAU,GAAGC,4BAA4B,CAACF,QAAQ,EAAEL,UAAU,EAAE,KAAK,CAAC;EAAEQ,wBAAwB,CAACH,QAAQ,EAAEC,UAAU,EAAEzB,KAAK,CAAC;EAAE,OAAOA,KAAK;AAAE;AAC/M,SAAS2B,wBAAwB,CAACH,QAAQ,EAAEC,UAAU,EAAEzB,KAAK,EAAE;EAAE,IAAIyB,UAAU,CAACL,GAAG,EAAE;IAAEK,UAAU,CAACL,GAAG,CAACL,IAAI,CAACS,QAAQ,EAAExB,KAAK,CAAC;EAAE,CAAC,MAAM;IAAE,IAAI,CAACyB,UAAU,CAACnB,QAAQ,EAAE;MAAE,MAAM,IAAIU,SAAS,CAAC,0CAA0C,CAAC;IAAE;IAAES,UAAU,CAACzB,KAAK,GAAGA,KAAK;EAAE;AAAE;AACjQ,SAAS4B,qBAAqB,CAACJ,QAAQ,EAAEL,UAAU,EAAE;EAAE,IAAIM,UAAU,GAAGC,4BAA4B,CAACF,QAAQ,EAAEL,UAAU,EAAE,KAAK,CAAC;EAAE,OAAOU,wBAAwB,CAACL,QAAQ,EAAEC,UAAU,CAAC;AAAE;AAC1L,SAASC,4BAA4B,CAACF,QAAQ,EAAEL,UAAU,EAAEW,MAAM,EAAE;EAAE,IAAI,CAACX,UAAU,CAACG,GAAG,CAACE,QAAQ,CAAC,EAAE;IAAE,MAAM,IAAIR,SAAS,CAAC,eAAe,GAAGc,MAAM,GAAG,gCAAgC,CAAC;EAAE;EAAE,OAAOX,UAAU,CAACY,GAAG,CAACP,QAAQ,CAAC;AAAE;AAC5N,SAASK,wBAAwB,CAACL,QAAQ,EAAEC,UAAU,EAAE;EAAE,IAAIA,UAAU,CAACM,GAAG,EAAE;IAAE,OAAON,UAAU,CAACM,GAAG,CAAChB,IAAI,CAACS,QAAQ,CAAC;EAAE;EAAE,OAAOC,UAAU,CAACzB,KAAK;AAAE;AACjJ,SAASgC,sBAAsB,CAACR,QAAQ,EAAE7B,UAAU,EAAEsC,EAAE,EAAE;EAAE,IAAI,CAACtC,UAAU,CAAC2B,GAAG,CAACE,QAAQ,CAAC,EAAE;IAAE,MAAM,IAAIR,SAAS,CAAC,gDAAgD,CAAC;EAAE;EAAE,OAAOiB,EAAE;AAAE;AACjL,SAASC,UAAU,QAAQ,mBAAmB;AAC9C,OAAOC,cAAc,MAAM,gCAAgC;AAC3D,SAASC,KAAK,EAAEC,IAAI,QAAQ,2BAA2B;AACvD,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAASC,SAAS,EAAEC,WAAW,QAAQ,yBAAyB;AAChE,SAASC,WAAW,EAAEC,UAAU,EAAEC,gBAAgB,EAAEC,yBAAyB,QAAQ,uBAAuB;AAC5G,SAASC,0BAA0B,EAAEC,yBAAyB,EAAEC,MAAM,EAAEC,WAAW,EAAEC,iBAAiB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,SAAS,QAAQ,aAAa;AAChL,SAASC,8BAA8B,EAAEC,yBAAyB,QAAQ,uBAAuB;AACjG,SAASC,eAAe,QAAQ,wBAAwB;AACxD,SAASC,gBAAgB,QAAQ,0BAA0B;AAC3D,OAAOC,KAAK,MAAM,uBAAuB;AACzC,OAAOC,WAAW,MAAM,yBAAyB;AACjD,OAAO,MAAMC,UAAU,GAAG,UAAU;AACpC,OAAO,MAAMC,YAAY,GAAG,CAAC,SAAS,EAAE,YAAY,EAAE,UAAU,CAAC;AACjE,OAAO,MAAMC,eAAe,GAAG,GAAG;AAClCJ,KAAK,CAACK,YAAY,EAAE,CAACC,QAAQ,CAAC,2BAA2B,CAAC;AAC1DN,KAAK,CAACK,YAAY,EAAE,CAACC,QAAQ,CAAC,6BAA6B,CAAC;AAC5DN,KAAK,CAACK,YAAY,EAAE,CAACC,QAAQ,CAAC,iBAAiB,CAAC;AAChDN,KAAK,CAACK,YAAY,EAAE,CAACC,QAAQ,CAAC,mBAAmB,CAAC;AAClDN,KAAK,CAACK,YAAY,EAAE,CAACC,QAAQ,CAAC,mBAAmB,CAAC;AAClDN,KAAK,CAACK,YAAY,EAAE,CAACC,QAAQ,CAAC,2BAA2B,CAAC;;AAE1D;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAGC,MAAM,IAAIA,MAAM,KAAK,eAAe,IAAIA,MAAM,KAAK,eAAe,IAAIA,MAAM,KAAK,MAAM;;AAE/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,yBAAyB,GAAG,aAAa,IAAIC,OAAO,EAAE;AAC1D,IAAIC,+BAA+B,GAAG,aAAa,IAAID,OAAO,EAAE;AAChE,IAAIE,gBAAgB,GAAG,aAAa,IAAIF,OAAO,EAAE;AACjD,IAAIG,iBAAiB,GAAG,aAAa,IAAIC,OAAO,EAAE;AAClD,IAAIC,iBAAiB,GAAG,aAAa,IAAID,OAAO,EAAE;AAClD,IAAIE,iBAAiB,GAAG,aAAa,IAAIF,OAAO,EAAE;AAClD,IAAIG,qBAAqB,GAAG,aAAa,IAAIH,OAAO,EAAE;AACtD,IAAII,gBAAgB,GAAG,aAAa,IAAIJ,OAAO,EAAE;AACjD,IAAIK,aAAa,GAAG,aAAa,IAAIL,OAAO,EAAE;AAC9C,IAAIM,mBAAmB,GAAG,aAAa,IAAIN,OAAO,EAAE;AACpD,IAAIO,qBAAqB,GAAG,aAAa,IAAIP,OAAO,EAAE;AACtD,IAAIQ,2BAA2B,GAAG,aAAa,IAAIR,OAAO,EAAE;AAC5D,IAAIS,kBAAkB,GAAG,aAAa,IAAIT,OAAO,EAAE;AACnD,IAAIU,kBAAkB,GAAG,aAAa,IAAIV,OAAO,EAAE;AACnD,IAAIW,kBAAkB,GAAG,aAAa,IAAIX,OAAO,EAAE;AACnD,IAAIY,kBAAkB,GAAG,aAAa,IAAIZ,OAAO,EAAE;AACnD,IAAIa,iBAAiB,GAAG,aAAa,IAAIb,OAAO,EAAE;AAClD,IAAIc,iBAAiB,GAAG,aAAa,IAAId,OAAO,EAAE;AAClD,IAAIe,iBAAiB,GAAG,aAAa,IAAIf,OAAO,EAAE;AAClD,IAAIgB,iBAAiB,GAAG,aAAa,IAAIhB,OAAO,EAAE;AAClD,IAAIiB,mBAAmB,GAAG,aAAa,IAAIjB,OAAO,EAAE;AACpD,IAAIkB,sBAAsB,GAAG,aAAa,IAAIlB,OAAO,EAAE;AACvD,IAAImB,8BAA8B,GAAG,aAAa,IAAInB,OAAO,EAAE;AAC/D,IAAIoB,gCAAgC,GAAG,aAAa,IAAIpB,OAAO,EAAE;AACjE,IAAIqB,mBAAmB,GAAG,aAAa,IAAIrB,OAAO,EAAE;AACpD,IAAIsB,qBAAqB,GAAG,aAAa,IAAItB,OAAO,EAAE;AACtD,IAAIuB,qBAAqB,GAAG,aAAa,IAAIvB,OAAO,EAAE;AACtD,OAAO,MAAMwB,QAAQ,SAAS7D,UAAU,CAAC;EACvC8D,WAAW,GAAG;IACZ,IAAIC,KAAK;IACT,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnBD,KAAK,GAAG,IAAI;IACZ;AACJ;AACA;AACA;AACA;AACA;AACA;IACIxG,2BAA2B,CAAC,IAAI,EAAEqG,qBAAqB,CAAC;IACxD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIrG,2BAA2B,CAAC,IAAI,EAAEoG,qBAAqB,CAAC;IACxD;AACJ;AACA;AACA;AACA;AACA;IACIpG,2BAA2B,CAAC,IAAI,EAAEmG,mBAAmB,CAAC;IACtD;AACJ;AACA;AACA;AACA;AACA;AACA;IACInG,2BAA2B,CAAC,IAAI,EAAEkG,gCAAgC,CAAC;IACnE;AACJ;AACA;AACA;AACA;AACA;AACA;IACIlG,2BAA2B,CAAC,IAAI,EAAEiG,8BAA8B,CAAC;IACjE;AACJ;AACA;AACA;AACA;AACA;IACIjG,2BAA2B,CAAC,IAAI,EAAEgG,sBAAsB,CAAC;IACzD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIhG,2BAA2B,CAAC,IAAI,EAAE+F,mBAAmB,CAAC;IACtD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI/F,2BAA2B,CAAC,IAAI,EAAE8F,iBAAiB,CAAC;IACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI9F,2BAA2B,CAAC,IAAI,EAAE6F,iBAAiB,CAAC;IACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI7F,2BAA2B,CAAC,IAAI,EAAE4F,iBAAiB,CAAC;IACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI5F,2BAA2B,CAAC,IAAI,EAAE2F,iBAAiB,CAAC;IACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI3F,2BAA2B,CAAC,IAAI,EAAE0F,kBAAkB,CAAC;IACrD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI1F,2BAA2B,CAAC,IAAI,EAAEyF,kBAAkB,CAAC;IACrD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIzF,2BAA2B,CAAC,IAAI,EAAEwF,kBAAkB,CAAC;IACrD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIxF,2BAA2B,CAAC,IAAI,EAAEuF,kBAAkB,CAAC;IACrD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIvF,2BAA2B,CAAC,IAAI,EAAEsF,2BAA2B,CAAC;IAC9D;AACJ;AACA;AACA;AACA;AACA;AACA;IACItF,2BAA2B,CAAC,IAAI,EAAEqF,qBAAqB,CAAC;IACxD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIrF,2BAA2B,CAAC,IAAI,EAAEoF,mBAAmB,CAAC;IACtD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIpF,2BAA2B,CAAC,IAAI,EAAEmF,aAAa,CAAC;IAChD;AACJ;AACA;AACA;AACA;AACA;AACA;IACInF,2BAA2B,CAAC,IAAI,EAAEkF,gBAAgB,CAAC;IACnD;AACJ;AACA;IACIlF,2BAA2B,CAAC,IAAI,EAAEiF,qBAAqB,CAAC;IACxD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIjF,2BAA2B,CAAC,IAAI,EAAEgF,iBAAiB,CAAC;IACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIhF,2BAA2B,CAAC,IAAI,EAAE+E,iBAAiB,CAAC;IACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI/E,2BAA2B,CAAC,IAAI,EAAE6E,iBAAiB,CAAC;IACpD;AACJ;AACA;AACA;AACA;AACA;IACIpD,0BAA0B,CAAC,IAAI,EAAEgD,yBAAyB,EAAE;MAC1D5D,QAAQ,EAAE,IAAI;MACdN,KAAK,EAAE;IACT,CAAC,CAAC;IACF;AACJ;AACA;AACA;AACA;AACA;IACIkB,0BAA0B,CAAC,IAAI,EAAEkD,+BAA+B,EAAE;MAChE9D,QAAQ,EAAE,IAAI;MACdN,KAAK,EAAE;IACT,CAAC,CAAC;IACF;AACJ;AACA;AACA;AACA;IACIkB,0BAA0B,CAAC,IAAI,EAAEmD,gBAAgB,EAAE;MACjD/D,QAAQ,EAAE,IAAI;MACdN,KAAK,EAAE,CAAC,CAAC,eAAe,EAAE,YAAY;QACpC,KAAK,IAAImG,IAAI,GAAGD,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACH,IAAI,CAAC,EAAEI,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGJ,IAAI,EAAEI,IAAI,EAAE,EAAE;UACvFF,IAAI,CAACE,IAAI,CAAC,GAAGL,SAAS,CAACK,IAAI,CAAC;QAC9B;QACA,OAAOvE,sBAAsB,CAACiE,KAAK,EAAER,sBAAsB,EAAEe,uBAAuB,CAAC,CAACzF,IAAI,CAACkF,KAAK,EAAE,GAAGI,IAAI,CAAC;MAC5G,CAAC,CAAC,EAAE,CAAC,sBAAsB,EAAE,YAAY;QACvC,KAAK,IAAII,KAAK,GAAGP,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACG,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;UAC7FL,IAAI,CAACK,KAAK,CAAC,GAAGR,SAAS,CAACQ,KAAK,CAAC;QAChC;QACA,OAAO1E,sBAAsB,CAACiE,KAAK,EAAEP,8BAA8B,EAAEiB,+BAA+B,CAAC,CAAC5F,IAAI,CAACkF,KAAK,EAAE,GAAGI,IAAI,CAAC;MAC5H,CAAC,CAAC,EAAE,CAAC,wBAAwB,EAAE,YAAY;QACzC,KAAK,IAAIO,KAAK,GAAGV,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACM,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;UAC7FR,IAAI,CAACQ,KAAK,CAAC,GAAGX,SAAS,CAACW,KAAK,CAAC;QAChC;QACA,OAAO7E,sBAAsB,CAACiE,KAAK,EAAEN,gCAAgC,EAAEmB,iCAAiC,CAAC,CAAC/F,IAAI,CAACkF,KAAK,EAAE,GAAGI,IAAI,CAAC;MAChI,CAAC,CAAC,EAAE,CAAC,YAAY,EAAE,YAAY;QAC7B,KAAK,IAAIU,KAAK,GAAGb,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACS,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;UAC7FX,IAAI,CAACW,KAAK,CAAC,GAAGd,SAAS,CAACc,KAAK,CAAC;QAChC;QACA,OAAOhF,sBAAsB,CAACiE,KAAK,EAAEL,mBAAmB,EAAEqB,oBAAoB,CAAC,CAAClG,IAAI,CAACkF,KAAK,EAAE,GAAGI,IAAI,CAAC;MACtG,CAAC,CAAC,EAAE,CAAC,cAAc,EAAE,YAAY;QAC/B,KAAK,IAAIa,KAAK,GAAGhB,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACY,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;UAC7Fd,IAAI,CAACc,KAAK,CAAC,GAAGjB,SAAS,CAACiB,KAAK,CAAC;QAChC;QACA,OAAOnF,sBAAsB,CAACiE,KAAK,EAAEJ,qBAAqB,EAAEuB,sBAAsB,CAAC,CAACrG,IAAI,CAACkF,KAAK,EAAE,GAAGI,IAAI,CAAC;MAC1G,CAAC,CAAC,EAAE,CAAC,cAAc,EAAE,YAAY;QAC/B,KAAK,IAAIgB,KAAK,GAAGnB,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACe,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;UAC7FjB,IAAI,CAACiB,KAAK,CAAC,GAAGpB,SAAS,CAACoB,KAAK,CAAC;QAChC;QACA,OAAOtF,sBAAsB,CAACiE,KAAK,EAAEH,qBAAqB,EAAEyB,sBAAsB,CAAC,CAACxG,IAAI,CAACkF,KAAK,EAAE,GAAGI,IAAI,CAAC;MAC1G,CAAC,CAAC;IACJ,CAAC,CAAC;IACF;AACJ;AACA;AACA;AACA;AACA;AACA;IACIvG,eAAe,CAAC,IAAI,EAAE,gBAAgB,EAAEqC,cAAc,CAAC,UAAU,CAAC,CAAC;IACnE;AACJ;AACA;AACA;AACA;IACIrC,eAAe,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC;IACrC;AACJ;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,WAAW,EAAE,IAAI,CAAC;IACxC;AACJ;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,aAAa,EAAE,IAAI,CAAC;IAC1C;AACJ;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,eAAe,EAAE,IAAI,CAAC;IAC5C;AACJ;AACA;AACA;AACA;IACIA,eAAe,CAAC,IAAI,EAAE,kBAAkB,EAAE,IAAI,CAAC;EACjD;EACA,WAAW6D,UAAU,GAAG;IACtB,OAAOA,UAAU;EACnB;EACA,WAAWE,eAAe,GAAG;IAC3B,OAAOA,eAAe;EACxB;EACA,WAAWD,YAAY,GAAG;IACxB,OAAO,CAACD,UAAU,EAAE,GAAGC,YAAY,CAAC;EACtC;EACA;AACF;AACA;AACA;AACA;EACE,IAAI4D,OAAO,GAAG;IACZ,OAAO,IAAI,CAACC,SAAS,KAAK,IAAI,GAAG,IAAI,GAAG,IAAI,CAACC,MAAM,CAACC,UAAU,CAAC,IAAI,CAACF,SAAS,CAAC;EAChF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEG,SAAS,GAAG;IACV;IACA,OAAO,IAAI,CAACC,GAAG,CAACC,WAAW,EAAE,CAACnE,UAAU,CAAC,GAAG,IAAI,GAAG,KAAK;EAC1D;;EAEA;AACF;AACA;EACEoE,YAAY,GAAG;IACb,IAAIC,YAAY;MACdC,MAAM,GAAG,IAAI;IACf,IAAI,IAAI,CAACC,OAAO,EAAE;MAChB;IACF;IACA,IAAI,CAACR,MAAM,GAAG,CAACM,YAAY,GAAGvF,WAAW,CAAC,IAAI,CAACoF,GAAG,CAAC,MAAM,IAAI,IAAIG,YAAY,KAAK,KAAK,CAAC,GAAGA,YAAY,GAAG,IAAI,CAACN,MAAM;IACrH,IAAI,CAAC,IAAI,CAACA,MAAM,EAAE;MAChBrF,IAAI,CAAC,2FAA2F,GAAG,sCAAsC,CAAC;MAC1I;IACF;;IAEA;IACA,IAAI,IAAI,CAACoF,SAAS,KAAK,IAAI,IAAI,CAAC,IAAI,CAACC,MAAM,CAACS,cAAc,CAAC,IAAI,CAACV,SAAS,CAAC,EAAE;MAC1E,MAAMW,YAAY,GAAG,IAAI,CAACC,QAAQ,CAAC,IAAI,CAACZ,SAAS,EAAE,IAAI,CAACI,GAAG,CAACS,kBAAkB,EAAE,CAAC;MACjF,IAAIF,YAAY,KAAK,KAAK,EAAE;QAC1B,IAAI,CAACX,SAAS,GAAGW,YAAY;MAC/B;IACF;IACA,IAAI,CAACG,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIC,KAAK,GAAGtC,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACkC,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7FpC,IAAI,CAACoC,KAAK,CAAC,GAAGvC,SAAS,CAACuC,KAAK,CAAC;MAChC;MACA,OAAOzG,sBAAsB,CAACiG,MAAM,EAAExD,iBAAiB,EAAEiE,kBAAkB,CAAC,CAAC3H,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACpG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,eAAe,EAAE,YAAY;MACxC,KAAK,IAAII,KAAK,GAAGzC,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACqC,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7FvC,IAAI,CAACuC,KAAK,CAAC,GAAG1C,SAAS,CAAC0C,KAAK,CAAC;MAChC;MACA,OAAO5G,sBAAsB,CAACiG,MAAM,EAAEtD,gBAAgB,EAAEkE,iBAAiB,CAAC,CAAC9H,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAClG,CAAC,CAAC;;IAEF;IACA,IAAI,CAACkC,OAAO,CAAC,kBAAkB,EAAE,YAAY;MAC3C,KAAK,IAAIO,KAAK,GAAG5C,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACwC,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;QAC7F1C,IAAI,CAAC0C,KAAK,CAAC,GAAG7C,SAAS,CAAC6C,KAAK,CAAC;MAChC;MACA,OAAO/G,sBAAsB,CAACiG,MAAM,EAAExD,iBAAiB,EAAEiE,kBAAkB,CAAC,CAAC3H,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACpG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,iBAAiB,EAAE,YAAY;MAC1C,KAAK,IAAIS,MAAM,GAAG9C,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAAC0C,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG5C,IAAI,CAAC4C,MAAM,CAAC,GAAG/C,SAAS,CAAC+C,MAAM,CAAC;MAClC;MACA,OAAOjH,sBAAsB,CAACiG,MAAM,EAAEtD,gBAAgB,EAAEkE,iBAAiB,CAAC,CAAC9H,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAClG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,YAAY,EAAE,YAAY;MACrC,KAAK,IAAIW,MAAM,GAAGhD,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAAC4C,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG9C,IAAI,CAAC8C,MAAM,CAAC,GAAGjD,SAAS,CAACiD,MAAM,CAAC;MAClC;MACA,OAAOnH,sBAAsB,CAACiG,MAAM,EAAErD,aAAa,EAAEwE,cAAc,CAAC,CAACrI,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5F,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,kBAAkB,EAAE,YAAY;MAC3C,KAAK,IAAIc,MAAM,GAAGnD,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAAC+C,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGjD,IAAI,CAACiD,MAAM,CAAC,GAAGpD,SAAS,CAACoD,MAAM,CAAC;MAClC;MACA,OAAOtH,sBAAsB,CAACiG,MAAM,EAAEpD,mBAAmB,EAAE0E,oBAAoB,CAAC,CAACxI,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACxG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIiB,MAAM,GAAGtD,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACkD,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGpD,IAAI,CAACoD,MAAM,CAAC,GAAGvD,SAAS,CAACuD,MAAM,CAAC;MAClC;MACA,OAAOzH,sBAAsB,CAACiG,MAAM,EAAE3D,iBAAiB,EAAEoF,kBAAkB,CAAC,CAAC3I,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACpG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,0BAA0B,EAAE,YAAY;MACnD,KAAK,IAAIoB,MAAM,GAAGzD,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACqD,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGvD,IAAI,CAACuD,MAAM,CAAC,GAAG1D,SAAS,CAAC0D,MAAM,CAAC;MAClC;MACA,OAAO5H,sBAAsB,CAACiG,MAAM,EAAElD,2BAA2B,EAAE8E,4BAA4B,CAAC,CAAC9I,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACxH,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,oBAAoB,EAAE,YAAY;MAC7C,KAAK,IAAIuB,MAAM,GAAG5D,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACwD,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG1D,IAAI,CAAC0D,MAAM,CAAC,GAAG7D,SAAS,CAAC6D,MAAM,CAAC;MAClC;MACA,OAAO/H,sBAAsB,CAACiG,MAAM,EAAEnD,qBAAqB,EAAEkF,sBAAsB,CAAC,CAACjJ,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5G,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,uBAAuB,EAAE,YAAY;MAChD,KAAK,IAAI0B,MAAM,GAAG/D,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAAC2D,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG7D,IAAI,CAAC6D,MAAM,CAAC,GAAGhE,SAAS,CAACgE,MAAM,CAAC;MAClC;MACA,OAAOlI,sBAAsB,CAACiG,MAAM,EAAEnD,qBAAqB,EAAEkF,sBAAsB,CAAC,CAACjJ,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5G,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,iBAAiB,EAAE,YAAY;MAC1C,KAAK,IAAI4B,MAAM,GAAGjE,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAAC6D,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG/D,IAAI,CAAC+D,MAAM,CAAC,GAAGlE,SAAS,CAACkE,MAAM,CAAC;MAClC;MACA,OAAOpI,sBAAsB,CAACiG,MAAM,EAAEjD,kBAAkB,EAAEqF,mBAAmB,CAAC,CAACtJ,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACtG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,iBAAiB,EAAE,YAAY;MAC1C,KAAK,IAAI+B,MAAM,GAAGpE,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACgE,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGlE,IAAI,CAACkE,MAAM,CAAC,GAAGrE,SAAS,CAACqE,MAAM,CAAC;MAClC;MACA,OAAOvI,sBAAsB,CAACiG,MAAM,EAAEhD,kBAAkB,EAAEuF,mBAAmB,CAAC,CAACzJ,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACtG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIkC,MAAM,GAAGvE,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACmE,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGrE,IAAI,CAACqE,MAAM,CAAC,GAAGxE,SAAS,CAACwE,MAAM,CAAC;MAClC;MACA,OAAO1I,sBAAsB,CAACiG,MAAM,EAAE7C,iBAAiB,EAAEuF,kBAAkB,CAAC,CAAC5J,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACpG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIqC,MAAM,GAAG1E,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACsE,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGxE,IAAI,CAACwE,MAAM,CAAC,GAAG3E,SAAS,CAAC2E,MAAM,CAAC;MAClC;MACA,OAAO7I,sBAAsB,CAACiG,MAAM,EAAE5C,iBAAiB,EAAEyF,kBAAkB,CAAC,CAAC/J,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACpG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,iBAAiB,EAAE,YAAY;MAC1C,KAAK,IAAIwC,MAAM,GAAG7E,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACyE,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG3E,IAAI,CAAC2E,MAAM,CAAC,GAAG9E,SAAS,CAAC8E,MAAM,CAAC;MAClC;MACA,OAAOhJ,sBAAsB,CAACiG,MAAM,EAAE/C,kBAAkB,EAAE+F,mBAAmB,CAAC,CAAClK,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACtG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,iBAAiB,EAAE,YAAY;MAC1C,KAAK,IAAI2C,MAAM,GAAGhF,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAAC4E,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG9E,IAAI,CAAC8E,MAAM,CAAC,GAAGjF,SAAS,CAACiF,MAAM,CAAC;MAClC;MACA,OAAOnJ,sBAAsB,CAACiG,MAAM,EAAE9C,kBAAkB,EAAEiG,mBAAmB,CAAC,CAACrK,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACtG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAI8C,MAAM,GAAGnF,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAAC+E,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGjF,IAAI,CAACiF,MAAM,CAAC,GAAGpF,SAAS,CAACoF,MAAM,CAAC;MAClC;MACA,OAAOtJ,sBAAsB,CAACiG,MAAM,EAAE3C,iBAAiB,EAAEiG,kBAAkB,CAAC,CAACxK,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACpG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIiD,MAAM,GAAGtF,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACkF,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGpF,IAAI,CAACoF,MAAM,CAAC,GAAGvF,SAAS,CAACuF,MAAM,CAAC;MAClC;MACA,OAAOzJ,sBAAsB,CAACiG,MAAM,EAAE1C,iBAAiB,EAAEmG,kBAAkB,CAAC,CAAC3K,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACpG,CAAC,CAAC;IACF,IAAI,CAACsF,WAAW,GAAG,IAAIjI,WAAW,CAAC,IAAI,CAACmE,GAAG,CAAC+D,cAAc,EAAE,IAAI,CAAC/D,GAAG,CAACgE,iBAAiB,EAAEC,eAAe,IAAI;MACzG,IAAI,CAACjE,GAAG,CAACkE,WAAW,CAAC,MAAM,EAAE,MAAM;QACjC;QACA;QACAD,eAAe,EAAE;MACnB,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,IAAI,CAACE,aAAa,GAAG,IAAI,CAACL,WAAW,CAACM,UAAU,CAAC,KAAK,CAAC;IACvD,IAAI,CAACC,gBAAgB,GAAG,IAAI,CAACP,WAAW,CAACM,UAAU,CAAC,QAAQ,CAAC;IAC7D,IAAI,CAACpE,GAAG,CAACU,OAAO,CAAC,wBAAwB,EAAE,IAAI,CAACyD,aAAa,CAACG,0BAA0B,EAAE,CAAC;IAC3F,IAAI,CAACtE,GAAG,CAACU,OAAO,CAAC,2BAA2B,EAAE,IAAI,CAAC2D,gBAAgB,CAACC,0BAA0B,EAAE,CAAC;IACjG,IAAI,CAACtE,GAAG,CAACU,OAAO,CAAC,eAAe,EAAE,CAAC6D,SAAS,EAAEC,UAAU,EAAEC,CAAC,EAAEC,YAAY,KAAK;MAC5E,IAAI,CAACP,aAAa,CAACQ,qBAAqB,CAACJ,SAAS,EAAEC,UAAU,EAAEE,YAAY,CAAC;IAC/E,CAAC,CAAC;IACF,IAAI,CAAC1E,GAAG,CAACU,OAAO,CAAC,kBAAkB,EAAE,CAACkE,YAAY,EAAEJ,UAAU,EAAEC,CAAC,EAAEC,YAAY,KAAK;MAClF,IAAI,CAACL,gBAAgB,CAACM,qBAAqB,CAACC,YAAY,EAAEJ,UAAU,EAAEE,YAAY,CAAC;IACrF,CAAC,CAAC;IACF,IAAI,CAAC1E,GAAG,CAACU,OAAO,CAAC,cAAc,EAAE,CAAC6D,SAAS,EAAEC,UAAU,EAAEK,SAAS,EAAEH,YAAY,EAAEI,YAAY,KAAK;MACjG,IAAI,CAACX,aAAa,CAACY,qBAAqB,CAACL,YAAY,EAAEI,YAAY,CAAC;IACtE,CAAC,CAAC;IACF,IAAI,CAAC9E,GAAG,CAACU,OAAO,CAAC,iBAAiB,EAAE,CAACkE,YAAY,EAAEJ,UAAU,EAAEK,SAAS,EAAEH,YAAY,EAAEI,YAAY,KAAK;MACvG,IAAI,CAACT,gBAAgB,CAACU,qBAAqB,CAACL,YAAY,EAAEI,YAAY,CAAC;IACzE,CAAC,CAAC;IACF,IAAI,CAAC9E,GAAG,CAACU,OAAO,CAAC,oBAAoB,EAAE,CAACsE,MAAM,EAAEC,eAAe,KAAK;MAClE,IAAI,CAACZ,gBAAgB,CAACM,qBAAqB,CAAC,CAACK,MAAM,CAAC,EAAE,IAAI,CAAChF,GAAG,CAACC,WAAW,EAAE,CAACiF,iBAAiB,EAAED,eAAe,CAAC;IAClH,CAAC,CAAC;IACF,IAAI,CAACjF,GAAG,CAACU,OAAO,CAAC,mBAAmB,EAAE,CAAC+D,CAAC,EAAEQ,eAAe,KAAK;MAC5D,IAAI,CAACZ,gBAAgB,CAACU,qBAAqB,CAACE,eAAe,EAAEA,eAAe,CAAC;IAC/E,CAAC,CAAC;IACF,IAAI,CAACjF,GAAG,CAACU,OAAO,CAAC,sBAAsB,EAAE,CAACsE,MAAM,EAAEG,iBAAiB,KAAK;MACtE,IAAI,CAACd,gBAAgB,CAACM,qBAAqB,CAAC,CAACK,MAAM,CAAC,EAAE,IAAI,CAAChF,GAAG,CAACC,WAAW,EAAE,CAACiF,iBAAiB,GAAG,CAAC,EAAEC,iBAAiB,CAAC;IACxH,CAAC,CAAC;IACF,IAAI,CAACnF,GAAG,CAACU,OAAO,CAAC,qBAAqB,EAAE,CAAC+D,CAAC,EAAEU,iBAAiB,KAAK;MAChE,IAAI,CAACd,gBAAgB,CAACU,qBAAqB,CAACI,iBAAiB,EAAEA,iBAAiB,CAAC;IACnF,CAAC,CAAC;;IAEF;IACA;IACA;IACA,IAAI,CAACzE,OAAO,CAAC,oBAAoB,EAAE,YAAY;MAC7C,KAAK,IAAI0E,MAAM,GAAG/G,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAAC2G,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnG7G,IAAI,CAAC6G,MAAM,CAAC,GAAGhH,SAAS,CAACgH,MAAM,CAAC;MAClC;MACA,OAAOlL,sBAAsB,CAACiG,MAAM,EAAEvD,qBAAqB,EAAEyI,sBAAsB,CAAC,CAACpM,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IAC5G,CAAC,CAAC;;IAEF;IACA,IAAI,CAACkC,OAAO,CAAC,YAAY,EAAE,MAAM;MAC/B,IAAI,CAACoD,WAAW,CAACyB,cAAc,CAAC,IAAI,CAAC;MACrC,IAAI,CAAC1F,MAAM,CAAC2F,IAAI,EAAE;IACpB,CAAC,CAAC;;IAEF;IACA,IAAI,CAAC9E,OAAO,CAAC,YAAY,EAAE,MAAM;MAC/B,IAAI,CAACoD,WAAW,CAAC2B,cAAc,CAAC,IAAI,CAAC;MACrC,IAAI,CAAC5F,MAAM,CAAC6F,IAAI,EAAE;IACpB,CAAC,CAAC;IACF,IAAI,CAAChF,OAAO,CAAC,WAAW,EAAE,MAAM;MAC9B,IAAI,CAACoD,WAAW,CAACyB,cAAc,CAAC,KAAK,CAAC;IACxC,CAAC,CAAC;IACF,IAAI,CAAC7E,OAAO,CAAC,WAAW,EAAE,MAAM;MAC9B,IAAI,CAACoD,WAAW,CAAC2B,cAAc,CAAC,KAAK,CAAC;IACxC,CAAC,CAAC;IACF,IAAI,CAAC/E,OAAO,CAAC,kBAAkB,EAAE,YAAY;MAC3C,KAAK,IAAIiF,MAAM,GAAGtH,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACkH,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGpH,IAAI,CAACoH,MAAM,CAAC,GAAGvH,SAAS,CAACuH,MAAM,CAAC;MAClC;MACA,OAAOzL,sBAAsB,CAACiG,MAAM,EAAEzC,mBAAmB,EAAEkI,oBAAoB,CAAC,CAAC3M,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACxG,CAAC,CAAC;IACF,IAAI,CAACkC,OAAO,CAAC,gBAAgB,EAAE,YAAY;MACzC,KAAK,IAAIoF,MAAM,GAAGzH,SAAS,CAACE,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACqH,MAAM,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,EAAEC,MAAM,EAAE,EAAE;QACnGvH,IAAI,CAACuH,MAAM,CAAC,GAAG1H,SAAS,CAAC0H,MAAM,CAAC;MAClC;MACA,OAAO5L,sBAAsB,CAACiG,MAAM,EAAEzD,iBAAiB,EAAEqJ,kBAAkB,CAAC,CAAC9M,IAAI,CAACkH,MAAM,EAAE,GAAG5B,IAAI,CAAC;IACpG,CAAC,CAAC;IACFzE,qBAAqB,CAAC,IAAI,EAAEyC,gBAAgB,CAAC,CAACyJ,OAAO,CAACC,IAAI,IAAI;MAC5D,IAAI,CAACC,SAAS,EAAEC,QAAQ,CAAC,GAAGF,IAAI;MAChC,OAAO,IAAI,CAACrG,MAAM,CAACwG,EAAE,CAACF,SAAS,EAAEC,QAAQ,CAAC;IAC5C,CAAC,CAAC;IACF,KAAK,CAAClG,YAAY,EAAE;EACtB;;EAEA;AACF;AACA;EACEoG,aAAa,GAAG;IACdvM,qBAAqB,CAAC,IAAI,EAAEyC,gBAAgB,CAAC,CAACyJ,OAAO,CAACM,KAAK,IAAI;MAC7D,IAAI,CAACJ,SAAS,EAAEC,QAAQ,CAAC,GAAGG,KAAK;MACjC,OAAO,IAAI,CAAC1G,MAAM,CAAC2G,GAAG,CAACL,SAAS,EAAEC,QAAQ,CAAC;IAC7C,CAAC,CAAC;IACFtL,gBAAgB,CAAC,IAAI,CAAC+E,MAAM,EAAE,IAAI,CAACG,GAAG,CAAC;IACvC,IAAI,CAACH,MAAM,GAAG,IAAI;IAClB,KAAK,CAACyG,aAAa,EAAE;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEG,YAAY,CAACC,WAAW,EAAE;IACxB,MAAMC,iBAAiB,GAAGnL,8BAA8B,CAAC,IAAI,CAACwE,GAAG,CAACC,WAAW,EAAE,CAAC;IAChF,IAAIxE,yBAAyB,CAAC,IAAI,CAACoE,MAAM,CAAC+G,SAAS,EAAE,EAAED,iBAAiB,CAAC,EAAE;MACzE,IAAI,CAAC9G,MAAM,CAACgH,YAAY,CAACF,iBAAiB,CAAC;IAC7C;IACA,MAAMG,cAAc,GAAG,IAAI,CAAC9G,GAAG,CAACC,WAAW,EAAE,CAACnE,UAAU,CAAC;IACzD,IAAIpB,SAAS,CAACoM,cAAc,CAAC,IAAIpM,SAAS,CAACoM,cAAc,CAAClH,SAAS,CAAC,IAAIkH,cAAc,CAAClH,SAAS,KAAK,IAAI,CAACA,SAAS,EAAE;MACnH,IAAI,CAACmH,WAAW,CAACD,cAAc,CAAClH,SAAS,CAAC;IAC5C;;IAEA;IACA;IACA,IAAI,CAAC8G,WAAW,CAACM,IAAI,IAAI,IAAI,CAACpH,SAAS,KAAK,IAAI,EAAE;MAChD,MAAMA,SAAS,GAAG,IAAI,CAACI,GAAG,CAACC,WAAW,EAAE,CAACnE,UAAU,CAAC,CAAC8D,SAAS;MAC9D,IAAIA,SAAS,IAAI,IAAI,CAACC,MAAM,CAACS,cAAc,CAACV,SAAS,CAAC,EAAE;QACtD,IAAI,CAACmH,WAAW,CAAC,IAAI,CAACnH,SAAS,CAAC;MAClC,CAAC,MAAM;QACL,IAAI,CAACA,SAAS,GAAG,IAAI,CAACY,QAAQ,CAACZ,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAGqH,SAAS,EAAE,IAAI,CAACjH,GAAG,CAACS,kBAAkB,EAAE,CAAC;MACnI;IACF;IACA,KAAK,CAACgG,YAAY,CAACC,WAAW,CAAC;EACjC;;EAEA;AACF;AACA;EACEQ,OAAO,GAAG;IACRnN,qBAAqB,CAAC,IAAI,EAAEyC,gBAAgB,CAAC,CAACyJ,OAAO,CAACkB,KAAK,IAAI;MAC7D,IAAIC,YAAY;MAChB,IAAI,CAACjB,SAAS,EAAEC,QAAQ,CAAC,GAAGe,KAAK;MACjC,OAAO,CAACC,YAAY,GAAG,IAAI,CAACvH,MAAM,MAAM,IAAI,IAAIuH,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACZ,GAAG,CAACL,SAAS,EAAEC,QAAQ,CAAC;IAC1H,CAAC,CAAC;IACF1M,qBAAqB,CAAC,IAAI,EAAE8C,gBAAgB,EAAE,IAAI,CAAC;IACnD1B,gBAAgB,CAAC,IAAI,CAAC+E,MAAM,EAAE,IAAI,CAACG,GAAG,CAAC;IACvC,IAAI,CAACH,MAAM,GAAG,IAAI;IAClB,KAAK,CAACqH,OAAO,EAAE;EACjB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE1G,QAAQ,CAACZ,SAAS,EAAEyH,SAAS,EAAE;IAC7B,IAAI3M,SAAS,CAAC2M,SAAS,CAAC,IAAI,CAAC3L,eAAe,CAAC2L,SAAS,CAAC,EAAE;MACvD7M,IAAI,CAAC,iDAAiD,CAAC;MACvD,OAAO,KAAK;IACd;IACA,IAAIoF,SAAS,KAAKqH,SAAS,IAAIrH,SAAS,KAAK,IAAI,IAAI,IAAI,CAACC,MAAM,CAACS,cAAc,CAACV,SAAS,CAAC,EAAE;MAC1FpF,IAAI,CAAC,8CAA8C,CAAC;MACpD,OAAO,KAAK;IACd;IACA,IAAI;MACF,MAAM8M,eAAe,GAAG,IAAI,CAACzH,MAAM,CAACW,QAAQ,CAACZ,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAGqH,SAAS,CAAC;MAChH,IAAII,SAAS,EAAE;QACb,IAAI,CAACxH,MAAM,CAAC0H,eAAe,CAAC,IAAI,CAAC1H,MAAM,CAACC,UAAU,CAACwH,eAAe,CAAC,EAAED,SAAS,CAAC;MACjF;MACA,OAAOC,eAAe;IACxB,CAAC,CAAC,OAAOvO,CAAC,EAAE;MACVyB,IAAI,CAACzB,CAAC,CAACyO,OAAO,CAAC;MACf,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACET,WAAW,CAACnH,SAAS,EAAE;IACrB,IAAI,CAAC,IAAI,CAACC,MAAM,CAACS,cAAc,CAACV,SAAS,CAAC,EAAE;MAC1CrF,KAAK,CAAE,qBAAoBqF,SAAU,oCAAmC,CAAC;MACzE;IACF;IACA,IAAI,CAACA,SAAS,GAAGA,SAAS;IAC1B,MAAM6H,UAAU,GAAG,IAAI,CAAC5H,MAAM,CAAC6H,kBAAkB,CAAC,IAAI,CAAC/H,OAAO,CAAC;IAC/D,IAAI8H,UAAU,CAAClJ,MAAM,GAAG,CAAC,EAAE;MACzB,IAAI,CAACyB,GAAG,CAAC2H,QAAQ,CAACF,UAAU,EAAG,GAAE9L,gBAAgB,CAACG,UAAU,CAAE,cAAa,CAAC;IAC9E;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE8L,WAAW,CAACC,GAAG,EAAE7C,MAAM,EAAE;IACvB,IAAI8C,KAAK,GAAGzJ,SAAS,CAACE,MAAM,GAAG,CAAC,IAAIF,SAAS,CAAC,CAAC,CAAC,KAAK4I,SAAS,GAAG5I,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAACsB,OAAO;IAC5F,MAAMoI,WAAW,GAAG,IAAI,CAAC/H,GAAG,CAACgI,aAAa,CAACH,GAAG,CAAC;IAC/C,MAAMI,cAAc,GAAG,IAAI,CAACjI,GAAG,CAACkI,gBAAgB,CAAClD,MAAM,CAAC;IACxD,IAAI+C,WAAW,KAAK,IAAI,IAAIE,cAAc,KAAK,IAAI,EAAE;MACnD,OAAO,IAAI,CAACpI,MAAM,CAAC+H,WAAW,CAAC;QAC7BE,KAAK;QACLD,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACN,GAAG,CAAC;QACtDO,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACnD,MAAM;MAC7D,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACA,OAAO,OAAO;IAChB;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEqD,iBAAiB,CAACR,GAAG,EAAE7C,MAAM,EAAE;IAC7B,IAAI8C,KAAK,GAAGzJ,SAAS,CAACE,MAAM,GAAG,CAAC,IAAIF,SAAS,CAAC,CAAC,CAAC,KAAK4I,SAAS,GAAG5I,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAACsB,OAAO;IAC5F,OAAO,IAAI,CAACE,MAAM,CAACyI,mBAAmB,CAAC;MACrCR,KAAK;MACLD,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACN,GAAG,CAAC;MACtDO,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACnD,MAAM;IAC7D,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEuD,qBAAqB,CAACC,cAAc,EAAE;IACpC,IAAIC,UAAU,GAAGpK,SAAS,CAACE,MAAM,GAAG,CAAC,IAAIF,SAAS,CAAC,CAAC,CAAC,KAAK4I,SAAS,GAAG5I,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;IAC1F,MAAMqK,gBAAgB,GAAG,IAAIC,GAAG,EAAE;IAClCH,cAAc,CAACvC,OAAO,CAAC2C,MAAM,IAAI;MAC/B,IAAIC,eAAe;MACnB;MACA,MAAMlJ,OAAO,GAAGiJ,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,IAAI,CAACC,eAAe,GAAGD,MAAM,CAACE,OAAO,MAAM,IAAI,IAAID,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,eAAe,CAACf,KAAK;MAClK,IAAInI,OAAO,KAAKsH,SAAS,EAAE;QACzB,IAAI,CAACyB,gBAAgB,CAACjP,GAAG,CAACkG,OAAO,CAAC,EAAE;UAClC+I,gBAAgB,CAAC1Q,GAAG,CAAC2H,OAAO,CAAC;QAC/B;MACF;IACF,CAAC,CAAC;IACF5E,yBAAyB,CAAC,IAAI,CAAC8E,MAAM,CAAC,CAACoG,OAAO,CAAC,CAAC8C,UAAU,EAAEpJ,OAAO,KAAK;MACtE,IAAI,CAAC8I,UAAU,IAAI9I,OAAO,KAAK,IAAI,CAACA,OAAO,KAAK+I,gBAAgB,CAACjP,GAAG,CAACkG,OAAO,CAAC,EAAE;QAC7E,IAAIqJ,gBAAgB;QACpBD,UAAU,CAACE,MAAM,EAAE;QACnB,CAACD,gBAAgB,GAAGD,UAAU,CAACG,IAAI,MAAM,IAAI,IAAIF,gBAAgB,KAAK,KAAK,CAAC,IAAIA,gBAAgB,CAACG,kBAAkB,EAAE;MACvH;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,sBAAsB,CAACZ,cAAc,EAAE;IACrC,IAAIa,YAAY,GAAGhL,SAAS,CAACE,MAAM,GAAG,CAAC,IAAIF,SAAS,CAAC,CAAC,CAAC,KAAK4I,SAAS,GAAG5I,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;IACzF,MAAMiL,gBAAgB,GAAGV,MAAM,IAAI;MACjC,IAAIW,gBAAgB;MACpB,MAAM;QACJ1B,GAAG;QACHO,GAAG;QACHN;MACF,CAAC,GAAG,CAACyB,gBAAgB,GAAGX,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACE,OAAO,MAAM,IAAI,IAAIS,gBAAgB,KAAK,KAAK,CAAC,GAAGA,gBAAgB,GAAG,CAAC,CAAC;MACvJ,OAAO7O,SAAS,CAACoN,KAAK,CAAC,GAAI,GAAEA,KAAM,IAAGD,GAAI,IAAGO,GAAI,EAAC,GAAG,EAAE;IACzD,CAAC;IACD,MAAMoB,eAAe,GAAG,IAAIb,GAAG,CAACU,YAAY,CAACI,GAAG,CAACb,MAAM,IAAIU,gBAAgB,CAACV,MAAM,CAAC,CAAC,CAAC;IACrFJ,cAAc,CAACvC,OAAO,CAAC2C,MAAM,IAAI;MAC/B,IAAIc,gBAAgB,EAAEC,gBAAgB;MACtC,MAAM;QACJ9B,GAAG;QACHO;MACF,CAAC,GAAG,CAACsB,gBAAgB,GAAGd,MAAM,CAACE,OAAO,MAAM,IAAI,IAAIY,gBAAgB,KAAK,KAAK,CAAC,GAAGA,gBAAgB,GAAG,CAAC,CAAC;;MAEvG;MACA,IAAIhP,SAAS,CAACmN,GAAG,CAAC,KAAK,KAAK,IAAInN,SAAS,CAAC0N,GAAG,CAAC,KAAK,KAAK,IAAIP,GAAG,IAAI,IAAI,CAAC7H,GAAG,CAAC4J,SAAS,EAAE,IAAIxB,GAAG,IAAI,IAAI,CAACpI,GAAG,CAAC6J,SAAS,EAAE,EAAE;QACtH;MACF;;MAEA;MACA,MAAMlK,OAAO,GAAGiJ,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,IAAI,CAACe,gBAAgB,GAAGf,MAAM,CAACE,OAAO,MAAM,IAAI,IAAIa,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAAC7B,KAAK;MACrK,MAAMgC,SAAS,GAAGR,gBAAgB,CAACV,MAAM,CAAC;;MAE1C;MACA;MACA,IAAIjJ,OAAO,KAAKsH,SAAS,IAAI,CAACuC,eAAe,CAAC/P,GAAG,CAACqQ,SAAS,CAAC,EAAE;QAC5D,MAAMC,QAAQ,GAAGhP,yBAAyB,CAAC,IAAI,CAAC8E,MAAM,CAAC,CAAC3F,GAAG,CAACyF,OAAO,CAAC;;QAEpE;QACA,IAAI,CAACoK,QAAQ,EAAE;UACb;QACF;;QAEA;QACAA,QAAQ,CAACC,YAAY,CAACD,QAAQ,CAACE,aAAa,CAACpC,GAAG,EAAEO,GAAG,CAAC,EAAE2B,QAAQ,CAACG,WAAW,CAACrC,GAAG,EAAEO,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;MACnG;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE+B,oBAAoB,CAACtC,GAAG,EAAE7C,MAAM,EAAEoF,QAAQ,EAAE;IAC1C,MAAMtB,OAAO,GAAG;MACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACN,GAAG,CAAC;MACtDO,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACnD,MAAM,CAAC;MAC5D8C,KAAK,EAAE,IAAI,CAACnI;IACd,CAAC;IACD,IAAI,CAAC,IAAI,CAACE,MAAM,CAACwK,6BAA6B,CAACvB,OAAO,CAAC,EAAE;MACvDtO,IAAI,CAAE,oCAAmC8P,IAAI,CAACC,SAAS,CAACzB,OAAO,CAAE,EAAC,CAAC;MACnE;IACF;IACA,MAAM0B,QAAQ,GAAG,IAAI,CAACxK,GAAG,CAACkK,WAAW,CAACrC,GAAG,EAAE7C,MAAM,CAAC;IAClD,IAAI9J,MAAM,CAACkP,QAAQ,EAAEI,QAAQ,CAACC,IAAI,CAAC,EAAE;MACnC,IAAItP,WAAW,CAACiP,QAAQ,EAAEI,QAAQ,CAACE,UAAU,CAAC,EAAE;QAC9C;QACAN,QAAQ,GAAGhP,iBAAiB,CAACgP,QAAQ,EAAEI,QAAQ,CAACE,UAAU,CAAC;MAC7D,CAAC,MAAM,IAAInP,SAAS,CAAC6O,QAAQ,CAAC,KAAK,KAAK,EAAE;QACxC;QACAA,QAAQ,GAAI,IAAGA,QAAS,EAAC;MAC3B;IACF;IACA,OAAO,IAAI,CAACvK,MAAM,CAAC8K,eAAe,CAAC7B,OAAO,EAAEsB,QAAQ,CAAC;EACvD;AACF;AACA,SAASvI,kBAAkB,CAAC1J,KAAK,EAAEyS,SAAS,EAAEC,IAAI,EAAE;EAClD,MAAMC,YAAY,GAAG,IAAI,CAAC9K,GAAG,CAAC+K,SAAS,CAACF,IAAI,CAAC;EAC7C,IAAI,IAAI,CAACxC,iBAAiB,CAACuC,SAAS,EAAEE,YAAY,CAAC,EAAE;IACnD,MAAMhC,OAAO,GAAG;MACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;MAC5DxC,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;MAClEhD,KAAK,EAAE,IAAI,CAACnI;IACd,CAAC;IACD,MAAM6K,QAAQ,GAAG,IAAI,CAACxK,GAAG,CAACkK,WAAW,CAACU,SAAS,EAAEE,YAAY,CAAC;IAC9D,IAAIE,SAAS,GAAG,IAAI,CAACnL,MAAM,CAACoL,YAAY,CAACnC,OAAO,CAAC,CAAC,CAAC;;IAEnD,IAAI0B,QAAQ,CAACC,IAAI,KAAK,MAAM,IAAIhQ,SAAS,CAACuQ,SAAS,CAAC,EAAE;MACpDA,SAAS,GAAG3P,oBAAoB,CAAC2P,SAAS,EAAER,QAAQ,CAACE,UAAU,CAAC;IAClE;;IAEA;IACA,OAAO,OAAOM,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,IAAI,GAAGA,SAAS,CAAC7S,KAAK,GAAG6S,SAAS;EAC1F;EACA,OAAO7S,KAAK;AACd;AACA,SAAS6N,kBAAkB,CAACkF,QAAQ,EAAEC,WAAW,EAAEC,WAAW,EAAE;EAC9D,MAAM;IACJvD,GAAG,EAAEwD,iBAAiB;IACtBjD,GAAG,EAAEkD;EACP,CAAC,GAAGH,WAAW,CAACI,iBAAiB,EAAE;EACnC,MAAM;IACJ1D,GAAG,EAAE2D,kBAAkB;IACvBpD,GAAG,EAAEqD;EACP,CAAC,GAAGN,WAAW,CAACO,kBAAkB,EAAE;EACpC,MAAM;IACJ7D,GAAG,EAAE8D,iBAAiB;IACtBvD,GAAG,EAAEwD;EACP,CAAC,GAAGR,WAAW,CAACG,iBAAiB,EAAE;EACnC,MAAM;IACJ1D,GAAG,EAAEgE,kBAAkB;IACvBzD,GAAG,EAAE0D;EACP,CAAC,GAAGV,WAAW,CAACM,kBAAkB,EAAE;EACpC,MAAMK,iBAAiB,GAAG;IACxBC,KAAK,EAAE;MACLnE,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACkD,iBAAiB,CAAC;MACpEjD,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACmD,oBAAoB,CAAC;MAC1ExD,KAAK,EAAE,IAAI,CAACnI;IACd,CAAC;IACDsM,GAAG,EAAE;MACHpE,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACqD,kBAAkB,CAAC;MACrEpD,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACsD,qBAAqB,CAAC;MAC3E3D,KAAK,EAAE,IAAI,CAACnI;IACd;EACF,CAAC;EACD,MAAMuM,iBAAiB,GAAG;IACxBF,KAAK,EAAE;MACLnE,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACwD,iBAAiB,CAAC;MACpEvD,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAACyD,oBAAoB,CAAC;MAC1E9D,KAAK,EAAE,IAAI,CAACnI;IACd,CAAC;IACDsM,GAAG,EAAE;MACHpE,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAAC0D,kBAAkB,CAAC;MACrEzD,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2D,qBAAqB,CAAC;MAC3EhE,KAAK,EAAE,IAAI,CAACnI;IACd;EACF,CAAC;;EAED;EACA;EACA,IAAI,IAAI,CAACE,MAAM,CAACwK,6BAA6B,CAAC6B,iBAAiB,CAAC,KAAK,KAAK,EAAE;IAC1E,OAAO,KAAK;EACd;EACA,MAAMC,aAAa,GAAG,IAAI,CAACtM,MAAM,CAACuM,gBAAgB,CAACL,iBAAiB,EAAEG,iBAAiB,CAAC;EACxF,MAAM;IACJrE,GAAG,EAAEwE,cAAc;IACnBjE,GAAG,EAAEkE;EACP,CAAC,GAAGP,iBAAiB,CAACC,KAAK;EAC3B,MAAM;IACJnE,GAAG,EAAE0E,YAAY;IACjBnE,GAAG,EAAEoE;EACP,CAAC,GAAGT,iBAAiB,CAACE,GAAG;EACzB,MAAMQ,mBAAmB,GAAGF,YAAY,GAAGF,cAAc,GAAG,CAAC;EAC7D,MAAMK,sBAAsB,GAAGF,eAAe,GAAGF,iBAAiB,GAAG,CAAC;EACtE,KAAK,IAAIK,iBAAiB,GAAG,CAAC,EAAEA,iBAAiB,GAAGR,aAAa,CAAC5N,MAAM,EAAEoO,iBAAiB,IAAI,CAAC,EAAE;IAChG,KAAK,IAAIC,oBAAoB,GAAG,CAAC,EAAEA,oBAAoB,GAAGT,aAAa,CAACQ,iBAAiB,CAAC,CAACpO,MAAM,EAAEqO,oBAAoB,IAAI,CAAC,EAAE;MAC5H,MAAMC,cAAc,GAAGV,aAAa,CAACQ,iBAAiB,CAAC,CAACC,oBAAoB,CAAC;MAC7E,MAAME,SAAS,GAAGH,iBAAiB,GAAGF,mBAAmB;MACzD,MAAMM,YAAY,GAAGH,oBAAoB,GAAGF,sBAAsB;MAClE,MAAMM,cAAc,GAAG,IAAI,CAAChN,GAAG,CAACkK,WAAW,CAAC4C,SAAS,EAAEC,YAAY,CAAC;MACpE,IAAI7R,MAAM,CAAC2R,cAAc,EAAEG,cAAc,CAACvC,IAAI,CAAC,EAAE;QAC/C,IAAIoC,cAAc,CAACI,UAAU,CAAC,IAAI,CAAC,EAAE;UACnC;UACAd,aAAa,CAACQ,iBAAiB,CAAC,CAACC,oBAAoB,CAAC,GAAGC,cAAc,CAACK,KAAK,CAAC,CAAC,CAAC;QAClF,CAAC,MAAM,IAAI,IAAI,CAAC7E,iBAAiB,CAACyE,SAAS,EAAEC,YAAY,EAAE,IAAI,CAACpN,OAAO,CAAC,KAAK,KAAK,EAAE;UAClF;UACAwM,aAAa,CAACQ,iBAAiB,CAAC,CAACC,oBAAoB,CAAC,GAAGtR,kBAAkB,CAACuR,cAAc,EAAEG,cAAc,CAACtC,UAAU,CAAC;QACxH;MACF;IACF;EACF;EACA,OAAOyB,aAAa;AACtB;AACA,SAAStL,kBAAkB,CAACsM,UAAU,EAAEC,WAAW,EAAE;EACnD,IAAIhR,MAAM,GAAGiC,SAAS,CAACE,MAAM,GAAG,CAAC,IAAIF,SAAS,CAAC,CAAC,CAAC,KAAK4I,SAAS,GAAG5I,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;EACnF,IAAIjC,MAAM,CAACiR,QAAQ,CAAC1R,gBAAgB,CAACG,UAAU,CAAC,CAAC,EAAE;IACjD;EACF;;EAEA;EACA;EACApC,qBAAqB,CAAC,IAAI,EAAE6C,+BAA+B,EAAE5B,WAAW,CAAC,IAAI,CAACqF,GAAG,CAACC,WAAW,EAAE,CAAC+G,IAAI,CAAC,CAAC;AACxG;AACA,SAAS1B,sBAAsB,GAAG;EAChC,MAAMgI,eAAe,GAAG,IAAI,CAACtN,GAAG,CAACS,kBAAkB,EAAE;EACrD,IAAI8M,YAAY,GAAG,KAAK;EACxBD,eAAe,CAACrH,OAAO,CAAC,CAACuH,OAAO,EAAEC,QAAQ,KAAK;IAC7CD,OAAO,CAACvH,OAAO,CAAC,CAAC+E,SAAS,EAAE0C,WAAW,KAAK;MAC1C,MAAMlD,QAAQ,GAAG,IAAI,CAACxK,GAAG,CAACkK,WAAW,CAACuD,QAAQ,EAAEC,WAAW,CAAC;MAC5D,MAAMhD,UAAU,GAAGF,QAAQ,CAACE,UAAU;MACtC,IAAIxP,MAAM,CAAC8P,SAAS,EAAER,QAAQ,CAACC,IAAI,CAAC,EAAE;QACpC8C,YAAY,GAAG,IAAI;QACnB,IAAIpS,WAAW,CAAC6P,SAAS,EAAEN,UAAU,CAAC,EAAE;UACtC;UACA4C,eAAe,CAACG,QAAQ,CAAC,CAACC,WAAW,CAAC,GAAGtS,iBAAiB,CAAC4P,SAAS,EAAEN,UAAU,CAAC;QACnF,CAAC,MAAM,IAAI,IAAI,CAACrC,iBAAiB,CAACoF,QAAQ,EAAEC,WAAW,CAAC,KAAK,KAAK,EAAE;UAClE;UACAJ,eAAe,CAACG,QAAQ,CAAC,CAACC,WAAW,CAAC,GAAI,IAAG1C,SAAU,EAAC;QAC1D;MACF;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,IAAIuC,YAAY,KAAK,IAAI,EAAE;IACzB7T,qBAAqB,CAAC,IAAI,EAAE2C,yBAAyB,EAAE,IAAI,CAAC;IAC5D,IAAI,CAACwD,MAAM,CAAC0H,eAAe,CAAC,IAAI,CAAC5H,OAAO,EAAE2N,eAAe,CAAC;IAC1D5T,qBAAqB,CAAC,IAAI,EAAE2C,yBAAyB,EAAE,KAAK,CAAC;EAC/D;AACF;AACA,SAAS2E,iBAAiB,CAACmM,UAAU,EAAEC,WAAW,EAAE;EAClD,IAAIhR,MAAM,GAAGiC,SAAS,CAACE,MAAM,GAAG,CAAC,IAAIF,SAAS,CAAC,CAAC,CAAC,KAAK4I,SAAS,GAAG5I,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;EACnF,IAAIjC,MAAM,CAACiR,QAAQ,CAAC1R,gBAAgB,CAACG,UAAU,CAAC,CAAC,EAAE;IACjD;EACF;EACA,IAAI,CAAC8D,SAAS,GAAG/E,UAAU,CAAC,IAAI,CAACgF,MAAM,EAAE,IAAI,CAACG,GAAG,CAACC,WAAW,EAAE,CAACnE,UAAU,CAAC,CAAC8D,SAAS,CAAC;EACtF,IAAI,CAAC7F,qBAAqB,CAAC,IAAI,EAAEwC,+BAA+B,CAAC,EAAE;IACjE,MAAM+Q,eAAe,GAAG,IAAI,CAACtN,GAAG,CAACS,kBAAkB,EAAE;IACrD,IAAI,IAAI,CAACZ,MAAM,CAAC8N,iCAAiC,CAAC,IAAI,CAAChO,OAAO,EAAE2N,eAAe,CAAC,EAAE;MAChF5T,qBAAqB,CAAC,IAAI,EAAE2C,yBAAyB,EAAE,IAAI,CAAC;MAC5D,MAAMmM,cAAc,GAAG,IAAI,CAAC3I,MAAM,CAAC0H,eAAe,CAAC,IAAI,CAAC5H,OAAO,EAAE2N,eAAe,CAAC;MACjF,IAAI,CAACxJ,WAAW,CAAC8J,iBAAiB,CAAC,IAAI,CAAC/N,MAAM,EAAE,IAAI,CAACF,OAAO,CAAC;MAC7D,IAAI,CAAC4I,qBAAqB,CAACC,cAAc,CAAC;MAC1C9O,qBAAqB,CAAC,IAAI,EAAE2C,yBAAyB,EAAE,KAAK,CAAC;IAC/D;EACF,CAAC,MAAM;IACL,IAAI,CAAC0K,WAAW,CAAC,IAAI,CAACnH,SAAS,CAAC;EAClC;AACF;AACA,SAAS2B,cAAc,CAACwG,WAAW,EAAE+C,YAAY,EAAE+C,WAAW,EAAEC,MAAM,EAAE;EACtE,IAAIA,MAAM,KAAK,KAAK,IAAI/T,qBAAqB,CAAC,IAAI,EAAEsC,yBAAyB,CAAC,IAAI,IAAI,CAACuD,SAAS,KAAK,IAAI,IAAI,CAAC,IAAI,CAACC,MAAM,CAACS,cAAc,CAAC,IAAI,CAACV,SAAS,CAAC,EAAE;IACxJ;EACF;EACA,MAAMgL,SAAS,GAAG,IAAI,CAAC5K,GAAG,CAAC+N,WAAW,CAAChG,WAAW,CAAC;EACnD,IAAI6C,SAAS,KAAK,IAAI,IAAIE,YAAY,KAAK,IAAI,EAAE;IAC/C;EACF;;EAEA;EACA,MAAMzC,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACuC,SAAS,EAAEE,YAAY,CAAC;EACzE,IAAI,CAACzC,iBAAiB,EAAE;IACtB,MAAM2F,QAAQ,GAAG,IAAI,CAACpG,WAAW,CAACgD,SAAS,EAAEE,YAAY,CAAC;IAC1D,IAAIkD,QAAQ,KAAK,OAAO,EAAE;MACxB,IAAIhT,0BAA0B,CAAC6S,WAAW,CAAC1V,KAAK,CAAC,EAAE;QACjD0V,WAAW,CAAC1V,KAAK,GAAG8C,yBAAyB,CAAC4S,WAAW,CAAC1V,KAAK,CAAC;MAClE;MACA;IACF;EACF;EACA,MAAM2Q,OAAO,GAAG;IACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;IAC5DxC,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;IAClEhD,KAAK,EAAE,IAAI,CAACnI;EACd,CAAC;EACD,IAAIqL,SAAS,GAAG,IAAI,CAACnL,MAAM,CAACoL,YAAY,CAACnC,OAAO,CAAC,CAAC,CAAC;EACnD,MAAM0B,QAAQ,GAAG,IAAI,CAACxK,GAAG,CAACkK,WAAW,CAACU,SAAS,EAAEE,YAAY,CAAC;EAC9D,IAAIN,QAAQ,CAACC,IAAI,KAAK,MAAM,IAAIhQ,SAAS,CAACuQ,SAAS,CAAC,EAAE;IACpDA,SAAS,GAAG3P,oBAAoB,CAAC2P,SAAS,EAAER,QAAQ,CAACE,UAAU,CAAC;EAClE;;EAEA;EACA,MAAMvS,KAAK,GAAG,OAAO6S,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,IAAI,GAAGA,SAAS,CAAC7S,KAAK,GAAG6S,SAAS;EAC/F6C,WAAW,CAAC1V,KAAK,GAAGA,KAAK;AAC3B;AACA,SAASuJ,oBAAoB,CAACmG,GAAG,EAAEoG,YAAY,EAAEJ,WAAW,EAAEC,MAAM,EAAE;EACpE,IAAIA,MAAM,KAAK,KAAK,IAAI/T,qBAAqB,CAAC,IAAI,EAAEsC,yBAAyB,CAAC,IAAI,IAAI,CAACuD,SAAS,KAAK,IAAI,IAAI,CAAC,IAAI,CAACC,MAAM,CAACS,cAAc,CAAC,IAAI,CAACV,SAAS,CAAC,EAAE;IACxJ;EACF;EACA,MAAMgL,SAAS,GAAG,IAAI,CAAC5K,GAAG,CAAC+N,WAAW,CAAClG,GAAG,CAAC;EAC3C,MAAMiD,YAAY,GAAG,IAAI,CAAC9K,GAAG,CAAC+K,SAAS,CAACkD,YAAY,CAAC;EACrD,IAAIrD,SAAS,KAAK,IAAI,IAAIE,YAAY,KAAK,IAAI,EAAE;IAC/C;EACF;;EAEA;EACA,MAAMzC,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACuC,SAAS,EAAEE,YAAY,CAAC;EACzE,IAAI,CAACzC,iBAAiB,EAAE;IACtB,MAAM2F,QAAQ,GAAG,IAAI,CAACpG,WAAW,CAACgD,SAAS,EAAEE,YAAY,CAAC;IAC1D,IAAIkD,QAAQ,KAAK,OAAO,EAAE;MACxB;IACF;EACF;EACA,MAAME,UAAU,GAAG,IAAI,CAACrO,MAAM,CAACsO,kBAAkB,CAAC,IAAI,CAACtO,MAAM,CAACC,UAAU,CAAC,IAAI,CAACF,SAAS,CAAC,CAAC;;EAEzF;EACA;EACA;EACA;EACA,IAAIsO,UAAU,CAACE,KAAK,KAAK,CAAC,IAAIF,UAAU,CAACG,MAAM,KAAK,CAAC,EAAE;IACrD;EACF;EACA,MAAMvF,OAAO,GAAG;IACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;IAC5DxC,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;IAClEhD,KAAK,EAAE,IAAI,CAACnI;EACd,CAAC;EACDkO,WAAW,CAAC1V,KAAK,GAAG,IAAI,CAAC0H,MAAM,CAACyO,iBAAiB,CAACxF,OAAO,CAAC;AAC5D;AACA,SAAS3G,sBAAsB,CAACoM,OAAO,EAAEnS,MAAM,EAAE;EAC/C,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAMoS,kBAAkB,GAAG,EAAE;EAC7B,MAAMnF,YAAY,GAAG,EAAE;EACvB,MAAMb,cAAc,GAAG,IAAI,CAAC3I,MAAM,CAAC4O,KAAK,CAAC,MAAM;IAC7CF,OAAO,CAACtI,OAAO,CAACyI,KAAK,IAAI;MACvB,IAAI,CAAC9D,SAAS,EAAEC,IAAI,GAAGT,QAAQ,CAAC,GAAGsE,KAAK;MACxC,MAAM5D,YAAY,GAAG,IAAI,CAAC9K,GAAG,CAAC+K,SAAS,CAACF,IAAI,CAAC;MAC7C,MAAM9C,WAAW,GAAG,IAAI,CAAC/H,GAAG,CAACgI,aAAa,CAAC4C,SAAS,CAAC;MACrD,MAAM3C,cAAc,GAAG,IAAI,CAACjI,GAAG,CAACkI,gBAAgB,CAAC4C,YAAY,CAAC;MAC9D,MAAMhC,OAAO,GAAG;QACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;QAC5DxC,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;QAClEhD,KAAK,EAAE,IAAI,CAACnI;MACd,CAAC;MACD,IAAIoI,WAAW,KAAK,IAAI,IAAIE,cAAc,KAAK,IAAI,EAAE;QACnD,IAAI,CAACkC,oBAAoB,CAACS,SAAS,EAAEE,YAAY,EAAEV,QAAQ,CAAC;MAC9D,CAAC,MAAM;QACLoE,kBAAkB,CAACG,IAAI,CAAC,CAAC/D,SAAS,EAAEE,YAAY,EAAEV,QAAQ,CAAC,CAAC;MAC9D;MACAf,YAAY,CAACsF,IAAI,CAAC;QAChB7F;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,IAAI0F,kBAAkB,CAACjQ,MAAM,EAAE;IAC7B;IACA;IACA,IAAI,CAACyB,GAAG,CAACkE,WAAW,CAAC,aAAa,EAAE,MAAM;MACxC,MAAM0K,yBAAyB,GAAG,IAAI,CAAC/O,MAAM,CAAC4O,KAAK,CAAC,MAAM;QACxDD,kBAAkB,CAACvI,OAAO,CAAC4I,KAAK,IAAI;UAClC,IAAI,CAAChH,GAAG,EAAE7C,MAAM,EAAEoF,QAAQ,CAAC,GAAGyE,KAAK;UACnC,IAAI,CAAC1E,oBAAoB,CAACtC,GAAG,EAAE7C,MAAM,EAAEoF,QAAQ,CAAC;QAClD,CAAC,CAAC;MACJ,CAAC,CAAC;MACF,IAAI,CAAC7B,qBAAqB,CAACqG,yBAAyB,EAAE,IAAI,CAAC;IAC7D,CAAC,CAAC;EACJ;EACA,IAAI,CAACrG,qBAAqB,CAACC,cAAc,CAAC;EAC1C,IAAI,CAACY,sBAAsB,CAACZ,cAAc,EAAEa,YAAY,CAAC;AAC3D;AACA,SAASrH,4BAA4B,CAACuM,OAAO,EAAEnS,MAAM,EAAE;EACrD,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAMoM,cAAc,GAAG,EAAE;EACzB,MAAMa,YAAY,GAAG,EAAE;EACvBkF,OAAO,CAACtI,OAAO,CAAC6I,KAAK,IAAI;IACvB,IAAI,CAAClE,SAAS,EAAEC,IAAI,GAAGT,QAAQ,CAAC,GAAG0E,KAAK;IACxC,MAAMhE,YAAY,GAAG,IAAI,CAAC9K,GAAG,CAAC+K,SAAS,CAACF,IAAI,CAAC;IAC7C,IAAI,CAACpQ,SAAS,CAACqQ,YAAY,CAAC,EAAE;MAC5B;IACF;IACA,MAAMhC,OAAO,GAAG;MACdjB,GAAG,EAAE,IAAI,CAAC1D,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;MAC5DxC,GAAG,EAAE,IAAI,CAAC/D,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;MAClEhD,KAAK,EAAE,IAAI,CAACnI;IACd,CAAC;IACD,IAAI,CAAC,IAAI,CAACE,MAAM,CAACwK,6BAA6B,CAACvB,OAAO,CAAC,EAAE;MACvDtO,IAAI,CAAE,2CAA0C8P,IAAI,CAACC,SAAS,CAACzB,OAAO,CAAE,EAAC,CAAC;MAC1E;IACF;IACAO,YAAY,CAACsF,IAAI,CAAC;MAChB7F;IACF,CAAC,CAAC;IACFN,cAAc,CAACmG,IAAI,CAAC,GAAG,IAAI,CAAC9O,MAAM,CAAC8K,eAAe,CAAC7B,OAAO,EAAEsB,QAAQ,CAAC,CAAC;EACxE,CAAC,CAAC;EACF,IAAI,CAAC7B,qBAAqB,CAACC,cAAc,CAAC;EAC1C,IAAI,CAACY,sBAAsB,CAACZ,cAAc,EAAEa,YAAY,CAAC;AAC3D;AACA,SAAS7G,mBAAmB,CAACoI,SAAS,EAAEmE,MAAM,EAAE;EAC9C,IAAIC,UAAU,GAAG,IAAI,CAAC7K,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC;EACxE,IAAIA,SAAS,IAAI,IAAI,CAAC5K,GAAG,CAAC4J,SAAS,EAAE,EAAE;IACrCoF,UAAU,GAAGpE,SAAS,CAAC,CAAC;EAC1B;;EACA,IAAI,IAAI,CAACjL,OAAO,KAAK,IAAI,IAAI,CAAC,IAAI,CAACE,MAAM,CAACS,cAAc,CAAC,IAAI,CAACV,SAAS,CAAC,IAAI,CAAC,IAAI,CAACC,MAAM,CAACoP,qBAAqB,CAAC,IAAI,CAACtP,OAAO,EAAE,CAACqP,UAAU,EAAED,MAAM,CAAC,CAAC,EAAE;IAClJ,OAAO,KAAK;EACd;AACF;AACA,SAASpM,mBAAmB,CAACmI,YAAY,EAAEiE,MAAM,EAAE;EACjD,IAAIG,aAAa,GAAG,IAAI,CAAC7K,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC;EACjF,IAAIA,YAAY,IAAI,IAAI,CAAC9K,GAAG,CAAC6J,SAAS,EAAE,EAAE;IACxCqF,aAAa,GAAGpE,YAAY,CAAC,CAAC;EAChC;;EACA,IAAI,IAAI,CAACnL,OAAO,KAAK,IAAI,IAAI,CAAC,IAAI,CAACE,MAAM,CAACS,cAAc,CAAC,IAAI,CAACV,SAAS,CAAC,IAAI,CAAC,IAAI,CAACC,MAAM,CAACsP,wBAAwB,CAAC,IAAI,CAACxP,OAAO,EAAE,CAACuP,aAAa,EAAEH,MAAM,CAAC,CAAC,EAAE;IACxJ,OAAO,KAAK;EACd;AACF;AACA,SAAS3L,mBAAmB,CAACyE,GAAG,EAAEkH,MAAM,EAAEK,YAAY,EAAE;EACtD,MAAMC,MAAM,GAAG,IAAI,CAAClL,aAAa,CAACmL,mBAAmB,CAACF,YAAY,CAAC;EACnE,MAAMG,QAAQ,GAAGF,MAAM,CAACG,KAAK,CAACC,KAAK,IAAI;IACrC,OAAO,IAAI,CAAC5P,MAAM,CAAC6P,wBAAwB,CAAC,IAAI,CAAC/P,OAAO,EAAE,CAAC8P,KAAK,EAAE,CAAC,CAAC,CAAC;EACvE,CAAC,CAAC;EACF,OAAOF,QAAQ,KAAK,KAAK,GAAG,KAAK,GAAGtI,SAAS;AAC/C;AACA,SAAS1D,mBAAmB,CAAC6E,GAAG,EAAE2G,MAAM,EAAEY,eAAe,EAAE;EACzD,MAAMC,SAAS,GAAG,IAAI,CAACvL,gBAAgB,CAACiL,mBAAmB,CAACK,eAAe,CAAC;EAC5E,MAAMJ,QAAQ,GAAGK,SAAS,CAACJ,KAAK,CAACK,QAAQ,IAAI;IAC3C,OAAO,IAAI,CAAChQ,MAAM,CAACiQ,2BAA2B,CAAC,IAAI,CAACnQ,OAAO,EAAE,CAACkQ,QAAQ,EAAE,CAAC,CAAC,CAAC;EAC7E,CAAC,CAAC;EACF,OAAON,QAAQ,KAAK,KAAK,GAAG,KAAK,GAAGtI,SAAS;AAC/C;AACA,SAASnE,kBAAkB,CAAC8H,SAAS,EAAEmE,MAAM,EAAE3S,MAAM,EAAE;EACrD,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAMmS,OAAO,GAAG,IAAI,CAAC1O,MAAM,CAACkQ,OAAO,CAAC,IAAI,CAACpQ,OAAO,EAAE,CAAC,IAAI,CAACwE,aAAa,CAACgE,yBAAyB,CAACyC,SAAS,CAAC,EAAEmE,MAAM,CAAC,CAAC;EACpH,IAAI,CAACxG,qBAAqB,CAACgG,OAAO,CAAC;AACrC;AACA,SAAStL,kBAAkB,CAAC6H,YAAY,EAAEiE,MAAM,EAAE3S,MAAM,EAAE;EACxD,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAMmS,OAAO,GAAG,IAAI,CAAC1O,MAAM,CAACmQ,UAAU,CAAC,IAAI,CAACrQ,OAAO,EAAE,CAAC,IAAI,CAAC0E,gBAAgB,CAAC8D,yBAAyB,CAAC2C,YAAY,CAAC,EAAEiE,MAAM,CAAC,CAAC;EAC7H,IAAI,CAACxG,qBAAqB,CAACgG,OAAO,CAAC;AACrC;AACA,SAAS7K,kBAAkB,CAACmE,GAAG,EAAEkH,MAAM,EAAEK,YAAY,EAAEhT,MAAM,EAAE;EAC7D,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAM6T,gBAAgB,GAAG,IAAI,CAAC9L,aAAa,CAAC+L,mBAAmB,EAAE,CAACC,IAAI,EAAE,CAACC,OAAO,EAAE;EAClF,MAAM7B,OAAO,GAAG,IAAI,CAAC1O,MAAM,CAAC4O,KAAK,CAAC,MAAM;IACtCwB,gBAAgB,CAAChK,OAAO,CAACwJ,KAAK,IAAI;MAChC,IAAI,CAAC5P,MAAM,CAACwQ,UAAU,CAAC,IAAI,CAAC1Q,OAAO,EAAE,CAAC8P,KAAK,EAAE,CAAC,CAAC,CAAC;IAClD,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,IAAI,CAAClH,qBAAqB,CAACgG,OAAO,CAAC;AACrC;AACA,SAAS1K,kBAAkB,CAACuE,GAAG,EAAE2G,MAAM,EAAEY,eAAe,EAAEvT,MAAM,EAAE;EAChE,IAAID,eAAe,CAACC,MAAM,CAAC,EAAE;IAC3B;EACF;EACA,MAAMkU,mBAAmB,GAAG,IAAI,CAACjM,gBAAgB,CAAC6L,mBAAmB,EAAE,CAACC,IAAI,EAAE,CAACC,OAAO,EAAE;EACxF,MAAM7B,OAAO,GAAG,IAAI,CAAC1O,MAAM,CAAC4O,KAAK,CAAC,MAAM;IACtC6B,mBAAmB,CAACrK,OAAO,CAAC4J,QAAQ,IAAI;MACtC,IAAI,CAAChQ,MAAM,CAAC0Q,aAAa,CAAC,IAAI,CAAC5Q,OAAO,EAAE,CAACkQ,QAAQ,EAAE,CAAC,CAAC,CAAC;IACxD,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,IAAI,CAACtH,qBAAqB,CAACgG,OAAO,CAAC;AACrC;AACA,SAAS1I,oBAAoB,CAAC2K,MAAM,EAAEC,OAAO,EAAEC,oBAAoB,EAAE;EACnE,IAAIC,mBAAmB;EACvBjX,qBAAqB,CAAC,IAAI,EAAE2C,yBAAyB,EAAE,IAAI,CAAC;EAC5D,MAAMuU,QAAQ,GAAG,IAAI,CAAC5Q,GAAG,CAACS,kBAAkB,CAACiQ,oBAAoB,EAAE,CAAC,EAAEA,oBAAoB,IAAI,CAAC,CAACC,mBAAmB,GAAGF,OAAO,CAACI,UAAU,MAAM,IAAI,IAAIF,mBAAmB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,mBAAmB,CAACpS,MAAM,KAAK,CAAC,CAAC,EAAE,IAAI,CAACyB,GAAG,CAAC8Q,eAAe,EAAE,CAAC;EAC9PpX,qBAAqB,CAAC,IAAI,EAAE2C,yBAAyB,EAAE,KAAK,CAAC;EAC7DuU,QAAQ,CAAC3K,OAAO,CAAC,CAAC4B,GAAG,EAAEkJ,gBAAgB,KAAK;IAC1ClJ,GAAG,CAAC5B,OAAO,CAAC,CAAC9N,KAAK,EAAE6Y,QAAQ,KAAK;MAC/B,IAAI,CAACnR,MAAM,CAAC8K,eAAe,CAAC;QAC1BvC,GAAG,EAAE4I,QAAQ;QACbnJ,GAAG,EAAE6I,oBAAoB,GAAGK,gBAAgB;QAC5CjJ,KAAK,EAAE,IAAI,CAACnI;MACd,CAAC,EAAE,CAAC,CAACxH,KAAK,CAAC,CAAC,CAAC;IACf,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AACA,SAASwG,uBAAuB,CAAC4P,OAAO,EAAE;EACxC,IAAI,CAACvO,GAAG,CAACiR,QAAQ,CAAC,2BAA2B,EAAE1C,OAAO,CAAC;AACzD;AACA,SAASzP,+BAA+B,CAACoS,mBAAmB,EAAE3C,OAAO,EAAE;EACrE,IAAI,CAACvO,GAAG,CAACiR,QAAQ,CAAC,2BAA2B,EAAEC,mBAAmB,EAAE3C,OAAO,CAAC;AAC9E;AACA,SAAStP,iCAAiC,CAACiS,mBAAmB,EAAE3C,OAAO,EAAE;EACvE,IAAI,CAACvO,GAAG,CAACiR,QAAQ,CAAC,6BAA6B,EAAEC,mBAAmB,EAAE3C,OAAO,CAAC;AAChF;AACA,SAASnP,oBAAoB,CAAC+R,qBAAqB,EAAE;EACnD,IAAI,CAACnR,GAAG,CAACiR,QAAQ,CAAC,iBAAiB,EAAEE,qBAAqB,CAAC;AAC7D;AACA,SAAS5R,sBAAsB,CAAC6R,cAAc,EAAEC,cAAc,EAAE;EAC9D,IAAI,CAACrR,GAAG,CAACiR,QAAQ,CAAC,mBAAmB,EAAEG,cAAc,EAAEC,cAAc,CAAC;AACxE;AACA,SAAS3R,sBAAsB,CAAC4R,uBAAuB,EAAE/C,OAAO,EAAE;EAChE,IAAI,CAACvO,GAAG,CAACiR,QAAQ,CAAC,mBAAmB,EAAEK,uBAAuB,EAAE/C,OAAO,CAAC;AAC1E"},"metadata":{},"sourceType":"module","externalDependencies":[]}