{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { arrayReduce } from \"../../helpers/array.mjs\";\nimport { addClass, removeClass, offset, getTrimmingContainer } from \"../../helpers/dom/element.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport BacklightUI from \"./ui/backlight.mjs\";\nimport GuidelineUI from \"./ui/guideline.mjs\";\nHooks.getSingleton().register('beforeRowMove');\nHooks.getSingleton().register('afterRowMove');\nexport const PLUGIN_KEY = 'manualRowMove';\nexport const PLUGIN_PRIORITY = 140;\nconst CSS_PLUGIN = 'ht__manualRowMove';\nconst CSS_SHOW_UI = 'show-ui';\nconst CSS_ON_MOVING = 'on-moving--rows';\nconst CSS_AFTER_SELECTION = 'after-selection--rows';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin ManualRowMove\n * @class ManualRowMove\n *\n * @description\n * This plugin allows to change rows order. To make rows order persistent the {@link Options#persistentState}\n * plugin should be enabled.\n *\n * API:\n * - `moveRow` - move single row to the new position.\n * - `moveRows` - move many rows (as an array of indexes) to the new position.\n * - `dragRow` - drag single row to the new position.\n * - `dragRows` - drag many rows (as an array of indexes) to the new position.\n *\n * [Documentation](@/guides/rows/row-moving.md) explain differences between drag and move actions. Please keep in mind that if you want apply visual changes,\n * you have to call manually the `render` method on the instance of Handsontable.\n *\n * The plugin creates additional components to make moving possibly using user interface:\n * - backlight - highlight of selected rows.\n * - guideline - line which shows where rows has been moved.\n *\n * @class ManualRowMove\n * @plugin ManualRowMove\n */\nvar _backlight = /*#__PURE__*/new WeakMap();\nvar _guideline = /*#__PURE__*/new WeakMap();\nvar _rowsToMove = /*#__PURE__*/new WeakMap();\nvar _pressed = /*#__PURE__*/new WeakMap();\nvar _target = /*#__PURE__*/new WeakMap();\nvar _cachedDropIndex = /*#__PURE__*/new WeakMap();\nvar _onBeforeOnCellMouseDown = /*#__PURE__*/new WeakSet();\nvar _onMouseMove = /*#__PURE__*/new WeakSet();\nvar _onBeforeOnCellMouseOver = /*#__PURE__*/new WeakSet();\nvar _onMouseUp = /*#__PURE__*/new WeakSet();\nvar _onAfterScrollHorizontally = /*#__PURE__*/new WeakSet();\nvar _onAfterLoadData = /*#__PURE__*/new WeakSet();\nexport class ManualRowMove extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Callback for the `afterLoadData` hook.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterLoadData);\n    /**\n     * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterScrollHorizontally);\n    /**\n     * `onMouseUp` hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _onMouseUp);\n    /**\n     * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.\n     *\n     * @param {MouseEvent} event `mouseover` event properties.\n     * @param {CellCoords} coords Visual cell coordinates where was fired event.\n     * @param {HTMLElement} TD Cell represented as HTMLElement.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeOnCellMouseOver);\n    /**\n     * 'mouseMove' event callback. Fired when pointer move on document.documentElement.\n     *\n     * @param {MouseEvent} event `mousemove` event properties.\n     */\n    _classPrivateMethodInitSpec(this, _onMouseMove);\n    /**\n     * Change the behavior of selection / dragging.\n     *\n     * @param {MouseEvent} event `mousedown` event properties.\n     * @param {CellCoords} coords Visual cell coordinates where was fired event.\n     * @param {HTMLElement} TD Cell represented as HTMLElement.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeOnCellMouseDown);\n    /**\n     * Backlight UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _backlight, {\n      writable: true,\n      value: new BacklightUI(this.hot)\n    });\n    /**\n     * Guideline UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _guideline, {\n      writable: true,\n      value: new GuidelineUI(this.hot)\n    });\n    /**\n     * @type {number[]}\n     */\n    _classPrivateFieldInitSpec(this, _rowsToMove, {\n      writable: true,\n      value: []\n    });\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _pressed, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _target, {\n      writable: true,\n      value: {}\n    });\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _cachedDropIndex, {\n      writable: true,\n      value: void 0\n    });\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link ManualRowMove#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeOnCellMouseDown, _onBeforeOnCellMouseDown2).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeOnCellMouseOver, _onBeforeOnCellMouseOver2).call(_this, ...args);\n    });\n    this.addHook('afterScrollHorizontally', () => _classPrivateMethodGet(this, _onAfterScrollHorizontally, _onAfterScrollHorizontally2).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _classPrivateMethodGet(_this, _onAfterLoadData, _onAfterLoadData2).call(_this, ...args);\n    });\n    this.buildPluginUI();\n    this.registerEvents();\n\n    // TODO: move adding plugin classname to BasePlugin.\n    addClass(this.hot.rootElement, CSS_PLUGIN);\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`manualRowMove`](@/api/options.md#manualrowmove)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.moveBySettingsOrLoad();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    removeClass(this.hot.rootElement, CSS_PLUGIN);\n    this.unregisterEvents();\n    _classPrivateFieldGet(this, _backlight).destroy();\n    _classPrivateFieldGet(this, _guideline).destroy();\n    super.disablePlugin();\n  }\n\n  /**\n   * Moves a single row.\n   *\n   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).\n   *\n   * @param {number} row Visual row index to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  moveRow(row, finalIndex) {\n    return this.moveRows([row], finalIndex);\n  }\n\n  /**\n   * Moves multiple rows.\n   *\n   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  moveRows(rows, finalIndex) {\n    const dropIndex = _classPrivateFieldGet(this, _cachedDropIndex);\n    const movePossible = this.isMovePossible(rows, finalIndex);\n    const beforeMoveHook = this.hot.runHooks('beforeRowMove', rows, finalIndex, dropIndex, movePossible);\n    _classPrivateFieldSet(this, _cachedDropIndex, undefined);\n    if (beforeMoveHook === false) {\n      return;\n    }\n    if (movePossible) {\n      this.hot.rowIndexMapper.moveIndexes(rows, finalIndex);\n    }\n    const movePerformed = movePossible && this.isRowOrderChanged(rows, finalIndex);\n    this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePerformed);\n    return movePerformed;\n  }\n\n  /**\n   * Drag a single row to drop index position.\n   *\n   * @param {number} row Visual row index to be dragged.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  dragRow(row, dropIndex) {\n    return this.dragRows([row], dropIndex);\n  }\n\n  /**\n   * Drag multiple rows to drop index position.\n   *\n   * @param {Array} rows Array of visual row indexes to be dragged.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  dragRows(rows, dropIndex) {\n    const finalIndex = this.countFinalIndex(rows, dropIndex);\n    _classPrivateFieldSet(this, _cachedDropIndex, dropIndex);\n    return this.moveRows(rows, finalIndex);\n  }\n\n  /**\n   * Indicates if it's possible to move rows to the desired position. Some of the actions aren't possible, i.e. You can’t move more than one element to the last position.\n   *\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @returns {boolean}\n   */\n  isMovePossible(movedRows, finalIndex) {\n    const length = this.hot.rowIndexMapper.getNotTrimmedIndexesLength();\n\n    // An attempt to transfer more rows to start destination than is possible (only when moving from the top to the bottom).\n    const tooHighDestinationIndex = movedRows.length + finalIndex > length;\n    const tooLowDestinationIndex = finalIndex < 0;\n    const tooLowMovedRowIndex = movedRows.some(movedRow => movedRow < 0);\n    const tooHighMovedRowIndex = movedRows.some(movedRow => movedRow >= length);\n    if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedRowIndex || tooHighMovedRowIndex) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Indicates if order of rows was changed.\n   *\n   * @private\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @returns {boolean}\n   */\n  isRowOrderChanged(movedRows, finalIndex) {\n    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);\n  }\n\n  /**\n   * Count the final row index from the drop index.\n   *\n   * @private\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows.\n   * @returns {number} Visual row index, being a start index for the moved rows.\n   */\n  countFinalIndex(movedRows, dropIndex) {\n    const numberOfRowsLowerThanDropIndex = arrayReduce(movedRows, (numberOfRows, currentRowIndex) => {\n      if (currentRowIndex < dropIndex) {\n        numberOfRows += 1;\n      }\n      return numberOfRows;\n    }, 0);\n    return dropIndex - numberOfRowsLowerThanDropIndex;\n  }\n\n  /**\n   * Gets the sum of the heights of rows in the provided range.\n   *\n   * @private\n   * @param {number} fromRow Visual row index.\n   * @param {number} toRow Visual row index.\n   * @returns {number}\n   */\n  getRowsHeight(fromRow, toRow) {\n    const rowMapper = this.hot.rowIndexMapper;\n    let rowsHeight = 0;\n    for (let visualRowIndex = fromRow; visualRowIndex <= toRow; visualRowIndex++) {\n      const renderableIndex = rowMapper.getRenderableFromVisualIndex(visualRowIndex);\n      if (renderableIndex !== null) {\n        rowsHeight += this.hot.view._wt.wtTable.getRowHeight(renderableIndex) || 23;\n      }\n    }\n    return rowsHeight;\n  }\n\n  /**\n   * Loads initial settings when persistent state is saved or when plugin was initialized as an array.\n   *\n   * @private\n   */\n  moveBySettingsOrLoad() {\n    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(pluginSettings)) {\n      this.moveRows(pluginSettings, 0);\n    } else if (pluginSettings !== undefined) {\n      const persistentState = this.persistentStateLoad();\n      if (persistentState.length) {\n        this.moveRows(persistentState, 0);\n      }\n    }\n  }\n\n  /**\n   * Checks if the provided row is in the fixedRowsTop section.\n   *\n   * @private\n   * @param {number} row Visual row index to check.\n   * @returns {boolean}\n   */\n  isFixedRowTop(row) {\n    return row < this.hot.getSettings().fixedRowsTop;\n  }\n\n  /**\n   * Checks if the provided row is in the fixedRowsBottom section.\n   *\n   * @private\n   * @param {number} row Visual row index to check.\n   * @returns {boolean}\n   */\n  isFixedRowBottom(row) {\n    return row > this.hot.countRows() - 1 - this.hot.getSettings().fixedRowsBottom;\n  }\n\n  /**\n   * Saves the manual row positions to the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateSave\n   */\n  persistentStateSave() {\n    // The `PersistentState` plugin should be refactored.\n    this.hot.runHooks('persistentStateSave', 'manualRowMove', this.hot.rowIndexMapper.getIndexesSequence());\n  }\n\n  /**\n   * Loads the manual row positions from the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateLoad\n   * @returns {Array} Stored state.\n   */\n  persistentStateLoad() {\n    const storedState = {};\n    this.hot.runHooks('persistentStateLoad', 'manualRowMove', storedState);\n    return storedState.value ? storedState.value : [];\n  }\n\n  /**\n   * Prepares an array of indexes based on actual selection.\n   *\n   * @private\n   * @returns {Array}\n   */\n  prepareRowsToMoving() {\n    const selection = this.hot.getSelectedRangeLast();\n    const selectedRows = [];\n    if (!selection) {\n      return selectedRows;\n    }\n    const {\n      from,\n      to\n    } = selection;\n    const start = Math.min(from.row, to.row);\n    const end = Math.max(from.row, to.row);\n    rangeEach(start, end, i => {\n      selectedRows.push(i);\n    });\n    return selectedRows;\n  }\n\n  /**\n   * Update the UI visual position.\n   *\n   * @private\n   */\n  refreshPositions() {\n    const coords = _classPrivateFieldGet(this, _target).coords;\n    const firstVisible = this.hot.view.getFirstFullyVisibleRow();\n    const lastVisible = this.hot.view.getLastFullyVisibleRow();\n    const countRows = this.hot.countRows();\n    if (this.isFixedRowTop(coords.row) && firstVisible > 0) {\n      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1));\n    }\n    if (this.isFixedRowBottom(coords.row) && lastVisible < countRows) {\n      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(lastVisible + 1, 1), undefined, true);\n    }\n    const wtTable = this.hot.view._wt.wtTable;\n    const TD = _classPrivateFieldGet(this, _target).TD;\n    const rootElement = this.hot.rootElement;\n    const rootElementOffset = offset(rootElement);\n    const trimmingContainer = getTrimmingContainer(rootElement);\n    const tableScroll = wtTable.holder.scrollTop;\n    const trimmingContainerScroll = this.hot.rootWindow !== trimmingContainer ? trimmingContainer.scrollTop : 0;\n    const pixelsAbove = rootElementOffset.top - trimmingContainerScroll;\n    const pixelsRelToTableStart = _classPrivateFieldGet(this, _target).eventPageY - pixelsAbove + tableScroll;\n    const hiderHeight = wtTable.hider.offsetHeight;\n    const tbodyOffsetTop = wtTable.TBODY.offsetTop;\n    const backlightElemMarginTop = _classPrivateFieldGet(this, _backlight).getOffset().top;\n    const backlightElemHeight = _classPrivateFieldGet(this, _backlight).getSize().height;\n    const tdMiddle = TD.offsetHeight / 2;\n    const tdHeight = TD.offsetHeight;\n    let tdStartPixel = this.hot.view.THEAD.offsetHeight + this.getRowsHeight(0, coords.row - 1);\n    const isBelowTable = pixelsRelToTableStart >= tdStartPixel + tdMiddle;\n    if (this.isFixedRowTop(coords.row)) {\n      tdStartPixel += this.hot.view._wt.wtOverlays.topOverlay.getOverlayOffset();\n    }\n    if (coords.row < 0) {\n      // if hover on colHeader\n      _classPrivateFieldGet(this, _target).row = firstVisible > 0 ? firstVisible - 1 : firstVisible;\n    } else if (isBelowTable) {\n      // if hover on lower part of TD\n      _classPrivateFieldGet(this, _target).row = coords.row + 1;\n      // unfortunately first row is bigger than rest\n      tdStartPixel += coords.row === 0 ? tdHeight - 1 : tdHeight;\n    } else {\n      // elsewhere on table\n      _classPrivateFieldGet(this, _target).row = coords.row;\n    }\n    let backlightTop = pixelsRelToTableStart;\n    let guidelineTop = tdStartPixel;\n    if (pixelsRelToTableStart + backlightElemHeight + backlightElemMarginTop >= hiderHeight) {\n      // prevent display backlight below table\n      backlightTop = hiderHeight - backlightElemHeight - backlightElemMarginTop;\n    } else if (pixelsRelToTableStart + backlightElemMarginTop < tbodyOffsetTop) {\n      // prevent display above below table\n      backlightTop = tbodyOffsetTop + Math.abs(backlightElemMarginTop);\n    }\n    if (tdStartPixel >= hiderHeight - 1) {\n      // prevent display guideline below table\n      guidelineTop = hiderHeight - 1;\n    }\n    _classPrivateFieldGet(this, _backlight).setPosition(backlightTop);\n    _classPrivateFieldGet(this, _guideline).setPosition(guidelineTop);\n  }\n\n  /**\n   * Binds the events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    this.eventManager.addEventListener(documentElement, 'mousemove', event => _classPrivateMethodGet(this, _onMouseMove, _onMouseMove2).call(this, event));\n    this.eventManager.addEventListener(documentElement, 'mouseup', () => _classPrivateMethodGet(this, _onMouseUp, _onMouseUp2).call(this));\n  }\n\n  /**\n   * Unbinds the events used by the plugin.\n   *\n   * @private\n   */\n  unregisterEvents() {\n    this.eventManager.clear();\n  }\n  /**\n   * Builds the plugin's UI.\n   *\n   * @private\n   */\n  buildPluginUI() {\n    _classPrivateFieldGet(this, _backlight).build();\n    _classPrivateFieldGet(this, _guideline).build();\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldGet(this, _backlight).destroy();\n    _classPrivateFieldGet(this, _guideline).destroy();\n    super.destroy();\n  }\n}\nfunction _onBeforeOnCellMouseDown2(event, coords, TD, controller) {\n  const {\n    wtTable,\n    wtViewport\n  } = this.hot.view._wt;\n  const isHeaderSelection = this.hot.selection.isSelectedByRowHeader();\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection || !isHeaderSelection || _classPrivateFieldGet(this, _pressed) || event.button !== 0) {\n    _classPrivateFieldSet(this, _pressed, false);\n    _classPrivateFieldGet(this, _rowsToMove).length = 0;\n    removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);\n    return;\n  }\n  const guidelineIsNotReady = _classPrivateFieldGet(this, _guideline).isBuilt() && !_classPrivateFieldGet(this, _guideline).isAppended();\n  const backlightIsNotReady = _classPrivateFieldGet(this, _backlight).isBuilt() && !_classPrivateFieldGet(this, _backlight).isAppended();\n  if (guidelineIsNotReady && backlightIsNotReady) {\n    _classPrivateFieldGet(this, _guideline).appendTo(wtTable.hider);\n    _classPrivateFieldGet(this, _backlight).appendTo(wtTable.hider);\n  }\n  const {\n    from,\n    to\n  } = selection;\n  const start = Math.min(from.row, to.row);\n  const end = Math.max(from.row, to.row);\n  if (coords.col < 0 && coords.row >= start && coords.row <= end) {\n    controller.row = true;\n    _classPrivateFieldSet(this, _pressed, true);\n    _classPrivateFieldGet(this, _target).eventPageY = event.pageY;\n    _classPrivateFieldGet(this, _target).coords = coords;\n    _classPrivateFieldGet(this, _target).TD = TD;\n    _classPrivateFieldSet(this, _rowsToMove, this.prepareRowsToMoving());\n    const leftPos = wtTable.holder.scrollLeft + wtViewport.getRowHeaderWidth();\n    const topOffset = this.getRowsHeight(start, coords.row - 1) + event.offsetY;\n    _classPrivateFieldGet(this, _backlight).setPosition(null, leftPos);\n    _classPrivateFieldGet(this, _backlight).setSize(wtTable.hider.offsetWidth - leftPos, this.getRowsHeight(start, end));\n    _classPrivateFieldGet(this, _backlight).setOffset(-topOffset, null);\n    addClass(this.hot.rootElement, CSS_ON_MOVING);\n    this.refreshPositions();\n  } else {\n    removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n    _classPrivateFieldSet(this, _pressed, false);\n    _classPrivateFieldGet(this, _rowsToMove).length = 0;\n  }\n}\nfunction _onMouseMove2(event) {\n  if (!_classPrivateFieldGet(this, _pressed)) {\n    return;\n  }\n  _classPrivateFieldGet(this, _target).eventPageY = event.pageY;\n  this.refreshPositions();\n}\nfunction _onBeforeOnCellMouseOver2(event, coords, TD, controller) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  if (!selectedRange || !_classPrivateFieldGet(this, _pressed)) {\n    return;\n  }\n  if (_classPrivateFieldGet(this, _rowsToMove).indexOf(coords.row) > -1) {\n    removeClass(this.hot.rootElement, CSS_SHOW_UI);\n  } else {\n    addClass(this.hot.rootElement, CSS_SHOW_UI);\n  }\n  controller.row = true;\n  controller.column = true;\n  controller.cell = true;\n  _classPrivateFieldGet(this, _target).coords = coords;\n  _classPrivateFieldGet(this, _target).TD = TD;\n}\nfunction _onMouseUp2() {\n  const target = _classPrivateFieldGet(this, _target).row;\n  const rowsLen = _classPrivateFieldGet(this, _rowsToMove).length;\n  _classPrivateFieldSet(this, _pressed, false);\n  removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);\n  if (this.hot.selection.isSelectedByRowHeader()) {\n    addClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n  }\n  if (rowsLen < 1 || target === undefined) {\n    return;\n  }\n  const firstMovedVisualRow = _classPrivateFieldGet(this, _rowsToMove)[0];\n  const firstMovedPhysicalRow = this.hot.toPhysicalRow(firstMovedVisualRow);\n  const movePerformed = this.dragRows(_classPrivateFieldGet(this, _rowsToMove), target);\n  _classPrivateFieldGet(this, _rowsToMove).length = 0;\n  if (movePerformed === true) {\n    this.persistentStateSave();\n    this.hot.render();\n    this.hot.view.adjustElementsSize(true);\n    const selectionStart = this.hot.toVisualRow(firstMovedPhysicalRow);\n    const selectionEnd = selectionStart + rowsLen - 1;\n    this.hot.selectRows(selectionStart, selectionEnd);\n  }\n}\nfunction _onAfterScrollHorizontally2() {\n  const wtTable = this.hot.view._wt.wtTable;\n  const headerWidth = this.hot.view._wt.wtViewport.getRowHeaderWidth();\n  const scrollLeft = wtTable.holder.scrollLeft;\n  const posLeft = headerWidth + scrollLeft;\n  _classPrivateFieldGet(this, _backlight).setPosition(null, posLeft);\n  _classPrivateFieldGet(this, _backlight).setSize(wtTable.hider.offsetWidth - posLeft);\n}\nfunction _onAfterLoadData2() {\n  this.moveBySettingsOrLoad();\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","privateMap","value","set","privateCollection","has","TypeError","_classPrivateFieldSet","receiver","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorSet","call","writable","_classPrivateFieldGet","_classApplyDescriptorGet","action","get","_classPrivateMethodGet","fn","BasePlugin","Hooks","arrayReduce","addClass","removeClass","offset","getTrimmingContainer","rangeEach","BacklightUI","GuidelineUI","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","CSS_PLUGIN","CSS_SHOW_UI","CSS_ON_MOVING","CSS_AFTER_SELECTION","_backlight","WeakMap","_guideline","_rowsToMove","_pressed","_target","_cachedDropIndex","_onBeforeOnCellMouseDown","WeakSet","_onMouseMove","_onBeforeOnCellMouseOver","_onMouseUp","_onAfterScrollHorizontally","_onAfterLoadData","ManualRowMove","constructor","arguments","hot","isEnabled","getSettings","enablePlugin","_this","enabled","addHook","_len","length","args","Array","_key","_onBeforeOnCellMouseDown2","_len2","_key2","_onBeforeOnCellMouseOver2","_onAfterScrollHorizontally2","_len3","_key3","_onAfterLoadData2","buildPluginUI","registerEvents","rootElement","updatePlugin","disablePlugin","moveBySettingsOrLoad","unregisterEvents","destroy","moveRow","row","finalIndex","moveRows","rows","dropIndex","movePossible","isMovePossible","beforeMoveHook","runHooks","undefined","rowIndexMapper","moveIndexes","movePerformed","isRowOrderChanged","dragRow","dragRows","countFinalIndex","movedRows","getNotTrimmedIndexesLength","tooHighDestinationIndex","tooLowDestinationIndex","tooLowMovedRowIndex","some","movedRow","tooHighMovedRowIndex","nrOfMovedElement","numberOfRowsLowerThanDropIndex","numberOfRows","currentRowIndex","getRowsHeight","fromRow","toRow","rowMapper","rowsHeight","visualRowIndex","renderableIndex","getRenderableFromVisualIndex","view","_wt","wtTable","getRowHeight","pluginSettings","isArray","persistentState","persistentStateLoad","isFixedRowTop","fixedRowsTop","isFixedRowBottom","countRows","fixedRowsBottom","persistentStateSave","getIndexesSequence","storedState","prepareRowsToMoving","selection","getSelectedRangeLast","selectedRows","from","to","start","Math","min","end","max","i","push","refreshPositions","coords","firstVisible","getFirstFullyVisibleRow","lastVisible","getLastFullyVisibleRow","scrollViewportTo","getNearestNotHiddenIndex","TD","rootElementOffset","trimmingContainer","tableScroll","holder","scrollTop","trimmingContainerScroll","rootWindow","pixelsAbove","top","pixelsRelToTableStart","eventPageY","hiderHeight","hider","offsetHeight","tbodyOffsetTop","TBODY","offsetTop","backlightElemMarginTop","getOffset","backlightElemHeight","getSize","height","tdMiddle","tdHeight","tdStartPixel","THEAD","isBelowTable","wtOverlays","topOverlay","getOverlayOffset","backlightTop","guidelineTop","abs","setPosition","documentElement","rootDocument","eventManager","addEventListener","event","_onMouseMove2","_onMouseUp2","clear","build","controller","wtViewport","isHeaderSelection","isSelectedByRowHeader","button","guidelineIsNotReady","isBuilt","isAppended","backlightIsNotReady","appendTo","col","pageY","leftPos","scrollLeft","getRowHeaderWidth","topOffset","offsetY","setSize","offsetWidth","setOffset","selectedRange","indexOf","column","cell","target","rowsLen","firstMovedVisualRow","firstMovedPhysicalRow","toPhysicalRow","render","adjustElementsSize","selectionStart","toVisualRow","selectionEnd","selectRows","headerWidth","posLeft"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/manualRowMove/manualRowMove.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { arrayReduce } from \"../../helpers/array.mjs\";\nimport { addClass, removeClass, offset, getTrimmingContainer } from \"../../helpers/dom/element.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport BacklightUI from \"./ui/backlight.mjs\";\nimport GuidelineUI from \"./ui/guideline.mjs\";\nHooks.getSingleton().register('beforeRowMove');\nHooks.getSingleton().register('afterRowMove');\nexport const PLUGIN_KEY = 'manualRowMove';\nexport const PLUGIN_PRIORITY = 140;\nconst CSS_PLUGIN = 'ht__manualRowMove';\nconst CSS_SHOW_UI = 'show-ui';\nconst CSS_ON_MOVING = 'on-moving--rows';\nconst CSS_AFTER_SELECTION = 'after-selection--rows';\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin ManualRowMove\n * @class ManualRowMove\n *\n * @description\n * This plugin allows to change rows order. To make rows order persistent the {@link Options#persistentState}\n * plugin should be enabled.\n *\n * API:\n * - `moveRow` - move single row to the new position.\n * - `moveRows` - move many rows (as an array of indexes) to the new position.\n * - `dragRow` - drag single row to the new position.\n * - `dragRows` - drag many rows (as an array of indexes) to the new position.\n *\n * [Documentation](@/guides/rows/row-moving.md) explain differences between drag and move actions. Please keep in mind that if you want apply visual changes,\n * you have to call manually the `render` method on the instance of Handsontable.\n *\n * The plugin creates additional components to make moving possibly using user interface:\n * - backlight - highlight of selected rows.\n * - guideline - line which shows where rows has been moved.\n *\n * @class ManualRowMove\n * @plugin ManualRowMove\n */\nvar _backlight = /*#__PURE__*/new WeakMap();\nvar _guideline = /*#__PURE__*/new WeakMap();\nvar _rowsToMove = /*#__PURE__*/new WeakMap();\nvar _pressed = /*#__PURE__*/new WeakMap();\nvar _target = /*#__PURE__*/new WeakMap();\nvar _cachedDropIndex = /*#__PURE__*/new WeakMap();\nvar _onBeforeOnCellMouseDown = /*#__PURE__*/new WeakSet();\nvar _onMouseMove = /*#__PURE__*/new WeakSet();\nvar _onBeforeOnCellMouseOver = /*#__PURE__*/new WeakSet();\nvar _onMouseUp = /*#__PURE__*/new WeakSet();\nvar _onAfterScrollHorizontally = /*#__PURE__*/new WeakSet();\nvar _onAfterLoadData = /*#__PURE__*/new WeakSet();\nexport class ManualRowMove extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Callback for the `afterLoadData` hook.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterLoadData);\n    /**\n     * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterScrollHorizontally);\n    /**\n     * `onMouseUp` hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _onMouseUp);\n    /**\n     * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.\n     *\n     * @param {MouseEvent} event `mouseover` event properties.\n     * @param {CellCoords} coords Visual cell coordinates where was fired event.\n     * @param {HTMLElement} TD Cell represented as HTMLElement.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeOnCellMouseOver);\n    /**\n     * 'mouseMove' event callback. Fired when pointer move on document.documentElement.\n     *\n     * @param {MouseEvent} event `mousemove` event properties.\n     */\n    _classPrivateMethodInitSpec(this, _onMouseMove);\n    /**\n     * Change the behavior of selection / dragging.\n     *\n     * @param {MouseEvent} event `mousedown` event properties.\n     * @param {CellCoords} coords Visual cell coordinates where was fired event.\n     * @param {HTMLElement} TD Cell represented as HTMLElement.\n     * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n     *                            a boolean value that allows or disallows changing the selection for that particular area.\n     */\n    _classPrivateMethodInitSpec(this, _onBeforeOnCellMouseDown);\n    /**\n     * Backlight UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _backlight, {\n      writable: true,\n      value: new BacklightUI(this.hot)\n    });\n    /**\n     * Guideline UI object.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _guideline, {\n      writable: true,\n      value: new GuidelineUI(this.hot)\n    });\n    /**\n     * @type {number[]}\n     */\n    _classPrivateFieldInitSpec(this, _rowsToMove, {\n      writable: true,\n      value: []\n    });\n    /**\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _pressed, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _target, {\n      writable: true,\n      value: {}\n    });\n    /**\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _cachedDropIndex, {\n      writable: true,\n      value: void 0\n    });\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link ManualRowMove#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeOnCellMouseDown, _onBeforeOnCellMouseDown2).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _classPrivateMethodGet(_this, _onBeforeOnCellMouseOver, _onBeforeOnCellMouseOver2).call(_this, ...args);\n    });\n    this.addHook('afterScrollHorizontally', () => _classPrivateMethodGet(this, _onAfterScrollHorizontally, _onAfterScrollHorizontally2).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _classPrivateMethodGet(_this, _onAfterLoadData, _onAfterLoadData2).call(_this, ...args);\n    });\n    this.buildPluginUI();\n    this.registerEvents();\n\n    // TODO: move adding plugin classname to BasePlugin.\n    addClass(this.hot.rootElement, CSS_PLUGIN);\n    super.enablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`manualRowMove`](@/api/options.md#manualrowmove)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.moveBySettingsOrLoad();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    removeClass(this.hot.rootElement, CSS_PLUGIN);\n    this.unregisterEvents();\n    _classPrivateFieldGet(this, _backlight).destroy();\n    _classPrivateFieldGet(this, _guideline).destroy();\n    super.disablePlugin();\n  }\n\n  /**\n   * Moves a single row.\n   *\n   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).\n   *\n   * @param {number} row Visual row index to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  moveRow(row, finalIndex) {\n    return this.moveRows([row], finalIndex);\n  }\n\n  /**\n   * Moves multiple rows.\n   *\n   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  moveRows(rows, finalIndex) {\n    const dropIndex = _classPrivateFieldGet(this, _cachedDropIndex);\n    const movePossible = this.isMovePossible(rows, finalIndex);\n    const beforeMoveHook = this.hot.runHooks('beforeRowMove', rows, finalIndex, dropIndex, movePossible);\n    _classPrivateFieldSet(this, _cachedDropIndex, undefined);\n    if (beforeMoveHook === false) {\n      return;\n    }\n    if (movePossible) {\n      this.hot.rowIndexMapper.moveIndexes(rows, finalIndex);\n    }\n    const movePerformed = movePossible && this.isRowOrderChanged(rows, finalIndex);\n    this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePerformed);\n    return movePerformed;\n  }\n\n  /**\n   * Drag a single row to drop index position.\n   *\n   * @param {number} row Visual row index to be dragged.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  dragRow(row, dropIndex) {\n    return this.dragRows([row], dropIndex);\n  }\n\n  /**\n   * Drag multiple rows to drop index position.\n   *\n   * @param {Array} rows Array of visual row indexes to be dragged.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.\n   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @fires Hooks#beforeRowMove\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  dragRows(rows, dropIndex) {\n    const finalIndex = this.countFinalIndex(rows, dropIndex);\n    _classPrivateFieldSet(this, _cachedDropIndex, dropIndex);\n    return this.moveRows(rows, finalIndex);\n  }\n\n  /**\n   * Indicates if it's possible to move rows to the desired position. Some of the actions aren't possible, i.e. You can’t move more than one element to the last position.\n   *\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @returns {boolean}\n   */\n  isMovePossible(movedRows, finalIndex) {\n    const length = this.hot.rowIndexMapper.getNotTrimmedIndexesLength();\n\n    // An attempt to transfer more rows to start destination than is possible (only when moving from the top to the bottom).\n    const tooHighDestinationIndex = movedRows.length + finalIndex > length;\n    const tooLowDestinationIndex = finalIndex < 0;\n    const tooLowMovedRowIndex = movedRows.some(movedRow => movedRow < 0);\n    const tooHighMovedRowIndex = movedRows.some(movedRow => movedRow >= length);\n    if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedRowIndex || tooHighMovedRowIndex) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Indicates if order of rows was changed.\n   *\n   * @private\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).\n   * @returns {boolean}\n   */\n  isRowOrderChanged(movedRows, finalIndex) {\n    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);\n  }\n\n  /**\n   * Count the final row index from the drop index.\n   *\n   * @private\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} dropIndex Visual row index, being a drop index for the moved rows.\n   * @returns {number} Visual row index, being a start index for the moved rows.\n   */\n  countFinalIndex(movedRows, dropIndex) {\n    const numberOfRowsLowerThanDropIndex = arrayReduce(movedRows, (numberOfRows, currentRowIndex) => {\n      if (currentRowIndex < dropIndex) {\n        numberOfRows += 1;\n      }\n      return numberOfRows;\n    }, 0);\n    return dropIndex - numberOfRowsLowerThanDropIndex;\n  }\n\n  /**\n   * Gets the sum of the heights of rows in the provided range.\n   *\n   * @private\n   * @param {number} fromRow Visual row index.\n   * @param {number} toRow Visual row index.\n   * @returns {number}\n   */\n  getRowsHeight(fromRow, toRow) {\n    const rowMapper = this.hot.rowIndexMapper;\n    let rowsHeight = 0;\n    for (let visualRowIndex = fromRow; visualRowIndex <= toRow; visualRowIndex++) {\n      const renderableIndex = rowMapper.getRenderableFromVisualIndex(visualRowIndex);\n      if (renderableIndex !== null) {\n        rowsHeight += this.hot.view._wt.wtTable.getRowHeight(renderableIndex) || 23;\n      }\n    }\n    return rowsHeight;\n  }\n\n  /**\n   * Loads initial settings when persistent state is saved or when plugin was initialized as an array.\n   *\n   * @private\n   */\n  moveBySettingsOrLoad() {\n    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(pluginSettings)) {\n      this.moveRows(pluginSettings, 0);\n    } else if (pluginSettings !== undefined) {\n      const persistentState = this.persistentStateLoad();\n      if (persistentState.length) {\n        this.moveRows(persistentState, 0);\n      }\n    }\n  }\n\n  /**\n   * Checks if the provided row is in the fixedRowsTop section.\n   *\n   * @private\n   * @param {number} row Visual row index to check.\n   * @returns {boolean}\n   */\n  isFixedRowTop(row) {\n    return row < this.hot.getSettings().fixedRowsTop;\n  }\n\n  /**\n   * Checks if the provided row is in the fixedRowsBottom section.\n   *\n   * @private\n   * @param {number} row Visual row index to check.\n   * @returns {boolean}\n   */\n  isFixedRowBottom(row) {\n    return row > this.hot.countRows() - 1 - this.hot.getSettings().fixedRowsBottom;\n  }\n\n  /**\n   * Saves the manual row positions to the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateSave\n   */\n  persistentStateSave() {\n    // The `PersistentState` plugin should be refactored.\n    this.hot.runHooks('persistentStateSave', 'manualRowMove', this.hot.rowIndexMapper.getIndexesSequence());\n  }\n\n  /**\n   * Loads the manual row positions from the persistent state (the {@link Options#persistentState} option has to be enabled).\n   *\n   * @private\n   * @fires Hooks#persistentStateLoad\n   * @returns {Array} Stored state.\n   */\n  persistentStateLoad() {\n    const storedState = {};\n    this.hot.runHooks('persistentStateLoad', 'manualRowMove', storedState);\n    return storedState.value ? storedState.value : [];\n  }\n\n  /**\n   * Prepares an array of indexes based on actual selection.\n   *\n   * @private\n   * @returns {Array}\n   */\n  prepareRowsToMoving() {\n    const selection = this.hot.getSelectedRangeLast();\n    const selectedRows = [];\n    if (!selection) {\n      return selectedRows;\n    }\n    const {\n      from,\n      to\n    } = selection;\n    const start = Math.min(from.row, to.row);\n    const end = Math.max(from.row, to.row);\n    rangeEach(start, end, i => {\n      selectedRows.push(i);\n    });\n    return selectedRows;\n  }\n\n  /**\n   * Update the UI visual position.\n   *\n   * @private\n   */\n  refreshPositions() {\n    const coords = _classPrivateFieldGet(this, _target).coords;\n    const firstVisible = this.hot.view.getFirstFullyVisibleRow();\n    const lastVisible = this.hot.view.getLastFullyVisibleRow();\n    const countRows = this.hot.countRows();\n    if (this.isFixedRowTop(coords.row) && firstVisible > 0) {\n      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1));\n    }\n    if (this.isFixedRowBottom(coords.row) && lastVisible < countRows) {\n      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(lastVisible + 1, 1), undefined, true);\n    }\n    const wtTable = this.hot.view._wt.wtTable;\n    const TD = _classPrivateFieldGet(this, _target).TD;\n    const rootElement = this.hot.rootElement;\n    const rootElementOffset = offset(rootElement);\n    const trimmingContainer = getTrimmingContainer(rootElement);\n    const tableScroll = wtTable.holder.scrollTop;\n    const trimmingContainerScroll = this.hot.rootWindow !== trimmingContainer ? trimmingContainer.scrollTop : 0;\n    const pixelsAbove = rootElementOffset.top - trimmingContainerScroll;\n    const pixelsRelToTableStart = _classPrivateFieldGet(this, _target).eventPageY - pixelsAbove + tableScroll;\n    const hiderHeight = wtTable.hider.offsetHeight;\n    const tbodyOffsetTop = wtTable.TBODY.offsetTop;\n    const backlightElemMarginTop = _classPrivateFieldGet(this, _backlight).getOffset().top;\n    const backlightElemHeight = _classPrivateFieldGet(this, _backlight).getSize().height;\n    const tdMiddle = TD.offsetHeight / 2;\n    const tdHeight = TD.offsetHeight;\n    let tdStartPixel = this.hot.view.THEAD.offsetHeight + this.getRowsHeight(0, coords.row - 1);\n    const isBelowTable = pixelsRelToTableStart >= tdStartPixel + tdMiddle;\n    if (this.isFixedRowTop(coords.row)) {\n      tdStartPixel += this.hot.view._wt.wtOverlays.topOverlay.getOverlayOffset();\n    }\n    if (coords.row < 0) {\n      // if hover on colHeader\n      _classPrivateFieldGet(this, _target).row = firstVisible > 0 ? firstVisible - 1 : firstVisible;\n    } else if (isBelowTable) {\n      // if hover on lower part of TD\n      _classPrivateFieldGet(this, _target).row = coords.row + 1;\n      // unfortunately first row is bigger than rest\n      tdStartPixel += coords.row === 0 ? tdHeight - 1 : tdHeight;\n    } else {\n      // elsewhere on table\n      _classPrivateFieldGet(this, _target).row = coords.row;\n    }\n    let backlightTop = pixelsRelToTableStart;\n    let guidelineTop = tdStartPixel;\n    if (pixelsRelToTableStart + backlightElemHeight + backlightElemMarginTop >= hiderHeight) {\n      // prevent display backlight below table\n      backlightTop = hiderHeight - backlightElemHeight - backlightElemMarginTop;\n    } else if (pixelsRelToTableStart + backlightElemMarginTop < tbodyOffsetTop) {\n      // prevent display above below table\n      backlightTop = tbodyOffsetTop + Math.abs(backlightElemMarginTop);\n    }\n    if (tdStartPixel >= hiderHeight - 1) {\n      // prevent display guideline below table\n      guidelineTop = hiderHeight - 1;\n    }\n    _classPrivateFieldGet(this, _backlight).setPosition(backlightTop);\n    _classPrivateFieldGet(this, _guideline).setPosition(guidelineTop);\n  }\n\n  /**\n   * Binds the events used by the plugin.\n   *\n   * @private\n   */\n  registerEvents() {\n    const {\n      documentElement\n    } = this.hot.rootDocument;\n    this.eventManager.addEventListener(documentElement, 'mousemove', event => _classPrivateMethodGet(this, _onMouseMove, _onMouseMove2).call(this, event));\n    this.eventManager.addEventListener(documentElement, 'mouseup', () => _classPrivateMethodGet(this, _onMouseUp, _onMouseUp2).call(this));\n  }\n\n  /**\n   * Unbinds the events used by the plugin.\n   *\n   * @private\n   */\n  unregisterEvents() {\n    this.eventManager.clear();\n  }\n  /**\n   * Builds the plugin's UI.\n   *\n   * @private\n   */\n  buildPluginUI() {\n    _classPrivateFieldGet(this, _backlight).build();\n    _classPrivateFieldGet(this, _guideline).build();\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldGet(this, _backlight).destroy();\n    _classPrivateFieldGet(this, _guideline).destroy();\n    super.destroy();\n  }\n}\nfunction _onBeforeOnCellMouseDown2(event, coords, TD, controller) {\n  const {\n    wtTable,\n    wtViewport\n  } = this.hot.view._wt;\n  const isHeaderSelection = this.hot.selection.isSelectedByRowHeader();\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection || !isHeaderSelection || _classPrivateFieldGet(this, _pressed) || event.button !== 0) {\n    _classPrivateFieldSet(this, _pressed, false);\n    _classPrivateFieldGet(this, _rowsToMove).length = 0;\n    removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);\n    return;\n  }\n  const guidelineIsNotReady = _classPrivateFieldGet(this, _guideline).isBuilt() && !_classPrivateFieldGet(this, _guideline).isAppended();\n  const backlightIsNotReady = _classPrivateFieldGet(this, _backlight).isBuilt() && !_classPrivateFieldGet(this, _backlight).isAppended();\n  if (guidelineIsNotReady && backlightIsNotReady) {\n    _classPrivateFieldGet(this, _guideline).appendTo(wtTable.hider);\n    _classPrivateFieldGet(this, _backlight).appendTo(wtTable.hider);\n  }\n  const {\n    from,\n    to\n  } = selection;\n  const start = Math.min(from.row, to.row);\n  const end = Math.max(from.row, to.row);\n  if (coords.col < 0 && coords.row >= start && coords.row <= end) {\n    controller.row = true;\n    _classPrivateFieldSet(this, _pressed, true);\n    _classPrivateFieldGet(this, _target).eventPageY = event.pageY;\n    _classPrivateFieldGet(this, _target).coords = coords;\n    _classPrivateFieldGet(this, _target).TD = TD;\n    _classPrivateFieldSet(this, _rowsToMove, this.prepareRowsToMoving());\n    const leftPos = wtTable.holder.scrollLeft + wtViewport.getRowHeaderWidth();\n    const topOffset = this.getRowsHeight(start, coords.row - 1) + event.offsetY;\n    _classPrivateFieldGet(this, _backlight).setPosition(null, leftPos);\n    _classPrivateFieldGet(this, _backlight).setSize(wtTable.hider.offsetWidth - leftPos, this.getRowsHeight(start, end));\n    _classPrivateFieldGet(this, _backlight).setOffset(-topOffset, null);\n    addClass(this.hot.rootElement, CSS_ON_MOVING);\n    this.refreshPositions();\n  } else {\n    removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n    _classPrivateFieldSet(this, _pressed, false);\n    _classPrivateFieldGet(this, _rowsToMove).length = 0;\n  }\n}\nfunction _onMouseMove2(event) {\n  if (!_classPrivateFieldGet(this, _pressed)) {\n    return;\n  }\n  _classPrivateFieldGet(this, _target).eventPageY = event.pageY;\n  this.refreshPositions();\n}\nfunction _onBeforeOnCellMouseOver2(event, coords, TD, controller) {\n  const selectedRange = this.hot.getSelectedRangeLast();\n  if (!selectedRange || !_classPrivateFieldGet(this, _pressed)) {\n    return;\n  }\n  if (_classPrivateFieldGet(this, _rowsToMove).indexOf(coords.row) > -1) {\n    removeClass(this.hot.rootElement, CSS_SHOW_UI);\n  } else {\n    addClass(this.hot.rootElement, CSS_SHOW_UI);\n  }\n  controller.row = true;\n  controller.column = true;\n  controller.cell = true;\n  _classPrivateFieldGet(this, _target).coords = coords;\n  _classPrivateFieldGet(this, _target).TD = TD;\n}\nfunction _onMouseUp2() {\n  const target = _classPrivateFieldGet(this, _target).row;\n  const rowsLen = _classPrivateFieldGet(this, _rowsToMove).length;\n  _classPrivateFieldSet(this, _pressed, false);\n  removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);\n  if (this.hot.selection.isSelectedByRowHeader()) {\n    addClass(this.hot.rootElement, CSS_AFTER_SELECTION);\n  }\n  if (rowsLen < 1 || target === undefined) {\n    return;\n  }\n  const firstMovedVisualRow = _classPrivateFieldGet(this, _rowsToMove)[0];\n  const firstMovedPhysicalRow = this.hot.toPhysicalRow(firstMovedVisualRow);\n  const movePerformed = this.dragRows(_classPrivateFieldGet(this, _rowsToMove), target);\n  _classPrivateFieldGet(this, _rowsToMove).length = 0;\n  if (movePerformed === true) {\n    this.persistentStateSave();\n    this.hot.render();\n    this.hot.view.adjustElementsSize(true);\n    const selectionStart = this.hot.toVisualRow(firstMovedPhysicalRow);\n    const selectionEnd = selectionStart + rowsLen - 1;\n    this.hot.selectRows(selectionStart, selectionEnd);\n  }\n}\nfunction _onAfterScrollHorizontally2() {\n  const wtTable = this.hot.view._wt.wtTable;\n  const headerWidth = this.hot.view._wt.wtViewport.getRowHeaderWidth();\n  const scrollLeft = wtTable.holder.scrollLeft;\n  const posLeft = headerWidth + scrollLeft;\n  _classPrivateFieldGet(this, _backlight).setPosition(null, posLeft);\n  _classPrivateFieldGet(this, _backlight).setSize(wtTable.hider.offsetWidth - posLeft);\n}\nfunction _onAfterLoadData2() {\n  this.moveBySettingsOrLoad();\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}