{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport { warn } from \"./helpers/console.mjs\";\nimport { isOutsideInput } from \"./helpers/dom/element.mjs\";\nimport { debounce } from \"./helpers/function.mjs\";\n/**\n * Possible focus modes.\n * - CELL - The browser's focus stays on the lastly selected cell element.\n * - MIXED - The browser's focus switches from the lastly selected cell element to the currently active editor's\n * `TEXTAREA` element after a delay defined in the manager.\n *\n * @type {{CELL: string, MIXED: string}}\n */\nconst FOCUS_MODES = Object.freeze({\n  CELL: 'cell',\n  MIXED: 'mixed'\n});\n\n/**\n * Manages the browser's focus in the table.\n */\nvar _hot = /*#__PURE__*/new WeakMap();\nvar _focusMode = /*#__PURE__*/new WeakMap();\nvar _refocusDelay = /*#__PURE__*/new WeakMap();\nvar _refocusElementGetter = /*#__PURE__*/new WeakMap();\nvar _debouncedSelect = /*#__PURE__*/new WeakMap();\nvar _getSelectedCell = /*#__PURE__*/new WeakSet();\nvar _focusCell = /*#__PURE__*/new WeakSet();\nvar _focusEditorElement = /*#__PURE__*/new WeakSet();\nvar _onUpdateSettings = /*#__PURE__*/new WeakSet();\nexport class FocusManager {\n  constructor(hotInstance) {\n    var _this = this;\n    /**\n     * Update the manager configuration after calling `updateSettings`.\n     *\n     * @param {object} newSettings The new settings passed to the `updateSettings` method.\n     */\n    _classPrivateMethodInitSpec(this, _onUpdateSettings);\n    /**\n     * Manage the browser's focus after cell selection end.\n     */\n    _classPrivateMethodInitSpec(this, _focusEditorElement);\n    /**\n     * Manage the browser's focus after each cell selection change.\n     */\n    _classPrivateMethodInitSpec(this, _focusCell);\n    /**\n     * Get and return the currently selected and highlighted cell/header element.\n     *\n     * @param {Function} callback Callback function to be called after the cell element is retrieved.\n     */\n    _classPrivateMethodInitSpec(this, _getSelectedCell);\n    /**\n     * The Handsontable instance.\n     */\n    _classPrivateFieldInitSpec(this, _hot, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The currently enabled focus mode.\n     * Can be either:\n     *\n     * - 'cell' - The browser's focus stays on the lastly selected cell element.\n     * - 'mixed' - The browser's focus switches from the lastly selected cell element to the currently active editor's\n     * `TEXTAREA` element after a delay defined in the manager.\n     *\n     * @type {'cell' | 'mixed'}\n     */\n    _classPrivateFieldInitSpec(this, _focusMode, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The delay after which the focus switches from the lastly selected cell to the active editor's `TEXTAREA`\n     * element if the focus mode is set to 'mixed'.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _refocusDelay, {\n      writable: true,\n      value: 50\n    });\n    /**\n     * Getter function for the element to be used when refocusing the browser after a delay. If `null`, the active\n     * editor's `TEXTAREA` element will be used.\n     *\n     * @type {null|Function}\n     */\n    _classPrivateFieldInitSpec(this, _refocusElementGetter, {\n      writable: true,\n      value: null\n    });\n    /**\n     * Map of the debounced `select` functions.\n     *\n     * @type {Map<number, Function>}\n     */\n    _classPrivateFieldInitSpec(this, _debouncedSelect, {\n      writable: true,\n      value: new Map()\n    });\n    const hotSettings = hotInstance.getSettings();\n    _classPrivateFieldSet(this, _hot, hotInstance);\n    _classPrivateFieldSet(this, _focusMode, hotSettings.imeFastEdit ? FOCUS_MODES.MIXED : FOCUS_MODES.CELL);\n    _classPrivateFieldGet(this, _hot).addHook('afterUpdateSettings', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onUpdateSettings, _onUpdateSettings2).call(_this, ...args);\n    });\n    _classPrivateFieldGet(this, _hot).addHook('afterSelection', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _classPrivateMethodGet(_this, _focusCell, _focusCell2).call(_this, ...args);\n    });\n    _classPrivateFieldGet(this, _hot).addHook('afterSelectionEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _classPrivateMethodGet(_this, _focusEditorElement, _focusEditorElement2).call(_this, ...args);\n    });\n  }\n\n  /**\n   * Get the current focus mode.\n   *\n   * @returns {'cell' | 'mixed'}\n   */\n  getFocusMode() {\n    return _classPrivateFieldGet(this, _focusMode);\n  }\n\n  /**\n   * Set the focus mode.\n   *\n   * @param {'cell' | 'mixed'} focusMode The new focus mode.\n   */\n  setFocusMode(focusMode) {\n    if (Object.values(FOCUS_MODES).includes(focusMode)) {\n      _classPrivateFieldSet(this, _focusMode, focusMode);\n    } else {\n      warn(`\"${focusMode}\" is not a valid focus mode.`);\n    }\n  }\n\n  /**\n   * Get the delay after which the focus will change from the cell elements to the active editor's `TEXTAREA`\n   * element if the focus mode is set to 'mixed'.\n   *\n   * @returns {number} Delay in milliseconds.\n   */\n  getRefocusDelay() {\n    return _classPrivateFieldGet(this, _refocusDelay);\n  }\n\n  /**\n   * Set the delay after which the focus will change from the cell elements to the active editor's `TEXTAREA`\n   * element if the focus mode is set to 'mixed'.\n   *\n   * @param {number} delay Delay in milliseconds.\n   */\n  setRefocusDelay(delay) {\n    _classPrivateFieldSet(this, _refocusDelay, delay);\n  }\n\n  /**\n   * Set the function to be used as the \"refocus element\" getter. It should return a focusable HTML element.\n   *\n   * @param {Function} getRefocusElementFunction The refocus element getter.\n   */\n  setRefocusElementGetter(getRefocusElementFunction) {\n    _classPrivateFieldSet(this, _refocusElementGetter, getRefocusElementFunction);\n  }\n\n  /**\n   * Get the element to be used when refocusing the browser after a delay in case of the focus mode being 'mixed'.\n   *\n   * @returns {HTMLTextAreaElement|HTMLElement|undefined}\n   */\n  getRefocusElement() {\n    if (typeof _classPrivateFieldGet(this, _refocusElementGetter) === 'function') {\n      return _classPrivateFieldGet(this, _refocusElementGetter).call(this);\n    } else {\n      var _classPrivateFieldGet2;\n      return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _hot).getActiveEditor()) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.TEXTAREA;\n    }\n  }\n\n  /**\n   * Set the browser's focus to the highlighted cell of the last selection.\n   *\n   * @param {HTMLTableCellElement} [selectedCell] The highlighted cell/header element.\n   */\n  focusOnHighlightedCell(selectedCell) {\n    const focusElement = element => {\n      var _classPrivateFieldGet3, _classPrivateFieldGet4;\n      const currentHighlightCoords = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _hot).getSelectedRangeLast()) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.highlight;\n      if (!currentHighlightCoords) {\n        return;\n      }\n      let elementToBeFocused = _classPrivateFieldGet(this, _hot).runHooks('modifyFocusedElement', currentHighlightCoords.row, currentHighlightCoords.col, element);\n      if (!(elementToBeFocused instanceof HTMLElement)) {\n        elementToBeFocused = element;\n      }\n      if (elementToBeFocused && !((_classPrivateFieldGet4 = _classPrivateFieldGet(this, _hot).getActiveEditor()) !== null && _classPrivateFieldGet4 !== void 0 && _classPrivateFieldGet4.isOpened())) {\n        elementToBeFocused.focus({\n          preventScroll: true\n        });\n      }\n    };\n    if (selectedCell) {\n      focusElement(selectedCell);\n    } else {\n      _classPrivateMethodGet(this, _getSelectedCell, _getSelectedCell2).call(this, element => focusElement(element));\n    }\n  }\n\n  /**\n   * Set the focus to the active editor's `TEXTAREA` element after the provided delay. If no delay is provided, it\n   * will be taken from the manager's configuration.\n   *\n   * @param {number} [delay] Delay in milliseconds.\n   */\n  refocusToEditorTextarea() {\n    var _classPrivateFieldGet5;\n    let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _classPrivateFieldGet(this, _refocusDelay);\n    const refocusElement = this.getRefocusElement();\n\n    // Re-focus on the editor's `TEXTAREA` element (or a predefined element) if the `imeFastEdit` option is enabled.\n    if (_classPrivateFieldGet(this, _hot).getSettings().imeFastEdit && !((_classPrivateFieldGet5 = _classPrivateFieldGet(this, _hot).getActiveEditor()) !== null && _classPrivateFieldGet5 !== void 0 && _classPrivateFieldGet5.isOpened()) && !!refocusElement) {\n      if (!_classPrivateFieldGet(this, _debouncedSelect).has(delay)) {\n        _classPrivateFieldGet(this, _debouncedSelect).set(delay, debounce(() => {\n          refocusElement.select();\n        }, delay));\n      }\n      _classPrivateFieldGet(this, _debouncedSelect).get(delay)();\n    }\n  }\n}\nfunction _getSelectedCell2(callback) {\n  var _classPrivateFieldGet6;\n  const highlight = (_classPrivateFieldGet6 = _classPrivateFieldGet(this, _hot).getSelectedRangeLast()) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.highlight;\n  if (!highlight || !_classPrivateFieldGet(this, _hot).selection.isCellVisible(highlight)) {\n    callback(null);\n    return;\n  }\n  const cell = _classPrivateFieldGet(this, _hot).getCell(highlight.row, highlight.col, true);\n  if (cell === null) {\n    _classPrivateFieldGet(this, _hot).addHookOnce('afterScroll', () => {\n      callback(_classPrivateFieldGet(this, _hot).getCell(highlight.row, highlight.col, true));\n    });\n  } else {\n    callback(cell);\n  }\n}\nfunction _focusCell2() {\n  _classPrivateMethodGet(this, _getSelectedCell, _getSelectedCell2).call(this, selectedCell => {\n    const {\n      activeElement\n    } = _classPrivateFieldGet(this, _hot).rootDocument;\n\n    // Blurring the `activeElement` removes the unwanted border around the focusable element (#6877)\n    // and resets the `document.activeElement` property. The blurring should happen only when the\n    // previously selected input element has not belonged to the Handsontable editor. If blurring is\n    // triggered for all elements, there is a problem with the disappearing IME editor (#9672).\n    if (activeElement && isOutsideInput(activeElement)) {\n      activeElement.blur();\n    }\n    this.focusOnHighlightedCell(selectedCell);\n  });\n}\nfunction _focusEditorElement2() {\n  _classPrivateMethodGet(this, _getSelectedCell, _getSelectedCell2).call(this, selectedCell => {\n    if (this.getFocusMode() === FOCUS_MODES.MIXED && selectedCell.nodeName === 'TD') {\n      this.refocusToEditorTextarea();\n    }\n  });\n}\nfunction _onUpdateSettings2(newSettings) {\n  if (newSettings.imeFastEdit && this.getFocusMode() !== FOCUS_MODES.MIXED) {\n    this.setFocusMode(FOCUS_MODES.MIXED);\n  } else if (!newSettings.imeFastEdit && this.getFocusMode() !== FOCUS_MODES.CELL) {\n    this.setFocusMode(FOCUS_MODES.CELL);\n  }\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","_classPrivateFieldInitSpec","privateMap","value","set","privateCollection","has","TypeError","_classPrivateMethodGet","receiver","fn","_classPrivateFieldGet","descriptor","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","call","_classPrivateFieldSet","_classApplyDescriptorSet","action","writable","warn","isOutsideInput","debounce","FOCUS_MODES","Object","freeze","CELL","MIXED","_hot","WeakMap","_focusMode","_refocusDelay","_refocusElementGetter","_debouncedSelect","_getSelectedCell","WeakSet","_focusCell","_focusEditorElement","_onUpdateSettings","FocusManager","constructor","hotInstance","_this","Map","hotSettings","getSettings","imeFastEdit","addHook","_len","arguments","length","args","Array","_key","_onUpdateSettings2","_len2","_key2","_focusCell2","_len3","_key3","_focusEditorElement2","getFocusMode","setFocusMode","focusMode","values","includes","getRefocusDelay","setRefocusDelay","delay","setRefocusElementGetter","getRefocusElementFunction","getRefocusElement","_classPrivateFieldGet2","getActiveEditor","TEXTAREA","focusOnHighlightedCell","selectedCell","focusElement","element","_classPrivateFieldGet3","_classPrivateFieldGet4","currentHighlightCoords","getSelectedRangeLast","highlight","elementToBeFocused","runHooks","row","col","HTMLElement","isOpened","focus","preventScroll","_getSelectedCell2","refocusToEditorTextarea","_classPrivateFieldGet5","undefined","refocusElement","select","callback","_classPrivateFieldGet6","selection","isCellVisible","cell","getCell","addHookOnce","activeElement","rootDocument","blur","nodeName","newSettings"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/focusManager.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { warn } from \"./helpers/console.mjs\";\nimport { isOutsideInput } from \"./helpers/dom/element.mjs\";\nimport { debounce } from \"./helpers/function.mjs\";\n/**\n * Possible focus modes.\n * - CELL - The browser's focus stays on the lastly selected cell element.\n * - MIXED - The browser's focus switches from the lastly selected cell element to the currently active editor's\n * `TEXTAREA` element after a delay defined in the manager.\n *\n * @type {{CELL: string, MIXED: string}}\n */\nconst FOCUS_MODES = Object.freeze({\n  CELL: 'cell',\n  MIXED: 'mixed'\n});\n\n/**\n * Manages the browser's focus in the table.\n */\nvar _hot = /*#__PURE__*/new WeakMap();\nvar _focusMode = /*#__PURE__*/new WeakMap();\nvar _refocusDelay = /*#__PURE__*/new WeakMap();\nvar _refocusElementGetter = /*#__PURE__*/new WeakMap();\nvar _debouncedSelect = /*#__PURE__*/new WeakMap();\nvar _getSelectedCell = /*#__PURE__*/new WeakSet();\nvar _focusCell = /*#__PURE__*/new WeakSet();\nvar _focusEditorElement = /*#__PURE__*/new WeakSet();\nvar _onUpdateSettings = /*#__PURE__*/new WeakSet();\nexport class FocusManager {\n  constructor(hotInstance) {\n    var _this = this;\n    /**\n     * Update the manager configuration after calling `updateSettings`.\n     *\n     * @param {object} newSettings The new settings passed to the `updateSettings` method.\n     */\n    _classPrivateMethodInitSpec(this, _onUpdateSettings);\n    /**\n     * Manage the browser's focus after cell selection end.\n     */\n    _classPrivateMethodInitSpec(this, _focusEditorElement);\n    /**\n     * Manage the browser's focus after each cell selection change.\n     */\n    _classPrivateMethodInitSpec(this, _focusCell);\n    /**\n     * Get and return the currently selected and highlighted cell/header element.\n     *\n     * @param {Function} callback Callback function to be called after the cell element is retrieved.\n     */\n    _classPrivateMethodInitSpec(this, _getSelectedCell);\n    /**\n     * The Handsontable instance.\n     */\n    _classPrivateFieldInitSpec(this, _hot, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The currently enabled focus mode.\n     * Can be either:\n     *\n     * - 'cell' - The browser's focus stays on the lastly selected cell element.\n     * - 'mixed' - The browser's focus switches from the lastly selected cell element to the currently active editor's\n     * `TEXTAREA` element after a delay defined in the manager.\n     *\n     * @type {'cell' | 'mixed'}\n     */\n    _classPrivateFieldInitSpec(this, _focusMode, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The delay after which the focus switches from the lastly selected cell to the active editor's `TEXTAREA`\n     * element if the focus mode is set to 'mixed'.\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _refocusDelay, {\n      writable: true,\n      value: 50\n    });\n    /**\n     * Getter function for the element to be used when refocusing the browser after a delay. If `null`, the active\n     * editor's `TEXTAREA` element will be used.\n     *\n     * @type {null|Function}\n     */\n    _classPrivateFieldInitSpec(this, _refocusElementGetter, {\n      writable: true,\n      value: null\n    });\n    /**\n     * Map of the debounced `select` functions.\n     *\n     * @type {Map<number, Function>}\n     */\n    _classPrivateFieldInitSpec(this, _debouncedSelect, {\n      writable: true,\n      value: new Map()\n    });\n    const hotSettings = hotInstance.getSettings();\n    _classPrivateFieldSet(this, _hot, hotInstance);\n    _classPrivateFieldSet(this, _focusMode, hotSettings.imeFastEdit ? FOCUS_MODES.MIXED : FOCUS_MODES.CELL);\n    _classPrivateFieldGet(this, _hot).addHook('afterUpdateSettings', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _classPrivateMethodGet(_this, _onUpdateSettings, _onUpdateSettings2).call(_this, ...args);\n    });\n    _classPrivateFieldGet(this, _hot).addHook('afterSelection', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _classPrivateMethodGet(_this, _focusCell, _focusCell2).call(_this, ...args);\n    });\n    _classPrivateFieldGet(this, _hot).addHook('afterSelectionEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _classPrivateMethodGet(_this, _focusEditorElement, _focusEditorElement2).call(_this, ...args);\n    });\n  }\n\n  /**\n   * Get the current focus mode.\n   *\n   * @returns {'cell' | 'mixed'}\n   */\n  getFocusMode() {\n    return _classPrivateFieldGet(this, _focusMode);\n  }\n\n  /**\n   * Set the focus mode.\n   *\n   * @param {'cell' | 'mixed'} focusMode The new focus mode.\n   */\n  setFocusMode(focusMode) {\n    if (Object.values(FOCUS_MODES).includes(focusMode)) {\n      _classPrivateFieldSet(this, _focusMode, focusMode);\n    } else {\n      warn(`\"${focusMode}\" is not a valid focus mode.`);\n    }\n  }\n\n  /**\n   * Get the delay after which the focus will change from the cell elements to the active editor's `TEXTAREA`\n   * element if the focus mode is set to 'mixed'.\n   *\n   * @returns {number} Delay in milliseconds.\n   */\n  getRefocusDelay() {\n    return _classPrivateFieldGet(this, _refocusDelay);\n  }\n\n  /**\n   * Set the delay after which the focus will change from the cell elements to the active editor's `TEXTAREA`\n   * element if the focus mode is set to 'mixed'.\n   *\n   * @param {number} delay Delay in milliseconds.\n   */\n  setRefocusDelay(delay) {\n    _classPrivateFieldSet(this, _refocusDelay, delay);\n  }\n\n  /**\n   * Set the function to be used as the \"refocus element\" getter. It should return a focusable HTML element.\n   *\n   * @param {Function} getRefocusElementFunction The refocus element getter.\n   */\n  setRefocusElementGetter(getRefocusElementFunction) {\n    _classPrivateFieldSet(this, _refocusElementGetter, getRefocusElementFunction);\n  }\n\n  /**\n   * Get the element to be used when refocusing the browser after a delay in case of the focus mode being 'mixed'.\n   *\n   * @returns {HTMLTextAreaElement|HTMLElement|undefined}\n   */\n  getRefocusElement() {\n    if (typeof _classPrivateFieldGet(this, _refocusElementGetter) === 'function') {\n      return _classPrivateFieldGet(this, _refocusElementGetter).call(this);\n    } else {\n      var _classPrivateFieldGet2;\n      return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _hot).getActiveEditor()) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.TEXTAREA;\n    }\n  }\n\n  /**\n   * Set the browser's focus to the highlighted cell of the last selection.\n   *\n   * @param {HTMLTableCellElement} [selectedCell] The highlighted cell/header element.\n   */\n  focusOnHighlightedCell(selectedCell) {\n    const focusElement = element => {\n      var _classPrivateFieldGet3, _classPrivateFieldGet4;\n      const currentHighlightCoords = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _hot).getSelectedRangeLast()) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.highlight;\n      if (!currentHighlightCoords) {\n        return;\n      }\n      let elementToBeFocused = _classPrivateFieldGet(this, _hot).runHooks('modifyFocusedElement', currentHighlightCoords.row, currentHighlightCoords.col, element);\n      if (!(elementToBeFocused instanceof HTMLElement)) {\n        elementToBeFocused = element;\n      }\n      if (elementToBeFocused && !((_classPrivateFieldGet4 = _classPrivateFieldGet(this, _hot).getActiveEditor()) !== null && _classPrivateFieldGet4 !== void 0 && _classPrivateFieldGet4.isOpened())) {\n        elementToBeFocused.focus({\n          preventScroll: true\n        });\n      }\n    };\n    if (selectedCell) {\n      focusElement(selectedCell);\n    } else {\n      _classPrivateMethodGet(this, _getSelectedCell, _getSelectedCell2).call(this, element => focusElement(element));\n    }\n  }\n\n  /**\n   * Set the focus to the active editor's `TEXTAREA` element after the provided delay. If no delay is provided, it\n   * will be taken from the manager's configuration.\n   *\n   * @param {number} [delay] Delay in milliseconds.\n   */\n  refocusToEditorTextarea() {\n    var _classPrivateFieldGet5;\n    let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _classPrivateFieldGet(this, _refocusDelay);\n    const refocusElement = this.getRefocusElement();\n\n    // Re-focus on the editor's `TEXTAREA` element (or a predefined element) if the `imeFastEdit` option is enabled.\n    if (_classPrivateFieldGet(this, _hot).getSettings().imeFastEdit && !((_classPrivateFieldGet5 = _classPrivateFieldGet(this, _hot).getActiveEditor()) !== null && _classPrivateFieldGet5 !== void 0 && _classPrivateFieldGet5.isOpened()) && !!refocusElement) {\n      if (!_classPrivateFieldGet(this, _debouncedSelect).has(delay)) {\n        _classPrivateFieldGet(this, _debouncedSelect).set(delay, debounce(() => {\n          refocusElement.select();\n        }, delay));\n      }\n      _classPrivateFieldGet(this, _debouncedSelect).get(delay)();\n    }\n  }\n}\nfunction _getSelectedCell2(callback) {\n  var _classPrivateFieldGet6;\n  const highlight = (_classPrivateFieldGet6 = _classPrivateFieldGet(this, _hot).getSelectedRangeLast()) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.highlight;\n  if (!highlight || !_classPrivateFieldGet(this, _hot).selection.isCellVisible(highlight)) {\n    callback(null);\n    return;\n  }\n  const cell = _classPrivateFieldGet(this, _hot).getCell(highlight.row, highlight.col, true);\n  if (cell === null) {\n    _classPrivateFieldGet(this, _hot).addHookOnce('afterScroll', () => {\n      callback(_classPrivateFieldGet(this, _hot).getCell(highlight.row, highlight.col, true));\n    });\n  } else {\n    callback(cell);\n  }\n}\nfunction _focusCell2() {\n  _classPrivateMethodGet(this, _getSelectedCell, _getSelectedCell2).call(this, selectedCell => {\n    const {\n      activeElement\n    } = _classPrivateFieldGet(this, _hot).rootDocument;\n\n    // Blurring the `activeElement` removes the unwanted border around the focusable element (#6877)\n    // and resets the `document.activeElement` property. The blurring should happen only when the\n    // previously selected input element has not belonged to the Handsontable editor. If blurring is\n    // triggered for all elements, there is a problem with the disappearing IME editor (#9672).\n    if (activeElement && isOutsideInput(activeElement)) {\n      activeElement.blur();\n    }\n    this.focusOnHighlightedCell(selectedCell);\n  });\n}\nfunction _focusEditorElement2() {\n  _classPrivateMethodGet(this, _getSelectedCell, _getSelectedCell2).call(this, selectedCell => {\n    if (this.getFocusMode() === FOCUS_MODES.MIXED && selectedCell.nodeName === 'TD') {\n      this.refocusToEditorTextarea();\n    }\n  });\n}\nfunction _onUpdateSettings2(newSettings) {\n  if (newSettings.imeFastEdit && this.getFocusMode() !== FOCUS_MODES.MIXED) {\n    this.setFocusMode(FOCUS_MODES.MIXED);\n  } else if (!newSettings.imeFastEdit && this.getFocusMode() !== FOCUS_MODES.CELL) {\n    this.setFocusMode(FOCUS_MODES.CELL);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}