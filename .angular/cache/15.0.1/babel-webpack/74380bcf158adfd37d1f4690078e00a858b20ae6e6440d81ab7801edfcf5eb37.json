{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { addClass, getScrollbarWidth, getScrollLeft, getWindowScrollTop, hasClass, outerWidth, removeClass, setOverlayPosition, resetCssTransform } from \"../../../../helpers/dom/element.mjs\";\nimport InlineStartOverlayTable from \"../table/inlineStart.mjs\";\nimport { Overlay } from \"./_base.mjs\";\nimport { CORNER_DEFAULT_STYLE } from \"../selection/index.mjs\";\nimport { CLONE_INLINE_START } from \"./constants.mjs\";\n/**\n * @class InlineStartOverlay\n */\nexport class InlineStartOverlay extends Overlay {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {\n    super(wotInstance, facadeGetter, CLONE_INLINE_START, wtSettings, domBindings);\n  }\n\n  /**\n   * Factory method to create a subclass of `Table` that is relevant to this overlay.\n   *\n   * @see Table#constructor\n   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.\n   * @returns {InlineStartOverlayTable}\n   */\n  createTable() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new InlineStartOverlayTable(...args);\n  }\n\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    return this.wtSettings.getSetting('shouldRenderInlineStartOverlay');\n  }\n\n  /**\n   * Updates the left overlay position.\n   *\n   * @returns {boolean}\n   */\n  resetFixedPosition() {\n    const {\n      wtTable\n    } = this.wot;\n    if (!this.needFullRender || !wtTable.holder.parentNode) {\n      // removed from DOM\n      return false;\n    }\n    const {\n      rootWindow\n    } = this.domBindings;\n    const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let overlayPosition = 0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n      overlayPosition = this.getOverlayOffset() * (this.isRtl() ? -1 : 1);\n      setOverlayPosition(overlayRoot, `${overlayPosition}px`, '0px');\n    } else {\n      overlayPosition = this.getScrollPosition();\n      resetCssTransform(overlayRoot);\n    }\n    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition);\n    this.adjustElementsSize();\n    return positionChanged;\n  }\n\n  /**\n   * Sets the main overlay's horizontal scroll position.\n   *\n   * @param {number} pos The scroll position.\n   * @returns {boolean}\n   */\n  setScrollPosition(pos) {\n    const {\n      rootWindow\n    } = this.domBindings;\n    let result = false;\n    if (this.isRtl()) {\n      pos = -pos;\n    }\n    if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollX !== pos) {\n      rootWindow.scrollTo(pos, getWindowScrollTop(rootWindow));\n      result = true;\n    } else if (this.mainTableScrollableElement.scrollLeft !== pos) {\n      this.mainTableScrollableElement.scrollLeft = pos;\n      result = true;\n    }\n    return result;\n  }\n\n  /**\n   * Triggers onScroll hook callback.\n   */\n  onScroll() {\n    this.wtSettings.getSetting('onScrollVertically');\n  }\n\n  /**\n   * Calculates total sum cells width.\n   *\n   * @param {number} from Column index which calculates started from.\n   * @param {number} to Column index where calculation is finished.\n   * @returns {number} Width sum.\n   */\n  sumCellSizes(from, to) {\n    const defaultColumnWidth = this.wtSettings.getSetting('defaultColumnWidth');\n    let column = from;\n    let sum = 0;\n    while (column < to) {\n      sum += this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;\n      column += 1;\n    }\n    return sum;\n  }\n\n  /**\n   * Adjust overlay root element, childs and master table element sizes (width, height).\n   *\n   * @param {boolean} [force=false] When `true`, it adjusts the DOM nodes sizes for that overlay.\n   */\n  adjustElementsSize() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.updateTrimmingContainer();\n    if (this.needFullRender || force) {\n      this.adjustRootElementSize();\n      this.adjustRootChildrenSize();\n    }\n  }\n\n  /**\n   * Adjust overlay root element size (width and height).\n   */\n  adjustRootElementSize() {\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const scrollbarHeight = getScrollbarWidth(rootDocument);\n    const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const overlayRootStyle = overlayRoot.style;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    if (this.trimmingContainer !== rootWindow || preventOverflow === 'vertical') {\n      let height = this.wot.wtViewport.getWorkspaceHeight();\n      if (this.wot.wtOverlays.hasScrollbarBottom) {\n        height -= scrollbarHeight;\n      }\n      height = Math.min(height, wtTable.wtRootElement.scrollHeight);\n      overlayRootStyle.height = `${height}px`;\n    } else {\n      overlayRootStyle.height = '';\n    }\n    this.clone.wtTable.holder.style.height = overlayRootStyle.height;\n    const tableWidth = outerWidth(this.clone.wtTable.TABLE);\n    overlayRootStyle.width = `${tableWidth}px`;\n  }\n\n  /**\n   * Adjust overlay root childs size.\n   */\n  adjustRootChildrenSize() {\n    const {\n      holder\n    } = this.clone.wtTable;\n    const selectionCornerOffset = this.wot.selectionManager.getFocusSelection() ? parseInt(CORNER_DEFAULT_STYLE.width, 10) / 2 : 0;\n    this.clone.wtTable.hider.style.height = this.hider.style.height;\n    holder.style.height = holder.parentNode.style.height;\n    // Add selection corner protruding part to the holder total width to make sure that\n    // borders' corner won't be cut after horizontal scroll (#6937).\n    holder.style.width = `${parseInt(holder.parentNode.style.width, 10) + selectionCornerOffset}px`;\n  }\n\n  /**\n   * Adjust the overlay dimensions and position.\n   */\n  applyToDOM() {\n    const total = this.wtSettings.getSetting('totalColumns');\n    const styleProperty = this.isRtl() ? 'right' : 'left';\n    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {\n      this.spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;\n    } else if (total === 0) {\n      this.spreader.style[styleProperty] = '0';\n    } else {\n      throw new Error('Incorrect value of the columnsRenderCalculator');\n    }\n    if (this.isRtl()) {\n      this.spreader.style.left = '';\n    } else {\n      this.spreader.style.right = '';\n    }\n    if (this.needFullRender) {\n      this.syncOverlayOffset();\n    }\n  }\n\n  /**\n   * Synchronize calculated top position to an element.\n   */\n  syncOverlayOffset() {\n    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {\n      this.clone.wtTable.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;\n    } else {\n      this.clone.wtTable.spreader.style.top = '';\n    }\n  }\n\n  /**\n   * Scrolls horizontally to a column at the left edge of the viewport.\n   *\n   * @param {number} sourceCol  Column index which you want to scroll to.\n   * @param {boolean} [beyondRendered]  If `true`, scrolls according to the right\n   *                                    edge (left edge is by default).\n   * @returns {boolean}\n   */\n  scrollTo(sourceCol, beyondRendered) {\n    let newX = this.getTableParentOffset();\n    const sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;\n    const mainHolder = sourceInstance.wtTable.holder;\n    let scrollbarCompensation = 0;\n    if (beyondRendered) {\n      const columnWidth = this.wot.wtTable.getColumnWidth(sourceCol);\n      const viewportWidth = this.wot.wtViewport.getViewportWidth();\n      if (columnWidth > viewportWidth) {\n        beyondRendered = false;\n      }\n    }\n    if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {\n      scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    if (beyondRendered) {\n      newX += this.sumCellSizes(0, sourceCol + 1);\n      newX -= this.wot.wtViewport.getViewportWidth();\n    } else {\n      newX += this.sumCellSizes(this.wtSettings.getSetting('fixedColumnsStart'), sourceCol);\n    }\n    newX += scrollbarCompensation;\n    return this.setScrollPosition(newX);\n  }\n\n  /**\n   * Gets table parent left position.\n   *\n   * @returns {number}\n   */\n  getTableParentOffset() {\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let offset = 0;\n    if (!preventOverflow && this.trimmingContainer === this.domBindings.rootWindow) {\n      offset = this.wot.wtTable.holderOffset.left;\n    }\n    return offset;\n  }\n\n  /**\n   * Gets the main overlay's horizontal scroll position.\n   *\n   * @returns {number} Main table's horizontal scroll position.\n   */\n  getScrollPosition() {\n    return Math.abs(getScrollLeft(this.mainTableScrollableElement, this.domBindings.rootWindow));\n  }\n\n  /**\n   * Gets the main overlay's horizontal overlay offset.\n   *\n   * @returns {number} Main table's horizontal overlay offset.\n   */\n  getOverlayOffset() {\n    const {\n      rootWindow\n    } = this.domBindings;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let overlayOffset = 0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n      if (this.isRtl()) {\n        overlayOffset = Math.abs(Math.min(this.getTableParentOffset() - this.getScrollPosition(), 0));\n      } else {\n        overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);\n      }\n      const rootWidth = this.wot.wtTable.getTotalWidth();\n      const overlayRootWidth = this.clone.wtTable.getTotalWidth();\n      const maxOffset = rootWidth - overlayRootWidth;\n      if (overlayOffset > maxOffset) {\n        overlayOffset = 0;\n      }\n    }\n    return overlayOffset;\n  }\n\n  /**\n   * Adds css classes to hide the header border's header (cell-selection border hiding issue).\n   *\n   * @param {number} position Header X position if trimming container is window or scroll top if not.\n   * @returns {boolean}\n   */\n  adjustHeaderBordersPosition(position) {\n    const masterParent = this.wot.wtTable.holder.parentNode;\n    const rowHeaders = this.wtSettings.getSetting('rowHeaders');\n    const fixedColumnsStart = this.wtSettings.getSetting('fixedColumnsStart');\n    const totalRows = this.wtSettings.getSetting('totalRows');\n    if (totalRows) {\n      removeClass(masterParent, 'emptyRows');\n    } else {\n      addClass(masterParent, 'emptyRows');\n    }\n    let positionChanged = false;\n    if (fixedColumnsStart && !rowHeaders.length) {\n      // \"innerBorderLeft\" is for backward compatibility\n      addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n    } else if (!fixedColumnsStart && rowHeaders.length) {\n      const previousState = hasClass(masterParent, 'innerBorderInlineStart');\n      if (position) {\n        addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n        positionChanged = !previousState;\n      } else {\n        removeClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n        positionChanged = previousState;\n      }\n    }\n    return positionChanged;\n  }\n}","map":{"version":3,"names":["addClass","getScrollbarWidth","getScrollLeft","getWindowScrollTop","hasClass","outerWidth","removeClass","setOverlayPosition","resetCssTransform","InlineStartOverlayTable","Overlay","CORNER_DEFAULT_STYLE","CLONE_INLINE_START","InlineStartOverlay","constructor","wotInstance","facadeGetter","wtSettings","domBindings","createTable","_len","arguments","length","args","Array","_key","shouldBeRendered","getSetting","resetFixedPosition","wtTable","wot","needFullRender","holder","parentNode","rootWindow","overlayRoot","clone","preventOverflow","overlayPosition","trimmingContainer","getOverlayOffset","isRtl","getScrollPosition","positionChanged","adjustHeaderBordersPosition","adjustElementsSize","setScrollPosition","pos","result","mainTableScrollableElement","scrollX","scrollTo","scrollLeft","onScroll","sumCellSizes","from","to","defaultColumnWidth","column","sum","getStretchedColumnWidth","force","undefined","updateTrimmingContainer","adjustRootElementSize","adjustRootChildrenSize","rootDocument","scrollbarHeight","overlayRootStyle","style","height","wtViewport","getWorkspaceHeight","wtOverlays","hasScrollbarBottom","Math","min","wtRootElement","scrollHeight","tableWidth","TABLE","width","selectionCornerOffset","selectionManager","getFocusSelection","parseInt","hider","applyToDOM","total","styleProperty","columnsRenderCalculator","startPosition","spreader","Error","left","right","syncOverlayOffset","rowsRenderCalculator","top","sourceCol","beyondRendered","newX","getTableParentOffset","sourceInstance","cloneSource","mainHolder","scrollbarCompensation","columnWidth","getColumnWidth","viewportWidth","getViewportWidth","offsetWidth","clientWidth","offset","holderOffset","abs","overlayOffset","max","rootWidth","getTotalWidth","overlayRootWidth","maxOffset","position","masterParent","rowHeaders","fixedColumnsStart","totalRows","previousState"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/3rdparty/walkontable/src/overlay/inlineStart.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport { addClass, getScrollbarWidth, getScrollLeft, getWindowScrollTop, hasClass, outerWidth, removeClass, setOverlayPosition, resetCssTransform } from \"../../../../helpers/dom/element.mjs\";\nimport InlineStartOverlayTable from \"../table/inlineStart.mjs\";\nimport { Overlay } from \"./_base.mjs\";\nimport { CORNER_DEFAULT_STYLE } from \"../selection/index.mjs\";\nimport { CLONE_INLINE_START } from \"./constants.mjs\";\n/**\n * @class InlineStartOverlay\n */\nexport class InlineStartOverlay extends Overlay {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {\n    super(wotInstance, facadeGetter, CLONE_INLINE_START, wtSettings, domBindings);\n  }\n\n  /**\n   * Factory method to create a subclass of `Table` that is relevant to this overlay.\n   *\n   * @see Table#constructor\n   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.\n   * @returns {InlineStartOverlayTable}\n   */\n  createTable() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new InlineStartOverlayTable(...args);\n  }\n\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    return this.wtSettings.getSetting('shouldRenderInlineStartOverlay');\n  }\n\n  /**\n   * Updates the left overlay position.\n   *\n   * @returns {boolean}\n   */\n  resetFixedPosition() {\n    const {\n      wtTable\n    } = this.wot;\n    if (!this.needFullRender || !wtTable.holder.parentNode) {\n      // removed from DOM\n      return false;\n    }\n    const {\n      rootWindow\n    } = this.domBindings;\n    const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let overlayPosition = 0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n      overlayPosition = this.getOverlayOffset() * (this.isRtl() ? -1 : 1);\n      setOverlayPosition(overlayRoot, `${overlayPosition}px`, '0px');\n    } else {\n      overlayPosition = this.getScrollPosition();\n      resetCssTransform(overlayRoot);\n    }\n    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition);\n    this.adjustElementsSize();\n    return positionChanged;\n  }\n\n  /**\n   * Sets the main overlay's horizontal scroll position.\n   *\n   * @param {number} pos The scroll position.\n   * @returns {boolean}\n   */\n  setScrollPosition(pos) {\n    const {\n      rootWindow\n    } = this.domBindings;\n    let result = false;\n    if (this.isRtl()) {\n      pos = -pos;\n    }\n    if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollX !== pos) {\n      rootWindow.scrollTo(pos, getWindowScrollTop(rootWindow));\n      result = true;\n    } else if (this.mainTableScrollableElement.scrollLeft !== pos) {\n      this.mainTableScrollableElement.scrollLeft = pos;\n      result = true;\n    }\n    return result;\n  }\n\n  /**\n   * Triggers onScroll hook callback.\n   */\n  onScroll() {\n    this.wtSettings.getSetting('onScrollVertically');\n  }\n\n  /**\n   * Calculates total sum cells width.\n   *\n   * @param {number} from Column index which calculates started from.\n   * @param {number} to Column index where calculation is finished.\n   * @returns {number} Width sum.\n   */\n  sumCellSizes(from, to) {\n    const defaultColumnWidth = this.wtSettings.getSetting('defaultColumnWidth');\n    let column = from;\n    let sum = 0;\n    while (column < to) {\n      sum += this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;\n      column += 1;\n    }\n    return sum;\n  }\n\n  /**\n   * Adjust overlay root element, childs and master table element sizes (width, height).\n   *\n   * @param {boolean} [force=false] When `true`, it adjusts the DOM nodes sizes for that overlay.\n   */\n  adjustElementsSize() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.updateTrimmingContainer();\n    if (this.needFullRender || force) {\n      this.adjustRootElementSize();\n      this.adjustRootChildrenSize();\n    }\n  }\n\n  /**\n   * Adjust overlay root element size (width and height).\n   */\n  adjustRootElementSize() {\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const scrollbarHeight = getScrollbarWidth(rootDocument);\n    const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const overlayRootStyle = overlayRoot.style;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    if (this.trimmingContainer !== rootWindow || preventOverflow === 'vertical') {\n      let height = this.wot.wtViewport.getWorkspaceHeight();\n      if (this.wot.wtOverlays.hasScrollbarBottom) {\n        height -= scrollbarHeight;\n      }\n      height = Math.min(height, wtTable.wtRootElement.scrollHeight);\n      overlayRootStyle.height = `${height}px`;\n    } else {\n      overlayRootStyle.height = '';\n    }\n    this.clone.wtTable.holder.style.height = overlayRootStyle.height;\n    const tableWidth = outerWidth(this.clone.wtTable.TABLE);\n    overlayRootStyle.width = `${tableWidth}px`;\n  }\n\n  /**\n   * Adjust overlay root childs size.\n   */\n  adjustRootChildrenSize() {\n    const {\n      holder\n    } = this.clone.wtTable;\n    const selectionCornerOffset = this.wot.selectionManager.getFocusSelection() ? parseInt(CORNER_DEFAULT_STYLE.width, 10) / 2 : 0;\n    this.clone.wtTable.hider.style.height = this.hider.style.height;\n    holder.style.height = holder.parentNode.style.height;\n    // Add selection corner protruding part to the holder total width to make sure that\n    // borders' corner won't be cut after horizontal scroll (#6937).\n    holder.style.width = `${parseInt(holder.parentNode.style.width, 10) + selectionCornerOffset}px`;\n  }\n\n  /**\n   * Adjust the overlay dimensions and position.\n   */\n  applyToDOM() {\n    const total = this.wtSettings.getSetting('totalColumns');\n    const styleProperty = this.isRtl() ? 'right' : 'left';\n    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {\n      this.spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;\n    } else if (total === 0) {\n      this.spreader.style[styleProperty] = '0';\n    } else {\n      throw new Error('Incorrect value of the columnsRenderCalculator');\n    }\n    if (this.isRtl()) {\n      this.spreader.style.left = '';\n    } else {\n      this.spreader.style.right = '';\n    }\n    if (this.needFullRender) {\n      this.syncOverlayOffset();\n    }\n  }\n\n  /**\n   * Synchronize calculated top position to an element.\n   */\n  syncOverlayOffset() {\n    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {\n      this.clone.wtTable.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;\n    } else {\n      this.clone.wtTable.spreader.style.top = '';\n    }\n  }\n\n  /**\n   * Scrolls horizontally to a column at the left edge of the viewport.\n   *\n   * @param {number} sourceCol  Column index which you want to scroll to.\n   * @param {boolean} [beyondRendered]  If `true`, scrolls according to the right\n   *                                    edge (left edge is by default).\n   * @returns {boolean}\n   */\n  scrollTo(sourceCol, beyondRendered) {\n    let newX = this.getTableParentOffset();\n    const sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;\n    const mainHolder = sourceInstance.wtTable.holder;\n    let scrollbarCompensation = 0;\n    if (beyondRendered) {\n      const columnWidth = this.wot.wtTable.getColumnWidth(sourceCol);\n      const viewportWidth = this.wot.wtViewport.getViewportWidth();\n      if (columnWidth > viewportWidth) {\n        beyondRendered = false;\n      }\n    }\n    if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {\n      scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    if (beyondRendered) {\n      newX += this.sumCellSizes(0, sourceCol + 1);\n      newX -= this.wot.wtViewport.getViewportWidth();\n    } else {\n      newX += this.sumCellSizes(this.wtSettings.getSetting('fixedColumnsStart'), sourceCol);\n    }\n    newX += scrollbarCompensation;\n    return this.setScrollPosition(newX);\n  }\n\n  /**\n   * Gets table parent left position.\n   *\n   * @returns {number}\n   */\n  getTableParentOffset() {\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let offset = 0;\n    if (!preventOverflow && this.trimmingContainer === this.domBindings.rootWindow) {\n      offset = this.wot.wtTable.holderOffset.left;\n    }\n    return offset;\n  }\n\n  /**\n   * Gets the main overlay's horizontal scroll position.\n   *\n   * @returns {number} Main table's horizontal scroll position.\n   */\n  getScrollPosition() {\n    return Math.abs(getScrollLeft(this.mainTableScrollableElement, this.domBindings.rootWindow));\n  }\n\n  /**\n   * Gets the main overlay's horizontal overlay offset.\n   *\n   * @returns {number} Main table's horizontal overlay offset.\n   */\n  getOverlayOffset() {\n    const {\n      rootWindow\n    } = this.domBindings;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let overlayOffset = 0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n      if (this.isRtl()) {\n        overlayOffset = Math.abs(Math.min(this.getTableParentOffset() - this.getScrollPosition(), 0));\n      } else {\n        overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);\n      }\n      const rootWidth = this.wot.wtTable.getTotalWidth();\n      const overlayRootWidth = this.clone.wtTable.getTotalWidth();\n      const maxOffset = rootWidth - overlayRootWidth;\n      if (overlayOffset > maxOffset) {\n        overlayOffset = 0;\n      }\n    }\n    return overlayOffset;\n  }\n\n  /**\n   * Adds css classes to hide the header border's header (cell-selection border hiding issue).\n   *\n   * @param {number} position Header X position if trimming container is window or scroll top if not.\n   * @returns {boolean}\n   */\n  adjustHeaderBordersPosition(position) {\n    const masterParent = this.wot.wtTable.holder.parentNode;\n    const rowHeaders = this.wtSettings.getSetting('rowHeaders');\n    const fixedColumnsStart = this.wtSettings.getSetting('fixedColumnsStart');\n    const totalRows = this.wtSettings.getSetting('totalRows');\n    if (totalRows) {\n      removeClass(masterParent, 'emptyRows');\n    } else {\n      addClass(masterParent, 'emptyRows');\n    }\n    let positionChanged = false;\n    if (fixedColumnsStart && !rowHeaders.length) {\n      // \"innerBorderLeft\" is for backward compatibility\n      addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n    } else if (!fixedColumnsStart && rowHeaders.length) {\n      const previousState = hasClass(masterParent, 'innerBorderInlineStart');\n      if (position) {\n        addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n        positionChanged = !previousState;\n      } else {\n        removeClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n        positionChanged = previousState;\n      }\n    }\n    return positionChanged;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}