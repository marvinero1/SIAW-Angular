{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { hasOwnProperty, deepClone } from \"../../helpers/object.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { arrayEach, arrayReduce, arrayMap } from \"../../helpers/array.mjs\";\nimport * as C from \"../../i18n/constants.mjs\";\nimport { top as menuItemTop, bottom as menuItemBottom, left as menuItemLeft, right as menuItemRight, noBorders as menuItemNoBorders } from \"./contextMenuItem/index.mjs\";\nimport { createId, createDefaultCustomBorder, createSingleEmptyBorder, createEmptyBorders, extendDefaultBorder, hasLeftRightTypeOptions, hasStartEndTypeOptions, toInlinePropName, normalizeBorder, denormalizeBorder } from \"./utils.mjs\";\nimport { detectSelectionType, normalizeSelectionFactory } from \"../../selection/index.mjs\";\nexport const PLUGIN_KEY = 'customBorders';\nexport const PLUGIN_PRIORITY = 90;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin CustomBorders\n * @class CustomBorders\n *\n * @description\n * This plugin enables an option to apply custom borders through the context menu (configurable with context menu key\n * `borders`).\n *\n * To initialize Handsontable with predefined custom borders, provide cell coordinates and border styles in a form\n * of an array.\n *\n * See [`customBorders` configuration option](@/api/options.md#customBorders) or go to\n * [Custom cell borders demo](@/guides/cell-features/formatting-cells.md#custom-cell-borders) for more examples.\n *\n * @example\n * ```js\n * customBorders: [\n *   {\n *    range: {\n *      from: {\n *        row: 1,\n *        col: 1\n *      },\n *      to: {\n *        row: 3,\n *        col: 4\n *      },\n *    },\n *    start: {},\n *    end: {},\n *    top: {},\n *    bottom: {},\n *   },\n * ],\n *\n * // or\n * customBorders: [\n *   { row: 2,\n *     col: 2,\n *     start: {\n *       width: 2,\n *       color: 'red',\n *     },\n *     end: {\n *       width: 1,\n *       color: 'green',\n *     },\n *     top: '',\n *     bottom: '',\n *   }\n * ],\n * ```\n */\nvar _onAfterContextMenuDefaultOptions = /*#__PURE__*/new WeakSet();\nvar _onAfterInit = /*#__PURE__*/new WeakSet();\nexport class CustomBorders extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `afterInit` hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterInit);\n    /**\n     * Add border options to context menu.\n     *\n     * @param {object} defaultOptions Context menu items.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterContextMenuDefaultOptions);\n    /**\n     * Saved borders.\n     *\n     * @private\n     * @type {Array}\n     */\n    _defineProperty(this, \"savedBorders\", []);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link CustomBorders#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => _classPrivateMethodGet(this, _onAfterContextMenuDefaultOptions, _onAfterContextMenuDefaultOptions2).call(this, options));\n    this.addHook('init', () => _classPrivateMethodGet(this, _onAfterInit, _onAfterInit2).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.hideBorders();\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`customBorders`](@/api/options.md#customborders)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.changeBorderSettings();\n    super.updatePlugin();\n  }\n\n  /**\n   * Set custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.setBorders([[1, 1, 2, 2], [6, 2, 0, 2]], {start: {width: 2, color: 'blue'}});\n   *\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * //  Selecting a cell range.\n   * hot.selectCell(0, 0, 2, 2);\n   * // Returning selected cells' range with the getSelectedRange method.\n   * customBordersPlugin.setBorders(hot.getSelectedRange(), {start: {hide: false, width: 2, color: 'blue'}});\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   * @param {object} borderObject Object with `top`, `right`, `bottom` and `start` properties.\n   */\n  setBorders(selectionRanges, borderObject) {\n    let borderKeys = ['top', 'bottom', 'start', 'end'];\n    let normBorder = null;\n    if (borderObject) {\n      this.checkSettingsCohesion([borderObject]);\n      borderKeys = Object.keys(borderObject);\n      normBorder = normalizeBorder(borderObject);\n    }\n    const selectionType = detectSelectionType(selectionRanges);\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: this.hot._createCellCoords.bind(this.hot),\n      createCellRange: this.hot._createCellRange.bind(this.hot)\n    });\n    arrayEach(selectionRanges, selection => {\n      selectionSchemaNormalizer(selection).forAll((row, col) => {\n        arrayEach(borderKeys, borderKey => {\n          this.prepareBorderFromCustomAdded(row, col, normBorder, toInlinePropName(borderKey));\n        });\n      });\n    });\n\n    /*\n    The line below triggers a re-render of Handsontable. This will be a \"fastDraw\"\n    render, because that is the default for the TableView class.\n     The re-render is needed for borders on cells that did not have a border before.\n    The way this call works is that it calls Table.refreshSelections, which calls\n    Selection.getBorder, which creates a new instance of Border.\n     Seems wise to keep this single-direction flow of creating new Borders\n    */\n    this.hot.view.render();\n  }\n\n  /**\n   * Get custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.getBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * customBordersPlugin.getBorders(hot.getSelectedRange());\n   * // Using without param - return all customBorders.\n   * customBordersPlugin.getBorders();\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   * @returns {object[]} Returns array of border objects.\n   */\n  getBorders(selectionRanges) {\n    if (!Array.isArray(selectionRanges)) {\n      return this.savedBorders;\n    }\n    const selectionType = detectSelectionType(selectionRanges);\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: this.hot._createCellCoords.bind(this.hot),\n      createCellRange: this.hot._createCellRange.bind(this.hot)\n    });\n    const selectedBorders = [];\n    arrayEach(selectionRanges, selection => {\n      selectionSchemaNormalizer(selection).forAll((row, col) => {\n        arrayEach(this.savedBorders, border => {\n          if (border.row === row && border.col === col) {\n            selectedBorders.push(denormalizeBorder(border));\n          }\n        });\n      });\n    });\n    return selectedBorders;\n  }\n\n  /**\n   * Clear custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.clearBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * customBordersPlugin.clearBorders(hot.getSelectedRange());\n   * // Using without param - clear all customBorders.\n   * customBordersPlugin.clearBorders();\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   */\n  clearBorders(selectionRanges) {\n    if (selectionRanges) {\n      this.setBorders(selectionRanges);\n    } else {\n      arrayEach(this.savedBorders, border => {\n        this.clearBordersFromSelectionSettings(border.id);\n        this.clearNullCellRange();\n        this.hot.removeCellMeta(border.row, border.col, 'borders');\n      });\n      this.savedBorders.length = 0;\n    }\n  }\n\n  /**\n   * Insert WalkontableSelection instance into Walkontable settings.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   */\n  insertBorderIntoSettings(border, place) {\n    const hasSavedBorders = this.checkSavedBorders(border);\n    if (!hasSavedBorders) {\n      this.savedBorders.push(border);\n    }\n    const visualCellRange = this.hot._createCellRange(this.hot._createCellCoords(border.row, border.col));\n    const hasCustomSelections = this.checkCustomSelections(border, visualCellRange, place);\n    if (!hasCustomSelections) {\n      this.hot.selection.highlight.addCustomSelection({\n        border,\n        visualCellRange\n      });\n    }\n  }\n\n  /**\n   * Prepare borders from setting (single cell).\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} borderDescriptor Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   */\n  prepareBorderFromCustomAdded(row, column, borderDescriptor, place) {\n    const nrOfRows = this.hot.countRows();\n    const nrOfColumns = this.hot.countCols();\n    if (row >= nrOfRows || column >= nrOfColumns) {\n      return;\n    }\n    let border = createEmptyBorders(row, column);\n    if (borderDescriptor) {\n      border = extendDefaultBorder(border, borderDescriptor);\n      arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n        if (border.id === customSelection.settings.id) {\n          Object.assign(customSelection.settings, borderDescriptor);\n          border.id = customSelection.settings.id;\n          border.top = customSelection.settings.top;\n          border.bottom = customSelection.settings.bottom;\n          border.start = customSelection.settings.start;\n          border.end = customSelection.settings.end;\n          return false; // breaks forAll\n        }\n      });\n    }\n\n    this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(border));\n    this.insertBorderIntoSettings(border, place);\n  }\n\n  /**\n   * Prepare borders from setting (object).\n   *\n   * @private\n   * @param {object} range {CellRange} The CellRange object.\n   * @param {object} customBorder Object with `start`, `end`, `top` and `bottom` properties.\n   */\n  prepareBorderFromCustomAddedRange(range, customBorder) {\n    const lastRowIndex = Math.min(range.to.row, this.hot.countRows() - 1);\n    const lastColumnIndex = Math.min(range.to.col, this.hot.countCols() - 1);\n    rangeEach(range.from.row, lastRowIndex, rowIndex => {\n      rangeEach(range.from.col, lastColumnIndex, colIndex => {\n        const border = createEmptyBorders(rowIndex, colIndex);\n        let add = 0;\n        if (rowIndex === range.from.row) {\n          if (hasOwnProperty(customBorder, 'top')) {\n            add += 1;\n            border.top = customBorder.top;\n          }\n        }\n\n        // Please keep in mind that `range.to.row` may be beyond the table boundaries. The border won't be rendered.\n        if (rowIndex === range.to.row) {\n          if (hasOwnProperty(customBorder, 'bottom')) {\n            add += 1;\n            border.bottom = customBorder.bottom;\n          }\n        }\n        if (colIndex === range.from.col) {\n          if (hasOwnProperty(customBorder, 'start')) {\n            add += 1;\n            border.start = customBorder.start;\n          }\n        }\n\n        // Please keep in mind that `range.to.col` may be beyond the table boundaries. The border won't be rendered.\n        if (colIndex === range.to.col) {\n          if (hasOwnProperty(customBorder, 'end')) {\n            add += 1;\n            border.end = customBorder.end;\n          }\n        }\n        if (add > 0) {\n          this.hot.setCellMeta(rowIndex, colIndex, 'borders', denormalizeBorder(border));\n          this.insertBorderIntoSettings(border);\n        } else {\n          // TODO sometimes it enters here. Why?\n        }\n      });\n    });\n  }\n\n  /**\n   * Remove border (triggered from context menu).\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   */\n  removeAllBorders(row, column) {\n    const borderId = createId(row, column);\n    this.spliceBorder(borderId);\n    this.clearBordersFromSelectionSettings(borderId);\n    this.clearNullCellRange();\n    this.hot.removeCellMeta(row, column, 'borders');\n  }\n\n  /**\n   * Set borders for each cell re. To border position.\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   */\n  setBorder(row, column, place, remove) {\n    let bordersMeta = this.hot.getCellMeta(row, column).borders;\n    if (!bordersMeta || bordersMeta.border === undefined) {\n      bordersMeta = createEmptyBorders(row, column);\n    } else {\n      bordersMeta = normalizeBorder(bordersMeta);\n    }\n    if (remove) {\n      bordersMeta[place] = createSingleEmptyBorder();\n      const hideCount = this.countHide(bordersMeta);\n      if (hideCount === 4) {\n        this.removeAllBorders(row, column);\n      } else {\n        const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);\n        if (!customSelectionsChecker) {\n          this.insertBorderIntoSettings(bordersMeta);\n        }\n        this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(bordersMeta));\n      }\n    } else {\n      bordersMeta[place] = createDefaultCustomBorder();\n      const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);\n      if (!customSelectionsChecker) {\n        this.insertBorderIntoSettings(bordersMeta);\n      }\n      this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(bordersMeta));\n    }\n  }\n\n  /**\n   * Prepare borders based on cell and border position.\n   *\n   * @private\n   * @param {CellRange[]} selected An array of CellRange objects.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   */\n  prepareBorder(selected, place, remove) {\n    arrayEach(selected, _ref => {\n      let {\n        start,\n        end\n      } = _ref;\n      if (start.row === end.row && start.col === end.col) {\n        if (place === 'noBorders') {\n          this.removeAllBorders(start.row, start.col);\n        } else {\n          this.setBorder(start.row, start.col, place, remove);\n        }\n      } else {\n        switch (place) {\n          case 'noBorders':\n            rangeEach(start.col, end.col, colIndex => {\n              rangeEach(start.row, end.row, rowIndex => {\n                this.removeAllBorders(rowIndex, colIndex);\n              });\n            });\n            break;\n          case 'top':\n            rangeEach(start.col, end.col, topCol => {\n              this.setBorder(start.row, topCol, place, remove);\n            });\n            break;\n          case 'bottom':\n            rangeEach(start.col, end.col, bottomCol => {\n              this.setBorder(end.row, bottomCol, place, remove);\n            });\n            break;\n          case 'start':\n            rangeEach(start.row, end.row, rowStart => {\n              this.setBorder(rowStart, start.col, place, remove);\n            });\n            break;\n          case 'end':\n            rangeEach(start.row, end.row, rowEnd => {\n              this.setBorder(rowEnd, end.col, place, remove);\n            });\n            break;\n          default:\n            break;\n        }\n      }\n    });\n  }\n\n  /**\n   * Create borders from settings.\n   *\n   * @private\n   * @param {Array} customBorders Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.\n   */\n  createCustomBorders(customBorders) {\n    arrayEach(customBorders, customBorder => {\n      const normCustomBorder = normalizeBorder(customBorder);\n      if (customBorder.range) {\n        this.prepareBorderFromCustomAddedRange(customBorder.range, normCustomBorder);\n      } else {\n        this.prepareBorderFromCustomAdded(customBorder.row, customBorder.col, normCustomBorder);\n      }\n    });\n  }\n\n  /**\n   * Count hide property in border object.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @returns {number}\n   */\n  countHide(border) {\n    const {\n      top,\n      bottom,\n      start,\n      end\n    } = border;\n    const values = [top, bottom, start, end];\n    return arrayReduce(values, (accumulator, value) => {\n      let result = accumulator;\n      if (value && value.hide) {\n        result += 1;\n      }\n      return result;\n    }, 0);\n  }\n\n  /**\n   * Clear borders settings from custom selections.\n   *\n   * @private\n   * @param {string} borderId Border id name as string.\n   */\n  clearBordersFromSelectionSettings(borderId) {\n    const index = arrayMap(this.hot.selection.highlight.customSelections, customSelection => customSelection.settings.id).indexOf(borderId);\n    if (index > -1) {\n      this.hot.selection.highlight.customSelections[index].clear();\n    }\n  }\n\n  /**\n   * Clear cellRange with null value.\n   *\n   * @private\n   */\n  clearNullCellRange() {\n    arrayEach(this.hot.selection.highlight.customSelections, (customSelection, index) => {\n      if (customSelection.cellRange === null) {\n        this.hot.selection.highlight.customSelections[index].destroy();\n        this.hot.selection.highlight.customSelections.splice(index, 1);\n        return false; // breaks forAll\n      }\n    });\n  }\n\n  /**\n   * Hide custom borders.\n   *\n   * @private\n   */\n  hideBorders() {\n    arrayEach(this.savedBorders, border => {\n      this.clearBordersFromSelectionSettings(border.id);\n      this.clearNullCellRange();\n    });\n  }\n\n  /**\n   * Splice border from savedBorders.\n   *\n   * @private\n   * @param {string} borderId Border id name as string.\n   */\n  spliceBorder(borderId) {\n    const index = arrayMap(this.savedBorders, border => border.id).indexOf(borderId);\n    if (index > -1) {\n      this.savedBorders.splice(index, 1);\n    }\n  }\n\n  /**\n   * Check if an border already exists in the savedBorders array, and if true update border in savedBorders.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   *\n   * @returns {boolean}\n   */\n  checkSavedBorders(border) {\n    let check = false;\n    const hideCount = this.countHide(border);\n    if (hideCount === 4) {\n      this.spliceBorder(border.id);\n      check = true;\n    } else {\n      arrayEach(this.savedBorders, (savedBorder, index) => {\n        if (border.id === savedBorder.id) {\n          this.savedBorders[index] = border;\n          check = true;\n          return false; // breaks forAll\n        }\n      });\n    }\n\n    return check;\n  }\n\n  /**\n   * Check if an border already exists in the customSelections, and if true call toggleHiddenClass method.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   *\n   * @returns {boolean}\n   */\n  checkCustomSelectionsFromContextMenu(border, place, remove) {\n    let check = false;\n    arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n      if (border.id === customSelection.settings.id) {\n        const borders = this.hot.view._wt.selectionManager.getBorderInstances(customSelection);\n        arrayEach(borders, borderObject => {\n          borderObject.toggleHiddenClass(place, remove); // TODO this also bad?\n        });\n\n        check = true;\n        return false; // breaks forAll\n      }\n    });\n\n    return check;\n  }\n\n  /**\n   * Check if an border already exists in the customSelections, and if true reset cellRange.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {CellRange} cellRange The selection range to check.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   * @returns {boolean}\n   */\n  checkCustomSelections(border, cellRange, place) {\n    const hideCount = this.countHide(border);\n    let check = false;\n    if (hideCount === 4) {\n      this.removeAllBorders(border.row, border.col);\n      check = true;\n    } else {\n      arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n        if (border.id === customSelection.settings.id) {\n          customSelection.visualCellRange = cellRange;\n          customSelection.commit();\n          if (place) {\n            const borders = this.hot.view._wt.selectionManager.getBorderInstances(customSelection);\n            arrayEach(borders, borderObject => {\n              borderObject.changeBorderStyle(place, border);\n            });\n          }\n          check = true;\n          return false; // breaks forAll\n        }\n      });\n    }\n\n    return check;\n  }\n\n  /**\n   * Change borders from settings.\n   *\n   * @private\n   */\n  changeBorderSettings() {\n    const customBorders = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(customBorders)) {\n      const bordersClone = deepClone(customBorders);\n      this.checkSettingsCohesion(bordersClone);\n      if (!bordersClone.length) {\n        this.savedBorders = bordersClone;\n      }\n      this.createCustomBorders(bordersClone);\n    } else if (customBorders !== undefined) {\n      this.createCustomBorders(this.savedBorders);\n    }\n  }\n\n  /**\n   * Checks the settings cohesion. The properties such like \"left\"/\"right\" are supported only\n   * in the LTR mode and the \"left\"/\"right\" options can not be used together with \"start\"/\"end\" properties.\n   *\n   * @private\n   * @param {object[]} customBorders The user defined custom border objects array.\n   */\n  checkSettingsCohesion(customBorders) {\n    const hasLeftOrRight = hasLeftRightTypeOptions(customBorders);\n    const hasStartOrEnd = hasStartEndTypeOptions(customBorders);\n    if (hasLeftOrRight && hasStartOrEnd) {\n      throw new Error('The \"left\"/\"right\" and \"start\"/\"end\" options should not be used together. ' + 'Please use only the option \"start\"/\"end\".');\n    }\n    if (this.hot.isRtl() && hasLeftOrRight) {\n      throw new Error('The \"left\"/\"right\" properties are not supported for RTL. Please use option \"start\"/\"end\".');\n    }\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onAfterContextMenuDefaultOptions2(defaultOptions) {\n  if (!this.hot.getSettings()[PLUGIN_KEY]) {\n    return;\n  }\n  defaultOptions.items.push({\n    name: '---------'\n  }, {\n    key: 'borders',\n    name() {\n      return this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_BORDERS);\n    },\n    disabled() {\n      const range = this.getSelectedRangeLast();\n      if (!range) {\n        return true;\n      }\n      if (range.isSingleHeader()) {\n        return true;\n      }\n      return this.selection.isSelectedByCorner();\n    },\n    submenu: {\n      items: [menuItemTop(this), menuItemRight(this), menuItemBottom(this), menuItemLeft(this), menuItemNoBorders(this)]\n    }\n  });\n}\nfunction _onAfterInit2() {\n  this.changeBorderSettings();\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","obj","privateSet","_checkPrivateRedeclaration","add","privateCollection","has","TypeError","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","Number","_classPrivateMethodGet","receiver","fn","BasePlugin","hasOwnProperty","deepClone","rangeEach","arrayEach","arrayReduce","arrayMap","C","top","menuItemTop","bottom","menuItemBottom","left","menuItemLeft","right","menuItemRight","noBorders","menuItemNoBorders","createId","createDefaultCustomBorder","createSingleEmptyBorder","createEmptyBorders","extendDefaultBorder","hasLeftRightTypeOptions","hasStartEndTypeOptions","toInlinePropName","normalizeBorder","denormalizeBorder","detectSelectionType","normalizeSelectionFactory","PLUGIN_KEY","PLUGIN_PRIORITY","_onAfterContextMenuDefaultOptions","WeakSet","_onAfterInit","CustomBorders","constructor","arguments","isEnabled","hot","getSettings","enablePlugin","enabled","addHook","options","_onAfterContextMenuDefaultOptions2","_onAfterInit2","disablePlugin","hideBorders","updatePlugin","changeBorderSettings","setBorders","selectionRanges","borderObject","borderKeys","normBorder","checkSettingsCohesion","keys","selectionType","selectionSchemaNormalizer","createCellCoords","_createCellCoords","bind","createCellRange","_createCellRange","selection","forAll","row","col","borderKey","prepareBorderFromCustomAdded","view","render","getBorders","Array","isArray","savedBorders","selectedBorders","border","push","clearBorders","clearBordersFromSelectionSettings","id","clearNullCellRange","removeCellMeta","length","insertBorderIntoSettings","place","hasSavedBorders","checkSavedBorders","visualCellRange","hasCustomSelections","checkCustomSelections","highlight","addCustomSelection","column","borderDescriptor","nrOfRows","countRows","nrOfColumns","countCols","customSelections","customSelection","settings","assign","start","end","setCellMeta","prepareBorderFromCustomAddedRange","range","customBorder","lastRowIndex","Math","min","to","lastColumnIndex","from","rowIndex","colIndex","removeAllBorders","borderId","spliceBorder","setBorder","remove","bordersMeta","getCellMeta","borders","undefined","hideCount","countHide","customSelectionsChecker","checkCustomSelectionsFromContextMenu","prepareBorder","selected","_ref","topCol","bottomCol","rowStart","rowEnd","createCustomBorders","customBorders","normCustomBorder","values","accumulator","result","hide","index","indexOf","clear","cellRange","destroy","splice","check","savedBorder","_wt","selectionManager","getBorderInstances","toggleHiddenClass","commit","changeBorderStyle","bordersClone","hasLeftOrRight","hasStartOrEnd","Error","isRtl","defaultOptions","items","name","getTranslatedPhrase","CONTEXTMENU_ITEMS_BORDERS","disabled","getSelectedRangeLast","isSingleHeader","isSelectedByCorner","submenu"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/customBorders/customBorders.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { hasOwnProperty, deepClone } from \"../../helpers/object.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { arrayEach, arrayReduce, arrayMap } from \"../../helpers/array.mjs\";\nimport * as C from \"../../i18n/constants.mjs\";\nimport { top as menuItemTop, bottom as menuItemBottom, left as menuItemLeft, right as menuItemRight, noBorders as menuItemNoBorders } from \"./contextMenuItem/index.mjs\";\nimport { createId, createDefaultCustomBorder, createSingleEmptyBorder, createEmptyBorders, extendDefaultBorder, hasLeftRightTypeOptions, hasStartEndTypeOptions, toInlinePropName, normalizeBorder, denormalizeBorder } from \"./utils.mjs\";\nimport { detectSelectionType, normalizeSelectionFactory } from \"../../selection/index.mjs\";\nexport const PLUGIN_KEY = 'customBorders';\nexport const PLUGIN_PRIORITY = 90;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin CustomBorders\n * @class CustomBorders\n *\n * @description\n * This plugin enables an option to apply custom borders through the context menu (configurable with context menu key\n * `borders`).\n *\n * To initialize Handsontable with predefined custom borders, provide cell coordinates and border styles in a form\n * of an array.\n *\n * See [`customBorders` configuration option](@/api/options.md#customBorders) or go to\n * [Custom cell borders demo](@/guides/cell-features/formatting-cells.md#custom-cell-borders) for more examples.\n *\n * @example\n * ```js\n * customBorders: [\n *   {\n *    range: {\n *      from: {\n *        row: 1,\n *        col: 1\n *      },\n *      to: {\n *        row: 3,\n *        col: 4\n *      },\n *    },\n *    start: {},\n *    end: {},\n *    top: {},\n *    bottom: {},\n *   },\n * ],\n *\n * // or\n * customBorders: [\n *   { row: 2,\n *     col: 2,\n *     start: {\n *       width: 2,\n *       color: 'red',\n *     },\n *     end: {\n *       width: 1,\n *       color: 'green',\n *     },\n *     top: '',\n *     bottom: '',\n *   }\n * ],\n * ```\n */\nvar _onAfterContextMenuDefaultOptions = /*#__PURE__*/new WeakSet();\nvar _onAfterInit = /*#__PURE__*/new WeakSet();\nexport class CustomBorders extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `afterInit` hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterInit);\n    /**\n     * Add border options to context menu.\n     *\n     * @param {object} defaultOptions Context menu items.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterContextMenuDefaultOptions);\n    /**\n     * Saved borders.\n     *\n     * @private\n     * @type {Array}\n     */\n    _defineProperty(this, \"savedBorders\", []);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link CustomBorders#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.addHook('afterContextMenuDefaultOptions', options => _classPrivateMethodGet(this, _onAfterContextMenuDefaultOptions, _onAfterContextMenuDefaultOptions2).call(this, options));\n    this.addHook('init', () => _classPrivateMethodGet(this, _onAfterInit, _onAfterInit2).call(this));\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.hideBorders();\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`customBorders`](@/api/options.md#customborders)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.changeBorderSettings();\n    super.updatePlugin();\n  }\n\n  /**\n   * Set custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.setBorders([[1, 1, 2, 2], [6, 2, 0, 2]], {start: {width: 2, color: 'blue'}});\n   *\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * //  Selecting a cell range.\n   * hot.selectCell(0, 0, 2, 2);\n   * // Returning selected cells' range with the getSelectedRange method.\n   * customBordersPlugin.setBorders(hot.getSelectedRange(), {start: {hide: false, width: 2, color: 'blue'}});\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   * @param {object} borderObject Object with `top`, `right`, `bottom` and `start` properties.\n   */\n  setBorders(selectionRanges, borderObject) {\n    let borderKeys = ['top', 'bottom', 'start', 'end'];\n    let normBorder = null;\n    if (borderObject) {\n      this.checkSettingsCohesion([borderObject]);\n      borderKeys = Object.keys(borderObject);\n      normBorder = normalizeBorder(borderObject);\n    }\n    const selectionType = detectSelectionType(selectionRanges);\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: this.hot._createCellCoords.bind(this.hot),\n      createCellRange: this.hot._createCellRange.bind(this.hot)\n    });\n    arrayEach(selectionRanges, selection => {\n      selectionSchemaNormalizer(selection).forAll((row, col) => {\n        arrayEach(borderKeys, borderKey => {\n          this.prepareBorderFromCustomAdded(row, col, normBorder, toInlinePropName(borderKey));\n        });\n      });\n    });\n\n    /*\n    The line below triggers a re-render of Handsontable. This will be a \"fastDraw\"\n    render, because that is the default for the TableView class.\n     The re-render is needed for borders on cells that did not have a border before.\n    The way this call works is that it calls Table.refreshSelections, which calls\n    Selection.getBorder, which creates a new instance of Border.\n     Seems wise to keep this single-direction flow of creating new Borders\n    */\n    this.hot.view.render();\n  }\n\n  /**\n   * Get custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.getBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * customBordersPlugin.getBorders(hot.getSelectedRange());\n   * // Using without param - return all customBorders.\n   * customBordersPlugin.getBorders();\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   * @returns {object[]} Returns array of border objects.\n   */\n  getBorders(selectionRanges) {\n    if (!Array.isArray(selectionRanges)) {\n      return this.savedBorders;\n    }\n    const selectionType = detectSelectionType(selectionRanges);\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: this.hot._createCellCoords.bind(this.hot),\n      createCellRange: this.hot._createCellRange.bind(this.hot)\n    });\n    const selectedBorders = [];\n    arrayEach(selectionRanges, selection => {\n      selectionSchemaNormalizer(selection).forAll((row, col) => {\n        arrayEach(this.savedBorders, border => {\n          if (border.row === row && border.col === col) {\n            selectedBorders.push(denormalizeBorder(border));\n          }\n        });\n      });\n    });\n    return selectedBorders;\n  }\n\n  /**\n   * Clear custom borders.\n   *\n   * @example\n   * ```js\n   * const customBordersPlugin = hot.getPlugin('customBorders');\n   *\n   * // Using an array of arrays (produced by `.getSelected()` method).\n   * customBordersPlugin.clearBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * customBordersPlugin.clearBorders(hot.getSelectedRange());\n   * // Using without param - clear all customBorders.\n   * customBordersPlugin.clearBorders();\n   * ```\n   *\n   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.\n   */\n  clearBorders(selectionRanges) {\n    if (selectionRanges) {\n      this.setBorders(selectionRanges);\n    } else {\n      arrayEach(this.savedBorders, border => {\n        this.clearBordersFromSelectionSettings(border.id);\n        this.clearNullCellRange();\n        this.hot.removeCellMeta(border.row, border.col, 'borders');\n      });\n      this.savedBorders.length = 0;\n    }\n  }\n\n  /**\n   * Insert WalkontableSelection instance into Walkontable settings.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   */\n  insertBorderIntoSettings(border, place) {\n    const hasSavedBorders = this.checkSavedBorders(border);\n    if (!hasSavedBorders) {\n      this.savedBorders.push(border);\n    }\n    const visualCellRange = this.hot._createCellRange(this.hot._createCellCoords(border.row, border.col));\n    const hasCustomSelections = this.checkCustomSelections(border, visualCellRange, place);\n    if (!hasCustomSelections) {\n      this.hot.selection.highlight.addCustomSelection({\n        border,\n        visualCellRange\n      });\n    }\n  }\n\n  /**\n   * Prepare borders from setting (single cell).\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} borderDescriptor Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   */\n  prepareBorderFromCustomAdded(row, column, borderDescriptor, place) {\n    const nrOfRows = this.hot.countRows();\n    const nrOfColumns = this.hot.countCols();\n    if (row >= nrOfRows || column >= nrOfColumns) {\n      return;\n    }\n    let border = createEmptyBorders(row, column);\n    if (borderDescriptor) {\n      border = extendDefaultBorder(border, borderDescriptor);\n      arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n        if (border.id === customSelection.settings.id) {\n          Object.assign(customSelection.settings, borderDescriptor);\n          border.id = customSelection.settings.id;\n          border.top = customSelection.settings.top;\n          border.bottom = customSelection.settings.bottom;\n          border.start = customSelection.settings.start;\n          border.end = customSelection.settings.end;\n          return false; // breaks forAll\n        }\n      });\n    }\n    this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(border));\n    this.insertBorderIntoSettings(border, place);\n  }\n\n  /**\n   * Prepare borders from setting (object).\n   *\n   * @private\n   * @param {object} range {CellRange} The CellRange object.\n   * @param {object} customBorder Object with `start`, `end`, `top` and `bottom` properties.\n   */\n  prepareBorderFromCustomAddedRange(range, customBorder) {\n    const lastRowIndex = Math.min(range.to.row, this.hot.countRows() - 1);\n    const lastColumnIndex = Math.min(range.to.col, this.hot.countCols() - 1);\n    rangeEach(range.from.row, lastRowIndex, rowIndex => {\n      rangeEach(range.from.col, lastColumnIndex, colIndex => {\n        const border = createEmptyBorders(rowIndex, colIndex);\n        let add = 0;\n        if (rowIndex === range.from.row) {\n          if (hasOwnProperty(customBorder, 'top')) {\n            add += 1;\n            border.top = customBorder.top;\n          }\n        }\n\n        // Please keep in mind that `range.to.row` may be beyond the table boundaries. The border won't be rendered.\n        if (rowIndex === range.to.row) {\n          if (hasOwnProperty(customBorder, 'bottom')) {\n            add += 1;\n            border.bottom = customBorder.bottom;\n          }\n        }\n        if (colIndex === range.from.col) {\n          if (hasOwnProperty(customBorder, 'start')) {\n            add += 1;\n            border.start = customBorder.start;\n          }\n        }\n\n        // Please keep in mind that `range.to.col` may be beyond the table boundaries. The border won't be rendered.\n        if (colIndex === range.to.col) {\n          if (hasOwnProperty(customBorder, 'end')) {\n            add += 1;\n            border.end = customBorder.end;\n          }\n        }\n        if (add > 0) {\n          this.hot.setCellMeta(rowIndex, colIndex, 'borders', denormalizeBorder(border));\n          this.insertBorderIntoSettings(border);\n        } else {\n          // TODO sometimes it enters here. Why?\n        }\n      });\n    });\n  }\n\n  /**\n   * Remove border (triggered from context menu).\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   */\n  removeAllBorders(row, column) {\n    const borderId = createId(row, column);\n    this.spliceBorder(borderId);\n    this.clearBordersFromSelectionSettings(borderId);\n    this.clearNullCellRange();\n    this.hot.removeCellMeta(row, column, 'borders');\n  }\n\n  /**\n   * Set borders for each cell re. To border position.\n   *\n   * @private\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   */\n  setBorder(row, column, place, remove) {\n    let bordersMeta = this.hot.getCellMeta(row, column).borders;\n    if (!bordersMeta || bordersMeta.border === undefined) {\n      bordersMeta = createEmptyBorders(row, column);\n    } else {\n      bordersMeta = normalizeBorder(bordersMeta);\n    }\n    if (remove) {\n      bordersMeta[place] = createSingleEmptyBorder();\n      const hideCount = this.countHide(bordersMeta);\n      if (hideCount === 4) {\n        this.removeAllBorders(row, column);\n      } else {\n        const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);\n        if (!customSelectionsChecker) {\n          this.insertBorderIntoSettings(bordersMeta);\n        }\n        this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(bordersMeta));\n      }\n    } else {\n      bordersMeta[place] = createDefaultCustomBorder();\n      const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);\n      if (!customSelectionsChecker) {\n        this.insertBorderIntoSettings(bordersMeta);\n      }\n      this.hot.setCellMeta(row, column, 'borders', denormalizeBorder(bordersMeta));\n    }\n  }\n\n  /**\n   * Prepare borders based on cell and border position.\n   *\n   * @private\n   * @param {CellRange[]} selected An array of CellRange objects.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   */\n  prepareBorder(selected, place, remove) {\n    arrayEach(selected, _ref => {\n      let {\n        start,\n        end\n      } = _ref;\n      if (start.row === end.row && start.col === end.col) {\n        if (place === 'noBorders') {\n          this.removeAllBorders(start.row, start.col);\n        } else {\n          this.setBorder(start.row, start.col, place, remove);\n        }\n      } else {\n        switch (place) {\n          case 'noBorders':\n            rangeEach(start.col, end.col, colIndex => {\n              rangeEach(start.row, end.row, rowIndex => {\n                this.removeAllBorders(rowIndex, colIndex);\n              });\n            });\n            break;\n          case 'top':\n            rangeEach(start.col, end.col, topCol => {\n              this.setBorder(start.row, topCol, place, remove);\n            });\n            break;\n          case 'bottom':\n            rangeEach(start.col, end.col, bottomCol => {\n              this.setBorder(end.row, bottomCol, place, remove);\n            });\n            break;\n          case 'start':\n            rangeEach(start.row, end.row, rowStart => {\n              this.setBorder(rowStart, start.col, place, remove);\n            });\n            break;\n          case 'end':\n            rangeEach(start.row, end.row, rowEnd => {\n              this.setBorder(rowEnd, end.col, place, remove);\n            });\n            break;\n          default:\n            break;\n        }\n      }\n    });\n  }\n\n  /**\n   * Create borders from settings.\n   *\n   * @private\n   * @param {Array} customBorders Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.\n   */\n  createCustomBorders(customBorders) {\n    arrayEach(customBorders, customBorder => {\n      const normCustomBorder = normalizeBorder(customBorder);\n      if (customBorder.range) {\n        this.prepareBorderFromCustomAddedRange(customBorder.range, normCustomBorder);\n      } else {\n        this.prepareBorderFromCustomAdded(customBorder.row, customBorder.col, normCustomBorder);\n      }\n    });\n  }\n\n  /**\n   * Count hide property in border object.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @returns {number}\n   */\n  countHide(border) {\n    const {\n      top,\n      bottom,\n      start,\n      end\n    } = border;\n    const values = [top, bottom, start, end];\n    return arrayReduce(values, (accumulator, value) => {\n      let result = accumulator;\n      if (value && value.hide) {\n        result += 1;\n      }\n      return result;\n    }, 0);\n  }\n\n  /**\n   * Clear borders settings from custom selections.\n   *\n   * @private\n   * @param {string} borderId Border id name as string.\n   */\n  clearBordersFromSelectionSettings(borderId) {\n    const index = arrayMap(this.hot.selection.highlight.customSelections, customSelection => customSelection.settings.id).indexOf(borderId);\n    if (index > -1) {\n      this.hot.selection.highlight.customSelections[index].clear();\n    }\n  }\n\n  /**\n   * Clear cellRange with null value.\n   *\n   * @private\n   */\n  clearNullCellRange() {\n    arrayEach(this.hot.selection.highlight.customSelections, (customSelection, index) => {\n      if (customSelection.cellRange === null) {\n        this.hot.selection.highlight.customSelections[index].destroy();\n        this.hot.selection.highlight.customSelections.splice(index, 1);\n        return false; // breaks forAll\n      }\n    });\n  }\n\n  /**\n   * Hide custom borders.\n   *\n   * @private\n   */\n  hideBorders() {\n    arrayEach(this.savedBorders, border => {\n      this.clearBordersFromSelectionSettings(border.id);\n      this.clearNullCellRange();\n    });\n  }\n\n  /**\n   * Splice border from savedBorders.\n   *\n   * @private\n   * @param {string} borderId Border id name as string.\n   */\n  spliceBorder(borderId) {\n    const index = arrayMap(this.savedBorders, border => border.id).indexOf(borderId);\n    if (index > -1) {\n      this.savedBorders.splice(index, 1);\n    }\n  }\n\n  /**\n   * Check if an border already exists in the savedBorders array, and if true update border in savedBorders.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   *\n   * @returns {boolean}\n   */\n  checkSavedBorders(border) {\n    let check = false;\n    const hideCount = this.countHide(border);\n    if (hideCount === 4) {\n      this.spliceBorder(border.id);\n      check = true;\n    } else {\n      arrayEach(this.savedBorders, (savedBorder, index) => {\n        if (border.id === savedBorder.id) {\n          this.savedBorders[index] = border;\n          check = true;\n          return false; // breaks forAll\n        }\n      });\n    }\n    return check;\n  }\n\n  /**\n   * Check if an border already exists in the customSelections, and if true call toggleHiddenClass method.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.\n   * @param {boolean} remove True when remove borders, and false when add borders.\n   *\n   * @returns {boolean}\n   */\n  checkCustomSelectionsFromContextMenu(border, place, remove) {\n    let check = false;\n    arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n      if (border.id === customSelection.settings.id) {\n        const borders = this.hot.view._wt.selectionManager.getBorderInstances(customSelection);\n        arrayEach(borders, borderObject => {\n          borderObject.toggleHiddenClass(place, remove); // TODO this also bad?\n        });\n        check = true;\n        return false; // breaks forAll\n      }\n    });\n    return check;\n  }\n\n  /**\n   * Check if an border already exists in the customSelections, and if true reset cellRange.\n   *\n   * @private\n   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and\n   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.\n   * @param {CellRange} cellRange The selection range to check.\n   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.\n   * @returns {boolean}\n   */\n  checkCustomSelections(border, cellRange, place) {\n    const hideCount = this.countHide(border);\n    let check = false;\n    if (hideCount === 4) {\n      this.removeAllBorders(border.row, border.col);\n      check = true;\n    } else {\n      arrayEach(this.hot.selection.highlight.customSelections, customSelection => {\n        if (border.id === customSelection.settings.id) {\n          customSelection.visualCellRange = cellRange;\n          customSelection.commit();\n          if (place) {\n            const borders = this.hot.view._wt.selectionManager.getBorderInstances(customSelection);\n            arrayEach(borders, borderObject => {\n              borderObject.changeBorderStyle(place, border);\n            });\n          }\n          check = true;\n          return false; // breaks forAll\n        }\n      });\n    }\n    return check;\n  }\n\n  /**\n   * Change borders from settings.\n   *\n   * @private\n   */\n  changeBorderSettings() {\n    const customBorders = this.hot.getSettings()[PLUGIN_KEY];\n    if (Array.isArray(customBorders)) {\n      const bordersClone = deepClone(customBorders);\n      this.checkSettingsCohesion(bordersClone);\n      if (!bordersClone.length) {\n        this.savedBorders = bordersClone;\n      }\n      this.createCustomBorders(bordersClone);\n    } else if (customBorders !== undefined) {\n      this.createCustomBorders(this.savedBorders);\n    }\n  }\n\n  /**\n   * Checks the settings cohesion. The properties such like \"left\"/\"right\" are supported only\n   * in the LTR mode and the \"left\"/\"right\" options can not be used together with \"start\"/\"end\" properties.\n   *\n   * @private\n   * @param {object[]} customBorders The user defined custom border objects array.\n   */\n  checkSettingsCohesion(customBorders) {\n    const hasLeftOrRight = hasLeftRightTypeOptions(customBorders);\n    const hasStartOrEnd = hasStartEndTypeOptions(customBorders);\n    if (hasLeftOrRight && hasStartOrEnd) {\n      throw new Error('The \"left\"/\"right\" and \"start\"/\"end\" options should not be used together. ' + 'Please use only the option \"start\"/\"end\".');\n    }\n    if (this.hot.isRtl() && hasLeftOrRight) {\n      throw new Error('The \"left\"/\"right\" properties are not supported for RTL. Please use option \"start\"/\"end\".');\n    }\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    super.destroy();\n  }\n}\nfunction _onAfterContextMenuDefaultOptions2(defaultOptions) {\n  if (!this.hot.getSettings()[PLUGIN_KEY]) {\n    return;\n  }\n  defaultOptions.items.push({\n    name: '---------'\n  }, {\n    key: 'borders',\n    name() {\n      return this.getTranslatedPhrase(C.CONTEXTMENU_ITEMS_BORDERS);\n    },\n    disabled() {\n      const range = this.getSelectedRangeLast();\n      if (!range) {\n        return true;\n      }\n      if (range.isSingleHeader()) {\n        return true;\n      }\n      return this.selection.isSelectedByCorner();\n    },\n    submenu: {\n      items: [menuItemTop(this), menuItemRight(this), menuItemBottom(this), menuItemLeft(this), menuItemNoBorders(this)]\n    }\n  });\n}\nfunction _onAfterInit2() {\n  this.changeBorderSettings();\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}