{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport { rangeEach, rangeEachReverse } from \"../../helpers/number.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * Defines a container object for the merged cells.\n *\n * @private\n * @class MergedCellsCollection\n */\nclass MergedCellsCollection {\n  constructor(mergeCellsPlugin) {\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Array of merged cells.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"mergedCells\", []);\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    this.plugin = mergeCellsPlugin;\n    this.hot = mergeCellsPlugin.hot;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_OVERLAPPING_WARNING(newMergedCell) {\n    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}], overlaps\\x20\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\x20\n      fix your setup.`;\n  }\n\n  /**\n   * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n   * of a merged cell, or any coordinates from the body of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @param {number} column Column index.\n   * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\n   */\n  get(row, column) {\n    const mergedCells = this.mergedCells;\n    let result = false;\n    arrayEach(mergedCells, mergedCell => {\n      if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n        result = mergedCell;\n        return false;\n      }\n      return true;\n    });\n    return result;\n  }\n\n  /**\n   * Get a merged cell containing the provided range.\n   *\n   * @param {CellRange|object} range The range to search merged cells for.\n   * @returns {MergedCellCoords|boolean}\n   */\n  getByRange(range) {\n    const mergedCells = this.mergedCells;\n    let result = false;\n    arrayEach(mergedCells, mergedCell => {\n      if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n        result = mergedCell;\n        return result;\n      }\n      return true;\n    });\n    return result;\n  }\n\n  /**\n   * Get a merged cell contained in the provided range.\n   *\n   * @param {CellRange|object} range The range to search merged cells in.\n   * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n   * @returns {Array|boolean} Array of found merged cells of `false` if none were found.\n   */\n  getWithinRange(range) {\n    let countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const mergedCells = this.mergedCells;\n    const foundMergedCells = [];\n    let testedRange = range;\n    if (!testedRange.includesRange) {\n      const from = this.hot._createCellCoords(testedRange.from.row, testedRange.from.col);\n      const to = this.hot._createCellCoords(testedRange.to.row, testedRange.to.col);\n      testedRange = this.hot._createCellRange(from, from, to);\n    }\n    arrayEach(mergedCells, mergedCell => {\n      const mergedCellTopLeft = this.hot._createCellCoords(mergedCell.row, mergedCell.col);\n      const mergedCellBottomRight = this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n      const mergedCellRange = this.hot._createCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n      if (countPartials) {\n        if (testedRange.overlaps(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      } else if (testedRange.includesRange(mergedCellRange)) {\n        foundMergedCells.push(mergedCell);\n      }\n    });\n    return foundMergedCells.length ? foundMergedCells : false;\n  }\n\n  /**\n   * Add a merged cell to the container.\n   *\n   * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n   * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\n   */\n  add(mergedCellInfo) {\n    const mergedCells = this.mergedCells;\n    const row = mergedCellInfo.row;\n    const column = mergedCellInfo.col;\n    const rowspan = mergedCellInfo.rowspan;\n    const colspan = mergedCellInfo.colspan;\n    const newMergedCell = new MergedCellCoords(row, column, rowspan, colspan, this.hot._createCellCoords, this.hot._createCellRange);\n    const alreadyExists = this.get(row, column);\n    const isOverlapping = this.isOverlapping(newMergedCell);\n    if (!alreadyExists && !isOverlapping) {\n      if (this.hot) {\n        newMergedCell.normalize(this.hot);\n      }\n      mergedCells.push(newMergedCell);\n      return newMergedCell;\n    }\n    warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n    return false;\n  }\n\n  /**\n   * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n   * of a merged cell, or any coordinates from the body of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @param {number} column Column index.\n   * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\n   */\n  remove(row, column) {\n    const mergedCells = this.mergedCells;\n    const wantedCollection = this.get(row, column);\n    const wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : -1;\n    if (wantedCollection && wantedCollectionIndex !== -1) {\n      mergedCells.splice(wantedCollectionIndex, 1);\n      return wantedCollection;\n    }\n    return false;\n  }\n\n  /**\n   * Clear all the merged cells.\n   */\n  clear() {\n    const mergedCells = this.mergedCells;\n    const mergedCellParentsToClear = [];\n    const hiddenCollectionElements = [];\n    arrayEach(mergedCells, mergedCell => {\n      const TD = this.hot.getCell(mergedCell.row, mergedCell.col);\n      if (TD) {\n        mergedCellParentsToClear.push([TD, this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n      }\n    });\n    this.mergedCells.length = 0;\n    arrayEach(mergedCellParentsToClear, (mergedCell, i) => {\n      rangeEach(0, mergedCell.rowspan - 1, j => {\n        rangeEach(0, mergedCell.colspan - 1, k => {\n          if (k !== 0 || j !== 0) {\n            const TD = this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n            if (TD) {\n              hiddenCollectionElements.push([TD, null, null, null]);\n            }\n          }\n        });\n      });\n      mergedCellParentsToClear[i][1] = null;\n    });\n    arrayEach(mergedCellParentsToClear, mergedCellParents => {\n      applySpanProperties(...mergedCellParents);\n    });\n    arrayEach(hiddenCollectionElements, hiddenCollectionElement => {\n      applySpanProperties(...hiddenCollectionElement);\n    });\n  }\n\n  /**\n   * Check if the provided merged cell overlaps with the others in the container.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n   * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n   */\n  isOverlapping(mergedCell) {\n    const mergedCellRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(mergedCell.row, mergedCell.col), this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n    let result = false;\n    arrayEach(this.mergedCells, col => {\n      const currentRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(col.row, col.col), this.hot._createCellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n      if (currentRange.overlaps(mergedCellRange)) {\n        result = true;\n        return false;\n      }\n      return true;\n    });\n    return result;\n  }\n\n  /**\n   * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {boolean}\n   */\n  isFirstRenderableMergedCell(row, column) {\n    const mergeParent = this.get(row, column);\n\n    // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\n    return mergeParent && this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) === column;\n  }\n\n  /**\n   * Get the first renderable coords of the merged cell at the provided coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\n   *                        merged cell.\n   */\n  getFirstRenderableCoords(row, column) {\n    const mergeParent = this.get(row, column);\n    if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\n      return this.hot._createCellCoords(row, column);\n    }\n    const firstRenderableRow = this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);\n    const firstRenderableColumn = this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);\n    return this.hot._createCellCoords(firstRenderableRow, firstRenderableColumn);\n  }\n\n  /**\n   * Shift the merged cell in the direction and by an offset defined in the arguments.\n   *\n   * @param {string} direction `right`, `left`, `up` or `down`.\n   * @param {number} index Index where the change, which caused the shifting took place.\n   * @param {number} count Number of rows/columns added/removed in the preceding action.\n   */\n  shiftCollections(direction, index, count) {\n    const shiftVector = [0, 0];\n    switch (direction) {\n      case 'right':\n        shiftVector[0] += count;\n        break;\n      case 'left':\n        shiftVector[0] -= count;\n        break;\n      case 'down':\n        shiftVector[1] += count;\n        break;\n      case 'up':\n        shiftVector[1] -= count;\n        break;\n      default:\n    }\n    arrayEach(this.mergedCells, currentMerge => {\n      currentMerge.shift(shiftVector, index);\n    });\n    rangeEachReverse(this.mergedCells.length - 1, 0, i => {\n      const currentMerge = this.mergedCells[i];\n      if (currentMerge && currentMerge.removed) {\n        this.mergedCells.splice(this.mergedCells.indexOf(currentMerge), 1);\n      }\n    });\n  }\n}\nexport default MergedCellsCollection;","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","MergedCellCoords","rangeEach","rangeEachReverse","warn","arrayEach","applySpanProperties","toSingleLine","MergedCellsCollection","constructor","mergeCellsPlugin","plugin","hot","IS_OVERLAPPING_WARNING","newMergedCell","row","col","get","column","mergedCells","result","mergedCell","rowspan","colspan","getByRange","range","from","to","getWithinRange","countPartials","arguments","length","undefined","foundMergedCells","testedRange","includesRange","_createCellCoords","_createCellRange","mergedCellTopLeft","mergedCellBottomRight","mergedCellRange","overlaps","push","add","mergedCellInfo","alreadyExists","isOverlapping","normalize","remove","wantedCollection","wantedCollectionIndex","indexOf","splice","clear","mergedCellParentsToClear","hiddenCollectionElements","TD","getCell","j","k","mergedCellParents","hiddenCollectionElement","currentRange","isFirstRenderableMergedCell","mergeParent","rowIndexMapper","getNearestNotHiddenIndex","columnIndexMapper","getFirstRenderableCoords","firstRenderableRow","firstRenderableColumn","shiftCollections","direction","index","count","shiftVector","currentMerge","shift","removed"],"sources":["C:/laragon/www/SIAW-Angular-B/node_modules/handsontable/plugins/mergeCells/cellsCollection.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport { rangeEach, rangeEachReverse } from \"../../helpers/number.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * Defines a container object for the merged cells.\n *\n * @private\n * @class MergedCellsCollection\n */\nclass MergedCellsCollection {\n  constructor(mergeCellsPlugin) {\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Array of merged cells.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"mergedCells\", []);\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    this.plugin = mergeCellsPlugin;\n    this.hot = mergeCellsPlugin.hot;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_OVERLAPPING_WARNING(newMergedCell) {\n    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}], overlaps\\x20\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\x20\n      fix your setup.`;\n  }\n\n  /**\n   * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n   * of a merged cell, or any coordinates from the body of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @param {number} column Column index.\n   * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\n   */\n  get(row, column) {\n    const mergedCells = this.mergedCells;\n    let result = false;\n    arrayEach(mergedCells, mergedCell => {\n      if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n        result = mergedCell;\n        return false;\n      }\n      return true;\n    });\n    return result;\n  }\n\n  /**\n   * Get a merged cell containing the provided range.\n   *\n   * @param {CellRange|object} range The range to search merged cells for.\n   * @returns {MergedCellCoords|boolean}\n   */\n  getByRange(range) {\n    const mergedCells = this.mergedCells;\n    let result = false;\n    arrayEach(mergedCells, mergedCell => {\n      if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n        result = mergedCell;\n        return result;\n      }\n      return true;\n    });\n    return result;\n  }\n\n  /**\n   * Get a merged cell contained in the provided range.\n   *\n   * @param {CellRange|object} range The range to search merged cells in.\n   * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n   * @returns {Array|boolean} Array of found merged cells of `false` if none were found.\n   */\n  getWithinRange(range) {\n    let countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const mergedCells = this.mergedCells;\n    const foundMergedCells = [];\n    let testedRange = range;\n    if (!testedRange.includesRange) {\n      const from = this.hot._createCellCoords(testedRange.from.row, testedRange.from.col);\n      const to = this.hot._createCellCoords(testedRange.to.row, testedRange.to.col);\n      testedRange = this.hot._createCellRange(from, from, to);\n    }\n    arrayEach(mergedCells, mergedCell => {\n      const mergedCellTopLeft = this.hot._createCellCoords(mergedCell.row, mergedCell.col);\n      const mergedCellBottomRight = this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n      const mergedCellRange = this.hot._createCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n      if (countPartials) {\n        if (testedRange.overlaps(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      } else if (testedRange.includesRange(mergedCellRange)) {\n        foundMergedCells.push(mergedCell);\n      }\n    });\n    return foundMergedCells.length ? foundMergedCells : false;\n  }\n\n  /**\n   * Add a merged cell to the container.\n   *\n   * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n   * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\n   */\n  add(mergedCellInfo) {\n    const mergedCells = this.mergedCells;\n    const row = mergedCellInfo.row;\n    const column = mergedCellInfo.col;\n    const rowspan = mergedCellInfo.rowspan;\n    const colspan = mergedCellInfo.colspan;\n    const newMergedCell = new MergedCellCoords(row, column, rowspan, colspan, this.hot._createCellCoords, this.hot._createCellRange);\n    const alreadyExists = this.get(row, column);\n    const isOverlapping = this.isOverlapping(newMergedCell);\n    if (!alreadyExists && !isOverlapping) {\n      if (this.hot) {\n        newMergedCell.normalize(this.hot);\n      }\n      mergedCells.push(newMergedCell);\n      return newMergedCell;\n    }\n    warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n    return false;\n  }\n\n  /**\n   * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n   * of a merged cell, or any coordinates from the body of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @param {number} column Column index.\n   * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\n   */\n  remove(row, column) {\n    const mergedCells = this.mergedCells;\n    const wantedCollection = this.get(row, column);\n    const wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : -1;\n    if (wantedCollection && wantedCollectionIndex !== -1) {\n      mergedCells.splice(wantedCollectionIndex, 1);\n      return wantedCollection;\n    }\n    return false;\n  }\n\n  /**\n   * Clear all the merged cells.\n   */\n  clear() {\n    const mergedCells = this.mergedCells;\n    const mergedCellParentsToClear = [];\n    const hiddenCollectionElements = [];\n    arrayEach(mergedCells, mergedCell => {\n      const TD = this.hot.getCell(mergedCell.row, mergedCell.col);\n      if (TD) {\n        mergedCellParentsToClear.push([TD, this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n      }\n    });\n    this.mergedCells.length = 0;\n    arrayEach(mergedCellParentsToClear, (mergedCell, i) => {\n      rangeEach(0, mergedCell.rowspan - 1, j => {\n        rangeEach(0, mergedCell.colspan - 1, k => {\n          if (k !== 0 || j !== 0) {\n            const TD = this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n            if (TD) {\n              hiddenCollectionElements.push([TD, null, null, null]);\n            }\n          }\n        });\n      });\n      mergedCellParentsToClear[i][1] = null;\n    });\n    arrayEach(mergedCellParentsToClear, mergedCellParents => {\n      applySpanProperties(...mergedCellParents);\n    });\n    arrayEach(hiddenCollectionElements, hiddenCollectionElement => {\n      applySpanProperties(...hiddenCollectionElement);\n    });\n  }\n\n  /**\n   * Check if the provided merged cell overlaps with the others in the container.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n   * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n   */\n  isOverlapping(mergedCell) {\n    const mergedCellRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(mergedCell.row, mergedCell.col), this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n    let result = false;\n    arrayEach(this.mergedCells, col => {\n      const currentRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(col.row, col.col), this.hot._createCellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n      if (currentRange.overlaps(mergedCellRange)) {\n        result = true;\n        return false;\n      }\n      return true;\n    });\n    return result;\n  }\n\n  /**\n   * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {boolean}\n   */\n  isFirstRenderableMergedCell(row, column) {\n    const mergeParent = this.get(row, column);\n\n    // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\n    return mergeParent && this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) === column;\n  }\n\n  /**\n   * Get the first renderable coords of the merged cell at the provided coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\n   *                        merged cell.\n   */\n  getFirstRenderableCoords(row, column) {\n    const mergeParent = this.get(row, column);\n    if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\n      return this.hot._createCellCoords(row, column);\n    }\n    const firstRenderableRow = this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);\n    const firstRenderableColumn = this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);\n    return this.hot._createCellCoords(firstRenderableRow, firstRenderableColumn);\n  }\n\n  /**\n   * Shift the merged cell in the direction and by an offset defined in the arguments.\n   *\n   * @param {string} direction `right`, `left`, `up` or `down`.\n   * @param {number} index Index where the change, which caused the shifting took place.\n   * @param {number} count Number of rows/columns added/removed in the preceding action.\n   */\n  shiftCollections(direction, index, count) {\n    const shiftVector = [0, 0];\n    switch (direction) {\n      case 'right':\n        shiftVector[0] += count;\n        break;\n      case 'left':\n        shiftVector[0] -= count;\n        break;\n      case 'down':\n        shiftVector[1] += count;\n        break;\n      case 'up':\n        shiftVector[1] -= count;\n        break;\n      default:\n    }\n    arrayEach(this.mergedCells, currentMerge => {\n      currentMerge.shift(shiftVector, index);\n    });\n    rangeEachReverse(this.mergedCells.length - 1, 0, i => {\n      const currentMerge = this.mergedCells[i];\n      if (currentMerge && currentMerge.removed) {\n        this.mergedCells.splice(this.mergedCells.indexOf(currentMerge), 1);\n      }\n    });\n  }\n}\nexport default MergedCellsCollection;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}